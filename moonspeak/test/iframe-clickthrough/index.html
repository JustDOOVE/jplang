<!DOCTYPE html>
<html>
<head>
<style>
body, html {
    margin: 0;
    padding: 0;
    width: 100vw; 
    height: 100vh;
}

.colored {
    background-color: red;
}

.fullscreen {
    position: absolute;
    width: 100vw;
    height: 100vh;
    border: none;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    background-color: transparent;
    pointer-events: none;
}

.active {
    pointer-events: auto;
}

.hidden {
    display: none;
}

</style>
</head>

<body onload="getDataIFrame()">

<div id="featuresContainer">
    <iframe id="frame_background" class="fullscreen" src="./frame_background.html"></iframe>
    <iframe id="frame_plus" class="fullscreen" src="./frame_plus.html"></iframe>
    <iframe id="frame_question" class="fullscreen" src="./frame_question.html"></iframe>
    <iframe id="frame_alert" class="fullscreen" src="./frame_alert.html"></iframe>
</div>
<div id="eventTrap" class="active fullscreen"></div>

<script>

let fullscreenFrames = new Array();
let container = document.getElementById("featuresContainer");
for (const child of container.childNodes) {
    if (child.tagName !== "IFRAME") {
        continue;
    }
    fullscreenFrames.push(child);
}
fullscreenFrames.reverse();

let STATE_PROPOGATING = "propogating";
let STATE_HANDLED = "handled";


async function getDataIFrame() {
    let urls = [
        "frame_background",
        "frame_question",
        "frame_plus",
        "frame_alert",
    ];

    let eventTrap = document.getElementById("eventTrap");

    let pointerHandler = (e) => {
        let evt = new MouseEvent(e.type, e);
        evt.moonspeakEventState = STATE_PROPOGATING;
        for (const child of fullscreenFrames) {
                if (evt.moonspeakEventState === STATE_HANDLED) {
                    // stop early if event was handled
                    break; 
                }
                let innerEl = child.contentWindow.document.elementFromPoint(e.clientX, e.clientY);
                if (innerEl) {
                    innerEl.dispatchEvent(evt);
                }
        };
    }

    eventTrap.addEventListener('click', pointerHandler, true);
    // eventTrap.addEventListener('hover', pointerHandler, true);
    // eventTrap.addEventListener('pointerdown', pointerHandler, true);
    // eventTrap.addEventListener('pointermove', pointerHandler, true);
    // eventTrap.addEventListener('pointerup', pointerHandler, true);
    // eventTrap.addEventListener('pointercancel', pointerHandler, true);
    // eventTrap.addEventListener('pointerout', pointerHandler, true);
    // eventTrap.addEventListener('pointerleave', pointerHandler, true);
    // eventTrap.addEventListener('gotpointercapture', pointerHandler, true);
    // eventTrap.addEventListener('lostpointercapture', pointerHandler, true);

    for (const name of urls) {
        let elemRef = document.getElementById(name);
        let iframeHtml = elemRef.contentWindow.document.documentElement;
        iframeHtml.addEventListener('click', (e) => {
            if (e.target !== iframeHtml) {
                // if the first element with event handler is NOT document.html tag
                // means there is a lower click event handler, so event was handled
                e.moonspeakEventState = STATE_HANDLED;

                // make this element active
                eventTrap.classList.remove('active');
                elemRef.classList.add('active');

            } else if (elemRef.classList.contains('active')) {

                // this element should stop being active
                elemRef.classList.remove('active');
                eventTrap.classList.add('active');
                let evt = new MouseEvent('click', e);
                eventTrap.dispatchEvent(evt);
            }
        });
    };
}



async function getDataRaw() {
    let urls = [
        "frame_background",
        "frame_question",
        "frame_plus",
        "frame_alert",
    ];

    for (const name of urls) {
        let elemRef = document.getElementById(name);
        let response = await fetch(name + ".html");
        let htmlText = await response.text()
        elemRef.innerHTML = htmlText;
        nodeScriptReplace(elemRef);
    };
}

function nodeScriptReplace(node) {
        if ( nodeScriptIs(node) === true ) {
                node.parentNode.replaceChild( nodeScriptClone(node) , node );
        }
        else {
                var i = -1, children = node.childNodes;
                while ( ++i < children.length ) {
                      nodeScriptReplace( children[i] );
                }
        }

        return node;
}

function nodeScriptClone(node){
        var script  = document.createElement("script");
        script.text = node.innerHTML;

        var i = -1, attrs = node.attributes, attr;
        while ( ++i < attrs.length ) {                                    
              script.setAttribute( (attr = attrs[i]).name, attr.value );
        }
        return script;
}

function nodeScriptIs(node) {
        return node.tagName === 'SCRIPT';
}

async function getDataShadow() {
    let urls = [
        // "frame_background",
        "frame_question",
        "frame_plus",
        "frame_alert",
    ];

    let parser = new DOMParser();

    for (const name of urls) {
        let elemRef = document.getElementById(name);
        elemRef.attachShadow({mode: 'open'});
        let response = await fetch(name + ".html");
        let htmlText = await response.text()
        elemRef.shadowRoot.innerHTML = htmlText;

        // now attach script tags

        let ancor = document.createElement("div");
        ancor.id = "appRootElement";
        elemRef.shadowRoot.appendChild(ancor);
        let bootstrap =  'var appRoot = appRootElement.getRootNode();'
        new Function('appRootElement', bootstrap).call(this, elemRef.shadowRoot.getElementById('appRootElement'));

        let html = parser.parseFromString(htmlText, 'text/html');
        let htmlScripts = html.querySelectorAll('script');

        for (const s of htmlScripts) {
            let scriptTag = document.createElement( 'script' );
            // see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace
            // const reg = new RegExp('/\b(document)[.]/', 'g');
            // let patched = s.innerHTML.replace(reg, "$`appRoot.");
            scriptTag.textContent = patched;

            var i = -1, attrs = s.attributes, attr;
            while ( ++i < attrs.length ) {                                    
                scriptTag.setAttribute( (attr = attrs[i]).name, attr.value );
            }
            elemRef.shadowRoot.appendChild(scriptTag);
        }

        console.log(elemRef);
        // nodeScriptReplace(elemRef.shadowRoot);
    };
}

</script>

</body>
</html>
