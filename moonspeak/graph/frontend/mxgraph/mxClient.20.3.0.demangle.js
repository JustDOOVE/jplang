'use strict';
var mxClient = {
  VERSION : "20.3.0",
  IS_IE : null != navigator.userAgent && 0 <= navigator.userAgent.indexOf("MSIE"),
  IS_IE11 : null != navigator.userAgent && !!navigator.userAgent.match(/Trident\/7\./),
  IS_EDGE : null != navigator.userAgent && !!navigator.userAgent.match(/Edge\//),
  IS_EM : "spellcheck" in document.createElement("textarea") && 8 == document.documentMode,
  VML_PREFIX : "v",
  OFFICE_PREFIX : "o",
  IS_NS : null != navigator.userAgent && 0 <= navigator.userAgent.indexOf("Mozilla/") && 0 > navigator.userAgent.indexOf("MSIE") && 0 > navigator.userAgent.indexOf("Edge/"),
  IS_OP : null != navigator.userAgent && (0 <= navigator.userAgent.indexOf("Opera/") || 0 <= navigator.userAgent.indexOf("OPR/")),
  IS_OT : null != navigator.userAgent && 0 <= navigator.userAgent.indexOf("Presto/") && 0 > navigator.userAgent.indexOf("Presto/2.4.") && 0 > navigator.userAgent.indexOf("Presto/2.3.") && 0 > navigator.userAgent.indexOf("Presto/2.2.") && 0 > navigator.userAgent.indexOf("Presto/2.1.") && 0 > navigator.userAgent.indexOf("Presto/2.0.") && 0 > navigator.userAgent.indexOf("Presto/1."),
  IS_SF : /Apple Computer, Inc/.test(navigator.vendor),
  IS_ANDROID : 0 <= navigator.appVersion.indexOf("Android"),
  IS_IOS : /iP(hone|od|ad)/.test(navigator.platform) || navigator.userAgent.match(/Mac/) && navigator.maxTouchPoints && 2 < navigator.maxTouchPoints,
  IS_WEBVIEW : /((iPhone|iPod|iPad).*AppleWebKit(?!.*Version)|; wv)/i.test(navigator.userAgent),
  IS_GC : /Google Inc/.test(navigator.vendor),
  IS_CHROMEAPP : null != window.chrome && null != chrome.app && null != chrome.app.runtime,
  IS_FF : "undefined" !== typeof InstallTrigger,
  IS_MT : 0 <= navigator.userAgent.indexOf("Firefox/") && 0 > navigator.userAgent.indexOf("Firefox/1.") && 0 > navigator.userAgent.indexOf("Firefox/2.") || 0 <= navigator.userAgent.indexOf("Iceweasel/") && 0 > navigator.userAgent.indexOf("Iceweasel/1.") && 0 > navigator.userAgent.indexOf("Iceweasel/2.") || 0 <= navigator.userAgent.indexOf("SeaMonkey/") && 0 > navigator.userAgent.indexOf("SeaMonkey/1.") || 0 <= navigator.userAgent.indexOf("Iceape/") && 0 > navigator.userAgent.indexOf("Iceape/1."),
  IS_SVG : "MICROSOFT INTERNET EXPLORER" != navigator.appName.toUpperCase(),
  NO_FO : !document.createElementNS || "[object SVGForeignObjectElement]" !== document.createElementNS("http://www.w3.org/2000/svg", "foreignObject").toString() || 0 <= navigator.userAgent.indexOf("Opera/"),
  IS_WIN : 0 < navigator.appVersion.indexOf("Win"),
  IS_MAC : 0 < navigator.appVersion.indexOf("Mac"),
  IS_CHROMEOS : /\bCrOS\b/.test(navigator.appVersion),
  IS_LINUX : /\bLinux\b/.test(navigator.appVersion),
  IS_TOUCH : "ontouchstart" in document.documentElement,
  IS_POINTER : null != window.PointerEvent && !(0 < navigator.appVersion.indexOf("Mac")),
  IS_LOCAL : 0 > document.location.href.indexOf("http://") && 0 > document.location.href.indexOf("https://"),
  defaultBundles : [],
  isBrowserSupported : function() {
    return mxClient.IS_SVG;
  },
  link : function(value, name, context, x) {
    context = context || document;
    var res = context.createElement("link");
    res.setAttribute("rel", value);
    res.setAttribute("href", name);
    res.setAttribute("charset", "UTF-8");
    res.setAttribute("type", "text/css");
    if (x) {
      res.setAttribute("id", x);
    }
    context.getElementsByTagName("head")[0].appendChild(res);
  },
  loadResources : function(callback, that) {
    /**
     * @return {undefined}
     */
    function callback() {
      if (0 == --readersLength) {
        callback();
      }
    }
    var readersLength = mxClient.defaultBundles.length;
    /** @type {number} */
    var i = 0;
    for (; i < mxClient.defaultBundles.length; i++) {
      mxResources.add(mxClient.defaultBundles[i], that, callback);
    }
  },
  include : function(controlName) {
    document.write('<script src="' + controlName + '">\x3c/script>');
  }
};
if ("undefined" == typeof mxLoadResources) {
  /** @type {boolean} */
  mxLoadResources = true;
}
if ("undefined" == typeof mxForceIncludes) {
  /** @type {boolean} */
  mxForceIncludes = false;
}
if ("undefined" == typeof mxResourceExtension) {
  /** @type {string} */
  mxResourceExtension = ".txt";
}
if ("undefined" == typeof mxLoadStylesheets) {
  /** @type {boolean} */
  mxLoadStylesheets = true;
}
if ("undefined" != typeof mxBasePath && 0 < mxBasePath.length) {
  if ("/" == mxBasePath.substring(mxBasePath.length - 1)) {
    mxBasePath = mxBasePath.substring(0, mxBasePath.length - 1);
  }
  mxClient.basePath = mxBasePath;
} else {
  /** @type {string} */
  mxClient.basePath = ".";
}
if ("undefined" != typeof mxImageBasePath && 0 < mxImageBasePath.length) {
  if ("/" == mxImageBasePath.substring(mxImageBasePath.length - 1)) {
    mxImageBasePath = mxImageBasePath.substring(0, mxImageBasePath.length - 1);
  }
  mxClient.imageBasePath = mxImageBasePath;
} else {
  /** @type {string} */
  mxClient.imageBasePath = "images";
}
mxClient.language = "undefined" != typeof mxLanguage && null != mxLanguage ? mxLanguage : mxClient.IS_IE ? navigator.userLanguage : navigator.language;
mxClient.defaultLanguage = "undefined" != typeof mxDefaultLanguage && null != mxDefaultLanguage ? mxDefaultLanguage : "en";
if (mxLoadStylesheets) {
  mxClient.link("stylesheet", "mxgraph/css/common.css");
}
if ("undefined" != typeof mxLanguages && null != mxLanguages) {
  mxClient.languages = mxLanguages;
}
var mxLog = {
  consoleName : "Console",
  TRACE : false,
  DEBUG : true,
  WARN : true,
  buffer : "",
  init : function() {
    if (null == mxLog.window && null != document.body) {
      /** @type {string} */
      var render = mxLog.consoleName + " - mxGraph " + mxClient.VERSION;
      /** @type {!Element} */
      var inShadowTable = document.createElement("table");
      inShadowTable.setAttribute("width", "100%");
      inShadowTable.setAttribute("height", "100%");
      /** @type {!Element} */
      var w = document.createElement("tbody");
      /** @type {!Element} */
      var x = document.createElement("tr");
      /** @type {!Element} */
      var row = document.createElement("td");
      /** @type {string} */
      row.style.verticalAlign = "top";
      /** @type {!Element} */
      mxLog.textarea = document.createElement("textarea");
      mxLog.textarea.setAttribute("wrap", "off");
      mxLog.textarea.setAttribute("readOnly", "true");
      /** @type {string} */
      mxLog.textarea.style.height = "100%";
      /** @type {string} */
      mxLog.textarea.style.resize = "none";
      mxLog.textarea.value = mxLog.buffer;
      /** @type {string} */
      mxLog.textarea.style.width = mxClient.IS_NS && "BackCompat" != document.compatMode ? "99%" : "100%";
      row.appendChild(mxLog.textarea);
      x.appendChild(row);
      w.appendChild(x);
      /** @type {!Element} */
      x = document.createElement("tr");
      /** @type {!Element} */
      mxLog.td = document.createElement("td");
      /** @type {string} */
      mxLog.td.style.verticalAlign = "top";
      mxLog.td.setAttribute("height", "30px");
      x.appendChild(mxLog.td);
      w.appendChild(x);
      inShadowTable.appendChild(w);
      mxLog.addButton("Info", function(canCreateDiscussions) {
        mxLog.info();
      });
      mxLog.addButton("DOM", function(enrollments) {
        enrollments = mxUtils.getInnerHtml(document.body);
        mxLog.debug(enrollments);
      });
      mxLog.addButton("Trace", function(canCreateDiscussions) {
        /** @type {boolean} */
        mxLog.TRACE = !mxLog.TRACE;
        if (mxLog.TRACE) {
          mxLog.debug("Tracing enabled");
        } else {
          mxLog.debug("Tracing disabled");
        }
      });
      mxLog.addButton("Copy", function(canCreateDiscussions) {
        try {
          mxUtils.copy(mxLog.textarea.value);
        } catch (error) {
          mxUtils.alert(error);
        }
      });
      mxLog.addButton("Show", function(canCreateDiscussions) {
        try {
          mxUtils.popup(mxLog.textarea.value);
        } catch (error) {
          mxUtils.alert(error);
        }
      });
      mxLog.addButton("Clear", function(canCreateDiscussions) {
        /** @type {string} */
        mxLog.textarea.value = "";
      });
      /** @type {number} */
      x = w = 0;
      if ("number" === typeof window.innerWidth) {
        /** @type {number} */
        w = window.innerHeight;
        /** @type {number} */
        x = window.innerWidth;
      } else {
        /** @type {number} */
        w = document.documentElement.clientHeight || document.body.clientHeight;
        /** @type {number} */
        x = document.body.clientWidth;
      }
      mxLog.window = new mxWindow(render, inShadowTable, Math.max(0, x - 320), Math.max(0, w - 210), 300, 160);
      mxLog.window.setMaximizable(true);
      mxLog.window.setScrollable(false);
      mxLog.window.setResizable(true);
      mxLog.window.setClosable(true);
      /** @type {boolean} */
      mxLog.window.destroyOnClose = false;
      if ((mxClient.IS_NS || mxClient.IS_IE) && !mxClient.IS_GC && !mxClient.IS_SF && "BackCompat" != document.compatMode || 11 == document.documentMode) {
        var viewcontainer = mxLog.window.getElement();
        /**
         * @param {?} url
         * @param {?} callback
         * @return {undefined}
         */
        render = function(url, callback) {
          /** @type {string} */
          mxLog.textarea.style.height = Math.max(0, viewcontainer.offsetHeight - 70) + "px";
        };
        mxLog.window.addListener(mxEvent.RESIZE_END, render);
        mxLog.window.addListener(mxEvent.MAXIMIZE, render);
        mxLog.window.addListener(mxEvent.NORMALIZE, render);
        /** @type {string} */
        mxLog.textarea.style.height = "92px";
      }
    }
  },
  info : function() {
    mxLog.writeln(mxUtils.toString(navigator));
  },
  addButton : function(label, type) {
    /** @type {!Element} */
    var elt = document.createElement("button");
    mxUtils.write(elt, label);
    mxEvent.addListener(elt, "click", type);
    mxLog.td.appendChild(elt);
  },
  isVisible : function() {
    return null != mxLog.window ? mxLog.window.isVisible() : false;
  },
  show : function() {
    mxLog.setVisible(true);
  },
  setVisible : function(visible) {
    if (null == mxLog.window) {
      mxLog.init();
    }
    if (null != mxLog.window) {
      mxLog.window.setVisible(visible);
    }
  },
  enter : function(key) {
    if (mxLog.TRACE) {
      return mxLog.writeln("Entering " + key), (new Date).getTime();
    }
  },
  leave : function(path, key) {
    if (mxLog.TRACE) {
      /** @type {string} */
      key = 0 != key ? " (" + ((new Date).getTime() - key) + " ms)" : "";
      mxLog.writeln("Leaving " + path + key);
    }
  },
  debug : function() {
    if (mxLog.DEBUG) {
      mxLog.writeln.apply(this, arguments);
    }
  },
  warn : function() {
    if (mxLog.WARN) {
      mxLog.writeln.apply(this, arguments);
    }
  },
  write : function() {
    /** @type {string} */
    var str = "";
    /** @type {number} */
    var i = 0;
    for (; i < arguments.length; i++) {
      /** @type {string} */
      str = str + arguments[i];
      if (i < arguments.length - 1) {
        /** @type {string} */
        str = str + " ";
      }
    }
    if (null != mxLog.textarea) {
      mxLog.textarea.value += str;
      if (null != navigator.userAgent && 0 <= navigator.userAgent.indexOf("Presto/2.5")) {
        /** @type {string} */
        mxLog.textarea.style.visibility = "hidden";
        /** @type {string} */
        mxLog.textarea.style.visibility = "visible";
      }
      mxLog.textarea.scrollTop = mxLog.textarea.scrollHeight;
    } else {
      mxLog.buffer += str;
    }
  },
  writeln : function() {
    /** @type {string} */
    var msg = "";
    /** @type {number} */
    var i = 0;
    for (; i < arguments.length; i++) {
      /** @type {string} */
      msg = msg + arguments[i];
      if (i < arguments.length - 1) {
        /** @type {string} */
        msg = msg + " ";
      }
    }
    mxLog.write(msg + "\n");
  }
};
var mxObjectIdentity = {
  FIELD_NAME : "mxObjectId",
  counter : 0,
  get : function(obj) {
    if (null != obj) {
      if (null == obj[mxObjectIdentity.FIELD_NAME]) {
        if ("object" === typeof obj) {
          var uriPathPrefix = mxUtils.getFunctionName(obj.constructor);
          /** @type {string} */
          obj[mxObjectIdentity.FIELD_NAME] = uriPathPrefix + "#" + mxObjectIdentity.counter++;
        } else {
          if ("function" === typeof obj) {
            /** @type {string} */
            obj[mxObjectIdentity.FIELD_NAME] = "Function#" + mxObjectIdentity.counter++;
          }
        }
      }
      return obj[mxObjectIdentity.FIELD_NAME];
    }
    return null;
  },
  clear : function(object) {
    if (!("object" !== typeof object && "function" !== typeof object)) {
      delete object[mxObjectIdentity.FIELD_NAME];
    }
  }
};
/**
 * @return {undefined}
 */
function mxDictionary() {
  this.clear();
}
/** @type {null} */
mxDictionary.prototype.map = null;
/**
 * @return {undefined}
 */
mxDictionary.prototype.clear = function() {
  this.map = {};
};
/**
 * @param {!Object} val
 * @return {?}
 */
mxDictionary.prototype.get = function(val) {
  val = mxObjectIdentity.get(val);
  return this.map[val];
};
/**
 * @param {!Object} data
 * @param {string} value
 * @return {?}
 */
mxDictionary.prototype.put = function(data, value) {
  data = mxObjectIdentity.get(data);
  var entry = this.map[data];
  /** @type {string} */
  this.map[data] = value;
  return entry;
};
/**
 * @param {!Object} type
 * @return {?}
 */
mxDictionary.prototype.remove = function(type) {
  type = mxObjectIdentity.get(type);
  var values = this.map[type];
  delete this.map[type];
  return values;
};
/**
 * @return {?}
 */
mxDictionary.prototype.getKeys = function() {
  /** @type {!Array} */
  var buffer = [];
  var id;
  for (id in this.map) {
    buffer.push(id);
  }
  return buffer;
};
/**
 * @return {?}
 */
mxDictionary.prototype.getValues = function() {
  /** @type {!Array} */
  var values = [];
  var i;
  for (i in this.map) {
    values.push(this.map[i]);
  }
  return values;
};
/**
 * @param {!Function} callback
 * @return {undefined}
 */
mxDictionary.prototype.visit = function(callback) {
  var i;
  for (i in this.map) {
    callback(i, this.map[i]);
  }
};
var mxResources = {
  resources : {},
  extension : mxResourceExtension,
  resourcesEncoded : false,
  loadDefaultBundle : true,
  loadSpecialBundle : true,
  isLanguageSupported : function(value) {
    return null != mxClient.languages ? 0 <= mxUtils.indexOf(mxClient.languages, value) : true;
  },
  getDefaultBundle : function(view, name) {
    return mxResources.loadDefaultBundle || !mxResources.isLanguageSupported(name) ? view + mxResources.extension : null;
  },
  getSpecialBundle : function(containerName, key) {
    if (null == mxClient.languages || !this.isLanguageSupported(key)) {
      var c = key.indexOf("-");
      if (0 < c) {
        key = key.substring(0, c);
      }
    }
    return mxResources.loadSpecialBundle && mxResources.isLanguageSupported(key) && key != mxClient.defaultLanguage ? containerName + "_" + key + mxResources.extension : null;
  },
  add : function(name, a, f) {
    a = null != a ? a : null != mxClient.language ? mxClient.language.toLowerCase() : mxConstants.NONE;
    if (a != mxConstants.NONE) {
      var value = mxResources.getDefaultBundle(name, a);
      var e = mxResources.getSpecialBundle(name, a);
      /**
       * @return {undefined}
       */
      var init = function() {
        if (null != e) {
          if (f) {
            mxUtils.get(e, function(status_tweet) {
              mxResources.parse(status_tweet.getText());
              f();
            }, function() {
              f();
            });
          } else {
            try {
              var control = mxUtils.load(e);
              if (control.isReady()) {
                mxResources.parse(control.getText());
              }
            } catch (l) {
            }
          }
        } else {
          if (null != f) {
            f();
          }
        }
      };
      if (null != value) {
        if (f) {
          mxUtils.get(value, function(status_tweet) {
            mxResources.parse(status_tweet.getText());
            init();
          }, function() {
            init();
          });
        } else {
          try {
            var indicator = mxUtils.load(value);
            if (indicator.isReady()) {
              mxResources.parse(indicator.getText());
            }
            init();
          } catch (k) {
          }
        }
      } else {
        init();
      }
    }
  },
  parse : function(tokens) {
    if (null != tokens) {
      tokens = tokens.split("\n");
      /** @type {number} */
      var j = 0;
      for (; j < tokens.length; j++) {
        if ("#" != tokens[j].charAt(0)) {
          var index = tokens[j].indexOf("=");
          if (0 < index) {
            var i = tokens[j].substring(0, index);
            var length = tokens[j].length;
            if (13 == tokens[j].charCodeAt(length - 1)) {
              length--;
            }
            index = tokens[j].substring(index + 1, length);
            if (this.resourcesEncoded) {
              index = index.replace(/\\(?=u[a-fA-F\d]{4})/g, "%");
              /** @type {string} */
              mxResources.resources[i] = unescape(index);
            } else {
              mxResources.resources[i] = index;
            }
          }
        }
      }
    }
  },
  get : function(name, idx, _) {
    name = mxResources.resources[name];
    if (null == name) {
      /** @type {!Function} */
      name = _;
    }
    if (null != name && null != idx) {
      name = mxResources.replacePlaceholders(name, idx);
    }
    return name;
  },
  replacePlaceholders : function(index, text) {
    /** @type {!Array} */
    var newtext = [];
    /** @type {null} */
    var i = null;
    /** @type {number} */
    var x = 0;
    for (; x < index.length; x++) {
      var mil = index.charAt(x);
      if ("{" == mil) {
        /** @type {string} */
        i = "";
      } else {
        if (null != i && "}" == mil) {
          /** @type {number} */
          i = parseInt(i) - 1;
          if (0 <= i && i < text.length) {
            newtext.push(text[i]);
          }
          /** @type {null} */
          i = null;
        } else {
          if (null != i) {
            /** @type {string} */
            i = i + mil;
          } else {
            newtext.push(mil);
          }
        }
      }
    }
    return newtext.join("");
  },
  loadResources : function(callback) {
    mxResources.add(mxClient.basePath + "/resources/editor", null, function() {
      mxResources.add(mxClient.basePath + "/resources/graph", null, callback);
    });
  }
};
/**
 * @param {number} a
 * @param {number} b
 * @return {undefined}
 */
function mxPoint(a, b) {
  this.x = null != a ? a : 0;
  this.y = null != b ? b : 0;
}
/** @type {null} */
mxPoint.prototype.x = null;
/** @type {null} */
mxPoint.prototype.y = null;
/**
 * @param {!Object} current
 * @return {?}
 */
mxPoint.prototype.equals = function(current) {
  return null != current && current.x == this.x && current.y == this.y;
};
/**
 * @return {?}
 */
mxPoint.prototype.clone = function() {
  return mxUtils.clone(this);
};
/**
 * @param {?} callback
 * @param {?} lineNumber
 * @param {number} width
 * @param {number} height
 * @return {undefined}
 */
function mxRectangle(callback, lineNumber, width, height) {
  mxPoint.call(this, callback, lineNumber);
  this.width = null != width ? width : 0;
  this.height = null != height ? height : 0;
}
mxRectangle.prototype = new mxPoint;
/** @type {function(?, ?, number, number): undefined} */
mxRectangle.prototype.constructor = mxRectangle;
/** @type {null} */
mxRectangle.prototype.width = null;
/** @type {null} */
mxRectangle.prototype.height = null;
/**
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @return {undefined}
 */
mxRectangle.prototype.setRect = function(x, y, width, height) {
  /** @type {number} */
  this.x = x;
  /** @type {number} */
  this.y = y;
  /** @type {number} */
  this.width = width;
  /** @type {number} */
  this.height = height;
};
/**
 * @return {?}
 */
mxRectangle.prototype.getCenterX = function() {
  return this.x + this.width / 2;
};
/**
 * @return {?}
 */
mxRectangle.prototype.getCenterY = function() {
  return this.y + this.height / 2;
};
/**
 * @param {number} value
 * @return {undefined}
 */
mxRectangle.prototype.add = function(value) {
  if (null != value) {
    /** @type {number} */
    var x = Math.min(this.x, value.x);
    /** @type {number} */
    var y = Math.min(this.y, value.y);
    /** @type {number} */
    var w = Math.max(this.x + this.width, value.x + value.width);
    /** @type {number} */
    value = Math.max(this.y + this.height, value.y + value.height);
    /** @type {number} */
    this.x = x;
    /** @type {number} */
    this.y = y;
    /** @type {number} */
    this.width = w - x;
    /** @type {number} */
    this.height = value - y;
  }
};
/**
 * @param {!Object} b
 * @return {undefined}
 */
mxRectangle.prototype.intersect = function(b) {
  if (null != b) {
    var ax2 = this.x + this.width;
    var dtStep = b.x + b.width;
    var y = this.y + this.height;
    var imgNowHeight = b.y + b.height;
    /** @type {number} */
    this.x = Math.max(this.x, b.x);
    /** @type {number} */
    this.y = Math.max(this.y, b.y);
    /** @type {number} */
    this.width = Math.min(ax2, dtStep) - this.x;
    /** @type {number} */
    this.height = Math.min(y, imgNowHeight) - this.y;
  }
};
/**
 * @param {number} x
 * @return {?}
 */
mxRectangle.prototype.grow = function(x) {
  this.x -= x;
  this.y -= x;
  this.width += 2 * x;
  this.height += 2 * x;
  return this;
};
/**
 * @return {?}
 */
mxRectangle.prototype.getPoint = function() {
  return new mxPoint(this.x, this.y);
};
/**
 * @return {undefined}
 */
mxRectangle.prototype.rotate90 = function() {
  /** @type {number} */
  var x = (this.width - this.height) / 2;
  this.x += x;
  this.y -= x;
  x = this.width;
  this.width = this.height;
  this.height = x;
};
/**
 * @param {!Object} current
 * @return {?}
 */
mxRectangle.prototype.equals = function(current) {
  return null != current && current.x == this.x && current.y == this.y && current.width == this.width && current.height == this.height;
};
/**
 * @param {!Object} x
 * @return {?}
 */
mxRectangle.fromPoint = function(x) {
  return new mxRectangle(x.x, x.y, 0, 0);
};
/**
 * @param {?} obj
 * @return {?}
 */
mxRectangle.fromRectangle = function(obj) {
  return new mxRectangle(obj.x, obj.y, obj.width, obj.height);
};
var mxEffects = {
  animateChanges : function(r, changes, done) {
    /** @type {number} */
    var squanchiness = 0;
    /**
     * @return {undefined}
     */
    var draw = function() {
      /** @type {boolean} */
      var hasCharacters = false;
      /** @type {number} */
      var i = 0;
      for (; i < changes.length; i++) {
        var change = changes[i];
        if (change instanceof mxGeometryChange || change instanceof mxTerminalChange || change instanceof mxValueChange || change instanceof mxChildChange || change instanceof mxStyleChange) {
          var node = r.getView().getState(change.cell || change.child, false);
          if (null != node) {
            if (hasCharacters = true, change.constructor != mxGeometryChange || r.model.isEdge(change.cell)) {
              mxUtils.setOpacity(node.shape.node, 100 * squanchiness / 10);
            } else {
              var scale = r.getView().scale;
              /** @type {number} */
              var x = (change.geometry.x - change.previous.x) * scale;
              /** @type {number} */
              var dy = (change.geometry.y - change.previous.y) * scale;
              /** @type {number} */
              var w = (change.geometry.width - change.previous.width) * scale;
              /** @type {number} */
              scale = scale * (change.geometry.height - change.previous.height);
              if (0 == squanchiness) {
                node.x -= x;
                node.y -= dy;
                node.width -= w;
                node.height -= scale;
              } else {
                node.x += x / 10;
                node.y += dy / 10;
                node.width += w / 10;
                node.height += scale / 10;
              }
              r.cellRenderer.redraw(node);
              mxEffects.cascadeOpacity(r, change.cell, 100 * squanchiness / 10);
            }
          }
        }
      }
      if (10 > squanchiness && hasCharacters) {
        squanchiness++;
        window.setTimeout(draw, renewTokenIn);
      } else {
        if (null != done) {
          done();
        }
      }
    };
    /** @type {number} */
    var renewTokenIn = 30;
    draw();
  },
  cascadeOpacity : function(self, start, value) {
    var d = self.model.getChildCount(start);
    /** @type {number} */
    var i = 0;
    for (; i < d; i++) {
      var token = self.model.getChildAt(start, i);
      var message = self.getView().getState(token);
      if (null != message) {
        mxUtils.setOpacity(message.shape.node, value);
        mxEffects.cascadeOpacity(self, token, value);
      }
    }
    start = self.model.getEdges(start);
    if (null != start) {
      /** @type {number} */
      i = 0;
      for (; i < start.length; i++) {
        d = self.getView().getState(start[i]);
        if (null != d) {
          mxUtils.setOpacity(d.shape.node, value);
        }
      }
    }
  },
  fadeOut : function(node, color, name, val, duration, targetVol) {
    val = val || 40;
    duration = duration || 30;
    var value = color || 100;
    mxUtils.setOpacity(node, value);
    if (targetVol || null == targetVol) {
      /**
       * @return {undefined}
       */
      var tick = function() {
        /** @type {number} */
        value = Math.max(value - val, 0);
        mxUtils.setOpacity(node, value);
        if (0 < value) {
          window.setTimeout(tick, duration);
        } else {
          /** @type {string} */
          node.style.visibility = "hidden";
          if (name && node.parentNode) {
            node.parentNode.removeChild(node);
          }
        }
      };
      window.setTimeout(tick, duration);
    } else {
      /** @type {string} */
      node.style.visibility = "hidden";
      if (name && node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
  }
};
var mxUtils = {
  errorResource : "none" != mxClient.language ? "error" : "",
  closeResource : "none" != mxClient.language ? "close" : "",
  errorImage : mxClient.imageBasePath + "/error.gif",
  removeCursors : function(root) {
    if (null != root.style) {
      /** @type {string} */
      root.style.cursor = "";
    }
    root = root.childNodes;
    if (null != root) {
      var l = root.length;
      /** @type {number} */
      var i = 0;
      for (; i < l; i = i + 1) {
        mxUtils.removeCursors(root[i]);
      }
    }
  },
  getCurrentStyle : function() {
    return mxClient.IS_IE && (null == document.documentMode || 9 > document.documentMode) ? function(o) {
      return null != o ? o.currentStyle : null;
    } : function(DOMNode) {
      return null != DOMNode ? window.getComputedStyle(DOMNode, "") : null;
    };
  }(),
  parseCssNumber : function(a) {
    if ("thin" == a) {
      /** @type {string} */
      a = "2";
    } else {
      if ("medium" == a) {
        /** @type {string} */
        a = "4";
      } else {
        if ("thick" == a) {
          /** @type {string} */
          a = "6";
        }
      }
    }
    /** @type {number} */
    a = parseFloat(a);
    if (isNaN(a)) {
      /** @type {number} */
      a = 0;
    }
    return a;
  },
  setPrefixedStyle : function() {
    /** @type {null} */
    var vendorCssPrefixJS = null;
    if (mxClient.IS_OT) {
      /** @type {string} */
      vendorCssPrefixJS = "O";
    } else {
      if (mxClient.IS_SF || mxClient.IS_GC) {
        /** @type {string} */
        vendorCssPrefixJS = "Webkit";
      } else {
        if (mxClient.IS_MT) {
          /** @type {string} */
          vendorCssPrefixJS = "Moz";
        } else {
          if (mxClient.IS_IE && 9 <= document.documentMode && 10 > document.documentMode) {
            /** @type {string} */
            vendorCssPrefixJS = "ms";
          }
        }
      }
    }
    return function(colVisible, c, newVisible) {
      colVisible[c] = newVisible;
      if (null != vendorCssPrefixJS && 0 < c.length) {
        c = vendorCssPrefixJS + c.substring(0, 1).toUpperCase() + c.substring(1);
        colVisible[c] = newVisible;
      }
    };
  }(),
  hasScrollbars : function(settings) {
    settings = mxUtils.getCurrentStyle(settings);
    return null != settings && ("scroll" == settings.overflow || "auto" == settings.overflow);
  },
  bind : function(a, f) {
    return function() {
      return f.apply(a, arguments);
    };
  },
  eval : function(a$jscomp$47) {
    /** @type {null} */
    var b$jscomp$30 = null;
    if (0 <= a$jscomp$47.indexOf("function")) {
      try {
        eval("var _mxJavaScriptExpression=" + a$jscomp$47);
        b$jscomp$30 = _mxJavaScriptExpression;
        /** @type {null} */
        _mxJavaScriptExpression = null;
      } catch (controlFlowAction) {
        mxLog.warn(controlFlowAction.message + " while evaluating " + a$jscomp$47);
      }
    } else {
      try {
        /** @type {*} */
        b$jscomp$30 = eval(a$jscomp$47);
      } catch (controlFlowAction) {
        mxLog.warn(controlFlowAction.message + " while evaluating " + a$jscomp$47);
      }
    }
    return b$jscomp$30;
  },
  findNode : function(node, value, root) {
    if (node.nodeType == mxConstants.NODETYPE_ELEMENT) {
      var result = node.getAttribute(value);
      if (null != result && result == root) {
        return node;
      }
    }
    node = node.firstChild;
    for (; null != node;) {
      result = mxUtils.findNode(node, value, root);
      if (null != result) {
        return result;
      }
      node = node.nextSibling;
    }
    return null;
  },
  getFunctionName : function(v) {
    /** @type {null} */
    var ret = null;
    if (null != v) {
      if (null != v.name) {
        ret = v.name;
      } else {
        ret = mxUtils.trim(v.toString());
        if (/^function\s/.test(ret)) {
          ret = mxUtils.ltrim(ret.substring(9));
          v = ret.indexOf("(");
          if (0 < v) {
            ret = ret.substring(0, v);
          }
        }
      }
    }
    return ret;
  },
  indexOf : function(str, s) {
    if (null != str && null != s) {
      /** @type {number} */
      var i = 0;
      for (; i < str.length; i++) {
        if (str[i] == s) {
          return i;
        }
      }
    }
    return -1;
  },
  forEach : function(array, iteratee) {
    if (null != array && null != iteratee) {
      /** @type {number} */
      var i = 0;
      for (; i < array.length; i++) {
        iteratee(array[i]);
      }
    }
    return array;
  },
  remove : function(value, data) {
    /** @type {null} */
    var _file = null;
    if ("object" == typeof data) {
      var d = mxUtils.indexOf(data, value);
      for (; 0 <= d;) {
        data.splice(d, 1);
        /** @type {!Object} */
        _file = value;
        d = mxUtils.indexOf(data, value);
      }
    }
    var i;
    for (i in data) {
      if (data[i] == value) {
        delete data[i];
        /** @type {!Object} */
        _file = value;
      }
    }
    return _file;
  },
  isNode : function(element, o, elem, value) {
    return null == element || element.constructor !== Element || null != o && element.nodeName.toLowerCase() != o.toLowerCase() ? false : null == elem || element.getAttribute(elem) == value;
  },
  isAncestorNode : function(node, ancestor) {
    for (; null != ancestor;) {
      if (ancestor == node) {
        return true;
      }
      ancestor = ancestor.parentNode;
    }
    return false;
  },
  getChildNodes : function(node, type) {
    type = type || mxConstants.NODETYPE_ELEMENT;
    /** @type {!Array} */
    var nodes = [];
    node = node.firstChild;
    for (; null != node;) {
      if (node.nodeType == type) {
        nodes.push(node);
      }
      node = node.nextSibling;
    }
    return nodes;
  },
  importNode : function(doc, node, importChildren) {
    return mxClient.IS_IE && (null == document.documentMode || 10 > document.documentMode) ? mxUtils.importNodeImplementation(doc, node, importChildren) : doc.importNode(node, importChildren);
  },
  importNodeImplementation : function(document, node, allChildren) {
    switch(node.nodeType) {
      case 1:
        var newNode = document.createElement(node.nodeName);
        if (node.attributes && 0 < node.attributes.length) {
          /** @type {number} */
          var i = 0;
          for (; i < node.attributes.length; i++) {
            newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i].nodeName));
          }
        }
        if (allChildren && node.childNodes && 0 < node.childNodes.length) {
          /** @type {number} */
          i = 0;
          for (; i < node.childNodes.length; i++) {
            newNode.appendChild(mxUtils.importNodeImplementation(document, node.childNodes[i], allChildren));
          }
        }
        return newNode;
      case 3:
      case 4:
      case 8:
        return document.createTextNode(null != node.nodeValue ? node.nodeValue : node.value);
    }
  },
  createXmlDocument : function() {
    /** @type {null} */
    var doc = null;
    if (document.implementation && document.implementation.createDocument) {
      /** @type {(Document|null)} */
      doc = document.implementation.createDocument("", "", null);
    }
    return doc;
  },
  parseXml : function(markup) {
    return (new DOMParser).parseFromString(markup, "text/xml");
  },
  clearSelection : function() {
    return document.selection ? function() {
      document.selection.empty();
    } : window.getSelection ? function() {
      if (window.getSelection().empty) {
        window.getSelection().empty();
      } else {
        if (window.getSelection().removeAllRanges) {
          window.getSelection().removeAllRanges();
        }
      }
    } : function() {
    };
  }(),
  removeWhitespace : function(node, left) {
    node = left ? node.previousSibling : node.nextSibling;
    for (; null != node && node.nodeType == mxConstants.NODETYPE_TEXT;) {
      var x = left ? node.previousSibling : node.nextSibling;
      var style = mxUtils.getTextContent(node);
      if (0 == mxUtils.trim(style).length) {
        node.parentNode.removeChild(node);
      }
      node = x;
    }
  },
  htmlEntities : function(text, str) {
    /** @type {string} */
    text = String(text || "");
    /** @type {string} */
    text = text.replace(/&/g, "&amp;");
    /** @type {string} */
    text = text.replace(/"/g, "&quot;");
    /** @type {string} */
    text = text.replace(/'/g, "&#39;");
    /** @type {string} */
    text = text.replace(/</g, "&lt;");
    /** @type {string} */
    text = text.replace(/>/g, "&gt;");
    if (null == str || str) {
      /** @type {string} */
      text = text.replace(/\n/g, "&#xa;");
    }
    return text;
  },
  decodeHtml : function(value) {
    /** @type {!Element} */
    var textArea = document.createElement("textarea");
    /** @type {string} */
    textArea.innerHTML = value;
    return textArea.value;
  },
  getXml : function(node, err) {
    /** @type {string} */
    var s = "";
    if (mxClient.IS_IE || mxClient.IS_IE11) {
      s = mxUtils.getPrettyXml(node, "", "", "");
    } else {
      if (null != window.XMLSerializer) {
        /** @type {string} */
        s = (new XMLSerializer).serializeToString(node);
      } else {
        if (null != node.xml) {
          s = node.xml.replace(/\r\n\t[\t]*/g, "").replace(/>\r\n/g, ">").replace(/\r\n/g, "\n");
        }
      }
    }
    return s = s.replace(/\n/g, err || "&#xa;");
  },
  getPrettyXml : function(node, e, i, obj, t) {
    /** @type {!Array} */
    var result = [];
    if (null != node) {
      if (e = null != e ? e : "  ", i = null != i ? i : "", obj = null != obj ? obj : "\n", null != node.namespaceURI && node.namespaceURI != t && (t = node.namespaceURI, null == node.getAttribute("xmlns") && node.setAttribute("xmlns", node.namespaceURI)), node.nodeType == mxConstants.NODETYPE_DOCUMENT) {
        result.push(mxUtils.getPrettyXml(node.documentElement, e, i, obj, t));
      } else {
        if (node.nodeType == mxConstants.NODETYPE_DOCUMENT_FRAGMENT) {
          var item = node.firstChild;
          if (null != item) {
            for (; null != item;) {
              result.push(mxUtils.getPrettyXml(item, e, i, obj, t));
              item = item.nextSibling;
            }
          }
        } else {
          if (node.nodeType == mxConstants.NODETYPE_COMMENT) {
            node = mxUtils.getTextContent(node);
            if (0 < node.length) {
              result.push(i + "\x3c!--" + node + "--\x3e" + obj);
            }
          } else {
            if (node.nodeType == mxConstants.NODETYPE_TEXT) {
              node = mxUtils.trim(mxUtils.getTextContent(node));
              if (0 < node.length) {
                result.push(i + mxUtils.htmlEntities(node, false) + obj);
              }
            } else {
              if (node.nodeType == mxConstants.NODETYPE_CDATA) {
                node = mxUtils.getTextContent(node);
                if (0 < node.length) {
                  result.push(i + "<![CDATA[" + node + "]]" + obj);
                }
              } else {
                result.push(i + "<" + node.nodeName);
                item = node.attributes;
                if (null != item) {
                  /** @type {number} */
                  var i = 0;
                  for (; i < item.length; i++) {
                    var l = mxUtils.htmlEntities(item[i].value);
                    result.push(" " + item[i].nodeName + '="' + l + '"');
                  }
                }
                item = node.firstChild;
                if (null != item) {
                  result.push(">" + obj);
                  for (; null != item;) {
                    result.push(mxUtils.getPrettyXml(item, e, i + e, obj, t));
                    item = item.nextSibling;
                  }
                  result.push(i + "</" + node.nodeName + ">" + obj);
                } else {
                  result.push(" />" + obj);
                }
              }
            }
          }
        }
      }
    }
    return result.join("");
  },
  extractTextWithWhitespace : function(x) {
    /**
     * @param {!Object} a
     * @return {undefined}
     */
    function fn(a) {
      if (1 != a.length || "BR" != a[0].nodeName && "\n" != a[0].innerHTML) {
        /** @type {number} */
        var i = 0;
        for (; i < a.length; i++) {
          var e = a[i];
          if ("BR" == e.nodeName || "\n" == e.innerHTML || (1 == a.length || 0 == i) && "DIV" == e.nodeName && "<br>" == e.innerHTML.toLowerCase()) {
            out.push("\n");
          } else {
            if (3 === e.nodeType || 4 === e.nodeType) {
              if (0 < e.nodeValue.length) {
                out.push(e.nodeValue);
              }
            } else {
              if (8 !== e.nodeType && 0 < e.childNodes.length) {
                fn(e.childNodes);
              }
            }
            if (i < a.length - 1 && 0 <= mxUtils.indexOf(str, a[i + 1].nodeName)) {
              out.push("\n");
            }
          }
        }
      }
    }
    /** @type {!Array<string>} */
    var str = "BLOCKQUOTE DIV H1 H2 H3 H4 H5 H6 OL P PRE TABLE UL".split(" ");
    /** @type {!Array} */
    var out = [];
    fn(x);
    return out.join("");
  },
  replaceTrailingNewlines : function(num, numBits) {
    /** @type {string} */
    var c = "";
    for (; 0 < num.length && "\n" == num.charAt(num.length - 1);) {
      num = num.substring(0, num.length - 1);
      /** @type {string} */
      c = c + numBits;
    }
    return num + c;
  },
  getTextContent : function(el) {
    return mxClient.IS_IE && void 0 !== el.innerText ? el.innerText : null != el ? el[void 0 === el.textContent ? "text" : "textContent"] : "";
  },
  setTextContent : function(node, value) {
    if (void 0 !== node.innerText) {
      /** @type {string} */
      node.innerText = value;
    } else {
      /** @type {string} */
      node[void 0 === node.textContent ? "text" : "textContent"] = value;
    }
  },
  getInnerHtml : function() {
    return mxClient.IS_IE ? function(result) {
      return null != result ? result.innerHTML : "";
    } : function(n) {
      return null != n ? (new XMLSerializer).serializeToString(n) : "";
    };
  }(),
  getOuterHtml : function() {
    return mxClient.IS_IE ? function(c) {
      if (null != c) {
        if (null != c.outerHTML) {
          return c.outerHTML;
        }
        /** @type {!Array} */
        var e = [];
        e.push("<" + c.nodeName);
        var n = c.attributes;
        if (null != n) {
          /** @type {number} */
          var i = 0;
          for (; i < n.length; i++) {
            var b = n[i].value;
            if (null != b && 0 < b.length) {
              e.push(" ");
              e.push(n[i].nodeName);
              e.push('="');
              e.push(b);
              e.push('"');
            }
          }
        }
        if (0 == c.innerHTML.length) {
          e.push("/>");
        } else {
          e.push(">");
          e.push(c.innerHTML);
          e.push("</" + c.nodeName + ">");
        }
        return e.join("");
      }
      return "";
    } : function(n) {
      return null != n ? (new XMLSerializer).serializeToString(n) : "";
    };
  }(),
  write : function(node, content) {
    content = node.ownerDocument.createTextNode(content);
    if (null != node) {
      node.appendChild(content);
    }
    return content;
  },
  writeln : function(e, out) {
    out = e.ownerDocument.createTextNode(out);
    if (null != e) {
      e.appendChild(out);
      e.appendChild(document.createElement("br"));
    }
    return out;
  },
  br : function(c, w) {
    w = w || 1;
    /** @type {null} */
    var entry = null;
    /** @type {number} */
    var nv = 0;
    for (; nv < w; nv++) {
      if (null != c) {
        entry = c.ownerDocument.createElement("br");
        c.appendChild(entry);
      }
    }
    return entry;
  },
  button : function(value, action, node) {
    node = null != node ? node : document;
    node = node.createElement("button");
    mxUtils.write(node, value);
    mxEvent.addListener(node, "click", function(toggler) {
      action(toggler);
    });
    return node;
  },
  para : function(address, label) {
    /** @type {!Element} */
    var text = document.createElement("p");
    mxUtils.write(text, label);
    if (null != address) {
      address.appendChild(text);
    }
    return text;
  },
  addTransparentBackgroundFilter : function(o) {
    o.style.filter += "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + mxClient.imageBasePath + "/transparent.gif', sizingMethod='scale')";
  },
  linkAction : function(value, link, action, fn, err) {
    return mxUtils.link(value, link, function() {
      action.execute(fn);
    }, err);
  },
  linkInvoke : function(link, value, _, func, arr, ct) {
    return mxUtils.link(link, value, function() {
      _[func](arr);
    }, ct);
  },
  link : function(key, value, scope, x) {
    /** @type {!Element} */
    var e = document.createElement("span");
    /** @type {string} */
    e.style.color = "blue";
    /** @type {string} */
    e.style.textDecoration = "underline";
    /** @type {string} */
    e.style.cursor = "pointer";
    if (null != x) {
      /** @type {string} */
      e.style.paddingLeft = x + "px";
    }
    mxEvent.addListener(e, "click", scope);
    mxUtils.write(e, value);
    if (null != key) {
      key.appendChild(e);
    }
    return e;
  },
  getDocumentSize : function() {
    /** @type {!HTMLBodyElement} */
    var el = document.body;
    /** @type {!Element} */
    var doc = document.documentElement;
    try {
      return new mxRectangle(0, 0, el.clientWidth || doc.clientWidth, Math.max(el.clientHeight || 0, doc.clientHeight));
    } catch (c) {
      return new mxRectangle;
    }
  },
  fit : function(obj) {
    var b = mxUtils.getDocumentSize();
    /** @type {number} */
    var start = parseInt(obj.offsetLeft);
    /** @type {number} */
    var offset = parseInt(obj.offsetWidth);
    var t = mxUtils.getDocumentScrollOrigin(obj.ownerDocument);
    var a = t.x;
    t = t.y;
    var length = a + b.width;
    if (start + offset > length) {
      /** @type {string} */
      obj.style.left = Math.max(a, length - offset) + "px";
    }
    /** @type {number} */
    start = parseInt(obj.offsetTop);
    /** @type {number} */
    offset = parseInt(obj.offsetHeight);
    b = t + b.height;
    if (start + offset > b) {
      /** @type {string} */
      obj.style.top = Math.max(t, b - offset) + "px";
    }
  },
  load : function(value) {
    value = new mxXmlRequest(value, null, "GET", false);
    value.send();
    return value;
  },
  get : function(a, v, data, value, fn, message, headers) {
    a = new mxXmlRequest(a, null, "GET");
    /** @type {function(!Object, ?): undefined} */
    var k = a.setRequestHeaders;
    if (headers) {
      /**
       * @param {!Object} xhr
       * @param {?} request
       * @return {undefined}
       */
      a.setRequestHeaders = function(xhr, request) {
        k.apply(this, arguments);
        var i;
        for (i in headers) {
          xhr.setRequestHeader(i, headers[i]);
        }
      };
    }
    if (null != value) {
      a.setBinary(value);
    }
    a.send(v, data, fn, message);
    return a;
  },
  getAll : function(t, table, c) {
    var pal = t.length;
    /** @type {!Array} */
    var data = [];
    /** @type {number} */
    var buffer = 0;
    /**
     * @return {undefined}
     */
    var success = function() {
      if (0 == buffer && null != c) {
        c();
      }
      buffer++;
    };
    /** @type {number} */
    var k = 0;
    for (; k < t.length; k++) {
      (function(value, num) {
        mxUtils.get(value, function(res) {
          var p = res.getStatus();
          if (200 > p || 299 < p) {
            success();
          } else {
            /** @type {(Object|string)} */
            data[num] = res;
            pal--;
            if (0 == pal) {
              table(data);
            }
          }
        }, success);
      })(t[k], k);
    }
    if (0 == pal) {
      table(data);
    }
  },
  post : function(options, callback, e, path) {
    return (new mxXmlRequest(options, callback)).send(e, path);
  },
  submit : function(command, json, target, type) {
    return (new mxXmlRequest(command, json)).simulate(target, type);
  },
  loadInto : function(options, doc, fn) {
    if (mxClient.IS_IE) {
      /**
       * @return {undefined}
       */
      doc.onreadystatechange = function() {
        if (4 == doc.readyState) {
          fn();
        }
      };
    } else {
      doc.addEventListener("load", fn, false);
    }
    doc.load(options);
  },
  getValue : function(str, index, id) {
    str = null != str ? str[index] : null;
    if (null == str) {
      /** @type {number} */
      str = id;
    }
    return str;
  },
  getNumber : function(step, i, options) {
    step = null != step ? step[i] : null;
    if (null == step) {
      step = options || 0;
    }
    return Number(step);
  },
  getColor : function(state, type, all) {
    state = null != state ? state[type] : null;
    if (null == state) {
      /** @type {string} */
      state = all;
    } else {
      if (state == mxConstants.NONE) {
        /** @type {null} */
        state = null;
      }
    }
    return state;
  },
  isEmptyObject : function(object) {
    var name;
    for (name in object) {
      return false;
    }
    return true;
  },
  clone : function(node, code, parent) {
    parent = null != parent ? parent : false;
    /** @type {null} */
    var rrs = null;
    if (null != node && "function" == typeof node.constructor) {
      if (node.constructor === Element) {
        rrs = node.cloneNode(null != parent ? !parent : false);
      } else {
        rrs = new node.constructor;
        var i;
        for (i in node) {
          if (i != mxObjectIdentity.FIELD_NAME && (null == code || 0 > mxUtils.indexOf(code, i))) {
            rrs[i] = parent || "object" != typeof node[i] ? node[i] : mxUtils.clone(node[i]);
          }
        }
      }
    }
    return rrs;
  },
  equalPoints : function(a, b) {
    if (null == a && null != b || null != a && null == b || null != a && null != b && a.length != b.length) {
      return false;
    }
    if (null != a && null != b) {
      /** @type {number} */
      var i = 0;
      for (; i < a.length; i++) {
        if (null != a[i] && null == b[i] || null == a[i] && null != b[i] || null != a[i] && null != b[i] && (a[i].x != b[i].x || a[i].y != b[i].y)) {
          return false;
        }
      }
    }
    return true;
  },
  equalEntries : function(data, values) {
    /** @type {number} */
    var c = 0;
    if (null == data && null != values || null != data && null == values || null != data && null != values && data.length != values.length) {
      return false;
    }
    if (null != data && null != values) {
      var i;
      for (i in values) {
        c++;
      }
      for (i in data) {
        if (c--, !(mxUtils.isNaN(data[i]) && mxUtils.isNaN(values[i]) || data[i] == values[i])) {
          return false;
        }
      }
    }
    return 0 == c;
  },
  removeDuplicates : function(a) {
    var r = new mxDictionary;
    /** @type {!Array} */
    var result = [];
    /** @type {number} */
    var i = 0;
    for (; i < a.length; i++) {
      if (!r.get(a[i])) {
        result.push(a[i]);
        r.put(a[i], true);
      }
    }
    return result;
  },
  isNaN : function(value) {
    return "number" == typeof value && isNaN(value);
  },
  extend : function(ctor, target) {
    /**
     * @return {undefined}
     */
    var F = function() {
    };
    F.prototype = target.prototype;
    ctor.prototype = new F;
    /** @type {string} */
    ctor.prototype.constructor = ctor;
  },
  toString : function(obj) {
    /** @type {string} */
    var string = "";
    var prop;
    for (prop in obj) {
      try {
        if (null == obj[prop]) {
          /** @type {string} */
          string = string + (prop + " = [null]\n");
        } else {
          if ("function" == typeof obj[prop]) {
            /** @type {string} */
            string = string + (prop + " => [Function]\n");
          } else {
            if ("object" == typeof obj[prop]) {
              var subprop = mxUtils.getFunctionName(obj[prop].constructor);
              /** @type {string} */
              string = string + (prop + " => [" + subprop + "]\n");
            } else {
              /** @type {string} */
              string = string + (prop + " = " + obj[prop] + "\n");
            }
          }
        }
      } catch (e) {
        /** @type {string} */
        string = string + (prop + "=" + e.message);
      }
    }
    return string;
  },
  toRadians : function(value) {
    return Math.PI * value / 180;
  },
  toDegree : function(val) {
    return 180 * val / Math.PI;
  },
  arcToCurves : function(l, b, i, h, d, n, max, t, r) {
    /** @type {number} */
    t = t - l;
    /** @type {number} */
    r = r - b;
    if (0 === i || 0 === h) {
      return s;
    }
    /** @type {number} */
    i = Math.abs(i);
    /** @type {number} */
    h = Math.abs(h);
    /** @type {number} */
    var height = -t / 2;
    /** @type {number} */
    var x = -r / 2;
    /** @type {number} */
    var c = Math.cos(d * Math.PI / 180);
    /** @type {number} */
    s = Math.sin(d * Math.PI / 180);
    /** @type {number} */
    d = c * height + s * x;
    /** @type {number} */
    height = -1 * s * height + c * x;
    /** @type {number} */
    x = d * d;
    /** @type {number} */
    var y = height * height;
    /** @type {number} */
    var a = i * i;
    /** @type {number} */
    var f = h * h;
    /** @type {number} */
    var num = x / a + y / f;
    if (1 < num) {
      /** @type {number} */
      i = i * Math.sqrt(num);
      /** @type {number} */
      h = h * Math.sqrt(num);
      /** @type {number} */
      n = 0;
    } else {
      /** @type {number} */
      num = 1;
      if (n === max) {
        /** @type {number} */
        num = -1;
      }
      /** @type {number} */
      n = num * Math.sqrt((a * f - a * y - f * x) / (a * y + f * x));
    }
    /** @type {number} */
    x = n * i * height / h;
    /** @type {number} */
    y = -1 * n * h * d / i;
    /** @type {number} */
    t = c * x - s * y + t / 2;
    /** @type {number} */
    r = s * x + c * y + r / 2;
    /** @type {number} */
    a = Math.atan2((height - y) / h, (d - x) / i) - Math.atan2(0, 1);
    /** @type {number} */
    n = 0 <= a ? a : 2 * Math.PI + a;
    /** @type {number} */
    a = Math.atan2((-height - y) / h, (-d - x) / i) - Math.atan2((height - y) / h, (d - x) / i);
    /** @type {number} */
    d = 0 <= a ? a : 2 * Math.PI + a;
    if (0 == max && 0 < d) {
      /** @type {number} */
      d = d - 2 * Math.PI;
    } else {
      if (0 != max && 0 > d) {
        /** @type {number} */
        d = d + 2 * Math.PI;
      }
    }
    /** @type {number} */
    max = 2 * d / Math.PI;
    /** @type {number} */
    max = Math.ceil(0 > max ? -1 * max : max);
    /** @type {number} */
    d = d / max;
    /** @type {number} */
    height = 8 / 3 * Math.sin(d / 4) * Math.sin(d / 4) / Math.sin(d / 2);
    /** @type {number} */
    x = c * i;
    /** @type {number} */
    c = c * h;
    /** @type {number} */
    i = i * s;
    /** @type {number} */
    h = h * s;
    /** @type {number} */
    var w = Math.cos(n);
    /** @type {number} */
    var z = Math.sin(n);
    /** @type {number} */
    y = -height * (x * z + h * w);
    /** @type {number} */
    a = -height * (i * z - c * w);
    /** @type {!Array} */
    var s = [];
    /** @type {number} */
    var scale = 0;
    for (; scale < max; ++scale) {
      /** @type {number} */
      n = n + d;
      /** @type {number} */
      w = Math.cos(n);
      /** @type {number} */
      z = Math.sin(n);
      /** @type {number} */
      f = x * w - h * z + t;
      /** @type {number} */
      num = i * w + c * z + r;
      /** @type {number} */
      var k = -height * (x * z + h * w);
      /** @type {number} */
      w = -height * (i * z - c * w);
      /** @type {number} */
      z = 6 * scale;
      /** @type {number} */
      s[z] = Number(y + l);
      /** @type {number} */
      s[z + 1] = Number(a + b);
      /** @type {number} */
      s[z + 2] = Number(f - k + l);
      /** @type {number} */
      s[z + 3] = Number(num - w + b);
      /** @type {number} */
      s[z + 4] = Number(f + l);
      /** @type {number} */
      s[z + 5] = Number(num + b);
      /** @type {number} */
      y = f + k;
      /** @type {number} */
      a = num + w;
    }
    return s;
  },
  getBoundingBox : function(value, o, data) {
    /** @type {null} */
    var y = null;
    if (null != value && null != o && 0 != o) {
      o = mxUtils.toRadians(o);
      /** @type {number} */
      y = Math.cos(o);
      /** @type {number} */
      var sin = Math.sin(o);
      data = null != data ? data : new mxPoint(value.x + value.width / 2, value.y + value.height / 2);
      var result = new mxPoint(value.x, value.y);
      o = new mxPoint(value.x + value.width, value.y);
      var pt = new mxPoint(o.x, value.y + value.height);
      value = new mxPoint(value.x, pt.y);
      result = mxUtils.getRotatedPoint(result, y, sin, data);
      o = mxUtils.getRotatedPoint(o, y, sin, data);
      pt = mxUtils.getRotatedPoint(pt, y, sin, data);
      value = mxUtils.getRotatedPoint(value, y, sin, data);
      y = new mxRectangle(result.x, result.y, 0, 0);
      y.add(new mxRectangle(o.x, o.y, 0, 0));
      y.add(new mxRectangle(pt.x, pt.y, 0, 0));
      y.add(new mxRectangle(value.x, value.y, 0, 0));
    }
    return y;
  },
  getRotatedPoint : function(a, x, y, b) {
    b = null != b ? b : new mxPoint;
    /** @type {number} */
    var c = a.x - b.x;
    /** @type {number} */
    a = a.y - b.y;
    return new mxPoint(c * x - a * y + b.x, a * x + c * y + b.y);
  },
  getPortConstraints : function(s, d, method, graph) {
    d = mxUtils.getValue(s.style, mxConstants.STYLE_PORT_CONSTRAINT, mxUtils.getValue(d.style, method ? mxConstants.STYLE_SOURCE_PORT_CONSTRAINT : mxConstants.STYLE_TARGET_PORT_CONSTRAINT, null));
    if (null == d) {
      return graph;
    }
    graph = d.toString();
    d = mxConstants.DIRECTION_MASK_NONE;
    /** @type {number} */
    method = 0;
    if (1 == mxUtils.getValue(s.style, mxConstants.STYLE_PORT_CONSTRAINT_ROTATION, 0)) {
      method = mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION, 0);
    }
    /** @type {number} */
    s = 0;
    if (45 < method) {
      /** @type {number} */
      s = 1;
      if (135 <= method) {
        /** @type {number} */
        s = 2;
      }
    } else {
      if (-45 > method) {
        /** @type {number} */
        s = 3;
        if (-135 >= method) {
          /** @type {number} */
          s = 2;
        }
      }
    }
    if (0 <= graph.indexOf(mxConstants.DIRECTION_NORTH)) {
      switch(s) {
        case 0:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_NORTH;
          break;
        case 1:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_EAST;
          break;
        case 2:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_SOUTH;
          break;
        case 3:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_WEST;
      }
    }
    if (0 <= graph.indexOf(mxConstants.DIRECTION_WEST)) {
      switch(s) {
        case 0:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_WEST;
          break;
        case 1:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_NORTH;
          break;
        case 2:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_EAST;
          break;
        case 3:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_SOUTH;
      }
    }
    if (0 <= graph.indexOf(mxConstants.DIRECTION_SOUTH)) {
      switch(s) {
        case 0:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_SOUTH;
          break;
        case 1:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_WEST;
          break;
        case 2:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_NORTH;
          break;
        case 3:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_EAST;
      }
    }
    if (0 <= graph.indexOf(mxConstants.DIRECTION_EAST)) {
      switch(s) {
        case 0:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_EAST;
          break;
        case 1:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_SOUTH;
          break;
        case 2:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_WEST;
          break;
        case 3:
          /** @type {number} */
          d = d | mxConstants.DIRECTION_MASK_NORTH;
      }
    }
    return d;
  },
  reversePortConstraints : function(a) {
    /** @type {number} */
    var b = (a & mxConstants.DIRECTION_MASK_WEST) << 3;
    /** @type {number} */
    b = b | (a & mxConstants.DIRECTION_MASK_NORTH) << 1;
    /** @type {number} */
    b = b | (a & mxConstants.DIRECTION_MASK_SOUTH) >> 1;
    return b = b | (a & mxConstants.DIRECTION_MASK_EAST) >> 3;
  },
  findNearestSegment : function(fn, macro_context, options) {
    /** @type {number} */
    var spliceTo = -1;
    if (0 < fn.absolutePoints.length) {
      var from = fn.absolutePoints[0];
      /** @type {null} */
      var to = null;
      /** @type {number} */
      var i = 1;
      for (; i < fn.absolutePoints.length; i++) {
        var tmp = fn.absolutePoints[i];
        from = mxUtils.ptSegDistSq(from.x, from.y, tmp.x, tmp.y, macro_context, options);
        if (null == to || from < to) {
          to = from;
          /** @type {number} */
          spliceTo = i - 1;
        }
        from = tmp;
      }
    }
    return spliceTo;
  },
  getDirectedBounds : function(offset, obj, value, options, parent) {
    var f = mxUtils.getValue(value, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
    options = null != options ? options : mxUtils.getValue(value, mxConstants.STYLE_FLIPH, false);
    parent = null != parent ? parent : mxUtils.getValue(value, mxConstants.STYLE_FLIPV, false);
    /** @type {number} */
    obj.x = Math.round(Math.max(0, Math.min(offset.width, obj.x)));
    /** @type {number} */
    obj.y = Math.round(Math.max(0, Math.min(offset.height, obj.y)));
    /** @type {number} */
    obj.width = Math.round(Math.max(0, Math.min(offset.width, obj.width)));
    /** @type {number} */
    obj.height = Math.round(Math.max(0, Math.min(offset.height, obj.height)));
    if (parent && (f == mxConstants.DIRECTION_SOUTH || f == mxConstants.DIRECTION_NORTH) || options && (f == mxConstants.DIRECTION_EAST || f == mxConstants.DIRECTION_WEST)) {
      /** @type {number} */
      value = obj.x;
      /** @type {number} */
      obj.x = obj.width;
      /** @type {number} */
      obj.width = value;
    }
    if (options && (f == mxConstants.DIRECTION_SOUTH || f == mxConstants.DIRECTION_NORTH) || parent && (f == mxConstants.DIRECTION_EAST || f == mxConstants.DIRECTION_WEST)) {
      /** @type {number} */
      value = obj.y;
      /** @type {number} */
      obj.y = obj.height;
      /** @type {number} */
      obj.height = value;
    }
    options = mxRectangle.fromRectangle(obj);
    if (f == mxConstants.DIRECTION_SOUTH) {
      /** @type {number} */
      options.y = obj.x;
      /** @type {number} */
      options.x = obj.height;
      /** @type {number} */
      options.width = obj.y;
      /** @type {number} */
      options.height = obj.width;
    } else {
      if (f == mxConstants.DIRECTION_WEST) {
        /** @type {number} */
        options.y = obj.height;
        /** @type {number} */
        options.x = obj.width;
        /** @type {number} */
        options.width = obj.x;
        /** @type {number} */
        options.height = obj.y;
      } else {
        if (f == mxConstants.DIRECTION_NORTH) {
          /** @type {number} */
          options.y = obj.width;
          /** @type {number} */
          options.x = obj.y;
          /** @type {number} */
          options.width = obj.height;
          /** @type {number} */
          options.height = obj.x;
        }
      }
    }
    return new mxRectangle(offset.x + options.x, offset.y + options.y, offset.width - options.width - options.x, offset.height - options.height - options.y);
  },
  getPerimeterPoint : function(obj, point, prev) {
    /** @type {null} */
    var second = null;
    /** @type {number} */
    var type = 0;
    for (; type < obj.length - 1; type++) {
      var first = mxUtils.intersection(obj[type].x, obj[type].y, obj[type + 1].x, obj[type + 1].y, point.x, point.y, prev.x, prev.y);
      if (null != first) {
        /** @type {number} */
        var lightJ = prev.x - first.x;
        /** @type {number} */
        var lightI = prev.y - first.y;
        first = {
          p : first,
          distSq : lightI * lightI + lightJ * lightJ
        };
        if (null != first && (null == second || second.distSq > first.distSq)) {
          second = first;
        }
      }
    }
    return null != second ? second.p : null;
  },
  intersectsPoints : function(value, all) {
    /** @type {number} */
    var i = 0;
    for (; i < all.length - 1; i++) {
      if (mxUtils.rectangleIntersectsSegment(value, all[i], all[i + 1])) {
        return true;
      }
    }
    return false;
  },
  rectangleIntersectsSegment : function(r, s, t) {
    var offset = r.y;
    var i = r.x;
    var max = offset + r.height;
    var size = i + r.width;
    r = s.x;
    var n = t.x;
    if (s.x > t.x) {
      r = t.x;
      n = s.x;
    }
    if (n > size) {
      n = size;
    }
    if (r < i) {
      r = i;
    }
    if (r > n) {
      return false;
    }
    i = s.y;
    size = t.y;
    /** @type {number} */
    var crossRS = t.x - s.x;
    if (1E-7 < Math.abs(crossRS)) {
      /** @type {number} */
      t = (t.y - s.y) / crossRS;
      /** @type {number} */
      s = s.y - t * s.x;
      /** @type {number} */
      i = t * r + s;
      /** @type {number} */
      size = t * n + s;
    }
    if (i > size) {
      s = size;
      size = i;
      /** @type {number} */
      i = s;
    }
    if (size > max) {
      size = max;
    }
    if (i < offset) {
      i = offset;
    }
    return i > size ? false : true;
  },
  contains : function(a, e, b) {
    return a.x <= e && a.x + a.width >= e && a.y <= b && a.y + a.height >= b;
  },
  intersects : function(a, b) {
    var j = a.width;
    var x = a.height;
    var h = b.width;
    var c = b.height;
    if (0 >= h || 0 >= c || 0 >= j || 0 >= x) {
      return false;
    }
    var height = a.x;
    a = a.y;
    var i = b.x;
    b = b.y;
    h = h + i;
    c = c + b;
    j = j + height;
    x = x + a;
    return (h < i || h > height) && (c < b || c > a) && (j < height || j > i) && (x < a || x > b);
  },
  intersectsHotspot : function(s, x, y, w, v, e) {
    w = null != w ? w : 1;
    v = null != v ? v : 0;
    e = null != e ? e : 0;
    if (0 < w) {
      var b = s.getCenterX();
      var l = s.getCenterY();
      var d = s.width;
      var c = s.height;
      /** @type {number} */
      var a = mxUtils.getValue(s.style, mxConstants.STYLE_STARTSIZE) * s.view.scale;
      if (0 < a) {
        if (mxUtils.getValue(s.style, mxConstants.STYLE_HORIZONTAL, true)) {
          l = s.y + a / 2;
          /** @type {number} */
          c = a;
        } else {
          b = s.x + a / 2;
          /** @type {number} */
          d = a;
        }
      }
      /** @type {number} */
      d = Math.max(v, d * w);
      /** @type {number} */
      c = Math.max(v, c * w);
      if (0 < e) {
        /** @type {number} */
        d = Math.min(d, e);
        /** @type {number} */
        c = Math.min(c, e);
      }
      w = new mxRectangle(b - d / 2, l - c / 2, d, c);
      b = mxUtils.toRadians(mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION) || 0);
      if (0 != b) {
        /** @type {number} */
        v = Math.cos(-b);
        /** @type {number} */
        e = Math.sin(-b);
        b = new mxPoint(s.getCenterX(), s.getCenterY());
        s = mxUtils.getRotatedPoint(new mxPoint(x, y), v, e, b);
        x = s.x;
        y = s.y;
      }
      return mxUtils.contains(w, x, y);
    }
    return true;
  },
  getOffset : function(obj, pos) {
    /** @type {number} */
    var x = 0;
    /** @type {number} */
    var height = 0;
    /** @type {boolean} */
    var bottom = false;
    /** @type {!Object} */
    var elt = obj;
    /** @type {!HTMLBodyElement} */
    var element = document.body;
    /** @type {!Element} */
    var ddE = document.documentElement;
    for (; null != elt && elt != element && elt != ddE && !bottom;) {
      var geometry = mxUtils.getCurrentStyle(elt);
      if (null != geometry) {
        /** @type {boolean} */
        bottom = bottom || "fixed" == geometry.position;
      }
      elt = elt.parentNode;
    }
    if (!(pos || bottom)) {
      pos = mxUtils.getDocumentScrollOrigin(obj.ownerDocument);
      x = x + pos.x;
      height = height + pos.y;
    }
    obj = obj.getBoundingClientRect();
    if (null != obj) {
      x = x + obj.left;
      height = height + obj.top;
    }
    return new mxPoint(x, height);
  },
  getDocumentScrollOrigin : function(elem) {
    elem = elem.defaultView || elem.parentWindow;
    return new mxPoint(null != elem && void 0 !== window.pageXOffset ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft, null != elem && void 0 !== window.pageYOffset ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop);
  },
  getScrollOrigin : function(e, name, max) {
    name = null != name ? name : false;
    max = null != max ? max : true;
    var node = null != e ? e.ownerDocument : document;
    var body = node.body;
    var root = node.documentElement;
    var pt = new mxPoint;
    /** @type {boolean} */
    var reverse = false;
    for (; null != e && e != body && e != root;) {
      if (!(isNaN(e.scrollLeft) || isNaN(e.scrollTop))) {
        pt.x += e.scrollLeft;
        pt.y += e.scrollTop;
      }
      var edgeLabel = mxUtils.getCurrentStyle(e);
      if (null != edgeLabel) {
        /** @type {boolean} */
        reverse = reverse || "fixed" == edgeLabel.position;
      }
      e = name ? e.parentNode : null;
    }
    if (!reverse && max) {
      e = mxUtils.getDocumentScrollOrigin(node);
      pt.x += e.x;
      pt.y += e.y;
    }
    return pt;
  },
  convertPoint : function(p, x, t) {
    var player = mxUtils.getScrollOrigin(p, false);
    p = mxUtils.getOffset(p);
    p.x -= player.x;
    p.y -= player.y;
    return new mxPoint(x - p.x, t - p.y);
  },
  ltrim : function(s, chars) {
    return null != s ? s.replace(new RegExp("^[" + (chars || "\\s") + "]+", "g"), "") : null;
  },
  rtrim : function(str, value) {
    return null != str ? str.replace(new RegExp("[" + (value || "\\s") + "]+$", "g"), "") : null;
  },
  trim : function(str, chars) {
    return mxUtils.ltrim(mxUtils.rtrim(str, chars), chars);
  },
  isNumeric : function(value) {
    return !isNaN(parseFloat(value)) && isFinite(value) && ("string" != typeof value || 0 > value.toLowerCase().indexOf("0x"));
  },
  isInteger : function(value) {
    return String(parseInt(value)) === String(value);
  },
  mod : function(x, n) {
    return (x % n + n) % n;
  },
  intersection : function(s, r, b, c, d, a, f, p) {
    /** @type {number} */
    var q = (p - a) * (b - s) - (f - d) * (c - r);
    /** @type {number} */
    f = ((f - d) * (r - a) - (p - a) * (s - d)) / q;
    /** @type {number} */
    d = ((b - s) * (r - a) - (c - r) * (s - d)) / q;
    return 0 <= f && 1 >= f && 0 <= d && 1 >= d ? new mxPoint(s + f * (b - s), r + f * (c - r)) : null;
  },
  ptSegDistSq : function(x, e, d, c, a, b) {
    /** @type {number} */
    d = d - x;
    /** @type {number} */
    c = c - e;
    /** @type {number} */
    a = a - x;
    /** @type {number} */
    b = b - e;
    if (0 >= a * d + b * c) {
      /** @type {number} */
      d = 0;
    } else {
      /** @type {number} */
      a = d - a;
      /** @type {number} */
      b = c - b;
      /** @type {number} */
      x = a * d + b * c;
      /** @type {number} */
      d = 0 >= x ? 0 : x * x / (d * d + c * c);
    }
    /** @type {number} */
    a = a * a + b * b - d;
    if (0 > a) {
      /** @type {number} */
      a = 0;
    }
    return a;
  },
  ptLineDist : function(d, g, b, r, a, c) {
    return Math.abs((r - g) * a - (b - d) * c + b * g - r * d) / Math.sqrt((r - g) * (r - g) + (b - d) * (b - d));
  },
  relativeCcw : function(d, a, f, i, b, c) {
    /** @type {number} */
    f = f - d;
    /** @type {number} */
    i = i - a;
    /** @type {number} */
    b = b - d;
    /** @type {number} */
    c = c - a;
    /** @type {number} */
    d = b * i - c * f;
    if (0 == d) {
      /** @type {number} */
      d = b * f + c * i;
      if (0 < d) {
        /** @type {number} */
        d = (b - f) * f + (c - i) * i;
        if (0 > d) {
          /** @type {number} */
          d = 0;
        }
      }
    }
    return 0 > d ? -1 : 0 < d ? 1 : 0;
  },
  animateChanges : function(a, b) {
    mxEffects.animateChanges.apply(this, arguments);
  },
  cascadeOpacity : function(a, val, reason) {
    mxEffects.cascadeOpacity.apply(this, arguments);
  },
  fadeOut : function(targetVol, startVol, stopAtEnd, val, force, elem) {
    mxEffects.fadeOut.apply(this, arguments);
  },
  setOpacity : function(elmt, opacity) {
    if (mxClient.IS_IE && ("undefined" === typeof document.documentMode || 9 > document.documentMode)) {
      /** @type {string} */
      elmt.style.filter = 100 <= opacity ? "" : "alpha(opacity=" + opacity + ")";
    } else {
      /** @type {number} */
      elmt.style.opacity = opacity / 100;
    }
  },
  createImage : function(position) {
    /** @type {!Element} */
    var img = document.createElement("img");
    img.setAttribute("src", position);
    img.setAttribute("border", "0");
    return img;
  },
  sortCells : function(a, v) {
    v = null != v ? v : true;
    var c = new mxDictionary;
    a.sort(function(b, d) {
      var a = c.get(b);
      if (null == a) {
        a = mxCellPath.create(b).split(mxCellPath.PATH_SEPARATOR);
        c.put(b, a);
      }
      b = c.get(d);
      if (null == b) {
        b = mxCellPath.create(d).split(mxCellPath.PATH_SEPARATOR);
        c.put(d, b);
      }
      d = mxCellPath.compare(a, b);
      return 0 == d ? 0 : 0 < d == v ? 1 : -1;
    });
    return a;
  },
  getStylename : function(a) {
    return null != a && (a = a.split(";")[0], 0 > a.indexOf("=")) ? a : "";
  },
  getStylenames : function(classes) {
    /** @type {!Array} */
    var remainingClasses = [];
    if (null != classes) {
      classes = classes.split(";");
      /** @type {number} */
      var i = 0;
      for (; i < classes.length; i++) {
        if (0 > classes[i].indexOf("=")) {
          remainingClasses.push(classes[i]);
        }
      }
    }
    return remainingClasses;
  },
  indexOfStylename : function(a, b) {
    if (null != a && null != b) {
      a = a.split(";");
      /** @type {number} */
      var ret = 0;
      /** @type {number} */
      var i = 0;
      for (; i < a.length; i++) {
        if (a[i] == b) {
          return ret;
        }
        ret = ret + (a[i].length + 1);
      }
    }
    return -1;
  },
  addStylename : function(result, value) {
    if (0 > mxUtils.indexOfStylename(result, value)) {
      if (null == result) {
        /** @type {string} */
        result = "";
      } else {
        if (0 < result.length && ";" != result.charAt(result.length - 1)) {
          /** @type {string} */
          result = result + ";";
        }
      }
      result = result + value;
    }
    return result;
  },
  removeStylename : function(a, v) {
    /** @type {!Array} */
    var na = [];
    if (null != a) {
      a = a.split(";");
      /** @type {number} */
      var i = 0;
      for (; i < a.length; i++) {
        if (a[i] != v) {
          na.push(a[i]);
        }
      }
    }
    return na.join(";");
  },
  removeAllStylenames : function(classes) {
    /** @type {!Array} */
    var remainingClasses = [];
    if (null != classes) {
      classes = classes.split(";");
      /** @type {number} */
      var i = 0;
      for (; i < classes.length; i++) {
        if (0 <= classes[i].indexOf("=")) {
          remainingClasses.push(classes[i]);
        }
      }
    }
    return remainingClasses.join(";");
  },
  setCellStyles : function(node, nodes, value, opacity) {
    if (null != nodes && 0 < nodes.length) {
      node.beginUpdate();
      try {
        /** @type {number} */
        var i = 0;
        for (; i < nodes.length; i++) {
          if (null != nodes[i]) {
            var ret = mxUtils.setStyle(node.getStyle(nodes[i]), value, opacity);
            node.setStyle(nodes[i], ret);
          }
        }
      } finally {
        node.endUpdate();
      }
    }
  },
  hex2rgb : function(out) {
    if (null != out && 7 == out.length && "#" == out.charAt(0)) {
      /** @type {number} */
      var whiteRating = parseInt(out.substring(1, 3), 16);
      /** @type {number} */
      var pageInd = parseInt(out.substring(3, 5), 16);
      /** @type {number} */
      out = parseInt(out.substring(5, 7), 16);
      /** @type {string} */
      out = "rgb(" + whiteRating + ", " + pageInd + ", " + out + ")";
    }
    return out;
  },
  hex2rgba : function(hexColor) {
    if (null != hexColor && 7 <= hexColor.length && "#" == hexColor.charAt(0)) {
      /** @type {number} */
      var num_subrows = parseInt(hexColor.substring(1, 3), 16);
      /** @type {number} */
      var whiteRating = parseInt(hexColor.substring(3, 5), 16);
      /** @type {number} */
      var pageInd = parseInt(hexColor.substring(5, 7), 16);
      /** @type {number} */
      var e = 1;
      if (7 < hexColor.length) {
        /** @type {number} */
        e = parseInt(hexColor.substring(7, 9), 16) / 255;
      }
      /** @type {string} */
      hexColor = "rgba(" + num_subrows + ", " + whiteRating + ", " + pageInd + ", " + e + ")";
    }
    return hexColor;
  },
  rgba2hex : function(value) {
    return (rgb = value && value.match ? value.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i) : value) && 4 === rgb.length ? "#" + ("0" + parseInt(rgb[1], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[2], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[3], 10).toString(16)).slice(-2) : value;
  },
  setCssText : function(el, val) {
    if (null != el && null != val) {
      val = val.split(";");
      /** @type {number} */
      var i = 0;
      for (; i < val.length; i++) {
        var names = val[i].split(":");
        if (1 < names.length) {
          names[0] = mxUtils.trim(names[0].replace(/-([a-z])/gi, function(canCreateDiscussions, shortMonthName) {
            return shortMonthName.toUpperCase();
          }));
          el[names[0]] = mxUtils.trim(names[1]);
        }
      }
    }
  },
  setStyle : function(text, value, prop) {
    /** @type {boolean} */
    var label = null != prop && ("undefined" == typeof prop.length || 0 < prop.length);
    if (null == text || 0 == text.length) {
      if (label) {
        /** @type {string} */
        text = value + "=" + prop + ";";
      }
    } else {
      if (text.substring(0, value.length + 1) == value + "=") {
        var i = text.indexOf(";");
        text = label ? value + "=" + prop + (0 > i ? ";" : text.substring(i)) : 0 > i || i == text.length - 1 ? "" : text.substring(i + 1);
      } else {
        var match = text.indexOf(";" + value + "=");
        if (0 > match) {
          if (label) {
            /** @type {string} */
            label = ";" == text.charAt(text.length - 1) ? "" : ";";
            /** @type {string} */
            text = text + label + value + "=" + prop + ";";
          }
        } else {
          i = text.indexOf(";", match + 1);
          text = label ? text.substring(0, match + 1) + value + "=" + prop + (0 > i ? ";" : text.substring(i)) : text.substring(0, match) + (0 > i ? ";" : text.substring(i));
        }
      }
    }
    return text;
  },
  setCellStyleFlags : function(me, list, value, opacity, position) {
    if (null != list && 0 < list.length) {
      me.beginUpdate();
      try {
        /** @type {number} */
        var i = 0;
        for (; i < list.length; i++) {
          if (null != list[i]) {
            var ret = mxUtils.setStyleFlag(me.getStyle(list[i]), value, opacity, position);
            me.setStyle(list[i], ret);
          }
        }
      } finally {
        me.endUpdate();
      }
    }
  },
  setStyleFlag : function(s, t, key, value) {
    if (null == s || 0 == s.length) {
      /** @type {string} */
      s = value || null == value ? t + "=" + key : t + "=0";
    } else {
      var e = s.indexOf(t + "=");
      if (0 > e) {
        /** @type {string} */
        e = ";" == s.charAt(s.length - 1) ? "" : ";";
        /** @type {string} */
        s = value || null == value ? s + e + t + "=" + key : s + e + t + "=0";
      } else {
        var position = s.indexOf(";", e);
        var i = 0 > position ? s.substring(e + t.length + 1) : s.substring(e + t.length + 1, position);
        /** @type {number} */
        i = null == value ? parseInt(i) ^ key : value ? parseInt(i) | key : parseInt(i) & ~key;
        s = s.substring(0, e) + t + "=" + i + (0 <= position ? s.substring(position) : "");
      }
    }
    return s;
  },
  getAlignmentAsPoint : function(align, valign) {
    /** @type {number} */
    var right = -.5;
    /** @type {number} */
    var bottom = -.5;
    if (align == mxConstants.ALIGN_LEFT) {
      /** @type {number} */
      right = 0;
    } else {
      if (align == mxConstants.ALIGN_RIGHT) {
        /** @type {number} */
        right = -1;
      }
    }
    if (valign == mxConstants.ALIGN_TOP) {
      /** @type {number} */
      bottom = 0;
    } else {
      if (valign == mxConstants.ALIGN_BOTTOM) {
        /** @type {number} */
        bottom = -1;
      }
    }
    return new mxPoint(right, bottom);
  },
  getSizeForString : function(text, val, name, d, lazyLayout) {
    val = null != val ? val : mxConstants.DEFAULT_FONTSIZE;
    name = null != name ? name : mxConstants.DEFAULT_FONTFAMILY;
    /** @type {!Element} */
    var el = document.createElement("div");
    /** @type {string} */
    el.style.fontFamily = name;
    /** @type {string} */
    el.style.fontSize = Math.round(val) + "px";
    /** @type {(number|string)} */
    el.style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? val * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT * mxSvgCanvas2D.prototype.lineHeightCorrection;
    if (null != lazyLayout) {
      if ((lazyLayout & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
        /** @type {string} */
        el.style.fontWeight = "bold";
      }
      if ((lazyLayout & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
        /** @type {string} */
        el.style.fontStyle = "italic";
      }
      /** @type {!Array} */
      val = [];
      if ((lazyLayout & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
        val.push("underline");
      }
      if ((lazyLayout & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
        val.push("line-through");
      }
      if (0 < val.length) {
        /** @type {string} */
        el.style.textDecoration = val.join(" ");
      }
    }
    /** @type {string} */
    el.style.position = "absolute";
    /** @type {string} */
    el.style.visibility = "hidden";
    /** @type {string} */
    el.style.display = "inline-block";
    /** @type {string} */
    el.style.zoom = "1";
    if (null != d) {
      /** @type {string} */
      el.style.width = d + "px";
      /** @type {string} */
      el.style.whiteSpace = "normal";
    } else {
      /** @type {string} */
      el.style.whiteSpace = "nowrap";
    }
    /** @type {string} */
    el.innerHTML = text;
    document.body.appendChild(el);
    text = new mxRectangle(0, 0, el.offsetWidth, el.offsetHeight);
    document.body.removeChild(el);
    return text;
  },
  getViewXml : function(graph, result, coords, width, height) {
    width = null != width ? width : 0;
    height = null != height ? height : 0;
    result = null != result ? result : 1;
    if (null == coords) {
      /** @type {!Array} */
      coords = [graph.getModel().getRoot()];
    }
    var self = graph.getView();
    /** @type {null} */
    var g = null;
    var se = self.isEventsEnabled();
    self.setEventsEnabled(false);
    var boxInput = self.drawPane;
    var locked_balance_JSBigInt = self.overlayPane;
    if (graph.dialect == mxConstants.DIALECT_SVG) {
      /** @type {!Element} */
      self.drawPane = document.createElementNS(mxConstants.NS_SVG, "g");
      self.canvas.appendChild(self.drawPane);
      /** @type {!Element} */
      self.overlayPane = document.createElementNS(mxConstants.NS_SVG, "g");
    } else {
      self.drawPane = self.drawPane.cloneNode(false);
      self.canvas.appendChild(self.drawPane);
      self.overlayPane = self.overlayPane.cloneNode(false);
    }
    self.canvas.appendChild(self.overlayPane);
    var newValue = self.getTranslate();
    self.translate = new mxPoint(width, height);
    result = new mxTemporaryCellStates(graph.getView(), result, coords);
    try {
      g = (new mxCodec).encode(graph.getView());
    } finally {
      result.destroy();
      self.translate = newValue;
      self.canvas.removeChild(self.drawPane);
      self.canvas.removeChild(self.overlayPane);
      self.drawPane = boxInput;
      self.overlayPane = locked_balance_JSBigInt;
      self.setEventsEnabled(se);
    }
    return g;
  },
  getScaleForPageCount : function(max, count, h, scale) {
    if (1 > max) {
      return 1;
    }
    h = null != h ? h : mxConstants.PAGE_FORMAT_A4_PORTRAIT;
    scale = null != scale ? scale : 0;
    /** @type {number} */
    var w = h.width - 2 * scale;
    /** @type {number} */
    h = h.height - 2 * scale;
    scale = count.getGraphBounds().clone();
    count = count.getView().getScale();
    scale.width /= count;
    scale.height /= count;
    count = scale.width;
    /** @type {number} */
    var size = Math.sqrt(max);
    /** @type {number} */
    scale = Math.sqrt(count / scale.height / (w / h));
    /** @type {number} */
    h = size * scale;
    /** @type {number} */
    scale = size / scale;
    if (1 > h && scale > max) {
      /** @type {number} */
      var ratio = scale / max;
      /** @type {number} */
      scale = max;
      /** @type {number} */
      h = h / ratio;
    }
    if (1 > scale && h > max) {
      /** @type {number} */
      ratio = h / max;
      /** @type {number} */
      h = max;
      /** @type {number} */
      scale = scale / ratio;
    }
    /** @type {number} */
    ratio = Math.ceil(h) * Math.ceil(scale);
    /** @type {number} */
    size = 0;
    for (; ratio > max;) {
      /** @type {number} */
      ratio = Math.floor(h) / h;
      /** @type {number} */
      var left = Math.floor(scale) / scale;
      if (1 == ratio) {
        /** @type {number} */
        ratio = Math.floor(h - 1) / h;
      }
      if (1 == left) {
        /** @type {number} */
        left = Math.floor(scale - 1) / scale;
      }
      /** @type {number} */
      ratio = ratio > left ? ratio : left;
      /** @type {number} */
      h = h * ratio;
      /** @type {number} */
      scale = scale * ratio;
      /** @type {number} */
      ratio = Math.ceil(h) * Math.ceil(scale);
      size++;
      if (10 < size) {
        break;
      }
    }
    return w * h / count * .99999;
  },
  show : function(instance, self, i, e, p, n) {
    i = null != i ? i : 0;
    e = null != e ? e : 0;
    if (null == self) {
      self = window.open().document;
    } else {
      self.open();
    }
    if (9 == document.documentMode) {
      self.writeln('\x3c!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=9"><![endif]--\x3e');
    }
    var s = instance.getGraphBounds();
    /** @type {number} */
    var targetL = Math.ceil(i - s.x);
    /** @type {number} */
    var y_body_bottom = Math.ceil(e - s.y);
    if (null == p) {
      /** @type {number} */
      p = Math.ceil(s.width + i) + Math.ceil(Math.ceil(s.x) - s.x);
    }
    if (null == n) {
      /** @type {number} */
      n = Math.ceil(s.height + e) + Math.ceil(Math.ceil(s.y) - s.y);
    }
    if (mxClient.IS_IE || 11 == document.documentMode) {
      /** @type {string} */
      e = "<html><head>";
      /** @type {!NodeList<Element>} */
      s = document.getElementsByTagName("base");
      /** @type {number} */
      i = 0;
      for (; i < s.length; i++) {
        /** @type {string} */
        e = e + s[i].outerHTML;
      }
      /** @type {string} */
      e = e + "<style>";
      /** @type {number} */
      i = 0;
      for (; i < document.styleSheets.length; i++) {
        try {
          /** @type {string} */
          e = e + document.styleSheets[i].cssText;
        } catch (m) {
        }
      }
      /** @type {string} */
      e = e + '</style></head><body style="margin:0px;"><div style="position:absolute;overflow:hidden;width:' + (p + "px;height:" + n + 'px;"><div style="position:relative;left:' + targetL + "px;top:" + y_body_bottom + 'px;">') + instance.container.innerHTML;
      self.writeln(e + "</div></div></body><html>");
      self.close();
    } else {
      self.writeln("<html><head>");
      /** @type {!NodeList<Element>} */
      s = document.getElementsByTagName("base");
      /** @type {number} */
      i = 0;
      for (; i < s.length; i++) {
        self.writeln(mxUtils.getOuterHtml(s[i]));
      }
      /** @type {!NodeList<Element>} */
      e = document.getElementsByTagName("link");
      /** @type {number} */
      i = 0;
      for (; i < e.length; i++) {
        self.writeln(mxUtils.getOuterHtml(e[i]));
      }
      /** @type {!NodeList<Element>} */
      e = document.getElementsByTagName("style");
      /** @type {number} */
      i = 0;
      for (; i < e.length; i++) {
        self.writeln(mxUtils.getOuterHtml(e[i]));
      }
      self.writeln('</head><body style="margin:0px;"></body></html>');
      self.close();
      i = self.createElement("div");
      /** @type {string} */
      i.position = "absolute";
      /** @type {string} */
      i.overflow = "hidden";
      /** @type {string} */
      i.style.width = p + "px";
      /** @type {string} */
      i.style.height = n + "px";
      p = self.createElement("div");
      /** @type {string} */
      p.style.position = "absolute";
      /** @type {string} */
      p.style.left = targetL + "px";
      /** @type {string} */
      p.style.top = y_body_bottom + "px";
      n = instance.container.firstChild;
      /** @type {null} */
      e = null;
      for (; null != n;) {
        s = n.cloneNode(true);
        if (n == instance.view.drawPane.ownerSVGElement) {
          i.appendChild(s);
          e = s;
        } else {
          p.appendChild(s);
        }
        n = n.nextSibling;
      }
      self.body.appendChild(i);
      if (null != p.firstChild) {
        self.body.appendChild(p);
      }
      if (null != e) {
        /** @type {string} */
        e.style.minWidth = "";
        /** @type {string} */
        e.style.minHeight = "";
        e.firstChild.setAttribute("transform", "translate(" + targetL + "," + y_body_bottom + ")");
      }
    }
    mxUtils.removeCursors(self.body);
    return self;
  },
  printScreen : function(error) {
    /** @type {(Window|null)} */
    var node = window.open();
    error.getGraphBounds();
    mxUtils.show(error, node.document);
    /**
     * @return {undefined}
     */
    error = function() {
      node.focus();
      node.print();
      node.close();
    };
    if (mxClient.IS_GC) {
      node.setTimeout(error, 500);
    } else {
      error();
    }
  },
  popup : function(text, container) {
    if (container) {
      /** @type {!Element} */
      var c = document.createElement("div");
      /** @type {string} */
      c.style.overflow = "scroll";
      /** @type {string} */
      c.style.width = "636px";
      /** @type {string} */
      c.style.height = "460px";
      /** @type {!Element} */
      container = document.createElement("pre");
      container.innerHTML = mxUtils.htmlEntities(text, false).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;");
      c.appendChild(container);
      c = new mxWindow("Popup Window", c, document.body.clientWidth / 2 - 320, Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight) / 2 - 240, 640, 480, false, true);
      c.setClosable(true);
      c.setVisible(true);
    } else {
      if (mxClient.IS_NS) {
        /** @type {(Window|null)} */
        c = window.open();
        c.document.writeln("<pre>" + mxUtils.htmlEntities(text) + "</pre");
        c.document.close();
      } else {
        /** @type {(Window|null)} */
        c = window.open();
        container = c.document.createElement("pre");
        container.innerHTML = mxUtils.htmlEntities(text, false).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;");
        c.document.body.appendChild(container);
      }
    }
  },
  alert : function(data) {
    alert(data);
  },
  prompt : function(message, url) {
    return prompt(message, null != url ? url : "");
  },
  confirm : function(question) {
    return confirm(question);
  },
  error : function(x, t, e, value) {
    /** @type {!Element} */
    var div = document.createElement("div");
    /** @type {string} */
    div.style.padding = "20px";
    /** @type {!Element} */
    var element = document.createElement("img");
    element.setAttribute("src", value || mxUtils.errorImage);
    element.setAttribute("valign", "bottom");
    /** @type {string} */
    element.style.verticalAlign = "middle";
    div.appendChild(element);
    div.appendChild(document.createTextNode("\u00a0"));
    div.appendChild(document.createTextNode("\u00a0"));
    div.appendChild(document.createTextNode("\u00a0"));
    mxUtils.write(div, x);
    /** @type {number} */
    x = document.body.clientWidth;
    /** @type {number} */
    value = document.body.clientHeight || document.documentElement.clientHeight;
    var dialog = new mxWindow(mxResources.get(mxUtils.errorResource) || mxUtils.errorResource, div, (x - t) / 2, value / 4, t, null, false, true);
    if (e) {
      mxUtils.br(div);
      /** @type {!Element} */
      t = document.createElement("p");
      /** @type {!Element} */
      e = document.createElement("button");
      if (mxClient.IS_IE) {
        /** @type {string} */
        e.style.cssText = "float:right";
      } else {
        e.setAttribute("style", "float:right");
      }
      mxEvent.addListener(e, "click", function(canCreateDiscussions) {
        dialog.destroy();
      });
      mxUtils.write(e, mxResources.get(mxUtils.closeResource) || mxUtils.closeResource);
      t.appendChild(e);
      div.appendChild(t);
      mxUtils.br(div);
      dialog.setClosable(true);
    }
    dialog.setVisible(true);
    return dialog;
  },
  makeDraggable : function(obj, callback, options, container, position, handle, item, context, name, params) {
    obj = new mxDragSource(obj, options);
    obj.dragOffset = new mxPoint(null != position ? position : 0, null != handle ? handle : mxConstants.TOOLTIP_VERTICAL_OFFSET);
    /** @type {string} */
    obj.autoscroll = item;
    obj.setGuidesEnabled(false);
    if (null != name) {
      /** @type {!Object} */
      obj.highlightDropTargets = name;
    }
    if (null != params) {
      /** @type {string} */
      obj.getDropTarget = params;
    }
    /**
     * @param {!Object} e
     * @return {?}
     */
    obj.getGraphForEvent = function(e) {
      return "function" == typeof callback ? callback(e) : callback;
    };
    if (null != container) {
      /**
       * @return {?}
       */
      obj.createDragElement = function() {
        return container.cloneNode(true);
      };
      if (context) {
        /**
         * @param {!Object} g
         * @return {?}
         */
        obj.createPreviewElement = function(g) {
          var listcontentPage = container.cloneNode(true);
          /** @type {number} */
          var v2 = parseInt(listcontentPage.style.width);
          /** @type {number} */
          var oy = parseInt(listcontentPage.style.height);
          /** @type {string} */
          listcontentPage.style.width = Math.round(v2 * g.view.scale) + "px";
          /** @type {string} */
          listcontentPage.style.height = Math.round(oy * g.view.scale) + "px";
          return listcontentPage;
        };
      }
    }
    return obj;
  },
  format : function(str) {
    return parseFloat(parseFloat(str).toFixed(2));
  }
};
var mxConstants = {
  DEFAULT_HOTSPOT : .3,
  MIN_HOTSPOT_SIZE : 8,
  MAX_HOTSPOT_SIZE : 0,
  RENDERING_HINT_EXACT : "exact",
  RENDERING_HINT_FASTER : "faster",
  RENDERING_HINT_FASTEST : "fastest",
  DIALECT_SVG : "svg",
  DIALECT_MIXEDHTML : "mixedHtml",
  DIALECT_PREFERHTML : "preferHtml",
  DIALECT_STRICTHTML : "strictHtml",
  NS_SVG : "http://www.w3.org/2000/svg",
  NS_XHTML : "http://www.w3.org/1999/xhtml",
  NS_XLINK : "http://www.w3.org/1999/xlink",
  SHADOWCOLOR : "gray",
  VML_SHADOWCOLOR : "gray",
  SHADOW_OFFSET_X : 2,
  SHADOW_OFFSET_Y : 3,
  SHADOW_OPACITY : 1,
  NODETYPE_ELEMENT : 1,
  NODETYPE_ATTRIBUTE : 2,
  NODETYPE_TEXT : 3,
  NODETYPE_CDATA : 4,
  NODETYPE_ENTITY_REFERENCE : 5,
  NODETYPE_ENTITY : 6,
  NODETYPE_PROCESSING_INSTRUCTION : 7,
  NODETYPE_COMMENT : 8,
  NODETYPE_DOCUMENT : 9,
  NODETYPE_DOCUMENTTYPE : 10,
  NODETYPE_DOCUMENT_FRAGMENT : 11,
  NODETYPE_NOTATION : 12,
  TOOLTIP_VERTICAL_OFFSET : 16,
  DEFAULT_VALID_COLOR : "#00FF00",
  DEFAULT_INVALID_COLOR : "#FF0000",
  OUTLINE_HIGHLIGHT_COLOR : "#00FF00",
  OUTLINE_HIGHLIGHT_STROKEWIDTH : 5,
  HIGHLIGHT_STROKEWIDTH : 3,
  HIGHLIGHT_SIZE : 2,
  HIGHLIGHT_OPACITY : 100,
  CURSOR_MOVABLE_VERTEX : "move",
  CURSOR_MOVABLE_EDGE : "move",
  CURSOR_LABEL_HANDLE : "default",
  CURSOR_TERMINAL_HANDLE : "pointer",
  CURSOR_BEND_HANDLE : "crosshair",
  CURSOR_VIRTUAL_BEND_HANDLE : "crosshair",
  CURSOR_CONNECT : "pointer",
  HIGHLIGHT_COLOR : "#00FF00",
  CONNECT_TARGET_COLOR : "#0000FF",
  INVALID_CONNECT_TARGET_COLOR : "#FF0000",
  DROP_TARGET_COLOR : "#0000FF",
  VALID_COLOR : "#00FF00",
  INVALID_COLOR : "#FF0000",
  EDGE_SELECTION_COLOR : "#00FF00",
  VERTEX_SELECTION_COLOR : "#00FF00",
  VERTEX_SELECTION_STROKEWIDTH : 1,
  EDGE_SELECTION_STROKEWIDTH : 1,
  VERTEX_SELECTION_DASHED : true,
  EDGE_SELECTION_DASHED : true,
  GUIDE_COLOR : "#FF0000",
  GUIDE_STROKEWIDTH : 1,
  OUTLINE_COLOR : "#0099FF",
  OUTLINE_STROKEWIDTH : mxClient.IS_IE ? 2 : 3,
  HANDLE_SIZE : 6,
  LABEL_HANDLE_SIZE : 4,
  HANDLE_FILLCOLOR : "#00FF00",
  HANDLE_STROKECOLOR : "black",
  LABEL_HANDLE_FILLCOLOR : "yellow",
  CONNECT_HANDLE_FILLCOLOR : "#0000FF",
  LOCKED_HANDLE_FILLCOLOR : "#FF0000",
  OUTLINE_HANDLE_FILLCOLOR : "#00FFFF",
  OUTLINE_HANDLE_STROKECOLOR : "#0033FF",
  DEFAULT_FONTFAMILY : "Arial,Helvetica",
  DEFAULT_FONTSIZE : 11,
  DEFAULT_TEXT_DIRECTION : "",
  LINE_HEIGHT : 1.2,
  WORD_WRAP : "normal",
  ABSOLUTE_LINE_HEIGHT : false,
  DEFAULT_FONTSTYLE : 0,
  DEFAULT_STARTSIZE : 40,
  DEFAULT_MARKERSIZE : 6,
  DEFAULT_IMAGESIZE : 24,
  ENTITY_SEGMENT : 30,
  RECTANGLE_ROUNDING_FACTOR : .15,
  LINE_ARCSIZE : 20,
  ARROW_SPACING : 0,
  ARROW_WIDTH : 30,
  ARROW_SIZE : 30,
  PAGE_FORMAT_A4_PORTRAIT : new mxRectangle(0, 0, 827, 1169),
  PAGE_FORMAT_A4_LANDSCAPE : new mxRectangle(0, 0, 1169, 827),
  PAGE_FORMAT_LETTER_PORTRAIT : new mxRectangle(0, 0, 850, 1100),
  PAGE_FORMAT_LETTER_LANDSCAPE : new mxRectangle(0, 0, 1100, 850),
  NONE : "none",
  STYLE_PERIMETER : "perimeter",
  STYLE_SOURCE_PORT : "sourcePort",
  STYLE_TARGET_PORT : "targetPort",
  STYLE_PORT_CONSTRAINT : "portConstraint",
  STYLE_PORT_CONSTRAINT_ROTATION : "portConstraintRotation",
  STYLE_SOURCE_PORT_CONSTRAINT : "sourcePortConstraint",
  STYLE_TARGET_PORT_CONSTRAINT : "targetPortConstraint",
  STYLE_OPACITY : "opacity",
  STYLE_FILL_OPACITY : "fillOpacity",
  STYLE_FILL_STYLE : "fillStyle",
  STYLE_STROKE_OPACITY : "strokeOpacity",
  STYLE_TEXT_OPACITY : "textOpacity",
  STYLE_TEXT_DIRECTION : "textDirection",
  STYLE_OVERFLOW : "overflow",
  STYLE_BLOCK_SPACING : "blockSpacing",
  STYLE_ORTHOGONAL : "orthogonal",
  STYLE_EXIT_X : "exitX",
  STYLE_EXIT_Y : "exitY",
  STYLE_EXIT_DX : "exitDx",
  STYLE_EXIT_DY : "exitDy",
  STYLE_EXIT_PERIMETER : "exitPerimeter",
  STYLE_ENTRY_X : "entryX",
  STYLE_ENTRY_Y : "entryY",
  STYLE_ENTRY_DX : "entryDx",
  STYLE_ENTRY_DY : "entryDy",
  STYLE_ENTRY_PERIMETER : "entryPerimeter",
  STYLE_WHITE_SPACE : "whiteSpace",
  STYLE_ROTATION : "rotation",
  STYLE_FILLCOLOR : "fillColor",
  STYLE_POINTER_EVENTS : "pointerEvents",
  STYLE_SWIMLANE_FILLCOLOR : "swimlaneFillColor",
  STYLE_MARGIN : "margin",
  STYLE_GRADIENTCOLOR : "gradientColor",
  STYLE_GRADIENT_DIRECTION : "gradientDirection",
  STYLE_STROKECOLOR : "strokeColor",
  STYLE_SEPARATORCOLOR : "separatorColor",
  STYLE_STROKEWIDTH : "strokeWidth",
  STYLE_ALIGN : "align",
  STYLE_VERTICAL_ALIGN : "verticalAlign",
  STYLE_LABEL_WIDTH : "labelWidth",
  STYLE_LABEL_POSITION : "labelPosition",
  STYLE_VERTICAL_LABEL_POSITION : "verticalLabelPosition",
  STYLE_IMAGE_ASPECT : "imageAspect",
  STYLE_IMAGE_ALIGN : "imageAlign",
  STYLE_IMAGE_VERTICAL_ALIGN : "imageVerticalAlign",
  STYLE_GLASS : "glass",
  STYLE_IMAGE : "image",
  STYLE_IMAGE_WIDTH : "imageWidth",
  STYLE_IMAGE_HEIGHT : "imageHeight",
  STYLE_IMAGE_BACKGROUND : "imageBackground",
  STYLE_IMAGE_BORDER : "imageBorder",
  STYLE_FLIPH : "flipH",
  STYLE_FLIPV : "flipV",
  STYLE_NOLABEL : "noLabel",
  STYLE_NOEDGESTYLE : "noEdgeStyle",
  STYLE_LABEL_BACKGROUNDCOLOR : "labelBackgroundColor",
  STYLE_LABEL_BORDERCOLOR : "labelBorderColor",
  STYLE_LABEL_PADDING : "labelPadding",
  STYLE_INDICATOR_SHAPE : "indicatorShape",
  STYLE_INDICATOR_IMAGE : "indicatorImage",
  STYLE_INDICATOR_COLOR : "indicatorColor",
  STYLE_INDICATOR_STROKECOLOR : "indicatorStrokeColor",
  STYLE_INDICATOR_GRADIENTCOLOR : "indicatorGradientColor",
  STYLE_INDICATOR_SPACING : "indicatorSpacing",
  STYLE_INDICATOR_WIDTH : "indicatorWidth",
  STYLE_INDICATOR_HEIGHT : "indicatorHeight",
  STYLE_INDICATOR_DIRECTION : "indicatorDirection",
  STYLE_SHADOW : "shadow",
  STYLE_SEGMENT : "segment",
  STYLE_ENDARROW : "endArrow",
  STYLE_STARTARROW : "startArrow",
  STYLE_ENDSIZE : "endSize",
  STYLE_STARTSIZE : "startSize",
  STYLE_SWIMLANE_LINE : "swimlaneLine",
  STYLE_SWIMLANE_HEAD : "swimlaneHead",
  STYLE_SWIMLANE_BODY : "swimlaneBody",
  STYLE_ENDFILL : "endFill",
  STYLE_STARTFILL : "startFill",
  STYLE_DASHED : "dashed",
  STYLE_DASH_PATTERN : "dashPattern",
  STYLE_FIX_DASH : "fixDash",
  STYLE_ROUNDED : "rounded",
  STYLE_CURVED : "curved",
  STYLE_ARCSIZE : "arcSize",
  STYLE_ABSOLUTE_ARCSIZE : "absoluteArcSize",
  STYLE_SOURCE_PERIMETER_SPACING : "sourcePerimeterSpacing",
  STYLE_TARGET_PERIMETER_SPACING : "targetPerimeterSpacing",
  STYLE_PERIMETER_SPACING : "perimeterSpacing",
  STYLE_SPACING : "spacing",
  STYLE_SPACING_TOP : "spacingTop",
  STYLE_SPACING_LEFT : "spacingLeft",
  STYLE_SPACING_BOTTOM : "spacingBottom",
  STYLE_SPACING_RIGHT : "spacingRight",
  STYLE_HORIZONTAL : "horizontal",
  STYLE_DIRECTION : "direction",
  STYLE_ANCHOR_POINT_DIRECTION : "anchorPointDirection",
  STYLE_ELBOW : "elbow",
  STYLE_FONTCOLOR : "fontColor",
  STYLE_FONTFAMILY : "fontFamily",
  STYLE_FONTSIZE : "fontSize",
  STYLE_FONTSTYLE : "fontStyle",
  STYLE_ASPECT : "aspect",
  STYLE_AUTOSIZE : "autosize",
  STYLE_FIXED_WIDTH : "fixedWidth",
  STYLE_FOLDABLE : "foldable",
  STYLE_EDITABLE : "editable",
  STYLE_BACKGROUND_OUTLINE : "backgroundOutline",
  STYLE_BENDABLE : "bendable",
  STYLE_MOVABLE : "movable",
  STYLE_RESIZABLE : "resizable",
  STYLE_RESIZE_WIDTH : "resizeWidth",
  STYLE_RESIZE_HEIGHT : "resizeHeight",
  STYLE_ROTATABLE : "rotatable",
  STYLE_CLONEABLE : "cloneable",
  STYLE_DELETABLE : "deletable",
  STYLE_SHAPE : "shape",
  STYLE_EDGE : "edgeStyle",
  STYLE_JETTY_SIZE : "jettySize",
  STYLE_SOURCE_JETTY_SIZE : "sourceJettySize",
  STYLE_TARGET_JETTY_SIZE : "targetJettySize",
  STYLE_LOOP : "loopStyle",
  STYLE_ORTHOGONAL_LOOP : "orthogonalLoop",
  STYLE_ROUTING_CENTER_X : "routingCenterX",
  STYLE_ROUTING_CENTER_Y : "routingCenterY",
  STYLE_CLIP_PATH : "clipPath",
  FONT_BOLD : 1,
  FONT_ITALIC : 2,
  FONT_UNDERLINE : 4,
  FONT_STRIKETHROUGH : 8,
  SHAPE_RECTANGLE : "rectangle",
  SHAPE_ELLIPSE : "ellipse",
  SHAPE_DOUBLE_ELLIPSE : "doubleEllipse",
  SHAPE_RHOMBUS : "rhombus",
  SHAPE_LINE : "line",
  SHAPE_IMAGE : "image",
  SHAPE_ARROW : "arrow",
  SHAPE_ARROW_CONNECTOR : "arrowConnector",
  SHAPE_LABEL : "label",
  SHAPE_CYLINDER : "cylinder",
  SHAPE_SWIMLANE : "swimlane",
  SHAPE_CONNECTOR : "connector",
  SHAPE_ACTOR : "actor",
  SHAPE_CLOUD : "cloud",
  SHAPE_TRIANGLE : "triangle",
  SHAPE_HEXAGON : "hexagon",
  ARROW_CLASSIC : "classic",
  ARROW_CLASSIC_THIN : "classicThin",
  ARROW_BLOCK : "block",
  ARROW_BLOCK_THIN : "blockThin",
  ARROW_OPEN : "open",
  ARROW_OPEN_THIN : "openThin",
  ARROW_OVAL : "oval",
  ARROW_DIAMOND : "diamond",
  ARROW_DIAMOND_THIN : "diamondThin",
  ALIGN_LEFT : "left",
  ALIGN_CENTER : "center",
  ALIGN_RIGHT : "right",
  ALIGN_TOP : "top",
  ALIGN_MIDDLE : "middle",
  ALIGN_BOTTOM : "bottom",
  DIRECTION_NORTH : "north",
  DIRECTION_SOUTH : "south",
  DIRECTION_EAST : "east",
  DIRECTION_WEST : "west",
  DIRECTION_RADIAL : "radial",
  TEXT_DIRECTION_DEFAULT : "",
  TEXT_DIRECTION_AUTO : "auto",
  TEXT_DIRECTION_LTR : "ltr",
  TEXT_DIRECTION_RTL : "rtl",
  DIRECTION_MASK_NONE : 0,
  DIRECTION_MASK_WEST : 1,
  DIRECTION_MASK_NORTH : 2,
  DIRECTION_MASK_SOUTH : 4,
  DIRECTION_MASK_EAST : 8,
  DIRECTION_MASK_ALL : 15,
  ELBOW_VERTICAL : "vertical",
  ELBOW_HORIZONTAL : "horizontal",
  EDGESTYLE_ELBOW : "elbowEdgeStyle",
  EDGESTYLE_ENTITY_RELATION : "entityRelationEdgeStyle",
  EDGESTYLE_LOOP : "loopEdgeStyle",
  EDGESTYLE_SIDETOSIDE : "sideToSideEdgeStyle",
  EDGESTYLE_TOPTOBOTTOM : "topToBottomEdgeStyle",
  EDGESTYLE_ORTHOGONAL : "orthogonalEdgeStyle",
  EDGESTYLE_SEGMENT : "segmentEdgeStyle",
  PERIMETER_ELLIPSE : "ellipsePerimeter",
  PERIMETER_RECTANGLE : "rectanglePerimeter",
  PERIMETER_RHOMBUS : "rhombusPerimeter",
  PERIMETER_HEXAGON : "hexagonPerimeter",
  PERIMETER_TRIANGLE : "trianglePerimeter"
};
/**
 * @param {string} name
 * @return {undefined}
 */
function mxEventObject(name) {
  /** @type {string} */
  this.name = name;
  /** @type {!Array} */
  this.properties = [];
  /** @type {number} */
  var i = 1;
  for (; i < arguments.length; i = i + 2) {
    if (null != arguments[i + 1]) {
      this.properties[arguments[i]] = arguments[i + 1];
    }
  }
}
/** @type {null} */
mxEventObject.prototype.name = null;
/** @type {null} */
mxEventObject.prototype.properties = null;
/** @type {boolean} */
mxEventObject.prototype.consumed = false;
/**
 * @return {?}
 */
mxEventObject.prototype.getName = function() {
  return this.name;
};
/**
 * @return {?}
 */
mxEventObject.prototype.getProperties = function() {
  return this.properties;
};
/**
 * @param {string} name
 * @return {?}
 */
mxEventObject.prototype.getProperty = function(name) {
  return this.properties[name];
};
/**
 * @return {?}
 */
mxEventObject.prototype.isConsumed = function() {
  return this.consumed;
};
/**
 * @return {undefined}
 */
mxEventObject.prototype.consume = function() {
  /** @type {boolean} */
  this.consumed = true;
};
/**
 * @param {!Event} evt
 * @param {!Object} val
 * @return {undefined}
 */
function mxMouseEvent(evt, val) {
  /** @type {!Event} */
  this.evt = evt;
  this.sourceState = this.state = val;
}
/** @type {boolean} */
mxMouseEvent.prototype.consumed = false;
/** @type {null} */
mxMouseEvent.prototype.evt = null;
/** @type {null} */
mxMouseEvent.prototype.graphX = null;
/** @type {null} */
mxMouseEvent.prototype.graphY = null;
/** @type {null} */
mxMouseEvent.prototype.state = null;
/** @type {null} */
mxMouseEvent.prototype.sourceState = null;
/**
 * @return {?}
 */
mxMouseEvent.prototype.getEvent = function() {
  return this.evt;
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.getSource = function() {
  return mxEvent.getSource(this.evt);
};
/**
 * @param {!Object} s
 * @return {?}
 */
mxMouseEvent.prototype.isSource = function(s) {
  return null != s ? mxUtils.isAncestorNode(s.node, this.getSource()) : false;
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.getX = function() {
  return mxEvent.getClientX(this.getEvent());
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.getY = function() {
  return mxEvent.getClientY(this.getEvent());
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.getGraphX = function() {
  return this.graphX;
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.getGraphY = function() {
  return this.graphY;
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.getState = function() {
  return this.state;
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.getCell = function() {
  var state = this.getState();
  return null != state ? state.cell : null;
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.isPopupTrigger = function() {
  return mxEvent.isPopupTrigger(this.getEvent());
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.isConsumed = function() {
  return this.consumed;
};
/**
 * @param {string} e
 * @return {undefined}
 */
mxMouseEvent.prototype.consume = function(e) {
  if ((e = null != e ? e : null != this.evt.touches || mxEvent.isMouseEvent(this.evt)) && this.evt.preventDefault) {
    this.evt.preventDefault();
  }
  if (mxClient.IS_IE) {
    /** @type {boolean} */
    this.evt.returnValue = true;
  }
  /** @type {boolean} */
  this.consumed = true;
};
/**
 * @param {?} primaryTxHex
 * @return {undefined}
 */
function mxEventSource(primaryTxHex) {
  this.setEventSource(primaryTxHex);
}
/** @type {null} */
mxEventSource.prototype.eventListeners = null;
/** @type {boolean} */
mxEventSource.prototype.eventsEnabled = true;
/** @type {null} */
mxEventSource.prototype.eventSource = null;
/**
 * @return {?}
 */
mxEventSource.prototype.isEventsEnabled = function() {
  return this.eventsEnabled;
};
/**
 * @param {boolean} enabled
 * @return {undefined}
 */
mxEventSource.prototype.setEventsEnabled = function(enabled) {
  /** @type {boolean} */
  this.eventsEnabled = enabled;
};
/**
 * @return {?}
 */
mxEventSource.prototype.getEventSource = function() {
  return this.eventSource;
};
/**
 * @param {?} newEventSource
 * @return {undefined}
 */
mxEventSource.prototype.setEventSource = function(newEventSource) {
  this.eventSource = newEventSource;
};
/**
 * @param {!Object} obj
 * @param {string} name
 * @return {undefined}
 */
mxEventSource.prototype.addListener = function(obj, name) {
  if (null == this.eventListeners) {
    /** @type {!Array} */
    this.eventListeners = [];
  }
  this.eventListeners.push(obj);
  this.eventListeners.push(name);
};
/**
 * @param {!Object} d
 * @return {undefined}
 */
mxEventSource.prototype.removeListener = function(d) {
  if (null != this.eventListeners) {
    /** @type {number} */
    var i = 0;
    for (; i < this.eventListeners.length;) {
      if (this.eventListeners[i + 1] == d) {
        this.eventListeners.splice(i, 2);
      } else {
        /** @type {number} */
        i = i + 2;
      }
    }
  }
};
/**
 * @param {!Object} event
 * @param {!Object} data
 * @return {undefined}
 */
mxEventSource.prototype.fireEvent = function(event, data) {
  if (null != this.eventListeners && this.isEventsEnabled()) {
    if (null == event) {
      event = new mxEventObject;
    }
    if (null == data) {
      data = this.getEventSource();
    }
    if (null == data) {
      data = this;
    }
    /** @type {number} */
    var i = 0;
    for (; i < this.eventListeners.length; i = i + 2) {
      var evLi = this.eventListeners[i];
      if (!(null != evLi && evLi != event.getName())) {
        this.eventListeners[i + 1].apply(this, [data, event]);
      }
    }
  }
};
var mxEvent = {
  addListener : function() {
    if (window.addEventListener) {
      /** @type {boolean} */
      var supportsPassiveOption = false;
      try {
        document.addEventListener("test", function() {
        }, Object.defineProperty && Object.defineProperty({}, "passive", {
          get : function() {
            /** @type {boolean} */
            supportsPassiveOption = true;
          }
        }));
      } catch (b) {
      }
      return function(target, titleBar, d) {
        target.addEventListener(titleBar, d, supportsPassiveOption ? {
          passive : false
        } : false);
        if (null == target.mxListenerList) {
          /** @type {!Array} */
          target.mxListenerList = [];
        }
        target.mxListenerList.push({
          name : titleBar,
          f : d
        });
      };
    }
    return function(target, event, functionref) {
      target.attachEvent("on" + event, functionref);
      if (null == target.mxListenerList) {
        /** @type {!Array} */
        target.mxListenerList = [];
      }
      target.mxListenerList.push({
        name : event,
        f : functionref
      });
    };
  }(),
  removeListener : function() {
    /**
     * @param {!Node} item
     * @param {number} i
     * @param {?} fn
     * @return {undefined}
     */
    var test = function(item, i, fn) {
      if (null != item.mxListenerList) {
        i = item.mxListenerList.length;
        /** @type {number} */
        var n = 0;
        for (; n < i; n++) {
          if (item.mxListenerList[n].f == fn) {
            item.mxListenerList.splice(n, 1);
            break;
          }
        }
        if (0 == item.mxListenerList.length) {
          /** @type {null} */
          item.mxListenerList = null;
        }
      }
    };
    return window.removeEventListener ? function(b, c, e) {
      b.removeEventListener(c, e, false);
      test(b, c, e);
    } : function(element, name, d) {
      element.detachEvent("on" + name, d);
      test(element, name, d);
    };
  }(),
  removeAllListeners : function(e) {
    var video = e.mxListenerList;
    if (null != video) {
      for (; 0 < video.length;) {
        var v = video[0];
        mxEvent.removeListener(e, v.name, v.f);
      }
    }
  },
  addGestureListeners : function(node, update, name, trialCounter) {
    if (null != update) {
      mxEvent.addListener(node, mxClient.IS_POINTER ? "pointerdown" : "mousedown", update);
    }
    if (null != name) {
      mxEvent.addListener(node, mxClient.IS_POINTER ? "pointermove" : "mousemove", name);
    }
    if (null != trialCounter) {
      mxEvent.addListener(node, mxClient.IS_POINTER ? "pointerup" : "mouseup", trialCounter);
    }
    if (!mxClient.IS_POINTER && mxClient.IS_TOUCH) {
      if (null != update) {
        mxEvent.addListener(node, "touchstart", update);
      }
      if (null != name) {
        mxEvent.addListener(node, "touchmove", name);
      }
      if (null != trialCounter) {
        mxEvent.addListener(node, "touchend", trialCounter);
      }
    }
  },
  removeGestureListeners : function(node, index, type, trialCounter) {
    if (null != index) {
      mxEvent.removeListener(node, mxClient.IS_POINTER ? "pointerdown" : "mousedown", index);
    }
    if (null != type) {
      mxEvent.removeListener(node, mxClient.IS_POINTER ? "pointermove" : "mousemove", type);
    }
    if (null != trialCounter) {
      mxEvent.removeListener(node, mxClient.IS_POINTER ? "pointerup" : "mouseup", trialCounter);
    }
    if (!mxClient.IS_POINTER && mxClient.IS_TOUCH) {
      if (null != index) {
        mxEvent.removeListener(node, "touchstart", index);
      }
      if (null != type) {
        mxEvent.removeListener(node, "touchmove", type);
      }
      if (null != trialCounter) {
        mxEvent.removeListener(node, "touchend", trialCounter);
      }
    }
  },
  redirectMouseEvents : function(node, graph, callback, next, move, f, val) {
    /**
     * @param {string} e
     * @return {?}
     */
    var f = function(e) {
      return "function" == typeof callback ? callback(e) : callback;
    };
    mxEvent.addGestureListeners(node, function(evt) {
      if (null != next) {
        next(evt);
      } else {
        if (!mxEvent.isConsumed(evt)) {
          graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, f(evt)));
        }
      }
    }, function(evt) {
      if (null != move) {
        move(evt);
      } else {
        if (!mxEvent.isConsumed(evt)) {
          graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, f(evt)));
        }
      }
    }, function(evt) {
      if (null != f) {
        f(evt);
      } else {
        if (!mxEvent.isConsumed(evt)) {
          graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, f(evt)));
        }
      }
    });
    mxEvent.addListener(node, "dblclick", function(e) {
      if (null != val) {
        val(e);
      } else {
        if (!mxEvent.isConsumed(e)) {
          var g = f(e);
          graph.dblClick(e, null != g ? g.cell : null);
        }
      }
    });
  },
  release : function(e) {
    try {
      if (null != e) {
        mxEvent.removeAllListeners(e);
        var n = e.childNodes;
        if (null != n) {
          var el = n.length;
          /** @type {number} */
          e = 0;
          for (; e < el; e = e + 1) {
            mxEvent.release(n[e]);
          }
        }
      }
    } catch (d) {
    }
  },
  addMouseWheelListener : function(callback, container) {
    if (null != callback) {
      container = null != container ? container : window;
      if (mxClient.IS_SF && !mxClient.IS_TOUCH) {
        /** @type {number} */
        var firstPressMoveY = 1;
        mxEvent.addListener(container, "gesturestart", function(e) {
          mxEvent.consume(e);
          /** @type {number} */
          firstPressMoveY = 1;
        });
        mxEvent.addListener(container, "gesturechange", function(evt) {
          mxEvent.consume(evt);
          /** @type {number} */
          var utcDayCalib = firstPressMoveY - evt.scale;
          if (.2 < Math.abs(utcDayCalib)) {
            callback(evt, 0 > utcDayCalib, true);
            firstPressMoveY = evt.scale;
          }
        });
        mxEvent.addListener(container, "gestureend", function(e) {
          mxEvent.consume(e);
        });
      } else {
        /** @type {!Array} */
        var touches = [];
        /** @type {number} */
        var m = 0;
        /** @type {number} */
        var x = 0;
        mxEvent.addGestureListeners(container, mxUtils.bind(this, function(e) {
          if (!(mxEvent.isMouseEvent(e) || null == e.pointerId)) {
            touches.push(e);
          }
        }), mxUtils.bind(this, function(e) {
          if (!mxEvent.isMouseEvent(e) && 2 == touches.length) {
            /** @type {number} */
            var i = 0;
            for (; i < touches.length; i++) {
              if (e.pointerId == touches[i].pointerId) {
                /** @type {!Object} */
                touches[i] = e;
                break;
              }
            }
            /** @type {number} */
            e = Math.abs(touches[0].clientX - touches[1].clientX);
            /** @type {number} */
            i = Math.abs(touches[0].clientY - touches[1].clientY);
            /** @type {number} */
            var deltaHoriz = Math.abs(e - m);
            /** @type {number} */
            var deltaVert = Math.abs(i - x);
            if (deltaHoriz > mxEvent.PINCH_THRESHOLD || deltaVert > mxEvent.PINCH_THRESHOLD) {
              callback(touches[0], deltaHoriz > deltaVert ? e > m : i > x, true, touches[0].clientX + (touches[1].clientX - touches[0].clientX) / 2, touches[0].clientY + (touches[1].clientY - touches[0].clientY) / 2);
              /** @type {!Object} */
              m = e;
              /** @type {number} */
              x = i;
            }
          }
        }), mxUtils.bind(this, function(canCreateDiscussions) {
          /** @type {!Array} */
          touches = [];
          /** @type {number} */
          x = m = 0;
        }));
      }
      mxEvent.addListener(container, "wheel", function(event) {
        if (null == event) {
          event = window.event;
        }
        if (event.ctrlKey) {
          event.preventDefault();
        }
        if (.5 < Math.abs(event.deltaX) || .5 < Math.abs(event.deltaY)) {
          callback(event, 0 == event.deltaY ? 0 < -event.deltaX : 0 < -event.deltaY);
        }
      });
    }
  },
  disableContextMenu : function(e) {
    mxEvent.addListener(e, "contextmenu", function(event) {
      if (event.preventDefault) {
        event.preventDefault();
      }
      return false;
    });
  },
  getSource : function(e) {
    return null != e.srcElement ? e.srcElement : e.target;
  },
  isConsumed : function(evt) {
    return null != evt.isConsumed && evt.isConsumed;
  },
  isTouchEvent : function(event) {
    return null != event.pointerType ? "touch" == event.pointerType || event.pointerType === event.MSPOINTER_TYPE_TOUCH : null != event.mozInputSource ? 5 == event.mozInputSource : 0 == event.type.indexOf("touch");
  },
  isPenEvent : function(event) {
    return null != event.pointerType ? "pen" == event.pointerType || event.pointerType === event.MSPOINTER_TYPE_PEN : null != event.mozInputSource ? 2 == event.mozInputSource : 0 == event.type.indexOf("pen");
  },
  isMultiTouchEvent : function(e) {
    return null != e.type && 0 == e.type.indexOf("touch") && null != e.touches && 1 < e.touches.length;
  },
  isMouseEvent : function(e) {
    return !mxClient.IS_ANDROID && mxClient.IS_LINUX && mxClient.IS_GC ? true : null != e.pointerType ? "mouse" == e.pointerType || e.pointerType === e.MSPOINTER_TYPE_MOUSE : null != e.mozInputSource ? 1 == e.mozInputSource : 0 == e.type.indexOf("mouse");
  },
  isLeftMouseButton : function(e) {
    return "buttons" in e && ("mousedown" == e.type || "mousemove" == e.type) ? 1 == e.buttons : "which" in e ? 1 === e.which : 1 === e.button;
  },
  isMiddleMouseButton : function(event) {
    return "which" in event ? 2 === event.which : 4 === event.button;
  },
  isRightMouseButton : function(e) {
    return "which" in e ? 3 === e.which : 2 === e.button;
  },
  isPopupTrigger : function(evt) {
    return mxEvent.isRightMouseButton(evt) || mxClient.IS_MAC && mxEvent.isControlDown(evt) && !mxEvent.isShiftDown(evt) && !mxEvent.isMetaDown(evt) && !mxEvent.isAltDown(evt);
  },
  isShiftDown : function(o) {
    return null != o ? o.shiftKey : false;
  },
  isAltDown : function(o) {
    return null != o ? o.altKey : false;
  },
  isControlDown : function(evt) {
    return null != evt ? evt.ctrlKey : false;
  },
  isMetaDown : function(o) {
    return null != o ? o.metaKey : false;
  },
  getMainEvent : function(event) {
    if ("touchstart" != event.type && "touchmove" != event.type || null == event.touches || null == event.touches[0]) {
      if ("touchend" == event.type && null != event.changedTouches && null != event.changedTouches[0]) {
        event = event.changedTouches[0];
      }
    } else {
      event = event.touches[0];
    }
    return event;
  },
  getClientX : function(e) {
    return mxEvent.getMainEvent(e).clientX;
  },
  getClientY : function(event) {
    return mxEvent.getMainEvent(event).clientY;
  },
  consume : function(e, count, limit) {
    limit = null != limit ? limit : true;
    if (null != count ? count : 1) {
      if (e.preventDefault) {
        if (limit) {
          e.stopPropagation();
        }
        e.preventDefault();
      } else {
        if (limit) {
          /** @type {boolean} */
          e.cancelBubble = true;
        }
      }
    }
    /** @type {boolean} */
    e.isConsumed = true;
    if (!e.preventDefault) {
      /** @type {boolean} */
      e.returnValue = false;
    }
  },
  LABEL_HANDLE : -1,
  ROTATION_HANDLE : -2,
  CUSTOM_HANDLE : -100,
  VIRTUAL_HANDLE : -1E5,
  MOUSE_DOWN : "mouseDown",
  MOUSE_MOVE : "mouseMove",
  MOUSE_UP : "mouseUp",
  ACTIVATE : "activate",
  RESIZE_START : "resizeStart",
  RESIZE : "resize",
  RESIZE_END : "resizeEnd",
  MOVE_START : "moveStart",
  MOVE : "move",
  MOVE_END : "moveEnd",
  PAN_START : "panStart",
  PAN : "pan",
  PAN_END : "panEnd",
  MINIMIZE : "minimize",
  NORMALIZE : "normalize",
  MAXIMIZE : "maximize",
  HIDE : "hide",
  SHOW : "show",
  CLOSE : "close",
  DESTROY : "destroy",
  REFRESH : "refresh",
  SIZE : "size",
  SELECT : "select",
  FIRED : "fired",
  FIRE_MOUSE_EVENT : "fireMouseEvent",
  GESTURE : "gesture",
  TAP_AND_HOLD : "tapAndHold",
  GET : "get",
  RECEIVE : "receive",
  CONNECT : "connect",
  DISCONNECT : "disconnect",
  SUSPEND : "suspend",
  RESUME : "resume",
  MARK : "mark",
  ROOT : "root",
  POST : "post",
  OPEN : "open",
  SAVE : "save",
  BEFORE_ADD_VERTEX : "beforeAddVertex",
  ADD_VERTEX : "addVertex",
  AFTER_ADD_VERTEX : "afterAddVertex",
  DONE : "done",
  EXECUTE : "execute",
  EXECUTED : "executed",
  BEGIN_UPDATE : "beginUpdate",
  START_EDIT : "startEdit",
  END_UPDATE : "endUpdate",
  END_EDIT : "endEdit",
  BEFORE_UNDO : "beforeUndo",
  UNDO : "undo",
  REDO : "redo",
  CHANGE : "change",
  NOTIFY : "notify",
  LAYOUT_CELLS : "layoutCells",
  CLICK : "click",
  SCALE : "scale",
  TRANSLATE : "translate",
  SCALE_AND_TRANSLATE : "scaleAndTranslate",
  UP : "up",
  DOWN : "down",
  ADD : "add",
  REMOVE : "remove",
  CLEAR : "clear",
  ADD_CELLS : "addCells",
  CELLS_ADDED : "cellsAdded",
  MOVE_CELLS : "moveCells",
  CELLS_MOVED : "cellsMoved",
  RESIZE_CELLS : "resizeCells",
  CELLS_RESIZED : "cellsResized",
  TOGGLE_CELLS : "toggleCells",
  CELLS_TOGGLED : "cellsToggled",
  ORDER_CELLS : "orderCells",
  CELLS_ORDERED : "cellsOrdered",
  REMOVE_CELLS : "removeCells",
  CELLS_REMOVED : "cellsRemoved",
  GROUP_CELLS : "groupCells",
  UNGROUP_CELLS : "ungroupCells",
  REMOVE_CELLS_FROM_PARENT : "removeCellsFromParent",
  FOLD_CELLS : "foldCells",
  CELLS_FOLDED : "cellsFolded",
  ALIGN_CELLS : "alignCells",
  LABEL_CHANGED : "labelChanged",
  CONNECT_CELL : "connectCell",
  CELL_CONNECTED : "cellConnected",
  SPLIT_EDGE : "splitEdge",
  FLIP_EDGE : "flipEdge",
  START_EDITING : "startEditing",
  EDITING_STARTED : "editingStarted",
  EDITING_STOPPED : "editingStopped",
  ADD_OVERLAY : "addOverlay",
  REMOVE_OVERLAY : "removeOverlay",
  UPDATE_CELL_SIZE : "updateCellSize",
  ESCAPE : "escape",
  DOUBLE_CLICK : "doubleClick",
  START : "start",
  RESET : "reset",
  PINCH_THRESHOLD : 10
};
/**
 * @param {string} url
 * @param {!Object} data
 * @param {string} method
 * @param {?} async
 * @param {string} username
 * @param {string} password
 * @return {undefined}
 */
function mxXmlRequest(url, data, method, async, username, password) {
  /** @type {string} */
  this.url = url;
  /** @type {!Object} */
  this.params = data;
  this.method = method || "POST";
  this.async = null != async ? async : true;
  /** @type {string} */
  this.username = username;
  /** @type {string} */
  this.password = password;
}
/** @type {null} */
mxXmlRequest.prototype.url = null;
/** @type {null} */
mxXmlRequest.prototype.params = null;
/** @type {null} */
mxXmlRequest.prototype.method = null;
/** @type {null} */
mxXmlRequest.prototype.async = null;
/** @type {boolean} */
mxXmlRequest.prototype.binary = false;
/** @type {boolean} */
mxXmlRequest.prototype.withCredentials = false;
/** @type {null} */
mxXmlRequest.prototype.username = null;
/** @type {null} */
mxXmlRequest.prototype.password = null;
/** @type {null} */
mxXmlRequest.prototype.request = null;
/** @type {boolean} */
mxXmlRequest.prototype.decodeSimulateValues = false;
/**
 * @return {?}
 */
mxXmlRequest.prototype.isBinary = function() {
  return this.binary;
};
/**
 * @param {string} binary
 * @return {undefined}
 */
mxXmlRequest.prototype.setBinary = function(binary) {
  /** @type {string} */
  this.binary = binary;
};
/**
 * @return {?}
 */
mxXmlRequest.prototype.getText = function() {
  return this.request.responseText;
};
/**
 * @return {?}
 */
mxXmlRequest.prototype.isReady = function() {
  return 4 == this.request.readyState;
};
/**
 * @return {?}
 */
mxXmlRequest.prototype.getDocumentElement = function() {
  var xml = this.getXml();
  return null != xml ? xml.documentElement : null;
};
/**
 * @return {?}
 */
mxXmlRequest.prototype.getXml = function() {
  var xml = this.request.responseXML;
  if (9 <= document.documentMode || null == xml || null == xml.documentElement) {
    xml = mxUtils.parseXml(this.request.responseText);
  }
  return xml;
};
/**
 * @return {?}
 */
mxXmlRequest.prototype.getStatus = function() {
  return null != this.request ? this.request.status : null;
};
mxXmlRequest.prototype.create = function() {
  if (window.XMLHttpRequest) {
    return function() {
      /** @type {!XMLHttpRequest} */
      var xhr = new XMLHttpRequest;
      if (this.isBinary() && xhr.overrideMimeType) {
        xhr.overrideMimeType("text/plain; charset=x-user-defined");
      }
      return xhr;
    };
  }
  if ("undefined" != typeof ActiveXObject) {
    return function() {
      return new ActiveXObject("Microsoft.XMLHTTP");
    };
  }
}();
/**
 * @param {string} t
 * @param {!Function} dir
 * @param {number} value
 * @param {?} error
 * @return {undefined}
 */
mxXmlRequest.prototype.send = function(t, dir, value, error) {
  this.request = this.create();
  if (null != this.request) {
    if (null != t) {
      this.request.onreadystatechange = mxUtils.bind(this, function() {
        if (this.isReady()) {
          t(this);
          /** @type {null} */
          this.request.onreadystatechange = null;
        }
      });
    }
    this.request.open(this.method, this.url, this.async, this.username, this.password);
    this.setRequestHeaders(this.request, this.params);
    if (window.XMLHttpRequest && this.withCredentials) {
      /** @type {string} */
      this.request.withCredentials = "true";
    }
    if ((null == document.documentMode || 9 < document.documentMode) && window.XMLHttpRequest && null != value && null != error) {
      /** @type {number} */
      this.request.timeout = value;
      this.request.ontimeout = error;
    }
    this.request.send(this.params);
  }
};
/**
 * @param {!Object} xhr
 * @param {?} url
 * @return {undefined}
 */
mxXmlRequest.prototype.setRequestHeaders = function(xhr, url) {
  if (null != url) {
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
  }
};
/**
 * @param {!Object} target
 * @param {string} type
 * @return {undefined}
 */
mxXmlRequest.prototype.simulate = function(target, type) {
  target = target || document;
  /** @type {null} */
  var jujuConfig = null;
  if (target == document) {
    /** @type {(function((Event|null)): ?|null)} */
    jujuConfig = window.onbeforeunload;
    /** @type {null} */
    window.onbeforeunload = null;
  }
  var form = target.createElement("form");
  form.setAttribute("method", this.method);
  form.setAttribute("action", this.url);
  if (null != type) {
    form.setAttribute("target", type);
  }
  /** @type {string} */
  form.style.display = "none";
  /** @type {string} */
  form.style.visibility = "hidden";
  type = 0 < this.params.indexOf("&") ? this.params.split("&") : this.params.split();
  /** @type {number} */
  var j = 0;
  for (; j < type.length; j++) {
    var a = type[j].indexOf("=");
    if (0 < a) {
      var nodeType = type[j].substring(0, a);
      a = type[j].substring(a + 1);
      if (this.decodeSimulateValues) {
        /** @type {string} */
        a = decodeURIComponent(a);
      }
      var node = target.createElement("textarea");
      node.setAttribute("wrap", "off");
      node.setAttribute("name", nodeType);
      mxUtils.write(node, a);
      form.appendChild(node);
    }
  }
  target.body.appendChild(form);
  form.submit();
  if (null != form.parentNode) {
    form.parentNode.removeChild(form);
  }
  if (null != jujuConfig) {
    window.onbeforeunload = jujuConfig;
  }
};
var mxClipboard = {
  STEPSIZE : 10,
  insertCount : 1,
  cells : null,
  setCells : function(cells) {
    /** @type {number} */
    mxClipboard.cells = cells;
  },
  getCells : function() {
    return mxClipboard.cells;
  },
  isEmpty : function() {
    return null == mxClipboard.getCells();
  },
  cut : function(id, url) {
    url = mxClipboard.copy(id, url);
    /** @type {number} */
    mxClipboard.insertCount = 0;
    mxClipboard.removeCells(id, url, false);
    return url;
  },
  removeCells : function(obj, url, id) {
    obj.removeCells(url, id);
  },
  copy : function(graph, node) {
    node = node || graph.getSelectionCells();
    node = graph.getExportableCells(graph.model.getTopmostCells(node));
    /** @type {number} */
    mxClipboard.insertCount = 1;
    mxClipboard.setCells(graph.cloneCells(node));
    return node;
  },
  paste : function(graph) {
    /** @type {null} */
    var cells = null;
    if (!mxClipboard.isEmpty()) {
      cells = graph.getImportableCells(mxClipboard.getCells());
      /** @type {number} */
      var y = mxClipboard.insertCount * mxClipboard.STEPSIZE;
      var target = graph.getDefaultParent();
      cells = graph.importCells(cells, y, y, target);
      mxClipboard.insertCount++;
      graph.setSelectionCells(cells);
    }
    return cells;
  }
};
/**
 * @param {string} text
 * @param {string} img
 * @param {undefined} a
 * @param {!Object} b
 * @param {string} x
 * @param {string} options
 * @param {?} max
 * @param {string} margin
 * @param {!Object} parent
 * @param {string} type
 * @return {undefined}
 */
function mxWindow(text, img, a, b, x, options, max, margin, parent, type) {
  if (null != img) {
    max = null != max ? max : true;
    /** @type {string} */
    this.content = img;
    this.init(a, b, x, options, type);
    this.installMaximizeHandler();
    this.installMinimizeHandler();
    this.installCloseHandler();
    this.setMinimizable(max);
    this.setTitle(text);
    if (null == margin || margin) {
      this.installMoveHandler();
    }
    if (null != parent && null != parent.parentNode) {
      parent.parentNode.replaceChild(this.div, parent);
    } else {
      document.body.appendChild(this.div);
    }
  }
}
mxWindow.prototype = new mxEventSource;
/** @type {function(string, string, undefined, !Object, string, string, ?, string, !Object, string): undefined} */
mxWindow.prototype.constructor = mxWindow;
/** @type {string} */
mxWindow.prototype.closeImage = mxClient.imageBasePath + "/close.gif";
/** @type {string} */
mxWindow.prototype.minimizeImage = mxClient.imageBasePath + "/minimize.gif";
/** @type {string} */
mxWindow.prototype.normalizeImage = mxClient.imageBasePath + "/normalize.gif";
/** @type {string} */
mxWindow.prototype.maximizeImage = mxClient.imageBasePath + "/maximize.gif";
/** @type {string} */
mxWindow.prototype.resizeImage = mxClient.imageBasePath + "/resize.gif";
/** @type {boolean} */
mxWindow.prototype.visible = false;
mxWindow.prototype.minimumSize = new mxRectangle(0, 0, 50, 40);
/** @type {boolean} */
mxWindow.prototype.destroyOnClose = true;
/** @type {number} */
mxWindow.prototype.contentHeightCorrection = 8 == document.documentMode || 7 == document.documentMode ? 6 : 2;
/** @type {null} */
mxWindow.prototype.title = null;
/** @type {null} */
mxWindow.prototype.content = null;
/**
 * @param {!Object} i
 * @param {!Object} b
 * @param {string} x
 * @param {string} h
 * @param {string} name
 * @return {undefined}
 */
mxWindow.prototype.init = function(i, b, x, h, name) {
  name = null != name ? name : "mxWindow";
  /** @type {!Element} */
  this.div = document.createElement("div");
  /** @type {string} */
  this.div.className = name;
  /** @type {string} */
  this.div.style.left = i + "px";
  /** @type {string} */
  this.div.style.top = b + "px";
  /** @type {!Element} */
  this.table = document.createElement("table");
  /** @type {string} */
  this.table.className = name;
  if (mxClient.IS_POINTER) {
    /** @type {string} */
    this.div.style.touchAction = "none";
  }
  if (null != x) {
    /** @type {string} */
    this.div.style.width = x + "px";
    /** @type {string} */
    this.table.style.width = x + "px";
  }
  if (null != h) {
    /** @type {string} */
    this.div.style.height = h + "px";
    /** @type {string} */
    this.table.style.height = h + "px";
  }
  /** @type {!Element} */
  i = document.createElement("tbody");
  /** @type {!Element} */
  b = document.createElement("tr");
  /** @type {!Element} */
  this.title = document.createElement("td");
  /** @type {string} */
  this.title.className = name + "Title";
  /** @type {!Element} */
  this.buttons = document.createElement("div");
  /** @type {string} */
  this.buttons.style.position = "absolute";
  /** @type {string} */
  this.buttons.style.display = "inline-block";
  /** @type {string} */
  this.buttons.style.right = "4px";
  /** @type {string} */
  this.buttons.style.top = "5px";
  this.title.appendChild(this.buttons);
  b.appendChild(this.title);
  i.appendChild(b);
  /** @type {!Element} */
  b = document.createElement("tr");
  /** @type {!Element} */
  this.td = document.createElement("td");
  /** @type {string} */
  this.td.className = name + "Pane";
  if (7 == document.documentMode) {
    /** @type {string} */
    this.td.style.height = "100%";
  }
  /** @type {!Element} */
  this.contentWrapper = document.createElement("div");
  /** @type {string} */
  this.contentWrapper.className = name + "Pane";
  /** @type {string} */
  this.contentWrapper.style.width = "100%";
  this.contentWrapper.appendChild(this.content);
  if ("DIV" != this.content.nodeName.toUpperCase()) {
    /** @type {string} */
    this.contentWrapper.style.height = "100%";
  }
  this.td.appendChild(this.contentWrapper);
  b.appendChild(this.td);
  i.appendChild(b);
  this.table.appendChild(i);
  this.div.appendChild(this.table);
  name = mxUtils.bind(this, function(canCreateDiscussions) {
    this.activate();
  });
  mxEvent.addGestureListeners(this.title, name);
  mxEvent.addGestureListeners(this.table, name);
  this.hide();
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxWindow.prototype.setTitle = function(value) {
  var shape = this.title.firstChild;
  for (; null != shape;) {
    var node = shape.nextSibling;
    if (shape.nodeType == mxConstants.NODETYPE_TEXT) {
      shape.parentNode.removeChild(shape);
    }
    shape = node;
  }
  mxUtils.write(this.title, value || "");
  this.title.appendChild(this.buttons);
};
/**
 * @param {boolean} state
 * @return {undefined}
 */
mxWindow.prototype.setScrollable = function(state) {
  if (null == navigator.userAgent || 0 > navigator.userAgent.indexOf("Presto/2.5")) {
    /** @type {string} */
    this.contentWrapper.style.overflow = state ? "auto" : "hidden";
  }
};
/**
 * @return {undefined}
 */
mxWindow.prototype.activate = function() {
  if (mxWindow.activeWindow != this) {
    var val = mxUtils.getCurrentStyle(this.getElement());
    val = null != val ? val.zIndex : 3;
    if (mxWindow.activeWindow) {
      var win = mxWindow.activeWindow.getElement();
      if (null != win && null != win.style) {
        win.style.zIndex = val;
      }
    }
    win = mxWindow.activeWindow;
    /** @type {number} */
    this.getElement().style.zIndex = parseInt(val) + 1;
    mxWindow.activeWindow = this;
    this.fireEvent(new mxEventObject(mxEvent.ACTIVATE, "previousWindow", win));
  }
};
/**
 * @return {?}
 */
mxWindow.prototype.getElement = function() {
  return this.div;
};
/**
 * @return {undefined}
 */
mxWindow.prototype.fit = function() {
  mxUtils.fit(this.div);
};
/**
 * @return {?}
 */
mxWindow.prototype.isResizable = function() {
  return null != this.resize ? "none" != this.resize.style.display : false;
};
/**
 * @param {string} interpolate
 * @return {undefined}
 */
mxWindow.prototype.setResizable = function(interpolate) {
  if (interpolate) {
    if (null == this.resize) {
      /** @type {!Element} */
      this.resize = document.createElement("img");
      /** @type {string} */
      this.resize.style.position = "absolute";
      /** @type {string} */
      this.resize.style.bottom = "2px";
      /** @type {string} */
      this.resize.style.right = "2px";
      this.resize.setAttribute("src", this.resizeImage);
      /** @type {string} */
      this.resize.style.cursor = "nw-resize";
      /** @type {null} */
      var msgW = null;
      /** @type {null} */
      var morphWithHalos = null;
      /** @type {null} */
      var dw = null;
      /** @type {null} */
      var dHeight = null;
      interpolate = mxUtils.bind(this, function(evt) {
        this.activate();
        msgW = mxEvent.getClientX(evt);
        morphWithHalos = mxEvent.getClientY(evt);
        dw = this.div.offsetWidth;
        dHeight = this.div.offsetHeight;
        mxEvent.addGestureListeners(document, null, update, trialCounter);
        this.fireEvent(new mxEventObject(mxEvent.RESIZE_START, "event", evt));
        mxEvent.consume(evt);
      });
      var update = mxUtils.bind(this, function(e) {
        if (null != msgW && null != morphWithHalos) {
          /** @type {number} */
          var deltaW = mxEvent.getClientX(e) - msgW;
          /** @type {number} */
          var deltaH = mxEvent.getClientY(e) - morphWithHalos;
          this.setSize(dw + deltaW, dHeight + deltaH);
          this.fireEvent(new mxEventObject(mxEvent.RESIZE, "event", e));
          mxEvent.consume(e);
        }
      });
      var trialCounter = mxUtils.bind(this, function(e) {
        if (null != msgW && null != morphWithHalos) {
          /** @type {null} */
          morphWithHalos = msgW = null;
          mxEvent.removeGestureListeners(document, null, update, trialCounter);
          this.fireEvent(new mxEventObject(mxEvent.RESIZE_END, "event", e));
          mxEvent.consume(e);
        }
      });
      mxEvent.addGestureListeners(this.resize, interpolate, update, trialCounter);
      this.div.appendChild(this.resize);
    } else {
      /** @type {string} */
      this.resize.style.display = "inline";
    }
  } else {
    if (null != this.resize) {
      /** @type {string} */
      this.resize.style.display = "none";
    }
  }
};
/**
 * @param {number} size
 * @param {number} offset
 * @return {undefined}
 */
mxWindow.prototype.setSize = function(size, offset) {
  /** @type {number} */
  size = Math.max(this.minimumSize.width, size);
  /** @type {number} */
  offset = Math.max(this.minimumSize.height, offset);
  /** @type {string} */
  this.div.style.width = size + "px";
  /** @type {string} */
  this.div.style.height = offset + "px";
  /** @type {string} */
  this.table.style.width = size + "px";
  /** @type {string} */
  this.table.style.height = offset + "px";
  /** @type {string} */
  this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
};
/**
 * @param {boolean} val
 * @return {undefined}
 */
mxWindow.prototype.setMinimizable = function(val) {
  /** @type {string} */
  this.minimizeImg.style.display = val ? "" : "none";
};
/**
 * @return {?}
 */
mxWindow.prototype.getMinimumSize = function() {
  return new mxRectangle(0, 0, 0, this.title.offsetHeight);
};
/**
 * @param {!Object} p
 * @return {undefined}
 */
mxWindow.prototype.toggleMinimized = function(p) {
  this.activate();
  if (this.minimized) {
    /** @type {boolean} */
    this.minimized = false;
    this.minimizeImg.setAttribute("src", this.minimizeImage);
    this.minimizeImg.setAttribute("title", "Minimize");
    /** @type {string} */
    this.contentWrapper.style.display = "";
    this.maximize.style.display = this.maxDisplay;
    this.div.style.height = this.height;
    this.table.style.height = this.height;
    if (null != this.resize) {
      /** @type {string} */
      this.resize.style.visibility = "";
    }
    this.fireEvent(new mxEventObject(mxEvent.NORMALIZE, "event", p));
  } else {
    /** @type {boolean} */
    this.minimized = true;
    this.minimizeImg.setAttribute("src", this.normalizeImage);
    this.minimizeImg.setAttribute("title", "Normalize");
    /** @type {string} */
    this.contentWrapper.style.display = "none";
    this.maxDisplay = this.maximize.style.display;
    /** @type {string} */
    this.maximize.style.display = "none";
    this.height = this.table.style.height;
    var svRect = this.getMinimumSize();
    if (0 < svRect.height) {
      /** @type {string} */
      this.div.style.height = svRect.height + "px";
      /** @type {string} */
      this.table.style.height = svRect.height + "px";
    }
    if (0 < svRect.width) {
      /** @type {string} */
      this.div.style.width = svRect.width + "px";
      /** @type {string} */
      this.table.style.width = svRect.width + "px";
    }
    if (null != this.resize) {
      /** @type {string} */
      this.resize.style.visibility = "hidden";
    }
    this.fireEvent(new mxEventObject(mxEvent.MINIMIZE, "event", p));
  }
};
/**
 * @return {undefined}
 */
mxWindow.prototype.installMinimizeHandler = function() {
  /** @type {!Element} */
  this.minimizeImg = document.createElement("img");
  this.minimizeImg.setAttribute("src", this.minimizeImage);
  this.minimizeImg.setAttribute("title", "Minimize");
  /** @type {string} */
  this.minimizeImg.style.cursor = "pointer";
  /** @type {string} */
  this.minimizeImg.style.marginLeft = "2px";
  /** @type {string} */
  this.minimizeImg.style.display = "none";
  this.buttons.appendChild(this.minimizeImg);
  /** @type {boolean} */
  this.minimized = false;
  /** @type {null} */
  this.height = this.maxDisplay = null;
  var googleUpdateMode = mxUtils.bind(this, function(evt) {
    this.toggleMinimized(evt);
    mxEvent.consume(evt);
  });
  mxEvent.addGestureListeners(this.minimizeImg, googleUpdateMode);
};
/**
 * @param {boolean} doShowDetailsSection
 * @return {undefined}
 */
mxWindow.prototype.setMaximizable = function(doShowDetailsSection) {
  /** @type {string} */
  this.maximize.style.display = doShowDetailsSection ? "" : "none";
};
/**
 * @return {undefined}
 */
mxWindow.prototype.installMaximizeHandler = function() {
  /** @type {!Element} */
  this.maximize = document.createElement("img");
  this.maximize.setAttribute("src", this.maximizeImage);
  this.maximize.setAttribute("title", "Maximize");
  /** @type {string} */
  this.maximize.style.cursor = "default";
  /** @type {string} */
  this.maximize.style.marginLeft = "2px";
  /** @type {string} */
  this.maximize.style.cursor = "pointer";
  /** @type {string} */
  this.maximize.style.display = "none";
  this.buttons.appendChild(this.maximize);
  /** @type {boolean} */
  var a = false;
  /** @type {null} */
  var imagePosLeft = null;
  /** @type {null} */
  var topValue = null;
  /** @type {null} */
  var _viewPortH = null;
  /** @type {null} */
  var runtimeWidth = null;
  /** @type {null} */
  var display = null;
  var update = mxUtils.bind(this, function(e) {
    this.activate();
    if ("none" != this.maximize.style.display) {
      if (a) {
        /** @type {boolean} */
        a = false;
        this.maximize.setAttribute("src", this.maximizeImage);
        this.maximize.setAttribute("title", "Maximize");
        /** @type {string} */
        this.contentWrapper.style.display = "";
        this.minimizeImg.style.display = display;
        this.div.style.left = imagePosLeft + "px";
        this.div.style.top = topValue + "px";
        this.div.style.height = _viewPortH;
        this.div.style.width = runtimeWidth;
        y = mxUtils.getCurrentStyle(this.contentWrapper);
        if ("auto" == y.overflow || null != this.resize) {
          /** @type {string} */
          this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
        }
        this.table.style.height = _viewPortH;
        this.table.style.width = runtimeWidth;
        if (null != this.resize) {
          /** @type {string} */
          this.resize.style.visibility = "";
        }
        this.fireEvent(new mxEventObject(mxEvent.NORMALIZE, "event", e));
      } else {
        /** @type {boolean} */
        a = true;
        this.maximize.setAttribute("src", this.normalizeImage);
        this.maximize.setAttribute("title", "Normalize");
        /** @type {string} */
        this.contentWrapper.style.display = "";
        display = this.minimizeImg.style.display;
        /** @type {string} */
        this.minimizeImg.style.display = "none";
        /** @type {number} */
        imagePosLeft = parseInt(this.div.style.left);
        /** @type {number} */
        topValue = parseInt(this.div.style.top);
        _viewPortH = this.table.style.height;
        runtimeWidth = this.table.style.width;
        /** @type {string} */
        this.div.style.left = "0px";
        /** @type {string} */
        this.div.style.top = "0px";
        /** @type {number} */
        y = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight || 0);
        /** @type {string} */
        this.div.style.width = document.body.clientWidth - 2 + "px";
        /** @type {string} */
        this.div.style.height = y - 2 + "px";
        /** @type {string} */
        this.table.style.width = document.body.clientWidth - 2 + "px";
        /** @type {string} */
        this.table.style.height = y - 2 + "px";
        if (null != this.resize) {
          /** @type {string} */
          this.resize.style.visibility = "hidden";
        }
        var y = mxUtils.getCurrentStyle(this.contentWrapper);
        if ("auto" == y.overflow || null != this.resize) {
          /** @type {string} */
          this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
        }
        this.fireEvent(new mxEventObject(mxEvent.MAXIMIZE, "event", e));
      }
      mxEvent.consume(e);
    }
  });
  mxEvent.addGestureListeners(this.maximize, update);
  mxEvent.addListener(this.title, "dblclick", update);
};
/**
 * @return {undefined}
 */
mxWindow.prototype.installMoveHandler = function() {
  /** @type {string} */
  this.title.style.cursor = "move";
  mxEvent.addGestureListeners(this.title, mxUtils.bind(this, function(evt) {
    var _getClientCoordinates = mxEvent.getClientX(evt);
    var offset = mxEvent.getClientY(evt);
    var x = this.getX();
    var left = this.getY();
    var update = mxUtils.bind(this, function(e) {
      /** @type {number} */
      var EPSILSON = mxEvent.getClientX(e) - _getClientCoordinates;
      /** @type {number} */
      var n = mxEvent.getClientY(e) - offset;
      this.setLocation(x + EPSILSON, left + n);
      this.fireEvent(new mxEventObject(mxEvent.MOVE, "event", e));
      mxEvent.consume(e);
    });
    var trialCounter = mxUtils.bind(this, function(e) {
      mxEvent.removeGestureListeners(document, null, update, trialCounter);
      this.fireEvent(new mxEventObject(mxEvent.MOVE_END, "event", e));
      mxEvent.consume(e);
    });
    mxEvent.addGestureListeners(document, null, update, trialCounter);
    this.fireEvent(new mxEventObject(mxEvent.MOVE_START, "event", evt));
    mxEvent.consume(evt);
  }));
  if (mxClient.IS_POINTER) {
    /** @type {string} */
    this.title.style.touchAction = "none";
  }
};
/**
 * @param {number} left
 * @param {number} top
 * @return {undefined}
 */
mxWindow.prototype.setLocation = function(left, top) {
  /** @type {string} */
  this.div.style.left = left + "px";
  /** @type {string} */
  this.div.style.top = top + "px";
};
/**
 * @return {?}
 */
mxWindow.prototype.getX = function() {
  return parseInt(this.div.style.left);
};
/**
 * @return {?}
 */
mxWindow.prototype.getY = function() {
  return parseInt(this.div.style.top);
};
/**
 * @return {undefined}
 */
mxWindow.prototype.installCloseHandler = function() {
  /** @type {!Element} */
  this.closeImg = document.createElement("img");
  this.closeImg.setAttribute("src", this.closeImage);
  this.closeImg.setAttribute("title", "Close");
  /** @type {string} */
  this.closeImg.style.marginLeft = "2px";
  /** @type {string} */
  this.closeImg.style.cursor = "pointer";
  /** @type {string} */
  this.closeImg.style.display = "none";
  this.buttons.appendChild(this.closeImg);
  mxEvent.addGestureListeners(this.closeImg, mxUtils.bind(this, function(e) {
    this.fireEvent(new mxEventObject(mxEvent.CLOSE, "event", e));
    if (this.destroyOnClose) {
      this.destroy();
    } else {
      this.setVisible(false);
    }
    mxEvent.consume(e);
  }));
};
/**
 * @param {!Object} source
 * @return {undefined}
 */
mxWindow.prototype.setImage = function(source) {
  /** @type {!Element} */
  this.image = document.createElement("img");
  this.image.setAttribute("src", source);
  this.image.setAttribute("align", "left");
  /** @type {string} */
  this.image.style.marginRight = "4px";
  /** @type {string} */
  this.image.style.marginLeft = "0px";
  /** @type {string} */
  this.image.style.marginTop = "-2px";
  this.title.insertBefore(this.image, this.title.firstChild);
};
/**
 * @param {boolean} doShowDetailsSection
 * @return {undefined}
 */
mxWindow.prototype.setClosable = function(doShowDetailsSection) {
  /** @type {string} */
  this.closeImg.style.display = doShowDetailsSection ? "" : "none";
};
/**
 * @return {?}
 */
mxWindow.prototype.isVisible = function() {
  return null != this.div ? "none" != this.div.style.display : false;
};
/**
 * @param {boolean} visible
 * @return {undefined}
 */
mxWindow.prototype.setVisible = function(visible) {
  if (null != this.div) {
    if (this.isVisible() != visible) {
      if (visible) {
        this.show();
      } else {
        this.hide();
      }
    } else {
      this.fireEvent(new mxEventObject(visible ? mxEvent.SHOW : mxEvent.HIDE));
    }
  }
};
/**
 * @return {undefined}
 */
mxWindow.prototype.show = function() {
  /** @type {string} */
  this.div.style.display = "";
  this.activate();
  if (!("auto" != mxUtils.getCurrentStyle(this.contentWrapper).overflow && null == this.resize || "none" == this.contentWrapper.style.display)) {
    /** @type {string} */
    this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
  }
  this.fireEvent(new mxEventObject(mxEvent.SHOW));
};
/**
 * @return {undefined}
 */
mxWindow.prototype.hide = function() {
  /** @type {string} */
  this.div.style.display = "none";
  this.fireEvent(new mxEventObject(mxEvent.HIDE));
};
/**
 * @return {undefined}
 */
mxWindow.prototype.destroy = function() {
  this.fireEvent(new mxEventObject(mxEvent.DESTROY));
  if (null != this.div) {
    mxEvent.release(this.div);
    this.div.parentNode.removeChild(this.div);
    /** @type {null} */
    this.div = null;
  }
  /** @type {null} */
  this.contentWrapper = this.content = this.title = null;
};
/**
 * @param {string} iconclass
 * @return {undefined}
 */
function mxForm(iconclass) {
  /** @type {!Element} */
  this.table = document.createElement("table");
  /** @type {string} */
  this.table.className = iconclass;
  /** @type {!Element} */
  this.body = document.createElement("tbody");
  this.table.appendChild(this.body);
}
/** @type {null} */
mxForm.prototype.table = null;
/** @type {boolean} */
mxForm.prototype.body = false;
/**
 * @return {?}
 */
mxForm.prototype.getTable = function() {
  return this.table;
};
/**
 * @param {?} icon
 * @param {?} onClick
 * @return {undefined}
 */
mxForm.prototype.addButtons = function(icon, onClick) {
  /** @type {!Element} */
  var trComments = document.createElement("tr");
  /** @type {!Element} */
  var commentsCell = document.createElement("td");
  trComments.appendChild(commentsCell);
  /** @type {!Element} */
  commentsCell = document.createElement("td");
  /** @type {!Element} */
  var div = document.createElement("button");
  mxUtils.write(div, mxResources.get("ok") || "OK");
  commentsCell.appendChild(div);
  mxEvent.addListener(div, "click", function() {
    icon();
  });
  /** @type {!Element} */
  div = document.createElement("button");
  mxUtils.write(div, mxResources.get("cancel") || "Cancel");
  commentsCell.appendChild(div);
  mxEvent.addListener(div, "click", function() {
    onClick();
  });
  trComments.appendChild(commentsCell);
  this.body.appendChild(trComments);
};
/**
 * @param {!Object} key
 * @param {!Object} condition
 * @param {string} type
 * @return {?}
 */
mxForm.prototype.addText = function(key, condition, type) {
  /** @type {!Element} */
  var input = document.createElement("input");
  input.setAttribute("type", type || "text");
  /** @type {!Object} */
  input.value = condition;
  return this.addField(key, input);
};
/**
 * @param {!Object} name
 * @param {?} state
 * @return {?}
 */
mxForm.prototype.addCheckbox = function(name, state) {
  /** @type {!Element} */
  var checkbox = document.createElement("input");
  checkbox.setAttribute("type", "checkbox");
  this.addField(name, checkbox);
  if (state) {
    /** @type {boolean} */
    checkbox.checked = true;
  }
  return checkbox;
};
/**
 * @param {!Object} key
 * @param {!Object} value
 * @param {number} id
 * @return {?}
 */
mxForm.prototype.addTextarea = function(key, value, id) {
  /** @type {!Element} */
  var node = document.createElement("textarea");
  if (mxClient.IS_NS) {
    id--;
  }
  node.setAttribute("rows", id || 2);
  /** @type {!Object} */
  node.value = value;
  return this.addField(key, node);
};
/**
 * @param {!Object} data
 * @param {?} selector
 * @param {!Object} callback
 * @return {?}
 */
mxForm.prototype.addCombo = function(data, selector, callback) {
  /** @type {!Element} */
  var node = document.createElement("select");
  if (null != callback) {
    node.setAttribute("size", callback);
  }
  if (selector) {
    node.setAttribute("multiple", "true");
  }
  return this.addField(data, node);
};
/**
 * @param {!Node} error
 * @param {?} value
 * @param {!Object} name
 * @param {!Object} val
 * @return {undefined}
 */
mxForm.prototype.addOption = function(error, value, name, val) {
  /** @type {!Element} */
  var e = document.createElement("option");
  mxUtils.writeln(e, value);
  e.setAttribute("value", name);
  if (val) {
    e.setAttribute("selected", val);
  }
  error.appendChild(e);
};
/**
 * @param {!Object} value
 * @param {(Node|Window)} input
 * @return {?}
 */
mxForm.prototype.addField = function(value, input) {
  /** @type {!Element} */
  var ref = document.createElement("tr");
  /** @type {!Element} */
  var node = document.createElement("td");
  mxUtils.write(node, value);
  ref.appendChild(node);
  /** @type {!Element} */
  node = document.createElement("td");
  node.appendChild(input);
  ref.appendChild(node);
  this.body.appendChild(ref);
  return input;
};
/**
 * @param {string} src
 * @param {string} width
 * @param {string} height
 * @param {string} x
 * @param {string} y
 * @return {undefined}
 */
function mxImage(src, width, height, x, y) {
  /** @type {string} */
  this.src = src;
  this.width = null != width ? width : this.width;
  this.height = null != height ? height : this.height;
  this.x = null != x ? x : this.x;
  this.y = null != y ? y : this.y;
}
/** @type {null} */
mxImage.prototype.src = null;
/** @type {number} */
mxImage.prototype.width = 0;
/** @type {number} */
mxImage.prototype.height = 0;
/** @type {number} */
mxImage.prototype.x = 0;
/** @type {number} */
mxImage.prototype.y = 0;
/**
 * @param {string} element
 * @param {!Object} e
 * @return {undefined}
 */
function mxDivResizer(element, e) {
  if ("div" == element.nodeName.toLowerCase()) {
    if (null == e) {
      /** @type {!Window} */
      e = window;
    }
    /** @type {string} */
    this.div = element;
    element = mxUtils.getCurrentStyle(element);
    if (null != element) {
      /** @type {boolean} */
      this.resizeWidth = "auto" == element.width;
      /** @type {boolean} */
      this.resizeHeight = "auto" == element.height;
    }
    mxEvent.addListener(e, "resize", mxUtils.bind(this, function(canCreateDiscussions) {
      if (!this.handlingResize) {
        /** @type {boolean} */
        this.handlingResize = true;
        this.resize();
        /** @type {boolean} */
        this.handlingResize = false;
      }
    }));
    this.resize();
  }
}
/** @type {boolean} */
mxDivResizer.prototype.resizeWidth = true;
/** @type {boolean} */
mxDivResizer.prototype.resizeHeight = true;
/** @type {boolean} */
mxDivResizer.prototype.handlingResize = false;
/**
 * @return {undefined}
 */
mxDivResizer.prototype.resize = function() {
  var h = this.getDocumentWidth();
  var b = this.getDocumentHeight();
  /** @type {number} */
  var g = parseInt(this.div.style.left);
  /** @type {number} */
  var w = parseInt(this.div.style.right);
  /** @type {number} */
  var t = parseInt(this.div.style.top);
  /** @type {number} */
  var a = parseInt(this.div.style.bottom);
  if (this.resizeWidth && !isNaN(g) && !isNaN(w) && 0 <= g && 0 <= w && 0 < h - w - g) {
    /** @type {string} */
    this.div.style.width = h - w - g + "px";
  }
  if (this.resizeHeight && !isNaN(t) && !isNaN(a) && 0 <= t && 0 <= a && 0 < b - t - a) {
    /** @type {string} */
    this.div.style.height = b - t - a + "px";
  }
};
/**
 * @return {?}
 */
mxDivResizer.prototype.getDocumentWidth = function() {
  return document.body.clientWidth;
};
/**
 * @return {?}
 */
mxDivResizer.prototype.getDocumentHeight = function() {
  return document.body.clientHeight;
};
/**
 * @param {!Object} img
 * @param {string} notNew
 * @return {undefined}
 */
function mxDragSource(img, notNew) {
  /** @type {!Object} */
  this.element = img;
  /** @type {string} */
  this.dropHandler = notNew;
  mxEvent.addGestureListeners(img, mxUtils.bind(this, function(element) {
    this.mouseDown(element);
  }));
  mxEvent.addListener(img, "dragstart", function(e) {
    mxEvent.consume(e);
  });
  /**
   * @param {?} result
   * @param {!Object} e
   * @return {undefined}
   */
  this.eventConsumer = function(result, e) {
    result = e.getProperty("eventName");
    e = e.getProperty("event");
    if (result != mxEvent.MOUSE_DOWN) {
      e.consume();
    }
  };
}
/** @type {null} */
mxDragSource.prototype.element = null;
/** @type {null} */
mxDragSource.prototype.dropHandler = null;
/** @type {null} */
mxDragSource.prototype.dragOffset = null;
/** @type {null} */
mxDragSource.prototype.dragElement = null;
/** @type {null} */
mxDragSource.prototype.previewElement = null;
/** @type {null} */
mxDragSource.prototype.previewOffset = null;
/** @type {boolean} */
mxDragSource.prototype.enabled = true;
/** @type {null} */
mxDragSource.prototype.currentGraph = null;
/** @type {null} */
mxDragSource.prototype.currentDropTarget = null;
/** @type {null} */
mxDragSource.prototype.currentPoint = null;
/** @type {null} */
mxDragSource.prototype.currentGuide = null;
/** @type {null} */
mxDragSource.prototype.currentHighlight = null;
/** @type {boolean} */
mxDragSource.prototype.autoscroll = true;
/** @type {boolean} */
mxDragSource.prototype.guidesEnabled = true;
/** @type {boolean} */
mxDragSource.prototype.gridEnabled = true;
/** @type {boolean} */
mxDragSource.prototype.highlightDropTargets = true;
/** @type {number} */
mxDragSource.prototype.dragElementZIndex = 100;
/** @type {number} */
mxDragSource.prototype.dragElementOpacity = 70;
/** @type {boolean} */
mxDragSource.prototype.checkEventSource = true;
/**
 * @return {?}
 */
mxDragSource.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {boolean} state
 * @return {undefined}
 */
mxDragSource.prototype.setEnabled = function(state) {
  /** @type {boolean} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxDragSource.prototype.isGuidesEnabled = function() {
  return this.guidesEnabled;
};
/**
 * @param {boolean} addedRenderer
 * @return {undefined}
 */
mxDragSource.prototype.setGuidesEnabled = function(addedRenderer) {
  /** @type {boolean} */
  this.guidesEnabled = addedRenderer;
};
/**
 * @return {?}
 */
mxDragSource.prototype.isGridEnabled = function() {
  return this.gridEnabled;
};
/**
 * @param {number} a
 * @return {undefined}
 */
mxDragSource.prototype.setGridEnabled = function(a) {
  /** @type {number} */
  this.gridEnabled = a;
};
/**
 * @param {!Object} a22
 * @return {?}
 */
mxDragSource.prototype.getGraphForEvent = function(a22) {
  return null;
};
/**
 * @param {!Object} graph
 * @param {?} x
 * @param {string} y
 * @param {!Object} event
 * @return {?}
 */
mxDragSource.prototype.getDropTarget = function(graph, x, y, event) {
  return graph.getCellAt(x, y);
};
/**
 * @param {!Object} element
 * @return {?}
 */
mxDragSource.prototype.createDragElement = function(element) {
  return this.element.cloneNode(true);
};
/**
 * @param {string} sourceGraph
 * @return {?}
 */
mxDragSource.prototype.createPreviewElement = function(sourceGraph) {
  return null;
};
/**
 * @return {?}
 */
mxDragSource.prototype.isActive = function() {
  return null != this.mouseMoveHandler;
};
/**
 * @return {undefined}
 */
mxDragSource.prototype.reset = function() {
  if (null != this.currentGraph) {
    this.dragExit(this.currentGraph);
    /** @type {null} */
    this.currentGraph = null;
  }
  this.removeDragElement();
  this.removeListeners();
  this.stopDrag();
};
/**
 * @param {undefined} e
 * @return {undefined}
 */
mxDragSource.prototype.mouseDown = function(e) {
  if (this.enabled && !mxEvent.isConsumed(e) && null == this.mouseMoveHandler) {
    this.startDrag(e);
    this.mouseMoveHandler = mxUtils.bind(this, this.mouseMove);
    this.mouseUpHandler = mxUtils.bind(this, this.mouseUp);
    mxEvent.addGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);
    if (mxClient.IS_TOUCH && !mxEvent.isMouseEvent(e)) {
      this.eventSource = mxEvent.getSource(e);
      mxEvent.addGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);
    }
  }
};
/**
 * @param {!Object} e
 * @return {undefined}
 */
mxDragSource.prototype.startDrag = function(e) {
  this.dragElement = this.createDragElement(e);
  /** @type {string} */
  this.dragElement.style.position = "absolute";
  this.dragElement.style.zIndex = this.dragElementZIndex;
  mxUtils.setOpacity(this.dragElement, this.dragElementOpacity);
  if (this.checkEventSource && mxClient.IS_SVG) {
    /** @type {string} */
    this.dragElement.style.pointerEvents = "none";
  }
};
/**
 * @return {undefined}
 */
mxDragSource.prototype.stopDrag = function() {
  this.removeDragElement();
};
/**
 * @return {undefined}
 */
mxDragSource.prototype.removeDragElement = function() {
  if (null != this.dragElement) {
    if (null != this.dragElement.parentNode) {
      this.dragElement.parentNode.removeChild(this.dragElement);
    }
    /** @type {null} */
    this.dragElement = null;
  }
};
/**
 * @param {undefined} e
 * @return {?}
 */
mxDragSource.prototype.getElementForEvent = function(e) {
  return mxEvent.isTouchEvent(e) || mxEvent.isPenEvent(e) ? document.elementFromPoint(mxEvent.getClientX(e), mxEvent.getClientY(e)) : mxEvent.getSource(e);
};
/**
 * @param {!Object} state
 * @param {string} e
 * @return {?}
 */
mxDragSource.prototype.graphContainsEvent = function(state, e) {
  var this_area = mxEvent.getClientX(e);
  var intervalGroups = mxEvent.getClientY(e);
  var dialogGeometry = mxUtils.getOffset(state.container);
  var containerGeometry = mxUtils.getScrollOrigin();
  e = this.getElementForEvent(e);
  if (this.checkEventSource) {
    for (; null != e && e != state.container;) {
      e = e.parentNode;
    }
  }
  return null != e && this_area >= dialogGeometry.x - containerGeometry.x && intervalGroups >= dialogGeometry.y - containerGeometry.y && this_area <= dialogGeometry.x - containerGeometry.x + state.container.offsetWidth && intervalGroups <= dialogGeometry.y - containerGeometry.y + state.container.offsetHeight;
};
/**
 * @param {undefined} e
 * @return {undefined}
 */
mxDragSource.prototype.mouseMove = function(e) {
  var id = this.getGraphForEvent(e);
  if (!(null == id || this.graphContainsEvent(id, e))) {
    /** @type {null} */
    id = null;
  }
  if (id != this.currentGraph) {
    if (null != this.currentGraph) {
      this.dragExit(this.currentGraph, e);
    }
    this.currentGraph = id;
    if (null != this.currentGraph) {
      this.dragEnter(this.currentGraph, e);
    }
  }
  if (null != this.currentGraph) {
    this.dragOver(this.currentGraph, e);
  }
  if (null == this.dragElement || null != this.previewElement && "visible" == this.previewElement.style.visibility) {
    if (null != this.dragElement) {
      /** @type {string} */
      this.dragElement.style.visibility = "hidden";
    }
  } else {
    id = mxEvent.getClientX(e);
    var y = mxEvent.getClientY(e);
    if (null == this.dragElement.parentNode) {
      document.body.appendChild(this.dragElement);
    }
    /** @type {string} */
    this.dragElement.style.visibility = "visible";
    if (null != this.dragOffset) {
      id = id + this.dragOffset.x;
      y = y + this.dragOffset.y;
    }
    var options = mxUtils.getDocumentScrollOrigin(document);
    /** @type {string} */
    this.dragElement.style.left = id + options.x + "px";
    /** @type {string} */
    this.dragElement.style.top = y + options.y + "px";
  }
  mxEvent.consume(e);
};
/**
 * @param {undefined} e
 * @return {undefined}
 */
mxDragSource.prototype.mouseUp = function(e) {
  if (null != this.currentGraph) {
    if (null != this.currentPoint && (null == this.previewElement || "hidden" != this.previewElement.style.visibility)) {
      var scale = this.currentGraph.view.scale;
      var geo = this.currentGraph.view.translate;
      this.drop(this.currentGraph, e, this.currentDropTarget, this.currentPoint.x / scale - geo.x, this.currentPoint.y / scale - geo.y);
    }
    this.dragExit(this.currentGraph);
    /** @type {null} */
    this.currentGraph = null;
  }
  this.stopDrag();
  this.removeListeners();
  mxEvent.consume(e);
};
/**
 * @return {undefined}
 */
mxDragSource.prototype.removeListeners = function() {
  if (null != this.eventSource) {
    mxEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);
    /** @type {null} */
    this.eventSource = null;
  }
  mxEvent.removeGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);
  /** @type {null} */
  this.mouseUpHandler = this.mouseMoveHandler = null;
};
/**
 * @param {string} graph
 * @param {!PointerEvent} evt
 * @return {undefined}
 */
mxDragSource.prototype.dragEnter = function(graph, evt) {
  /** @type {boolean} */
  graph.isMouseDown = true;
  graph.isMouseTrigger = mxEvent.isMouseEvent(evt);
  this.previewElement = this.createPreviewElement(graph);
  if (null != this.previewElement && this.checkEventSource && mxClient.IS_SVG) {
    /** @type {string} */
    this.previewElement.style.pointerEvents = "none";
  }
  if (this.isGuidesEnabled() && null != this.previewElement) {
    this.currentGuide = new mxGuide(graph, graph.graphHandler.getGuideStates());
  }
  if (this.highlightDropTargets) {
    this.currentHighlight = new mxCellHighlight(graph, mxConstants.DROP_TARGET_COLOR);
  }
  graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.eventConsumer);
};
/**
 * @param {!Object} event
 * @param {!Object} observer
 * @return {undefined}
 */
mxDragSource.prototype.dragExit = function(event, observer) {
  /** @type {null} */
  this.currentPoint = this.currentDropTarget = null;
  /** @type {boolean} */
  event.isMouseDown = false;
  event.removeListener(this.eventConsumer);
  if (null != this.previewElement) {
    if (null != this.previewElement.parentNode) {
      this.previewElement.parentNode.removeChild(this.previewElement);
    }
    /** @type {null} */
    this.previewElement = null;
  }
  if (null != this.currentGuide) {
    this.currentGuide.destroy();
    /** @type {null} */
    this.currentGuide = null;
  }
  if (null != this.currentHighlight) {
    this.currentHighlight.destroy();
    /** @type {null} */
    this.currentHighlight = null;
  }
};
/**
 * @param {!Object} self
 * @param {!Object} event
 * @return {undefined}
 */
mxDragSource.prototype.dragOver = function(self, event) {
  var value = mxUtils.getOffset(self.container);
  var scale = mxUtils.getScrollOrigin(self.container);
  /** @type {number} */
  var width = mxEvent.getClientX(event) - value.x + scale.x - self.panDx;
  /** @type {number} */
  value = mxEvent.getClientY(event) - value.y + scale.y - self.panDy;
  if (self.autoScroll && (null == this.autoscroll || this.autoscroll)) {
    self.scrollPointToVisible(width, value, self.autoExtend);
  }
  if (null != this.currentHighlight && self.isDropEnabled()) {
    this.currentDropTarget = this.getDropTarget(self, width, value, event);
    scale = self.getView().getState(this.currentDropTarget);
    this.currentHighlight.highlight(scale);
  }
  if (null != this.previewElement) {
    if (null == this.previewElement.parentNode) {
      self.container.appendChild(this.previewElement);
      /** @type {string} */
      this.previewElement.style.zIndex = "3";
      /** @type {string} */
      this.previewElement.style.position = "absolute";
    }
    scale = this.isGridEnabled() && self.isGridEnabledEvent(event);
    /** @type {boolean} */
    var size = true;
    if (null != this.currentGuide && this.currentGuide.isEnabledForEvent(event)) {
      /** @type {number} */
      self = parseInt(this.previewElement.style.width);
      /** @type {number} */
      size = parseInt(this.previewElement.style.height);
      self = new mxRectangle(0, 0, self, size);
      value = new mxPoint(width, value);
      value = this.currentGuide.move(self, value, scale, true);
      /** @type {boolean} */
      size = false;
      width = value.x;
      value = value.y;
    } else {
      if (scale) {
        scale = self.view.scale;
        event = self.view.translate;
        /** @type {number} */
        var start = self.gridSize / 2;
        /** @type {number} */
        width = (self.snap(width / scale - event.x - start) + event.x) * scale;
        /** @type {number} */
        value = (self.snap(value / scale - event.y - start) + event.y) * scale;
      }
    }
    if (null != this.currentGuide && size) {
      this.currentGuide.hide();
    }
    if (null != this.previewOffset) {
      width = width + this.previewOffset.x;
      value = value + this.previewOffset.y;
    }
    /** @type {string} */
    this.previewElement.style.left = Math.round(width) + "px";
    /** @type {string} */
    this.previewElement.style.top = Math.round(value) + "px";
    /** @type {string} */
    this.previewElement.style.visibility = "visible";
  }
  this.currentPoint = new mxPoint(width, value);
};
/**
 * @param {!Object} x
 * @param {!Object} key
 * @param {?} aEvent
 * @param {number} aDragDropObserver
 * @param {number} mouseOverItem
 * @return {undefined}
 */
mxDragSource.prototype.drop = function(x, key, aEvent, aDragDropObserver, mouseOverItem) {
  this.dropHandler.apply(this, arguments);
  if ("hidden" != x.container.style.visibility) {
    x.container.focus();
  }
};
/**
 * @param {!Node} dom
 * @return {undefined}
 */
function mxToolbar(dom) {
  /** @type {!Node} */
  this.container = dom;
}
mxToolbar.prototype = new mxEventSource;
/** @type {function(!Node): undefined} */
mxToolbar.prototype.constructor = mxToolbar;
/** @type {null} */
mxToolbar.prototype.container = null;
/** @type {boolean} */
mxToolbar.prototype.enabled = true;
/** @type {boolean} */
mxToolbar.prototype.noReset = false;
/** @type {boolean} */
mxToolbar.prototype.updateDefaultMode = true;
/**
 * @param {string} value
 * @param {!Object} label
 * @param {!Object} show
 * @param {!Object} id
 * @param {string} el
 * @param {?} text
 * @return {?}
 */
mxToolbar.prototype.addItem = function(value, label, show, id, el, text) {
  /** @type {!Element} */
  var node = document.createElement(null != label ? "img" : "button");
  var id = el || (null != text ? "mxToolbarMode" : "mxToolbarItem");
  node.className = id;
  node.setAttribute("src", label);
  if (null != value) {
    if (null != label) {
      node.setAttribute("title", value);
    } else {
      mxUtils.write(node, value);
    }
  }
  this.container.appendChild(node);
  if (null != show) {
    mxEvent.addListener(node, "click", show);
    if (mxClient.IS_TOUCH) {
      mxEvent.addListener(node, "touchend", show);
    }
  }
  value = mxUtils.bind(this, function(canCreateDiscussions) {
    if (null != id) {
      node.setAttribute("src", label);
    } else {
      /** @type {string} */
      node.style.backgroundColor = "";
    }
  });
  mxEvent.addGestureListeners(node, mxUtils.bind(this, function(side) {
    if (null != id) {
      node.setAttribute("src", id);
    } else {
      /** @type {string} */
      node.style.backgroundColor = "gray";
    }
    if (null != text) {
      if (null == this.menu) {
        this.menu = new mxPopupMenu;
        this.menu.init();
      }
      var e = this.currentImg;
      if (this.menu.isMenuShowing()) {
        this.menu.hideMenu();
      }
      if (e != node) {
        /** @type {!Element} */
        this.currentImg = node;
        this.menu.factoryMethod = text;
        e = new mxPoint(node.offsetLeft, node.offsetTop + node.offsetHeight);
        this.menu.popup(e.x, e.y, null, side);
        if (this.menu.isMenuShowing()) {
          /** @type {string} */
          node.className = id + "Selected";
          /**
           * @return {undefined}
           */
          this.menu.hideMenu = function() {
            mxPopupMenu.prototype.hideMenu.apply(this);
            node.className = id;
            /** @type {null} */
            this.currentImg = null;
          };
        }
      }
    }
  }), null, value);
  mxEvent.addListener(node, "mouseout", value);
  return node;
};
/**
 * @param {string} customStyle
 * @return {?}
 */
mxToolbar.prototype.addCombo = function(customStyle) {
  /** @type {!Element} */
  var scroller = document.createElement("div");
  /** @type {string} */
  scroller.style.display = "inline";
  /** @type {string} */
  scroller.className = "mxToolbarComboContainer";
  /** @type {!Element} */
  var el = document.createElement("select");
  el.className = customStyle || "mxToolbarCombo";
  scroller.appendChild(el);
  this.container.appendChild(scroller);
  return el;
};
/**
 * @param {?} value
 * @param {string} className
 * @return {?}
 */
mxToolbar.prototype.addActionCombo = function(value, className) {
  /** @type {!Element} */
  var e = document.createElement("select");
  e.className = className || "mxToolbarCombo";
  this.addOption(e, value, null);
  mxEvent.addListener(e, "change", function(rawStream) {
    var sec = e.options[e.selectedIndex];
    /** @type {number} */
    e.selectedIndex = 0;
    if (null != sec.funct) {
      sec.funct(rawStream);
    }
  });
  this.container.appendChild(e);
  return e;
};
/**
 * @param {!Node} error
 * @param {?} value
 * @param {!Function} name
 * @return {?}
 */
mxToolbar.prototype.addOption = function(error, value, name) {
  /** @type {!Element} */
  var e = document.createElement("option");
  mxUtils.writeln(e, value);
  if ("function" == typeof name) {
    /** @type {!Function} */
    e.funct = name;
  } else {
    e.setAttribute("value", name);
  }
  error.appendChild(e);
  return e;
};
/**
 * @param {!Object} m
 * @param {!Object} s
 * @param {?} method
 * @param {string} selected
 * @param {string} candidate
 * @return {?}
 */
mxToolbar.prototype.addSwitchMode = function(m, s, method, selected, candidate) {
  /** @type {!Element} */
  var item = document.createElement("img");
  item.initialClassName = candidate || "mxToolbarMode";
  item.className = item.initialClassName;
  item.setAttribute("src", s);
  /** @type {string} */
  item.altIcon = selected;
  if (null != m) {
    item.setAttribute("title", m);
  }
  mxEvent.addListener(item, "click", mxUtils.bind(this, function(aID) {
    aID = this.selectedMode.altIcon;
    if (null != aID) {
      this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
      this.selectedMode.setAttribute("src", aID);
    } else {
      this.selectedMode.className = this.selectedMode.initialClassName;
    }
    if (this.updateDefaultMode) {
      /** @type {!Element} */
      this.defaultMode = item;
    }
    /** @type {!Element} */
    this.selectedMode = item;
    aID = item.altIcon;
    if (null != aID) {
      /** @type {string} */
      item.altIcon = item.getAttribute("src");
      item.setAttribute("src", aID);
    } else {
      /** @type {string} */
      item.className = item.initialClassName + "Selected";
    }
    this.fireEvent(new mxEventObject(mxEvent.SELECT));
    method();
  }));
  this.container.appendChild(item);
  if (null == this.defaultMode) {
    /** @type {!Element} */
    this.defaultMode = item;
    this.selectMode(item);
    method();
  }
  return item;
};
/**
 * @param {!Object} text
 * @param {!Object} options
 * @param {!Function} name
 * @param {string} mode
 * @param {string} params
 * @param {?} title
 * @return {?}
 */
mxToolbar.prototype.addMode = function(text, options, name, mode, params, title) {
  title = null != title ? title : true;
  /** @type {!Element} */
  var o = document.createElement(null != options ? "img" : "button");
  o.initialClassName = params || "mxToolbarMode";
  o.className = o.initialClassName;
  o.setAttribute("src", options);
  /** @type {string} */
  o.altIcon = mode;
  if (null != text) {
    o.setAttribute("title", text);
  }
  if (this.enabled && title) {
    mxEvent.addListener(o, "click", mxUtils.bind(this, function(canCreateDiscussions) {
      this.selectMode(o, name);
      /** @type {boolean} */
      this.noReset = false;
    }));
    mxEvent.addListener(o, "dblclick", mxUtils.bind(this, function(canCreateDiscussions) {
      this.selectMode(o, name);
      /** @type {boolean} */
      this.noReset = true;
    }));
    if (null == this.defaultMode) {
      /** @type {!Element} */
      this.defaultMode = o;
      /** @type {!Function} */
      this.defaultFunction = name;
      this.selectMode(o, name);
    }
  }
  this.container.appendChild(o);
  return o;
};
/**
 * @param {string} entity
 * @param {!Function} name
 * @return {undefined}
 */
mxToolbar.prototype.selectMode = function(entity, name) {
  if (this.selectedMode != entity) {
    if (null != this.selectedMode) {
      var TEXT_SIZE_CONTAINER_ID = this.selectedMode.altIcon;
      if (null != TEXT_SIZE_CONTAINER_ID) {
        this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
        this.selectedMode.setAttribute("src", TEXT_SIZE_CONTAINER_ID);
      } else {
        this.selectedMode.className = this.selectedMode.initialClassName;
      }
    }
    /** @type {string} */
    this.selectedMode = entity;
    TEXT_SIZE_CONTAINER_ID = this.selectedMode.altIcon;
    if (null != TEXT_SIZE_CONTAINER_ID) {
      this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
      this.selectedMode.setAttribute("src", TEXT_SIZE_CONTAINER_ID);
    } else {
      /** @type {string} */
      this.selectedMode.className = this.selectedMode.initialClassName + "Selected";
    }
    this.fireEvent(new mxEventObject(mxEvent.SELECT, "function", name));
  }
};
/**
 * @param {?} params
 * @return {undefined}
 */
mxToolbar.prototype.resetMode = function(params) {
  if (!(!params && this.noReset || this.selectedMode == this.defaultMode)) {
    this.selectMode(this.defaultMode, this.defaultFunction);
  }
};
/**
 * @param {!Object} i
 * @return {?}
 */
mxToolbar.prototype.addSeparator = function(i) {
  return this.addItem(null, i, null);
};
/**
 * @return {undefined}
 */
mxToolbar.prototype.addBreak = function() {
  mxUtils.br(this.container);
};
/**
 * @return {undefined}
 */
mxToolbar.prototype.addLine = function() {
  /** @type {!Element} */
  var elem = document.createElement("hr");
  /** @type {string} */
  elem.style.marginRight = "6px";
  elem.setAttribute("size", "1");
  this.container.appendChild(elem);
};
/**
 * @return {undefined}
 */
mxToolbar.prototype.destroy = function() {
  mxEvent.release(this.container);
  /** @type {null} */
  this.selectedMode = this.defaultFunction = this.defaultMode = this.container = null;
  if (null != this.menu) {
    this.menu.destroy();
  }
};
/**
 * @param {string} data
 * @param {?} linkedEntities
 * @return {undefined}
 */
function mxUndoableEdit(data, linkedEntities) {
  /** @type {string} */
  this.source = data;
  /** @type {!Array} */
  this.changes = [];
  this.significant = null != linkedEntities ? linkedEntities : true;
}
/** @type {null} */
mxUndoableEdit.prototype.source = null;
/** @type {null} */
mxUndoableEdit.prototype.changes = null;
/** @type {null} */
mxUndoableEdit.prototype.significant = null;
/** @type {boolean} */
mxUndoableEdit.prototype.undone = false;
/** @type {boolean} */
mxUndoableEdit.prototype.redone = false;
/**
 * @return {?}
 */
mxUndoableEdit.prototype.isEmpty = function() {
  return 0 == this.changes.length;
};
/**
 * @return {?}
 */
mxUndoableEdit.prototype.isSignificant = function() {
  return this.significant;
};
/**
 * @param {!Object} path
 * @return {undefined}
 */
mxUndoableEdit.prototype.add = function(path) {
  this.changes.push(path);
};
/**
 * @return {undefined}
 */
mxUndoableEdit.prototype.notify = function() {
};
/**
 * @return {undefined}
 */
mxUndoableEdit.prototype.die = function() {
};
/**
 * @return {undefined}
 */
mxUndoableEdit.prototype.undo = function() {
  if (!this.undone) {
    this.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));
    /** @type {number} */
    var i = this.changes.length - 1;
    for (; 0 <= i; i--) {
      var change = this.changes[i];
      if (null != change.execute) {
        change.execute();
      } else {
        if (null != change.undo) {
          change.undo();
        }
      }
      this.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", change));
    }
    /** @type {boolean} */
    this.undone = true;
    /** @type {boolean} */
    this.redone = false;
    this.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));
  }
  this.notify();
};
/**
 * @return {undefined}
 */
mxUndoableEdit.prototype.redo = function() {
  if (!this.redone) {
    this.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));
    var length = this.changes.length;
    /** @type {number} */
    var i = 0;
    for (; i < length; i++) {
      var change = this.changes[i];
      if (null != change.execute) {
        change.execute();
      } else {
        if (null != change.redo) {
          change.redo();
        }
      }
      this.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", change));
    }
    /** @type {boolean} */
    this.undone = false;
    /** @type {boolean} */
    this.redone = true;
    this.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));
  }
  this.notify();
};
/**
 * @param {number} size
 * @return {undefined}
 */
function mxUndoManager(size) {
  this.size = null != size ? size : 100;
  this.clear();
}
mxUndoManager.prototype = new mxEventSource;
/** @type {function(number): undefined} */
mxUndoManager.prototype.constructor = mxUndoManager;
/** @type {null} */
mxUndoManager.prototype.size = null;
/** @type {null} */
mxUndoManager.prototype.history = null;
/** @type {number} */
mxUndoManager.prototype.indexOfNextAdd = 0;
/**
 * @return {?}
 */
mxUndoManager.prototype.isEmpty = function() {
  return 0 == this.history.length;
};
/**
 * @return {undefined}
 */
mxUndoManager.prototype.clear = function() {
  /** @type {!Array} */
  this.history = [];
  /** @type {number} */
  this.indexOfNextAdd = 0;
  this.fireEvent(new mxEventObject(mxEvent.CLEAR));
};
/**
 * @return {?}
 */
mxUndoManager.prototype.canUndo = function() {
  return 0 < this.indexOfNextAdd;
};
/**
 * @return {undefined}
 */
mxUndoManager.prototype.undo = function() {
  for (; 0 < this.indexOfNextAdd;) {
    var history = this.history[--this.indexOfNextAdd];
    history.undo();
    if (history.isSignificant()) {
      this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", history));
      break;
    }
  }
};
/**
 * @return {?}
 */
mxUndoManager.prototype.canRedo = function() {
  return this.indexOfNextAdd < this.history.length;
};
/**
 * @return {undefined}
 */
mxUndoManager.prototype.redo = function() {
  var l = this.history.length;
  for (; this.indexOfNextAdd < l;) {
    var history = this.history[this.indexOfNextAdd++];
    history.redo();
    if (history.isSignificant()) {
      this.fireEvent(new mxEventObject(mxEvent.REDO, "edit", history));
      break;
    }
  }
};
/**
 * @param {!Function} edit
 * @return {undefined}
 */
mxUndoManager.prototype.undoableEditHappened = function(edit) {
  this.trim();
  if (0 < this.size && this.size == this.history.length) {
    this.history.shift();
  }
  this.history.push(edit);
  this.indexOfNextAdd = this.history.length;
  this.fireEvent(new mxEventObject(mxEvent.ADD, "edit", edit));
};
/**
 * @return {undefined}
 */
mxUndoManager.prototype.trim = function() {
  if (this.history.length > this.indexOfNextAdd) {
    var views_to_remove = this.history.splice(this.indexOfNextAdd, this.history.length - this.indexOfNextAdd);
    /** @type {number} */
    var i = 0;
    for (; i < views_to_remove.length; i++) {
      views_to_remove[i].die();
    }
  }
};
/**
 * @return {undefined}
 */
var mxUrlConverter = function() {
};
/** @type {boolean} */
mxUrlConverter.prototype.enabled = true;
/** @type {null} */
mxUrlConverter.prototype.baseUrl = null;
/** @type {null} */
mxUrlConverter.prototype.baseDomain = null;
/**
 * @return {undefined}
 */
mxUrlConverter.prototype.updateBaseUrl = function() {
  /** @type {string} */
  this.baseDomain = location.protocol + "//" + location.host;
  /** @type {string} */
  this.baseUrl = this.baseDomain + location.pathname;
  /** @type {number} */
  var folderPathIndex = this.baseUrl.lastIndexOf("/");
  if (0 < folderPathIndex) {
    /** @type {string} */
    this.baseUrl = this.baseUrl.substring(0, folderPathIndex + 1);
  }
};
/**
 * @return {?}
 */
mxUrlConverter.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxUrlConverter.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxUrlConverter.prototype.getBaseUrl = function() {
  return this.baseUrl;
};
/**
 * @param {string} url
 * @return {undefined}
 */
mxUrlConverter.prototype.setBaseUrl = function(url) {
  /** @type {string} */
  this.baseUrl = url;
};
/**
 * @return {?}
 */
mxUrlConverter.prototype.getBaseDomain = function() {
  return this.baseDomain;
};
/**
 * @param {string} a
 * @return {undefined}
 */
mxUrlConverter.prototype.setBaseDomain = function(a) {
  /** @type {string} */
  this.baseDomain = a;
};
/**
 * @param {string} url
 * @return {?}
 */
mxUrlConverter.prototype.isRelativeUrl = function(url) {
  return null != url && "//" != url.substring(0, 2) && "http://" != url.substring(0, 7) && "https://" != url.substring(0, 8) && "data:image" != url.substring(0, 10) && "file://" != url.substring(0, 7);
};
/**
 * @param {string} s
 * @return {?}
 */
mxUrlConverter.prototype.convert = function(s) {
  if (this.isEnabled() && this.isRelativeUrl(s)) {
    if (null == this.getBaseUrl()) {
      this.updateBaseUrl();
    }
    s = "/" == s.charAt(0) ? this.getBaseDomain() + s : this.getBaseUrl() + s;
  }
  return s;
};
/**
 * @param {!Object} self
 * @return {undefined}
 */
function mxPanningManager(self) {
  /** @type {null} */
  this.thread = null;
  /** @type {boolean} */
  this.active = false;
  /** @type {number} */
  this.dy = this.dx = this.t0y = this.t0x = this.tdy = this.tdx = 0;
  /** @type {boolean} */
  this.scrollbars = false;
  /** @type {number} */
  this.scrollTop = this.scrollLeft = 0;
  this.mouseListener = {
    mouseDown : function(item, event) {
    },
    mouseMove : function(new_yaw, new_pitch) {
    },
    mouseUp : mxUtils.bind(this, function(canCreateDiscussions, isSlidingUp) {
      if (this.active) {
        this.stop();
      }
    })
  };
  self.addMouseListener(this.mouseListener);
  this.mouseUpListener = mxUtils.bind(this, function() {
    if (this.active) {
      this.stop();
    }
  });
  mxEvent.addListener(document, "mouseup", this.mouseUpListener);
  var animate = mxUtils.bind(this, function() {
    this.scrollbars = mxUtils.hasScrollbars(self.container);
    this.scrollLeft = self.container.scrollLeft;
    this.scrollTop = self.container.scrollTop;
    return window.setInterval(mxUtils.bind(this, function() {
      this.tdx -= this.dx;
      this.tdy -= this.dy;
      if (this.scrollbars) {
        self.panGraph(-self.container.scrollLeft - Math.ceil(this.dx), -self.container.scrollTop - Math.ceil(this.dy));
        /** @type {number} */
        self.panDx = this.scrollLeft - self.container.scrollLeft;
        /** @type {number} */
        self.panDy = this.scrollTop - self.container.scrollTop;
        self.fireEvent(new mxEventObject(mxEvent.PAN));
      } else {
        self.panGraph(this.getDx(), this.getDy());
      }
    }), this.delay);
  });
  /**
   * @return {?}
   */
  this.isActive = function() {
    return active;
  };
  /**
   * @return {?}
   */
  this.getDx = function() {
    return Math.round(this.tdx);
  };
  /**
   * @return {?}
   */
  this.getDy = function() {
    return Math.round(this.tdy);
  };
  /**
   * @return {undefined}
   */
  this.start = function() {
    this.t0x = self.view.translate.x;
    this.t0y = self.view.translate.y;
    /** @type {boolean} */
    this.active = true;
  };
  /**
   * @param {number} x
   * @param {number} y
   * @param {number} count
   * @param {number} width
   * @return {undefined}
   */
  this.panTo = function(x, y, count, width) {
    if (!this.active) {
      this.start();
    }
    this.scrollLeft = self.container.scrollLeft;
    this.scrollTop = self.container.scrollTop;
    var box = self.container;
    /** @type {number} */
    this.dx = x + (null != count ? count : 0) - box.scrollLeft - box.clientWidth;
    this.dx = 0 > this.dx && Math.abs(this.dx) < this.border ? this.border + this.dx : this.handleMouseOut ? Math.max(this.dx, 0) : 0;
    if (0 == this.dx) {
      /** @type {number} */
      this.dx = x - box.scrollLeft;
      /** @type {number} */
      this.dx = 0 < this.dx && this.dx < this.border ? this.dx - this.border : this.handleMouseOut ? Math.min(0, this.dx) : 0;
    }
    /** @type {number} */
    this.dy = y + (null != width ? width : 0) - box.scrollTop - box.clientHeight;
    this.dy = 0 > this.dy && Math.abs(this.dy) < this.border ? this.border + this.dy : this.handleMouseOut ? Math.max(this.dy, 0) : 0;
    if (0 == this.dy) {
      /** @type {number} */
      this.dy = y - box.scrollTop;
      /** @type {number} */
      this.dy = 0 < this.dy && this.dy < this.border ? this.dy - this.border : this.handleMouseOut ? Math.min(0, this.dy) : 0;
    }
    if (0 != this.dx || 0 != this.dy) {
      this.dx *= this.damper;
      this.dy *= this.damper;
      if (null == this.thread) {
        this.thread = animate();
      }
    } else {
      if (null != this.thread) {
        window.clearInterval(this.thread);
        /** @type {null} */
        this.thread = null;
      }
    }
  };
  /**
   * @return {undefined}
   */
  this.stop = function() {
    if (this.active) {
      if (this.active = false, null != this.thread && (window.clearInterval(this.thread), this.thread = null), this.tdy = this.tdx = 0, this.scrollbars) {
        /** @type {number} */
        self.panDx = 0;
        /** @type {number} */
        self.panDy = 0;
        self.fireEvent(new mxEventObject(mxEvent.PAN));
      } else {
        var scale = self.panDx;
        var em = self.panDy;
        if (0 != scale || 0 != em) {
          self.panGraph(0, 0);
          self.view.setTranslate(this.t0x + scale / self.view.scale, this.t0y + em / self.view.scale);
        }
      }
    }
  };
  /**
   * @return {undefined}
   */
  this.destroy = function() {
    self.removeMouseListener(this.mouseListener);
    mxEvent.removeListener(document, "mouseup", this.mouseUpListener);
  };
}
/** @type {number} */
mxPanningManager.prototype.damper = 1 / 6;
/** @type {number} */
mxPanningManager.prototype.delay = 10;
/** @type {boolean} */
mxPanningManager.prototype.handleMouseOut = true;
/** @type {number} */
mxPanningManager.prototype.border = 0;
/**
 * @param {?} a
 * @return {undefined}
 */
function mxPopupMenu(a) {
  this.factoryMethod = a;
  if (null != a) {
    this.init();
  }
}
mxPopupMenu.prototype = new mxEventSource;
/** @type {function(?): undefined} */
mxPopupMenu.prototype.constructor = mxPopupMenu;
/** @type {string} */
mxPopupMenu.prototype.submenuImage = mxClient.imageBasePath + "/submenu.gif";
/** @type {number} */
mxPopupMenu.prototype.zIndex = 10006;
/** @type {null} */
mxPopupMenu.prototype.factoryMethod = null;
/** @type {boolean} */
mxPopupMenu.prototype.useLeftButtonForPopup = false;
/** @type {boolean} */
mxPopupMenu.prototype.enabled = true;
/** @type {number} */
mxPopupMenu.prototype.itemCount = 0;
/** @type {boolean} */
mxPopupMenu.prototype.autoExpand = false;
/** @type {boolean} */
mxPopupMenu.prototype.smartSeparators = false;
/** @type {boolean} */
mxPopupMenu.prototype.labels = true;
/**
 * @return {undefined}
 */
mxPopupMenu.prototype.init = function() {
  /** @type {!Element} */
  this.table = document.createElement("table");
  /** @type {string} */
  this.table.className = "mxPopupMenu";
  /** @type {!Element} */
  this.tbody = document.createElement("tbody");
  this.table.appendChild(this.tbody);
  /** @type {!Element} */
  this.div = document.createElement("div");
  /** @type {string} */
  this.div.className = "mxPopupMenu";
  /** @type {string} */
  this.div.style.display = "inline";
  this.div.style.zIndex = this.zIndex;
  this.div.appendChild(this.table);
  mxEvent.disableContextMenu(this.div);
};
/**
 * @return {?}
 */
mxPopupMenu.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxPopupMenu.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @param {!Event} child
 * @return {?}
 */
mxPopupMenu.prototype.isPopupTrigger = function(child) {
  return child.isPopupTrigger() || this.useLeftButtonForPopup && mxEvent.isLeftMouseButton(child.getEvent());
};
/**
 * @param {!Element} e
 * @param {!Object} b
 * @param {!Object} func
 * @param {!Object} obj
 * @param {string} c
 * @param {string} error
 * @param {number} description
 * @param {?} isVegetarian
 * @return {?}
 */
mxPopupMenu.prototype.addItem = function(e, b, func, obj, c, error, description, isVegetarian) {
  obj = obj || this;
  this.itemCount++;
  if (obj.willAddSeparator) {
    if (obj.containsItems) {
      this.addSeparator(obj, true);
    }
    /** @type {boolean} */
    obj.willAddSeparator = false;
  }
  /** @type {boolean} */
  obj.containsItems = true;
  /** @type {!Element} */
  var result = document.createElement("tr");
  /** @type {string} */
  result.className = "mxPopupMenuItem";
  /** @type {!Element} */
  var node = document.createElement("td");
  /** @type {string} */
  node.className = "mxPopupMenuIcon";
  if (null != b) {
    /** @type {!Element} */
    c = document.createElement("img");
    /** @type {!Object} */
    c.src = b;
    node.appendChild(c);
  } else {
    if (null != c) {
      /** @type {!Element} */
      b = document.createElement("div");
      /** @type {string} */
      b.className = c;
      node.appendChild(b);
    }
  }
  result.appendChild(node);
  if (this.labels) {
    /** @type {!Element} */
    node = document.createElement("td");
    /** @type {string} */
    node.className = "mxPopupMenuItem" + (null == error || error ? "" : " mxDisabled");
    mxUtils.write(node, e);
    /** @type {string} */
    node.align = "left";
    result.appendChild(node);
    /** @type {!Element} */
    e = document.createElement("td");
    /** @type {string} */
    e.className = "mxPopupMenuItem" + (null == error || error ? "" : " mxDisabled");
    /** @type {string} */
    e.style.paddingRight = "6px";
    /** @type {string} */
    e.style.textAlign = "right";
    result.appendChild(e);
    if (null == obj.div) {
      this.createSubmenu(obj);
    }
  }
  obj.tbody.appendChild(result);
  if (0 != description && 0 != error) {
    /** @type {null} */
    var logoRef = null;
    mxEvent.addGestureListeners(result, mxUtils.bind(this, function(e) {
      /** @type {!Element} */
      this.eventReceiver = result;
      if (obj.activeRow != result && obj.activeRow != obj) {
        if (null != obj.activeRow && null != obj.activeRow.div.parentNode) {
          this.hideSubmenu(obj);
        }
        if (null != result.div) {
          this.showSubmenu(obj, result);
          /** @type {!Element} */
          obj.activeRow = result;
        }
      }
      if (null != document.selection && 8 == document.documentMode) {
        /** @type {(ControlRange|TextRange|null)} */
        logoRef = document.selection.createRange();
      }
      mxEvent.consume(e);
    }), mxUtils.bind(this, function(p) {
      if (obj.activeRow != result && obj.activeRow != obj) {
        if (null != obj.activeRow && null != obj.activeRow.div.parentNode) {
          this.hideSubmenu(obj);
        }
        if (this.autoExpand && null != result.div) {
          this.showSubmenu(obj, result);
          /** @type {!Element} */
          obj.activeRow = result;
        }
      }
      if (!isVegetarian) {
        /** @type {string} */
        result.className = "mxPopupMenuItemHover";
      }
    }), mxUtils.bind(this, function(evt) {
      if (this.eventReceiver == result) {
        if (obj.activeRow != result) {
          this.hideMenu();
        }
        if (null != logoRef) {
          try {
            logoRef.select();
          } catch (q) {
          }
          /** @type {null} */
          logoRef = null;
        }
        if (null != func) {
          func(evt);
        }
      }
      /** @type {null} */
      this.eventReceiver = null;
      mxEvent.consume(evt);
    }));
    if (!isVegetarian) {
      mxEvent.addListener(result, "mouseout", mxUtils.bind(this, function(p) {
        /** @type {string} */
        result.className = "mxPopupMenuItem";
      }));
    }
  }
  return result;
};
/**
 * @param {!Object} item
 * @param {string} changeMeta
 * @return {undefined}
 */
mxPopupMenu.prototype.addCheckmark = function(item, changeMeta) {
  item = item.firstChild.nextSibling;
  /** @type {string} */
  item.style.backgroundImage = "url('" + changeMeta + "')";
  /** @type {string} */
  item.style.backgroundRepeat = "no-repeat";
  /** @type {string} */
  item.style.backgroundPosition = "2px 50%";
};
/**
 * @param {!Object} self
 * @return {undefined}
 */
mxPopupMenu.prototype.createSubmenu = function(self) {
  /** @type {!Element} */
  self.table = document.createElement("table");
  /** @type {string} */
  self.table.className = "mxPopupMenu";
  /** @type {!Element} */
  self.tbody = document.createElement("tbody");
  self.table.appendChild(self.tbody);
  /** @type {!Element} */
  self.div = document.createElement("div");
  /** @type {string} */
  self.div.className = "mxPopupMenu";
  /** @type {string} */
  self.div.style.position = "absolute";
  /** @type {string} */
  self.div.style.display = "inline";
  self.div.style.zIndex = this.zIndex;
  self.div.appendChild(self.table);
  /** @type {!Element} */
  var b = document.createElement("img");
  b.setAttribute("src", this.submenuImage);
  td = self.firstChild.nextSibling.nextSibling;
  td.appendChild(b);
};
/**
 * @param {!Object} a
 * @param {!Object} obj
 * @return {undefined}
 */
mxPopupMenu.prototype.showSubmenu = function(a, obj) {
  if (null != obj.div) {
    /** @type {string} */
    obj.div.style.left = a.div.offsetLeft + obj.offsetLeft + obj.offsetWidth - 1 + "px";
    /** @type {string} */
    obj.div.style.top = a.div.offsetTop + obj.offsetTop + "px";
    document.body.appendChild(obj.div);
    /** @type {number} */
    var index = parseInt(obj.div.offsetLeft);
    /** @type {number} */
    var centerOffset = parseInt(obj.div.offsetWidth);
    var doc = mxUtils.getDocumentScrollOrigin(document);
    /** @type {!Element} */
    var docElem = document.documentElement;
    if (index + centerOffset > doc.x + (document.body.clientWidth || docElem.clientWidth)) {
      /** @type {string} */
      obj.div.style.left = Math.max(0, a.div.offsetLeft - centerOffset + (mxClient.IS_IE ? 6 : -6)) + "px";
    }
    /** @type {string} */
    obj.div.style.overflowY = "auto";
    /** @type {string} */
    obj.div.style.overflowX = "hidden";
    /** @type {string} */
    obj.div.style.maxHeight = Math.max(document.body.clientHeight, document.documentElement.clientHeight) - 10 + "px";
    mxUtils.fit(obj.div);
  }
};
/**
 * @param {!Object} dom
 * @param {!Object} options
 * @return {undefined}
 */
mxPopupMenu.prototype.addSeparator = function(dom, options) {
  dom = dom || this;
  if (this.smartSeparators && !options) {
    /** @type {boolean} */
    dom.willAddSeparator = true;
  } else {
    if (null != dom.tbody) {
      /** @type {boolean} */
      dom.willAddSeparator = false;
      /** @type {!Element} */
      options = document.createElement("tr");
      /** @type {!Element} */
      var cell = document.createElement("td");
      /** @type {string} */
      cell.className = "mxPopupMenuIcon";
      /** @type {string} */
      cell.style.padding = "0 0 0 0px";
      options.appendChild(cell);
      /** @type {!Element} */
      cell = document.createElement("td");
      /** @type {string} */
      cell.style.padding = "0 0 0 0px";
      cell.setAttribute("colSpan", "2");
      /** @type {!Element} */
      var node = document.createElement("hr");
      node.setAttribute("size", "1");
      cell.appendChild(node);
      options.appendChild(cell);
      dom.tbody.appendChild(options);
    }
  }
};
/**
 * @param {number} width
 * @param {number} height
 * @param {!Object} position
 * @param {?} elem
 * @return {undefined}
 */
mxPopupMenu.prototype.popup = function(width, height, position, elem) {
  if (null != this.div && null != this.tbody && null != this.factoryMethod) {
    /** @type {string} */
    this.div.style.left = width + "px";
    /** @type {string} */
    this.div.style.top = height + "px";
    for (; null != this.tbody.firstChild;) {
      mxEvent.release(this.tbody.firstChild);
      this.tbody.removeChild(this.tbody.firstChild);
    }
    /** @type {number} */
    this.itemCount = 0;
    this.factoryMethod(this, position, elem);
    if (0 < this.itemCount) {
      this.showMenu();
      this.fireEvent(new mxEventObject(mxEvent.SHOW));
    }
  }
};
/**
 * @return {?}
 */
mxPopupMenu.prototype.isMenuShowing = function() {
  return null != this.div && this.div.parentNode == document.body;
};
/**
 * @return {undefined}
 */
mxPopupMenu.prototype.showMenu = function() {
  if (9 <= document.documentMode) {
    /** @type {string} */
    this.div.style.filter = "none";
  }
  document.body.appendChild(this.div);
  mxUtils.fit(this.div);
};
/**
 * @return {undefined}
 */
mxPopupMenu.prototype.hideMenu = function() {
  if (null != this.div) {
    if (null != this.div.parentNode) {
      this.div.parentNode.removeChild(this.div);
    }
    this.hideSubmenu(this);
    /** @type {boolean} */
    this.containsItems = false;
    this.fireEvent(new mxEventObject(mxEvent.HIDE));
  }
};
/**
 * @param {!Object} $scope
 * @return {undefined}
 */
mxPopupMenu.prototype.hideSubmenu = function($scope) {
  if (null != $scope.activeRow) {
    this.hideSubmenu($scope.activeRow);
    if (null != $scope.activeRow.div.parentNode) {
      $scope.activeRow.div.parentNode.removeChild($scope.activeRow.div);
    }
    /** @type {null} */
    $scope.activeRow = null;
  }
};
/**
 * @return {undefined}
 */
mxPopupMenu.prototype.destroy = function() {
  if (null != this.div) {
    mxEvent.release(this.div);
    if (null != this.div.parentNode) {
      this.div.parentNode.removeChild(this.div);
    }
    /** @type {null} */
    this.div = null;
  }
};
/**
 * @param {!Object} vScale
 * @return {undefined}
 */
function mxAutoSaveManager(vScale) {
  this.changeHandler = mxUtils.bind(this, function(b, link) {
    if (this.isEnabled()) {
      this.graphModelChanged(link.getProperty("edit").changes);
    }
  });
  this.setGraph(vScale);
}
mxAutoSaveManager.prototype = new mxEventSource;
/** @type {function(!Object): undefined} */
mxAutoSaveManager.prototype.constructor = mxAutoSaveManager;
/** @type {null} */
mxAutoSaveManager.prototype.graph = null;
/** @type {number} */
mxAutoSaveManager.prototype.autoSaveDelay = 10;
/** @type {number} */
mxAutoSaveManager.prototype.autoSaveThrottle = 2;
/** @type {number} */
mxAutoSaveManager.prototype.autoSaveThreshold = 5;
/** @type {number} */
mxAutoSaveManager.prototype.ignoredChanges = 0;
/** @type {number} */
mxAutoSaveManager.prototype.lastSnapshot = 0;
/** @type {boolean} */
mxAutoSaveManager.prototype.enabled = true;
/** @type {null} */
mxAutoSaveManager.prototype.changeHandler = null;
/**
 * @return {?}
 */
mxAutoSaveManager.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {boolean} state
 * @return {undefined}
 */
mxAutoSaveManager.prototype.setEnabled = function(state) {
  /** @type {boolean} */
  this.enabled = state;
};
/**
 * @param {!Object} gf
 * @return {undefined}
 */
mxAutoSaveManager.prototype.setGraph = function(gf) {
  if (null != this.graph) {
    this.graph.getModel().removeListener(this.changeHandler);
  }
  /** @type {!Object} */
  this.graph = gf;
  if (null != this.graph) {
    this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
  }
};
/**
 * @return {undefined}
 */
mxAutoSaveManager.prototype.save = function() {
};
/**
 * @param {number} a
 * @return {undefined}
 */
mxAutoSaveManager.prototype.graphModelChanged = function(a) {
  /** @type {number} */
  a = ((new Date).getTime() - this.lastSnapshot) / 1E3;
  if (a > this.autoSaveDelay || this.ignoredChanges >= this.autoSaveThreshold && a > this.autoSaveThrottle) {
    this.save();
    this.reset();
  } else {
    this.ignoredChanges++;
  }
};
/**
 * @return {undefined}
 */
mxAutoSaveManager.prototype.reset = function() {
  /** @type {number} */
  this.lastSnapshot = (new Date).getTime();
  /** @type {number} */
  this.ignoredChanges = 0;
};
/**
 * @return {undefined}
 */
mxAutoSaveManager.prototype.destroy = function() {
  this.setGraph(null);
};
/**
 * @param {number} delay
 * @return {undefined}
 */
function mxAnimation(delay) {
  this.delay = null != delay ? delay : 20;
}
mxAnimation.prototype = new mxEventSource;
/** @type {function(number): undefined} */
mxAnimation.prototype.constructor = mxAnimation;
/** @type {null} */
mxAnimation.prototype.delay = null;
/** @type {null} */
mxAnimation.prototype.thread = null;
/**
 * @return {?}
 */
mxAnimation.prototype.isRunning = function() {
  return null != this.thread;
};
/**
 * @return {undefined}
 */
mxAnimation.prototype.startAnimation = function() {
  if (null == this.thread) {
    this.thread = window.setInterval(mxUtils.bind(this, this.updateAnimation), this.delay);
  }
};
/**
 * @return {undefined}
 */
mxAnimation.prototype.updateAnimation = function() {
  this.fireEvent(new mxEventObject(mxEvent.EXECUTE));
};
/**
 * @return {undefined}
 */
mxAnimation.prototype.stopAnimation = function() {
  if (null != this.thread) {
    window.clearInterval(this.thread);
    /** @type {null} */
    this.thread = null;
    this.fireEvent(new mxEventObject(mxEvent.DONE));
  }
};
/**
 * @param {!Object} src
 * @param {number} name
 * @param {string} max
 * @param {?} excludes
 * @return {undefined}
 */
function mxMorphing(src, name, max, excludes) {
  mxAnimation.call(this, excludes);
  /** @type {!Object} */
  this.graph = src;
  this.steps = null != name ? name : 6;
  this.ease = null != max ? max : 1.5;
}
mxMorphing.prototype = new mxAnimation;
/** @type {function(!Object, number, string, ?): undefined} */
mxMorphing.prototype.constructor = mxMorphing;
/** @type {null} */
mxMorphing.prototype.graph = null;
/** @type {null} */
mxMorphing.prototype.steps = null;
/** @type {number} */
mxMorphing.prototype.step = 0;
/** @type {null} */
mxMorphing.prototype.ease = null;
/** @type {null} */
mxMorphing.prototype.cells = null;
/**
 * @return {undefined}
 */
mxMorphing.prototype.updateAnimation = function() {
  mxAnimation.prototype.updateAnimation.apply(this, arguments);
  var a = new mxCellStatePreview(this.graph);
  if (null != this.cells) {
    /** @type {number} */
    var i = 0;
    for (; i < this.cells.length; i++) {
      this.animateCell(this.cells[i], a, false);
    }
  } else {
    this.animateCell(this.graph.getModel().getRoot(), a, true);
  }
  this.show(a);
  if (a.isEmpty() || this.step++ >= this.steps) {
    this.stopAnimation();
  }
};
/**
 * @param {!Object} result
 * @return {undefined}
 */
mxMorphing.prototype.show = function(result) {
  result.show();
};
/**
 * @param {undefined} cell
 * @param {?} pos
 * @param {boolean} removeCount
 * @return {undefined}
 */
mxMorphing.prototype.animateCell = function(cell, pos, removeCount) {
  var index = this.graph.getView().getState(cell);
  /** @type {null} */
  var i = null;
  if (null != index && (i = this.getDelta(index), this.graph.getModel().isVertex(cell) && (0 != i.x || 0 != i.y))) {
    var signalCoords = this.graph.view.getTranslate();
    var factor = this.graph.view.getScale();
    i.x += signalCoords.x * factor;
    i.y += signalCoords.y * factor;
    pos.moveState(index, -i.x / this.ease, -i.y / this.ease);
  }
  if (removeCount && !this.stopRecursion(index, i)) {
    index = this.graph.getModel().getChildCount(cell);
    /** @type {number} */
    i = 0;
    for (; i < index; i++) {
      this.animateCell(this.graph.getModel().getChildAt(cell, i), pos, removeCount);
    }
  }
};
/**
 * @param {?} m
 * @param {!Object} b
 * @return {?}
 */
mxMorphing.prototype.stopRecursion = function(m, b) {
  return null != b && (0 != b.x || 0 != b.y);
};
/**
 * @param {!Object} o
 * @return {?}
 */
mxMorphing.prototype.getDelta = function(o) {
  var b = this.getOriginForCell(o.cell);
  var geo = this.graph.getView().getTranslate();
  var scale = this.graph.getView().getScale();
  return new mxPoint((b.x - (o.x / scale - geo.x)) * scale, (b.y - (o.y / scale - geo.y)) * scale);
};
/**
 * @param {!Object} target
 * @return {?}
 */
mxMorphing.prototype.getOriginForCell = function(target) {
  /** @type {null} */
  var start = null;
  if (null != target) {
    var element = this.graph.getModel().getParent(target);
    target = this.graph.getCellGeometry(target);
    start = this.getOriginForCell(element);
    if (null != target) {
      if (target.relative) {
        element = this.graph.getCellGeometry(element);
        if (null != element) {
          start.x += target.x * element.width;
          start.y += target.y * element.height;
        }
      } else {
        start.x += target.x;
        start.y += target.y;
      }
    }
  }
  if (null == start) {
    start = this.graph.view.getTranslate();
    start = new mxPoint(-start.x, -start.y);
  }
  return start;
};
/**
 * @param {string} a
 * @return {undefined}
 */
function mxImageBundle(a) {
  /** @type {!Array} */
  this.images = [];
  this.alt = null != a ? a : false;
}
/** @type {null} */
mxImageBundle.prototype.images = null;
/** @type {null} */
mxImageBundle.prototype.alt = null;
/**
 * @param {?} key
 * @param {!Object} img
 * @param {(HTMLCanvasElement|HTMLImageElement|string)} data
 * @return {undefined}
 */
mxImageBundle.prototype.putImage = function(key, img, data) {
  this.images[key] = {
    value : img,
    fallback : data
  };
};
/**
 * @param {!Object} image
 * @return {?}
 */
mxImageBundle.prototype.getImage = function(image) {
  /** @type {null} */
  var template = null;
  if (null != image) {
    image = this.images[image];
    if (null != image) {
      template = this.alt ? image.fallback : image.value;
    }
  }
  return template;
};
/**
 * @return {undefined}
 */
function mxImageExport() {
}
/** @type {boolean} */
mxImageExport.prototype.includeOverlays = false;
/**
 * @param {!Object} context
 * @param {?} client
 * @return {undefined}
 */
mxImageExport.prototype.drawState = function(context, client) {
  if (null != context) {
    this.visitStatesRecursive(context, client, mxUtils.bind(this, function() {
      this.drawCellState.apply(this, arguments);
    }));
    if (this.includeOverlays) {
      this.visitStatesRecursive(context, client, mxUtils.bind(this, function() {
        this.drawOverlays.apply(this, arguments);
      }));
    }
  }
};
/**
 * @param {!Object} e
 * @param {?} t
 * @param {?} c
 * @return {undefined}
 */
mxImageExport.prototype.visitStatesRecursive = function(e, t, c) {
  if (null != e) {
    c(e, t);
    var self = e.view.graph;
    var cell_amount = self.model.getChildCount(e.cell);
    /** @type {number} */
    var i = 0;
    for (; i < cell_amount; i++) {
      var uboard = self.view.getState(self.model.getChildAt(e.cell, i));
      this.visitStatesRecursive(uboard, t, c);
    }
  }
};
/**
 * @param {!Object} _
 * @param {!Object} a
 * @return {?}
 */
mxImageExport.prototype.getLinkForCellState = function(_, a) {
  return null;
};
/**
 * @param {!Object} providers
 * @param {!Object} providerType
 * @return {?}
 */
mxImageExport.prototype.getLinkTargetForCellState = function(providers, providerType) {
  return null;
};
/**
 * @param {!Object} b
 * @param {!Object} context
 * @return {undefined}
 */
mxImageExport.prototype.drawCellState = function(b, context) {
  var link = this.getLinkForCellState(b, context);
  if (null != link) {
    context.setLink(link, this.getLinkTargetForCellState(b, context));
  }
  this.drawShape(b, context);
  this.drawText(b, context);
  if (null != link) {
    context.setLink(null);
  }
};
/**
 * @param {!Object} s
 * @param {!Object} ctx
 * @return {undefined}
 */
mxImageExport.prototype.drawShape = function(s, ctx) {
  if (s.shape instanceof mxShape) {
    this.doDrawShape(s.shape, ctx);
  }
};
/**
 * @param {!Object} b
 * @param {!Object} a
 * @return {undefined}
 */
mxImageExport.prototype.drawText = function(b, a) {
  this.doDrawShape(b.text, a);
};
/**
 * @param {!Object} shape
 * @param {!Object} context
 * @return {undefined}
 */
mxImageExport.prototype.doDrawShape = function(shape, context) {
  if (null != shape && shape.checkBounds()) {
    context.save();
    shape.beforePaint(context);
    shape.paint(context);
    shape.afterPaint(context);
    context.restore();
  }
};
/**
 * @param {!Object} params
 * @param {!Object} context
 * @return {undefined}
 */
mxImageExport.prototype.drawOverlays = function(params, context) {
  if (null != params.overlays) {
    params.overlays.visit(function(canCreateDiscussions, leftWin) {
      if (leftWin instanceof mxShape) {
        leftWin.paint(context);
      }
    });
  }
};
/**
 * @return {undefined}
 */
function mxAbstractCanvas2D() {
  this.converter = this.createUrlConverter();
  this.reset();
}
/** @type {null} */
mxAbstractCanvas2D.prototype.state = null;
/** @type {null} */
mxAbstractCanvas2D.prototype.states = null;
/** @type {null} */
mxAbstractCanvas2D.prototype.path = null;
/** @type {boolean} */
mxAbstractCanvas2D.prototype.rotateHtml = true;
/** @type {number} */
mxAbstractCanvas2D.prototype.lastX = 0;
/** @type {number} */
mxAbstractCanvas2D.prototype.lastY = 0;
/** @type {string} */
mxAbstractCanvas2D.prototype.moveOp = "M";
/** @type {string} */
mxAbstractCanvas2D.prototype.lineOp = "L";
/** @type {string} */
mxAbstractCanvas2D.prototype.quadOp = "Q";
/** @type {string} */
mxAbstractCanvas2D.prototype.curveOp = "C";
/** @type {string} */
mxAbstractCanvas2D.prototype.closeOp = "Z";
/** @type {boolean} */
mxAbstractCanvas2D.prototype.pointerEvents = false;
/**
 * @return {?}
 */
mxAbstractCanvas2D.prototype.createUrlConverter = function() {
  return new mxUrlConverter;
};
/**
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.reset = function() {
  this.state = this.createState();
  /** @type {!Array} */
  this.states = [];
};
/**
 * @return {?}
 */
mxAbstractCanvas2D.prototype.createState = function() {
  return {
    dx : 0,
    dy : 0,
    scale : 1,
    alpha : 1,
    fillAlpha : 1,
    strokeAlpha : 1,
    fillColor : null,
    gradientFillAlpha : 1,
    gradientColor : null,
    gradientAlpha : 1,
    gradientDirection : null,
    strokeColor : null,
    strokeWidth : 1,
    dashed : false,
    dashPattern : "3 3",
    fixDash : false,
    lineCap : "flat",
    lineJoin : "miter",
    miterLimit : 10,
    fontColor : "#000000",
    fontBackgroundColor : null,
    fontBorderColor : null,
    fontSize : mxConstants.DEFAULT_FONTSIZE,
    fontFamily : mxConstants.DEFAULT_FONTFAMILY,
    fontStyle : 0,
    shadow : false,
    shadowColor : mxConstants.SHADOWCOLOR,
    shadowAlpha : mxConstants.SHADOW_OPACITY,
    shadowDx : mxConstants.SHADOW_OFFSET_X,
    shadowDy : mxConstants.SHADOW_OFFSET_Y,
    rotation : 0,
    rotationCx : 0,
    rotationCy : 0
  };
};
/**
 * @param {number} str
 * @return {?}
 */
mxAbstractCanvas2D.prototype.format = function(str) {
  return Math.round(parseFloat(str));
};
/**
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.addOp = function() {
  if (null != this.path && (this.path.push(arguments[0]), 2 < arguments.length)) {
    var state = this.state;
    /** @type {number} */
    var i = 2;
    for (; i < arguments.length; i = i + 2) {
      this.lastX = arguments[i - 1];
      this.lastY = arguments[i];
      this.path.push(this.format((this.lastX + state.dx) * state.scale));
      this.path.push(this.format((this.lastY + state.dy) * state.scale));
    }
  }
};
/**
 * @param {number} x
 * @param {number} y
 * @param {number} alpha
 * @param {?} width
 * @param {boolean} height
 * @return {?}
 */
mxAbstractCanvas2D.prototype.rotatePoint = function(x, y, alpha, width, height) {
  /** @type {number} */
  alpha = alpha * (Math.PI / 180);
  return mxUtils.getRotatedPoint(new mxPoint(x, y), Math.cos(alpha), Math.sin(alpha), new mxPoint(width, height));
};
/**
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.save = function() {
  this.states.push(this.state);
  this.state = mxUtils.clone(this.state);
};
/**
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.restore = function() {
  if (0 < this.states.length) {
    this.state = this.states.pop();
  }
};
/**
 * @param {!Object} name
 * @param {?} value
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setLink = function(name, value) {
};
/**
 * @param {number} scale
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.scale = function(scale) {
  this.state.scale *= scale;
  this.state.strokeWidth *= scale;
};
/**
 * @param {number} c
 * @param {number} data
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.translate = function(c, data) {
  this.state.dx += c;
  this.state.dy += data;
};
/**
 * @param {number} a
 * @param {?} b
 * @param {?} status
 * @param {?} err
 * @param {?} _0
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.rotate = function(a, b, status, err, _0) {
};
/**
 * @param {number} val
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setAlpha = function(val) {
  /** @type {number} */
  this.state.alpha = val;
};
/**
 * @param {number} v
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFillAlpha = function(v) {
  /** @type {number} */
  this.state.fillAlpha = v;
};
/**
 * @param {number} name
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setStrokeAlpha = function(name) {
  /** @type {number} */
  this.state.strokeAlpha = name;
};
/**
 * @param {string} align
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFillColor = function(align) {
  if (align == mxConstants.NONE) {
    /** @type {null} */
    align = null;
  }
  /** @type {string} */
  this.state.fillColor = align;
  /** @type {null} */
  this.state.gradientColor = null;
};
/**
 * @param {string} color
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFillStyle = function(color) {
  if (color == mxConstants.NONE) {
    /** @type {null} */
    color = null;
  }
  /** @type {string} */
  this.state.fillStyle = color;
};
/**
 * @param {string} value
 * @param {string} color
 * @param {!Object} o
 * @param {number} element
 * @param {number} percent
 * @param {number} options
 * @param {string} d
 * @param {number} l
 * @param {number} a
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setGradient = function(value, color, o, element, percent, options, d, l, a) {
  o = this.state;
  /** @type {string} */
  o.fillColor = value;
  o.gradientFillAlpha = null != l ? l : 1;
  /** @type {string} */
  o.gradientColor = color;
  o.gradientAlpha = null != a ? a : 1;
  /** @type {string} */
  o.gradientDirection = d;
};
/**
 * @param {string} color
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setStrokeColor = function(color) {
  if (color == mxConstants.NONE) {
    /** @type {null} */
    color = null;
  }
  /** @type {string} */
  this.state.strokeColor = color;
};
/**
 * @param {number} width
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setStrokeWidth = function(width) {
  /** @type {number} */
  this.state.strokeWidth = width;
};
/**
 * @param {string} dashed
 * @param {boolean} dash
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setDashed = function(dashed, dash) {
  /** @type {string} */
  this.state.dashed = dashed;
  /** @type {boolean} */
  this.state.fixDash = dash;
};
/**
 * @param {!Object} str
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setDashPattern = function(str) {
  /** @type {!Object} */
  this.state.dashPattern = str;
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setLineCap = function(value) {
  /** @type {string} */
  this.state.lineCap = value;
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setLineJoin = function(value) {
  /** @type {string} */
  this.state.lineJoin = value;
};
/**
 * @param {number} limit
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setMiterLimit = function(limit) {
  /** @type {number} */
  this.state.miterLimit = limit;
};
/**
 * @param {string} color
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFontColor = function(color) {
  if (color == mxConstants.NONE) {
    /** @type {null} */
    color = null;
  }
  /** @type {string} */
  this.state.fontColor = color;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFontBackgroundColor = function(state) {
  if (state == mxConstants.NONE) {
    /** @type {null} */
    state = null;
  }
  /** @type {string} */
  this.state.fontBackgroundColor = state;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFontBorderColor = function(state) {
  if (state == mxConstants.NONE) {
    /** @type {null} */
    state = null;
  }
  /** @type {string} */
  this.state.fontBorderColor = state;
};
/**
 * @param {number} fontSize
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFontSize = function(fontSize) {
  /** @type {number} */
  this.state.fontSize = parseFloat(fontSize);
};
/**
 * @param {string} fontFamily
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFontFamily = function(fontFamily) {
  /** @type {string} */
  this.state.fontFamily = fontFamily;
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFontStyle = function(value) {
  if (null == value) {
    /** @type {number} */
    value = 0;
  }
  /** @type {string} */
  this.state.fontStyle = value;
};
/**
 * @param {boolean} value
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setShadow = function(value) {
  /** @type {boolean} */
  this.state.shadow = value;
};
/**
 * @param {string} color
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setShadowColor = function(color) {
  if (color == mxConstants.NONE) {
    /** @type {null} */
    color = null;
  }
  /** @type {string} */
  this.state.shadowColor = color;
};
/**
 * @param {?} name
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setShadowAlpha = function(name) {
  this.state.shadowAlpha = name;
};
/**
 * @param {?} tpl
 * @param {?} name
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setShadowOffset = function(tpl, name) {
  this.state.shadowDx = tpl;
  this.state.shadowDy = name;
};
/**
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.begin = function() {
  /** @type {number} */
  this.lastY = this.lastX = 0;
  /** @type {!Array} */
  this.path = [];
};
/**
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.moveTo = function(x, y) {
  this.addOp(this.moveOp, x, y);
};
/**
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.lineTo = function(x, y) {
  this.addOp(this.lineOp, x, y);
};
/**
 * @param {number} type
 * @param {number} num
 * @param {number} x
 * @param {number} key
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.quadTo = function(type, num, x, key) {
  this.addOp(this.quadOp, type, num, x, key);
};
/**
 * @param {number} e
 * @param {number} d
 * @param {number} a
 * @param {number} c
 * @param {number} f
 * @param {number} x
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.curveTo = function(e, d, a, c, f, x) {
  this.addOp(this.curveOp, e, d, a, c, f, x);
};
/**
 * @param {number} result
 * @param {number} x
 * @param {number} x1
 * @param {number} x2
 * @param {number} y
 * @param {undefined} r
 * @param {undefined} row
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.arcTo = function(result, x, x1, x2, y, r, row) {
  result = mxUtils.arcToCurves(this.lastX, this.lastY, result, x, x1, x2, y, r, row);
  if (null != result) {
    /** @type {number} */
    x = 0;
    for (; x < result.length; x = x + 6) {
      this.curveTo(result[x], result[x + 1], result[x + 2], result[x + 3], result[x + 4], result[x + 5]);
    }
  }
};
/**
 * @param {?} a
 * @param {?} f
 * @param {?} duration
 * @param {?} fast
 * @param {?} callback
 * @param {?} isClose
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.close = function(a, f, duration, fast, callback, isClose) {
  this.addOp(this.closeOp);
};
/**
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.end = function() {
};
/**
 * @param {string} p
 * @return {undefined}
 */
function mxXmlCanvas2D(p) {
  mxAbstractCanvas2D.call(this);
  /** @type {string} */
  this.root = p;
  this.writeDefaults();
}
mxUtils.extend(mxXmlCanvas2D, mxAbstractCanvas2D);
/** @type {boolean} */
mxXmlCanvas2D.prototype.textEnabled = true;
/** @type {boolean} */
mxXmlCanvas2D.prototype.compressed = true;
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.writeDefaults = function() {
  var node = this.createElement("fontfamily");
  node.setAttribute("family", mxConstants.DEFAULT_FONTFAMILY);
  this.root.appendChild(node);
  node = this.createElement("fontsize");
  node.setAttribute("size", mxConstants.DEFAULT_FONTSIZE);
  this.root.appendChild(node);
  node = this.createElement("shadowcolor");
  node.setAttribute("color", mxConstants.SHADOWCOLOR);
  this.root.appendChild(node);
  node = this.createElement("shadowalpha");
  node.setAttribute("alpha", mxConstants.SHADOW_OPACITY);
  this.root.appendChild(node);
  node = this.createElement("shadowoffset");
  node.setAttribute("dx", mxConstants.SHADOW_OFFSET_X);
  node.setAttribute("dy", mxConstants.SHADOW_OFFSET_Y);
  this.root.appendChild(node);
};
/**
 * @param {number} str
 * @return {?}
 */
mxXmlCanvas2D.prototype.format = function(str) {
  return parseFloat(parseFloat(str).toFixed(2));
};
/**
 * @param {string} name
 * @return {?}
 */
mxXmlCanvas2D.prototype.createElement = function(name) {
  return this.root.ownerDocument.createElement(name);
};
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.save = function() {
  if (this.compressed) {
    mxAbstractCanvas2D.prototype.save.apply(this, arguments);
  }
  this.root.appendChild(this.createElement("save"));
};
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.restore = function() {
  if (this.compressed) {
    mxAbstractCanvas2D.prototype.restore.apply(this, arguments);
  }
  this.root.appendChild(this.createElement("restore"));
};
/**
 * @param {number} val
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.scale = function(val) {
  var elem = this.createElement("scale");
  elem.setAttribute("scale", val);
  this.root.appendChild(elem);
};
/**
 * @param {number} val
 * @param {number} key
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.translate = function(val, key) {
  var el = this.createElement("translate");
  el.setAttribute("dx", this.format(val));
  el.setAttribute("dy", this.format(key));
  this.root.appendChild(el);
};
/**
 * @param {number} data
 * @param {boolean} state
 * @param {string} text
 * @param {undefined} i
 * @param {undefined} val
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.rotate = function(data, state, text, i, val) {
  var el = this.createElement("rotate");
  if (0 != data || state || text) {
    el.setAttribute("theta", this.format(data));
    el.setAttribute("flipH", state ? "1" : "0");
    el.setAttribute("flipV", text ? "1" : "0");
    el.setAttribute("cx", this.format(i));
    el.setAttribute("cy", this.format(val));
    this.root.appendChild(el);
  }
};
/**
 * @param {number} val
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setAlpha = function(val) {
  if (this.compressed) {
    if (this.state.alpha == val) {
      return;
    }
    mxAbstractCanvas2D.prototype.setAlpha.apply(this, arguments);
  }
  var el = this.createElement("alpha");
  el.setAttribute("alpha", this.format(val));
  this.root.appendChild(el);
};
/**
 * @param {number} val
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFillAlpha = function(val) {
  if (this.compressed) {
    if (this.state.fillAlpha == val) {
      return;
    }
    mxAbstractCanvas2D.prototype.setFillAlpha.apply(this, arguments);
  }
  var el = this.createElement("fillalpha");
  el.setAttribute("alpha", this.format(val));
  this.root.appendChild(el);
};
/**
 * @param {number} val
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setStrokeAlpha = function(val) {
  if (this.compressed) {
    if (this.state.strokeAlpha == val) {
      return;
    }
    mxAbstractCanvas2D.prototype.setStrokeAlpha.apply(this, arguments);
  }
  var el = this.createElement("strokealpha");
  el.setAttribute("alpha", this.format(val));
  this.root.appendChild(el);
};
/**
 * @param {string} align
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFillColor = function(align) {
  if (align == mxConstants.NONE) {
    /** @type {null} */
    align = null;
  }
  if (this.compressed) {
    if (this.state.fillColor == align) {
      return;
    }
    mxAbstractCanvas2D.prototype.setFillColor.apply(this, arguments);
  }
  var style = this.createElement("fillcolor");
  style.setAttribute("color", null != align ? align : mxConstants.NONE);
  this.root.appendChild(style);
};
/**
 * @param {!Object} node
 * @param {!Object} source
 * @param {number} data
 * @param {number} key
 * @param {number} val
 * @param {number} value
 * @param {!Object} name
 * @param {?} status
 * @param {?} percent
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setGradient = function(node, source, data, key, val, value, name, status, percent) {
  if (null != node && null != source) {
    mxAbstractCanvas2D.prototype.setGradient.apply(this, arguments);
    var el = this.createElement("gradient");
    el.setAttribute("c1", node);
    el.setAttribute("c2", source);
    el.setAttribute("x", this.format(data));
    el.setAttribute("y", this.format(key));
    el.setAttribute("w", this.format(val));
    el.setAttribute("h", this.format(value));
    if (null != name) {
      el.setAttribute("direction", name);
    }
    if (null != status) {
      el.setAttribute("alpha1", status);
    }
    if (null != percent) {
      el.setAttribute("alpha2", percent);
    }
    this.root.appendChild(el);
  }
};
/**
 * @param {string} name
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setStrokeColor = function(name) {
  if (name == mxConstants.NONE) {
    /** @type {null} */
    name = null;
  }
  if (this.compressed) {
    if (this.state.strokeColor == name) {
      return;
    }
    mxAbstractCanvas2D.prototype.setStrokeColor.apply(this, arguments);
  }
  var element = this.createElement("strokecolor");
  element.setAttribute("color", null != name ? name : mxConstants.NONE);
  this.root.appendChild(element);
};
/**
 * @param {number} value
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setStrokeWidth = function(value) {
  if (this.compressed) {
    if (this.state.strokeWidth == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setStrokeWidth.apply(this, arguments);
  }
  var el = this.createElement("strokewidth");
  el.setAttribute("width", this.format(value));
  this.root.appendChild(el);
};
/**
 * @param {string} state
 * @param {string} text
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setDashed = function(state, text) {
  if (this.compressed) {
    if (this.state.dashed == state) {
      return;
    }
    mxAbstractCanvas2D.prototype.setDashed.apply(this, arguments);
  }
  var el = this.createElement("dashed");
  el.setAttribute("dashed", state ? "1" : "0");
  if (null != text) {
    el.setAttribute("fixDash", text ? "1" : "0");
  }
  this.root.appendChild(el);
};
/**
 * @param {!Object} x
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setDashPattern = function(x) {
  if (this.compressed) {
    if (this.state.dashPattern == x) {
      return;
    }
    mxAbstractCanvas2D.prototype.setDashPattern.apply(this, arguments);
  }
  var elem = this.createElement("dashpattern");
  elem.setAttribute("pattern", x);
  this.root.appendChild(elem);
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setLineCap = function(value) {
  if (this.compressed) {
    if (this.state.lineCap == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setLineCap.apply(this, arguments);
  }
  var group = this.createElement("linecap");
  group.setAttribute("cap", value);
  this.root.appendChild(group);
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setLineJoin = function(value) {
  if (this.compressed) {
    if (this.state.lineJoin == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setLineJoin.apply(this, arguments);
  }
  var group = this.createElement("linejoin");
  group.setAttribute("join", value);
  this.root.appendChild(group);
};
/**
 * @param {number} id
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setMiterLimit = function(id) {
  if (this.compressed) {
    if (this.state.miterLimit == id) {
      return;
    }
    mxAbstractCanvas2D.prototype.setMiterLimit.apply(this, arguments);
  }
  var elem = this.createElement("miterlimit");
  elem.setAttribute("limit", id);
  this.root.appendChild(elem);
};
/**
 * @param {string} name
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFontColor = function(name) {
  if (this.textEnabled) {
    if (name == mxConstants.NONE) {
      /** @type {null} */
      name = null;
    }
    if (this.compressed) {
      if (this.state.fontColor == name) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontColor.apply(this, arguments);
    }
    var element = this.createElement("fontcolor");
    element.setAttribute("color", null != name ? name : mxConstants.NONE);
    this.root.appendChild(element);
  }
};
/**
 * @param {string} name
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFontBackgroundColor = function(name) {
  if (this.textEnabled) {
    if (name == mxConstants.NONE) {
      /** @type {null} */
      name = null;
    }
    if (this.compressed) {
      if (this.state.fontBackgroundColor == name) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontBackgroundColor.apply(this, arguments);
    }
    var element = this.createElement("fontbackgroundcolor");
    element.setAttribute("color", null != name ? name : mxConstants.NONE);
    this.root.appendChild(element);
  }
};
/**
 * @param {string} name
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFontBorderColor = function(name) {
  if (this.textEnabled) {
    if (name == mxConstants.NONE) {
      /** @type {null} */
      name = null;
    }
    if (this.compressed) {
      if (this.state.fontBorderColor == name) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontBorderColor.apply(this, arguments);
    }
    var element = this.createElement("fontbordercolor");
    element.setAttribute("color", null != name ? name : mxConstants.NONE);
    this.root.appendChild(element);
  }
};
/**
 * @param {?} value
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFontSize = function(value) {
  if (this.textEnabled) {
    if (this.compressed) {
      if (this.state.fontSize == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontSize.apply(this, arguments);
    }
    var style = this.createElement("fontsize");
    style.setAttribute("size", value);
    this.root.appendChild(style);
  }
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFontFamily = function(value) {
  if (this.textEnabled) {
    if (this.compressed) {
      if (this.state.fontFamily == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontFamily.apply(this, arguments);
    }
    var el = this.createElement("fontfamily");
    el.setAttribute("family", value);
    this.root.appendChild(el);
  }
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFontStyle = function(value) {
  if (this.textEnabled) {
    if (null == value) {
      /** @type {number} */
      value = 0;
    }
    if (this.compressed) {
      if (this.state.fontStyle == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontStyle.apply(this, arguments);
    }
    var elem = this.createElement("fontstyle");
    elem.setAttribute("style", value);
    this.root.appendChild(elem);
  }
};
/**
 * @param {string} x
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setShadow = function(x) {
  if (this.compressed) {
    if (this.state.shadow == x) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadow.apply(this, arguments);
  }
  var btn = this.createElement("shadow");
  btn.setAttribute("enabled", x ? "1" : "0");
  this.root.appendChild(btn);
};
/**
 * @param {string} name
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setShadowColor = function(name) {
  if (this.compressed) {
    if (name == mxConstants.NONE) {
      /** @type {null} */
      name = null;
    }
    if (this.state.shadowColor == name) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadowColor.apply(this, arguments);
  }
  var element = this.createElement("shadowcolor");
  element.setAttribute("color", null != name ? name : mxConstants.NONE);
  this.root.appendChild(element);
};
/**
 * @param {!Object} mode
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setShadowAlpha = function(mode) {
  if (this.compressed) {
    if (this.state.shadowAlpha == mode) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadowAlpha.apply(this, arguments);
  }
  var node = this.createElement("shadowalpha");
  node.setAttribute("alpha", mode);
  this.root.appendChild(node);
};
/**
 * @param {!Object} parentId
 * @param {!Object} x
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setShadowOffset = function(parentId, x) {
  if (this.compressed) {
    if (this.state.shadowDx == parentId && this.state.shadowDy == x) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadowOffset.apply(this, arguments);
  }
  var node = this.createElement("shadowoffset");
  node.setAttribute("dx", parentId);
  node.setAttribute("dy", x);
  this.root.appendChild(node);
};
/**
 * @param {number} val
 * @param {number} data
 * @param {number} key
 * @param {number} value
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.rect = function(val, data, key, value) {
  var el = this.createElement("rect");
  el.setAttribute("x", this.format(val));
  el.setAttribute("y", this.format(data));
  el.setAttribute("w", this.format(key));
  el.setAttribute("h", this.format(value));
  this.root.appendChild(el);
};
/**
 * @param {number} y
 * @param {number} key
 * @param {number} e
 * @param {number} d
 * @param {number} node
 * @param {number} name
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.roundrect = function(y, key, e, d, node, name) {
  var t = this.createElement("roundrect");
  t.setAttribute("x", this.format(y));
  t.setAttribute("y", this.format(key));
  t.setAttribute("w", this.format(e));
  t.setAttribute("h", this.format(d));
  t.setAttribute("dx", this.format(node));
  t.setAttribute("dy", this.format(name));
  this.root.appendChild(t);
};
/**
 * @param {number} d
 * @param {number} key
 * @param {number} val
 * @param {number} name
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.ellipse = function(d, key, val, name) {
  var el = this.createElement("ellipse");
  el.setAttribute("x", this.format(d));
  el.setAttribute("y", this.format(key));
  el.setAttribute("w", this.format(val));
  el.setAttribute("h", this.format(name));
  this.root.appendChild(el);
};
/**
 * @param {number} label
 * @param {number} val
 * @param {number} key
 * @param {number} data
 * @param {!Object} value
 * @param {string} text
 * @param {string} state
 * @param {string} style
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.image = function(label, val, key, data, value, text, state, style) {
  value = this.converter.convert(value);
  var el = this.createElement("image");
  el.setAttribute("x", this.format(label));
  el.setAttribute("y", this.format(val));
  el.setAttribute("w", this.format(key));
  el.setAttribute("h", this.format(data));
  el.setAttribute("src", value);
  el.setAttribute("aspect", text ? "1" : "0");
  el.setAttribute("flipH", state ? "1" : "0");
  el.setAttribute("flipV", style ? "1" : "0");
  this.root.appendChild(el);
};
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.begin = function() {
  this.root.appendChild(this.createElement("begin"));
  /** @type {number} */
  this.lastY = this.lastX = 0;
};
/**
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.moveTo = function(x, y) {
  var el = this.createElement("move");
  el.setAttribute("x", this.format(x));
  el.setAttribute("y", this.format(y));
  this.root.appendChild(el);
  /** @type {number} */
  this.lastX = x;
  /** @type {number} */
  this.lastY = y;
};
/**
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.lineTo = function(x, y) {
  var info = this.createElement("line");
  info.setAttribute("x", this.format(x));
  info.setAttribute("y", this.format(y));
  this.root.appendChild(info);
  /** @type {number} */
  this.lastX = x;
  /** @type {number} */
  this.lastY = y;
};
/**
 * @param {number} key
 * @param {number} value
 * @param {number} val
 * @param {number} data
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.quadTo = function(key, value, val, data) {
  var el = this.createElement("quad");
  el.setAttribute("x1", this.format(key));
  el.setAttribute("y1", this.format(value));
  el.setAttribute("x2", this.format(val));
  el.setAttribute("y2", this.format(data));
  this.root.appendChild(el);
  /** @type {number} */
  this.lastX = val;
  /** @type {number} */
  this.lastY = data;
};
/**
 * @param {number} e
 * @param {number} end
 * @param {number} d
 * @param {number} i
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.curveTo = function(e, end, d, i, x, y) {
  var assert = this.createElement("curve");
  assert.setAttribute("x1", this.format(e));
  assert.setAttribute("y1", this.format(end));
  assert.setAttribute("x2", this.format(d));
  assert.setAttribute("y2", this.format(i));
  assert.setAttribute("x3", this.format(x));
  assert.setAttribute("y3", this.format(y));
  this.root.appendChild(assert);
  /** @type {number} */
  this.lastX = x;
  /** @type {number} */
  this.lastY = y;
};
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.close = function() {
  this.root.appendChild(this.createElement("close"));
};
/**
 * @param {number} key
 * @param {number} value
 * @param {number} i
 * @param {number} data
 * @param {!Object} node
 * @param {!Object} a
 * @param {!Object} x
 * @param {string} v
 * @param {string} h
 * @param {!Object} c
 * @param {string} state
 * @param {?} filename
 * @param {!Object} text
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.text = function(key, value, i, data, node, a, x, v, h, c, state, filename, text) {
  if (this.textEnabled && null != node) {
    if (mxUtils.isNode(node)) {
      node = mxUtils.getOuterHtml(node);
    }
    var el = this.createElement("text");
    el.setAttribute("x", this.format(key));
    el.setAttribute("y", this.format(value));
    el.setAttribute("w", this.format(i));
    el.setAttribute("h", this.format(data));
    el.setAttribute("str", node);
    if (null != a) {
      el.setAttribute("align", a);
    }
    if (null != x) {
      el.setAttribute("valign", x);
    }
    el.setAttribute("wrap", v ? "1" : "0");
    if (null == h) {
      /** @type {string} */
      h = "";
    }
    el.setAttribute("format", h);
    if (null != c) {
      el.setAttribute("overflow", c);
    }
    if (null != state) {
      el.setAttribute("clip", state ? "1" : "0");
    }
    if (null != filename) {
      el.setAttribute("rotation", filename);
    }
    if (null != text) {
      el.setAttribute("dir", text);
    }
    this.root.appendChild(el);
  }
};
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.stroke = function() {
  this.root.appendChild(this.createElement("stroke"));
};
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.fill = function() {
  this.root.appendChild(this.createElement("fill"));
};
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.fillAndStroke = function() {
  this.root.appendChild(this.createElement("fillstroke"));
};
/**
 * @param {!Object} node
 * @param {!Object} elem
 * @return {undefined}
 */
function mxSvgCanvas2D(node, elem) {
  mxAbstractCanvas2D.call(this);
  /** @type {!Object} */
  this.root = node;
  /** @type {!Array} */
  this.gradients = [];
  /** @type {!Array} */
  this.fillPatterns = [];
  /** @type {null} */
  this.defs = null;
  this.styleEnabled = null != elem ? elem : false;
  /** @type {null} */
  elem = null;
  if (node.ownerDocument != document) {
    for (; null != node && "svg" != node.nodeName;) {
      node = node.parentNode;
    }
    /** @type {!Object} */
    elem = node;
  }
  if (null != elem) {
    if (0 < elem.getElementsByTagName("defs").length) {
      this.defs = elem.getElementsByTagName("defs")[0];
    }
    if (null == this.defs) {
      this.defs = this.createElement("defs");
      if (null != elem.firstChild) {
        elem.insertBefore(this.defs, elem.firstChild);
      } else {
        elem.appendChild(this.defs);
      }
    }
    if (this.styleEnabled) {
      this.defs.appendChild(this.createStyle());
    }
  }
}
mxUtils.extend(mxSvgCanvas2D, mxAbstractCanvas2D);
(function() {
  /** @type {boolean} */
  mxSvgCanvas2D.prototype.useDomParser = !mxClient.IS_IE && "function" === typeof DOMParser && "function" === typeof XMLSerializer;
  if (mxSvgCanvas2D.prototype.useDomParser) {
    try {
      /** @type {(Document|null)} */
      var doc = (new DOMParser).parseFromString("test text", "text/html");
      /** @type {boolean} */
      mxSvgCanvas2D.prototype.useDomParser = null != doc;
    } catch (b) {
      /** @type {boolean} */
      mxSvgCanvas2D.prototype.useDomParser = false;
    }
  }
  /** @type {boolean} */
  mxSvgCanvas2D.prototype.useAbsoluteIds = !mxClient.IS_CHROMEAPP && !mxClient.IS_IE && !mxClient.IS_IE11 && !mxClient.IS_EDGE && 0 < document.getElementsByTagName("base").length;
})();
/** @type {null} */
mxSvgCanvas2D.prototype.node = null;
/** @type {boolean} */
mxSvgCanvas2D.prototype.matchHtmlAlignment = true;
/** @type {boolean} */
mxSvgCanvas2D.prototype.textEnabled = true;
/** @type {boolean} */
mxSvgCanvas2D.prototype.foEnabled = true;
/** @type {string} */
mxSvgCanvas2D.prototype.foAltText = "[Object]";
/** @type {number} */
mxSvgCanvas2D.prototype.foOffset = 0;
/** @type {number} */
mxSvgCanvas2D.prototype.textOffset = 0;
/** @type {number} */
mxSvgCanvas2D.prototype.imageOffset = 0;
/** @type {number} */
mxSvgCanvas2D.prototype.strokeTolerance = 0;
/** @type {number} */
mxSvgCanvas2D.prototype.minStrokeWidth = 1;
/** @type {number} */
mxSvgCanvas2D.prototype.refCount = 0;
/** @type {number} */
mxSvgCanvas2D.prototype.lineHeightCorrection = 1;
/** @type {string} */
mxSvgCanvas2D.prototype.pointerEventsValue = "all";
/** @type {number} */
mxSvgCanvas2D.prototype.fontMetricsPadding = 10;
/** @type {number} */
mxSvgCanvas2D.prototype.foreignObjectPadding = 2;
/** @type {boolean} */
mxSvgCanvas2D.prototype.cacheOffsetSize = true;
/**
 * @param {!Element} el
 * @param {string} value
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.setCssText = function(el, value) {
  if (mxClient.IS_IE || mxClient.IS_IE11) {
    el.setAttribute("style", value);
  } else {
    mxUtils.setCssText(el.style, value);
  }
};
/**
 * @param {number} str
 * @return {?}
 */
mxSvgCanvas2D.prototype.format = function(str) {
  return parseFloat(parseFloat(str).toFixed(2));
};
/**
 * @return {?}
 */
mxSvgCanvas2D.prototype.getBaseUrl = function() {
  /** @type {string} */
  var baseUrl = window.location.href;
  /** @type {number} */
  var index = baseUrl.lastIndexOf("#");
  if (0 < index) {
    /** @type {string} */
    baseUrl = baseUrl.substring(0, index);
  }
  return baseUrl;
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.reset = function() {
  mxAbstractCanvas2D.prototype.reset.apply(this, arguments);
  /** @type {!Array} */
  this.gradients = [];
  /** @type {!Array} */
  this.fillPatterns = [];
};
/**
 * @param {!Object} style
 * @return {?}
 */
mxSvgCanvas2D.prototype.createStyle = function(style) {
  style = this.createElement("style");
  style.setAttribute("type", "text/css");
  mxUtils.write(style, "svg{font-family:" + mxConstants.DEFAULT_FONTFAMILY + ";font-size:" + mxConstants.DEFAULT_FONTSIZE + ";fill:none;stroke-miterlimit:10}");
  return style;
};
/**
 * @param {!Object} name
 * @param {!Object} ns
 * @return {?}
 */
mxSvgCanvas2D.prototype.createElement = function(name, ns) {
  if (null != this.root.ownerDocument.createElementNS) {
    return this.root.ownerDocument.createElementNS(ns || mxConstants.NS_SVG, name);
  }
  name = this.root.ownerDocument.createElement(name);
  if (null != ns) {
    name.setAttribute("xmlns", ns);
  }
  return name;
};
/**
 * @param {!Object} a22
 * @param {string} Px
 * @param {number} Py
 * @param {!Object} Model
 * @param {string} type
 * @param {string} i
 * @param {!Object} p
 * @param {number} p2
 * @param {!Object} options
 * @param {string} at
 * @param {string} n
 * @param {?} name
 * @param {number} state
 * @return {?}
 */
mxSvgCanvas2D.prototype.getAlternateText = function(a22, Px, Py, Model, type, i, p, p2, options, at, n, name, state) {
  return null != i ? this.foAltText : null;
};
/**
 * @param {!Object} e
 * @param {string} x
 * @param {number} y
 * @param {!Object} options
 * @param {string} end
 * @param {string} f
 * @param {!Object} el
 * @param {number} index
 * @param {!Object} a
 * @param {string} item
 * @param {string} form
 * @param {?} mode
 * @param {number} name
 * @return {?}
 */
mxSvgCanvas2D.prototype.createAlternateContent = function(e, x, y, options, end, f, el, index, a, item, form, mode, name) {
  e = this.getAlternateText(e, x, y, options, end, f, el, index, a, item, form, mode, name);
  options = this.state;
  return null != e && 0 < options.fontSize ? (index = index == mxConstants.ALIGN_TOP ? 1 : index == mxConstants.ALIGN_BOTTOM ? 0 : .3, end = el == mxConstants.ALIGN_RIGHT ? "end" : el == mxConstants.ALIGN_LEFT ? "start" : "middle", el = this.createElement("text"), el.setAttribute("x", Math.round(x + options.dx)), el.setAttribute("y", Math.round(y + options.dy + index * options.fontSize)), el.setAttribute("fill", options.fontColor || "black"), el.setAttribute("font-family", options.fontFamily), el.setAttribute("font-size", 
  Math.round(options.fontSize) + "px"), "start" != end && el.setAttribute("text-anchor", end), (options.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && el.setAttribute("font-weight", "bold"), (options.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && el.setAttribute("font-style", "italic"), x = [], (options.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE && x.push("underline"), (options.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH && 
  x.push("line-through"), 0 < x.length && el.setAttribute("text-decoration", x.join(" ")), mxUtils.write(el, e), el) : null;
};
/**
 * @param {string} data
 * @param {string} text
 * @param {string} c
 * @param {string} val
 * @param {string} section
 * @return {?}
 */
mxSvgCanvas2D.prototype.createGradientId = function(data, text, c, val, section) {
  data = mxUtils.rgba2hex(data);
  if ("#" == data.charAt(0)) {
    data = data.substring(1);
  }
  text = mxUtils.rgba2hex(text);
  if ("#" == text.charAt(0)) {
    text = text.substring(1);
  }
  data = data.toLowerCase() + "-" + c;
  text = text.toLowerCase() + "-" + val;
  /** @type {null} */
  c = null;
  if (null == section || section == mxConstants.DIRECTION_SOUTH) {
    /** @type {string} */
    c = "s";
  } else {
    if (section == mxConstants.DIRECTION_EAST) {
      /** @type {string} */
      c = "e";
    } else {
      if (section == mxConstants.DIRECTION_RADIAL) {
        /** @type {string} */
        c = "r";
      } else {
        /** @type {string} */
        val = data;
        /** @type {string} */
        data = text;
        /** @type {string} */
        text = val;
        if (section == mxConstants.DIRECTION_NORTH) {
          /** @type {string} */
          c = "s";
        } else {
          if (section == mxConstants.DIRECTION_WEST) {
            /** @type {string} */
            c = "e";
          }
        }
      }
    }
  }
  return "mx-gradient-" + data + "-" + text + "-" + c;
};
/**
 * @param {string} element
 * @param {string} type
 * @param {string} name
 * @param {string} list
 * @param {undefined} container
 * @return {?}
 */
mxSvgCanvas2D.prototype.getSvgGradient = function(element, type, name, list, container) {
  var i = this.createGradientId(element, type, name, list, container);
  var node = this.gradients[i];
  if (null == node) {
    var document = this.root.ownerSVGElement;
    /** @type {number} */
    var id = 0;
    /** @type {string} */
    var key = i + "-" + id;
    if (null != document) {
      node = document.ownerDocument.getElementById(key);
      for (; null != node && node.ownerSVGElement != document;) {
        /** @type {string} */
        key = i + "-" + id++;
        node = document.ownerDocument.getElementById(key);
      }
    } else {
      /** @type {string} */
      key = "id" + ++this.refCount;
    }
    if (null == node) {
      node = this.createSvgGradient(element, type, name, list, container);
      node.setAttribute("id", key);
      if (null != this.defs) {
        this.defs.appendChild(node);
      } else {
        document.appendChild(node);
      }
    }
    this.gradients[i] = node;
  }
  return node.getAttribute("id");
};
/**
 * @param {string} suppressDisabledCheck
 * @param {string} element
 * @param {string} event
 * @param {string} a
 * @param {!Object} b
 * @return {?}
 */
mxSvgCanvas2D.prototype.createSvgGradient = function(suppressDisabledCheck, element, event, a, b) {
  var node = this.createElement(b == mxConstants.DIRECTION_RADIAL ? "radialGradient" : "linearGradient");
  node.setAttribute("x1", "0%");
  node.setAttribute("y1", "0%");
  node.setAttribute("x2", "0%");
  node.setAttribute("y2", "0%");
  if (null == b || b == mxConstants.DIRECTION_SOUTH) {
    node.setAttribute("y2", "100%");
  } else {
    if (b == mxConstants.DIRECTION_EAST) {
      node.setAttribute("x2", "100%");
    } else {
      if (b == mxConstants.DIRECTION_NORTH) {
        node.setAttribute("y1", "100%");
      } else {
        if (b == mxConstants.DIRECTION_WEST) {
          node.setAttribute("x1", "100%");
        }
      }
    }
  }
  b = this.createElement("stop");
  b.setAttribute("offset", "0%");
  /** @type {string} */
  b.style.stopColor = suppressDisabledCheck;
  /** @type {string} */
  b.style.stopOpacity = event;
  node.appendChild(b);
  b = this.createElement("stop");
  b.setAttribute("offset", "100%");
  /** @type {string} */
  b.style.stopColor = element;
  /** @type {string} */
  b.style.stopOpacity = a;
  node.appendChild(b);
  return node;
};
/**
 * @param {string} address
 * @param {string} kind
 * @param {string} value
 * @return {?}
 */
mxSvgCanvas2D.prototype.createFillPatternId = function(address, kind, value) {
  value = mxUtils.rgba2hex(value);
  if ("#" == value.charAt(0)) {
    value = value.substring(1);
  }
  return ("mx-pattern-" + address + "-" + kind + "-" + value).toLowerCase();
};
/**
 * @param {string} f
 * @param {undefined} a
 * @param {undefined} root
 * @param {undefined} html
 * @return {?}
 */
mxSvgCanvas2D.prototype.getFillPattern = function(f, a, root, html) {
  var i = this.createFillPatternId(f, a, root);
  var node = this.fillPatterns[i];
  if (null == node) {
    var document = this.root.ownerSVGElement;
    /** @type {number} */
    var id = 0;
    /** @type {string} */
    var key = i + "-" + id;
    if (null != document) {
      node = document.ownerDocument.getElementById(key);
      for (; null != node && node.ownerSVGElement != document;) {
        /** @type {string} */
        key = i + "-" + id++;
        node = document.ownerDocument.getElementById(key);
      }
    } else {
      /** @type {string} */
      key = "id" + ++this.refCount;
    }
    if (null == node) {
      switch(f) {
        case "hatch":
          node = this.createHatchPattern(a, root, html);
          break;
        case "dots":
          node = this.createDotsPattern(a, root, html);
          break;
        case "cross-hatch":
          node = this.createCrossHatchPattern(a, root, html);
          break;
        case "dashed":
          node = this.createDashedPattern(a, root, html);
          break;
        case "zigzag":
        case "zigzag-line":
          node = this.createZigZagLinePattern(a, root, html);
          break;
        default:
          return "ERROR";
      }
      node.setAttribute("id", key);
      if (null != this.defs) {
        this.defs.appendChild(node);
      } else {
        document.appendChild(node);
      }
    }
    this.fillPatterns[i] = node;
  }
  return node.getAttribute("id");
};
/**
 * @param {number} b
 * @param {!Object} c
 * @param {number} f
 * @return {?}
 */
mxSvgCanvas2D.prototype.createHatchPattern = function(b, c, f) {
  /** @type {number} */
  b = 1.5 * b * f;
  f = this.format((10 + b) * f);
  var element = this.createElement("pattern");
  element.setAttribute("patternUnits", "userSpaceOnUse");
  element.setAttribute("width", f);
  element.setAttribute("height", f);
  element.setAttribute("x", "0");
  element.setAttribute("y", "0");
  element.setAttribute("patternTransform", "rotate(45)");
  var el = this.createElement("line");
  el.setAttribute("x1", "0");
  el.setAttribute("y1", "0");
  el.setAttribute("x2", "0");
  el.setAttribute("y2", f);
  el.setAttribute("stroke", c);
  el.setAttribute("stroke-width", b);
  element.appendChild(el);
  return element;
};
/**
 * @param {number} a
 * @param {!Object} i
 * @param {number} h
 * @return {?}
 */
mxSvgCanvas2D.prototype.createDashedPattern = function(a, i, h) {
  /** @type {number} */
  a = 1.5 * a * h;
  h = this.format((10 + a) * h);
  var pattern = this.createElement("pattern");
  pattern.setAttribute("patternUnits", "userSpaceOnUse");
  pattern.setAttribute("width", h);
  pattern.setAttribute("height", h);
  pattern.setAttribute("x", "0");
  pattern.setAttribute("y", "0");
  pattern.setAttribute("patternTransform", "rotate(45)");
  var elem = this.createElement("line");
  elem.setAttribute("x1", "0");
  elem.setAttribute("y1", h / 4);
  elem.setAttribute("x2", "0");
  elem.setAttribute("y2", 3 * h / 4);
  elem.setAttribute("stroke", i);
  elem.setAttribute("stroke-width", a);
  pattern.appendChild(elem);
  return pattern;
};
/**
 * @param {number} t
 * @param {!Object} w
 * @param {number} s
 * @return {?}
 */
mxSvgCanvas2D.prototype.createZigZagLinePattern = function(t, w, s) {
  /** @type {number} */
  t = 1.5 * t * s;
  s = this.format((10 + t) * s);
  var element = this.createElement("pattern");
  element.setAttribute("patternUnits", "userSpaceOnUse");
  element.setAttribute("width", s);
  element.setAttribute("height", s);
  element.setAttribute("x", "0");
  element.setAttribute("y", "0");
  element.setAttribute("patternTransform", "rotate(45)");
  var el = this.createElement("path");
  /** @type {number} */
  var v1 = s / 4;
  /** @type {number} */
  var g = 3 * s / 4;
  el.setAttribute("d", "M " + v1 + " 0 L " + g + " 0 L " + v1 + " " + s + " L " + g + " " + s);
  el.setAttribute("stroke", w);
  el.setAttribute("stroke-width", t);
  el.setAttribute("fill", "none");
  element.appendChild(el);
  return element;
};
/**
 * @param {number} c
 * @param {!Object} a
 * @param {number} f
 * @return {?}
 */
mxSvgCanvas2D.prototype.createCrossHatchPattern = function(c, a, f) {
  /** @type {number} */
  c = .5 * c * f;
  f = this.format(1.5 * (10 + c) * f);
  var pattern = this.createElement("pattern");
  pattern.setAttribute("patternUnits", "userSpaceOnUse");
  pattern.setAttribute("width", f);
  pattern.setAttribute("height", f);
  pattern.setAttribute("x", "0");
  pattern.setAttribute("y", "0");
  pattern.setAttribute("patternTransform", "rotate(45)");
  var element = this.createElement("rect");
  element.setAttribute("x", 0);
  element.setAttribute("y", 0);
  element.setAttribute("width", f);
  element.setAttribute("height", f);
  element.setAttribute("stroke", a);
  element.setAttribute("stroke-width", c);
  element.setAttribute("fill", "none");
  pattern.appendChild(element);
  return pattern;
};
/**
 * @param {number} i
 * @param {!Object} hash
 * @param {!Node} el
 * @return {?}
 */
mxSvgCanvas2D.prototype.createDotsPattern = function(i, hash, el) {
  i = this.format((10 + i) * el);
  el = this.createElement("pattern");
  el.setAttribute("patternUnits", "userSpaceOnUse");
  el.setAttribute("width", i);
  el.setAttribute("height", i);
  el.setAttribute("x", "0");
  el.setAttribute("y", "0");
  var node = this.createElement("circle");
  node.setAttribute("cx", i / 2);
  node.setAttribute("cy", i / 2);
  node.setAttribute("r", i / 4);
  node.setAttribute("stroke", "none");
  node.setAttribute("fill", hash);
  el.appendChild(node);
  return el;
};
/**
 * @param {boolean} data
 * @param {boolean} delta
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.addNode = function(data, delta) {
  var elem = this.node;
  var obj = this.state;
  if (null != elem) {
    if ("path" == elem.nodeName) {
      if (null != this.path && 0 < this.path.length) {
        elem.setAttribute("d", this.path.join(" "));
      } else {
        return;
      }
    }
    if (data && null != obj.fillColor) {
      this.updateFill();
    } else {
      if (!this.styleEnabled) {
        if ("ellipse" == elem.nodeName && mxClient.IS_FF) {
          elem.setAttribute("fill", "transparent");
        } else {
          elem.setAttribute("fill", "none");
        }
        /** @type {boolean} */
        data = false;
      }
    }
    if (delta && null != obj.strokeColor) {
      this.updateStroke();
    } else {
      if (!this.styleEnabled) {
        elem.setAttribute("stroke", "none");
      }
    }
    if (null != obj.transform && 0 < obj.transform.length) {
      elem.setAttribute("transform", obj.transform);
    }
    if (this.pointerEvents) {
      elem.setAttribute("pointer-events", this.pointerEventsValue);
    } else {
      if (!(this.pointerEvents || null != this.originalRoot)) {
        elem.setAttribute("pointer-events", "none");
      }
    }
    if (obj.shadow) {
      this.root.appendChild(this.createShadow(elem));
    }
    if (0 < this.strokeTolerance && (!data || null == obj.fillColor)) {
      this.addTolerance(elem);
    }
    if ("rect" != elem.nodeName && "path" != elem.nodeName && "ellipse" != elem.nodeName || "none" != elem.getAttribute("fill") && "transparent" != elem.getAttribute("fill") || "none" != elem.getAttribute("stroke") || "none" != elem.getAttribute("pointer-events")) {
      this.root.appendChild(elem);
    }
    /** @type {null} */
    this.node = null;
  }
};
/**
 * @param {!Node} element
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.addTolerance = function(element) {
  this.root.appendChild(this.createTolerance(element));
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.updateFill = function() {
  var params = this.state;
  if (1 > params.alpha || 1 > params.fillAlpha) {
    this.node.setAttribute("fill-opacity", params.alpha * params.fillAlpha);
  }
  /** @type {boolean} */
  var b = false;
  if (null != params.fillColor) {
    if (null != params.gradientColor && params.gradientColor != mxConstants.NONE) {
      /** @type {boolean} */
      b = true;
      var picKey = this.getSvgGradient(String(params.fillColor), String(params.gradientColor), params.gradientFillAlpha, params.gradientAlpha, params.gradientDirection);
      if (this.root.ownerDocument == document && this.useAbsoluteIds) {
        var value = this.getBaseUrl().replace(/([\(\)])/g, "\\$1");
        /** @type {string} */
        value = "url(" + value + "#" + picKey + ")";
      } else {
        /** @type {string} */
        value = "url(#" + picKey + ")";
      }
    } else {
      /** @type {string} */
      value = String(params.fillColor).toLowerCase();
    }
  }
  if (b || null == params.fillStyle || "auto" == params.fillStyle || "solid" == params.fillStyle) {
    this.node.setAttribute("fill", value);
  } else {
    params = this.getFillPattern(params.fillStyle, this.getCurrentStrokeWidth(), value, params.scale);
    if (this.root.ownerDocument == document && this.useAbsoluteIds) {
      value = this.getBaseUrl().replace(/([\(\)])/g, "\\$1");
      this.node.setAttribute("fill", "url(" + value + "#" + params + ")");
    } else {
      this.node.setAttribute("fill", "url(#" + params + ")");
    }
  }
};
/**
 * @return {?}
 */
mxSvgCanvas2D.prototype.getCurrentStrokeWidth = function() {
  return Math.max(this.minStrokeWidth, Math.max(.01, this.format(this.state.strokeWidth * this.state.scale)));
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.updateStroke = function() {
  var options = this.state;
  this.node.setAttribute("stroke", String(options.strokeColor).toLowerCase());
  if (1 > options.alpha || 1 > options.strokeAlpha) {
    this.node.setAttribute("stroke-opacity", options.alpha * options.strokeAlpha);
  }
  var value = this.getCurrentStrokeWidth();
  if (1 != value) {
    this.node.setAttribute("stroke-width", value);
  }
  if ("path" == this.node.nodeName) {
    this.updateStrokeAttributes();
  }
  if (options.dashed) {
    this.node.setAttribute("stroke-dasharray", this.createDashPattern((options.fixDash ? 1 : options.strokeWidth) * options.scale));
  }
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.updateStrokeAttributes = function() {
  var options = this.state;
  if (null != options.lineJoin && "miter" != options.lineJoin) {
    this.node.setAttribute("stroke-linejoin", options.lineJoin);
  }
  if (null != options.lineCap) {
    var value = options.lineCap;
    if ("flat" == value) {
      /** @type {string} */
      value = "butt";
    }
    if ("butt" != value) {
      this.node.setAttribute("stroke-linecap", value);
    }
  }
  if (!(null == options.miterLimit || this.styleEnabled && 10 == options.miterLimit)) {
    this.node.setAttribute("stroke-miterlimit", options.miterLimit);
  }
};
/**
 * @param {number} multiplier
 * @return {?}
 */
mxSvgCanvas2D.prototype.createDashPattern = function(multiplier) {
  /** @type {!Array} */
  var outputBuffer = [];
  if ("string" === typeof this.state.dashPattern) {
    /** @type {!Array<string>} */
    var SMPTE = this.state.dashPattern.split(" ");
    if (0 < SMPTE.length) {
      /** @type {number} */
      var i = 0;
      for (; i < SMPTE.length; i++) {
        /** @type {number} */
        outputBuffer[i] = Number(SMPTE[i]) * multiplier;
      }
    }
  }
  return outputBuffer.join(" ");
};
/**
 * @param {!Node} el
 * @return {?}
 */
mxSvgCanvas2D.prototype.createTolerance = function(el) {
  el = el.cloneNode(true);
  var styleElId = parseFloat(el.getAttribute("stroke-width") || 1) + this.strokeTolerance;
  el.setAttribute("pointer-events", "stroke");
  el.setAttribute("visibility", "hidden");
  el.removeAttribute("stroke-dasharray");
  el.setAttribute("stroke-width", styleElId);
  el.setAttribute("fill", "none");
  el.setAttribute("stroke", mxClient.IS_OT ? "none" : "white");
  return el;
};
/**
 * @param {!Node} e
 * @return {?}
 */
mxSvgCanvas2D.prototype.createShadow = function(e) {
  e = e.cloneNode(true);
  var style = this.state;
  if (!("none" == e.getAttribute("fill") || mxClient.IS_FF && "transparent" == e.getAttribute("fill"))) {
    e.setAttribute("fill", style.shadowColor);
  }
  if ("none" != e.getAttribute("stroke")) {
    e.setAttribute("stroke", style.shadowColor);
  }
  e.setAttribute("transform", "translate(" + this.format(style.shadowDx * style.scale) + "," + this.format(style.shadowDy * style.scale) + ")" + (style.transform || ""));
  e.setAttribute("opacity", style.shadowAlpha);
  return e;
};
/**
 * @param {!Object} value
 * @param {!Object} name
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.setLink = function(value, name) {
  if (null == value) {
    this.root = this.originalRoot;
  } else {
    this.originalRoot = this.root;
    var el = this.createElement("a");
    if (null == el.setAttributeNS || this.root.ownerDocument != document && null == document.documentMode) {
      el.setAttribute("xlink:href", value);
    } else {
      el.setAttributeNS(mxConstants.NS_XLINK, "xlink:href", value);
    }
    if (null != name) {
      el.setAttribute("target", name);
    }
    this.root.appendChild(el);
    this.root = el;
  }
};
/**
 * @param {number} d
 * @param {boolean} a
 * @param {boolean} b
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.rotate = function(d, a, b, x, y) {
  if (0 != d || a || b) {
    var s = this.state;
    x = x + s.dx;
    y = y + s.dy;
    /** @type {number} */
    x = x * s.scale;
    /** @type {number} */
    y = y * s.scale;
    s.transform = s.transform || "";
    if (a && b) {
      d = d + 180;
    } else {
      if (a != b) {
        var data = a ? x : 0;
        /** @type {number} */
        var start = a ? -1 : 1;
        var d = b ? y : 0;
        /** @type {number} */
        var name = b ? -1 : 1;
        s.transform += "translate(" + this.format(data) + "," + this.format(d) + ")scale(" + this.format(start) + "," + this.format(name) + ")translate(" + this.format(-data) + "," + this.format(-d) + ")";
      }
    }
    if (a ? !b : b) {
      /** @type {number} */
      d = d * -1;
    }
    if (0 != d) {
      s.transform += "rotate(" + this.format(d) + "," + this.format(x) + "," + this.format(y) + ")";
    }
    s.rotation += d;
    /** @type {number} */
    s.rotationCx = x;
    /** @type {number} */
    s.rotationCy = y;
  }
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.begin = function() {
  mxAbstractCanvas2D.prototype.begin.apply(this, arguments);
  this.node = this.createElement("path");
};
/**
 * @param {number} x
 * @param {number} y
 * @param {number} h
 * @param {number} w
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.rect = function(x, y, h, w) {
  var s = this.state;
  var el = this.createElement("rect");
  el.setAttribute("x", this.format((x + s.dx) * s.scale));
  el.setAttribute("y", this.format((y + s.dy) * s.scale));
  el.setAttribute("width", this.format(h * s.scale));
  el.setAttribute("height", this.format(w * s.scale));
  this.node = el;
};
/**
 * @param {number} g
 * @param {number} s
 * @param {number} h
 * @param {number} y
 * @param {number} value
 * @param {number} x
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.roundrect = function(g, s, h, y, value, x) {
  this.rect(g, s, h, y);
  if (0 < value) {
    this.node.setAttribute("rx", this.format(value * this.state.scale));
  }
  if (0 < x) {
    this.node.setAttribute("ry", this.format(x * this.state.scale));
  }
};
/**
 * @param {number} a
 * @param {number} b
 * @param {number} t
 * @param {number} c
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.ellipse = function(a, b, t, c) {
  var state = this.state;
  var el = this.createElement("ellipse");
  el.setAttribute("cx", this.format((a + t / 2 + state.dx) * state.scale));
  el.setAttribute("cy", this.format((b + c / 2 + state.dy) * state.scale));
  el.setAttribute("rx", t / 2 * state.scale);
  el.setAttribute("ry", c / 2 * state.scale);
  this.node = el;
};
/**
 * @param {number} x
 * @param {number} y
 * @param {number} size
 * @param {number} width
 * @param {string} value
 * @param {?} name
 * @param {string} index
 * @param {string} type
 * @param {?} key
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.image = function(x, y, size, width, value, name, index, type, key) {
  value = this.converter.convert(value);
  name = null != name ? name : true;
  index = null != index ? index : false;
  type = null != type ? type : false;
  var params = this.state;
  x = x + params.dx;
  y = y + params.dy;
  var el = this.createElement("image");
  el.setAttribute("x", this.format(x * params.scale) + this.imageOffset);
  el.setAttribute("y", this.format(y * params.scale) + this.imageOffset);
  el.setAttribute("width", this.format(size * params.scale));
  el.setAttribute("height", this.format(width * params.scale));
  if (null == el.setAttributeNS) {
    el.setAttribute("xlink:href", value);
  } else {
    el.setAttributeNS(mxConstants.NS_XLINK, "xlink:href", value);
  }
  if (!name) {
    el.setAttribute("preserveAspectRatio", "none");
  }
  if (1 > params.alpha || 1 > params.fillAlpha) {
    el.setAttribute("opacity", params.alpha * params.fillAlpha);
  }
  value = this.state.transform || "";
  if (index || type) {
    /** @type {number} */
    var prefix = name = 1;
    /** @type {number} */
    var l = 0;
    /** @type {number} */
    var zoom = 0;
    if (index) {
      /** @type {number} */
      name = -1;
      /** @type {number} */
      l = -size - 2 * x;
    }
    if (type) {
      /** @type {number} */
      prefix = -1;
      /** @type {number} */
      zoom = -width - 2 * y;
    }
    /** @type {string} */
    value = value + ("scale(" + name + "," + prefix + ")translate(" + l * params.scale + "," + zoom * params.scale + ")");
  }
  if (0 < value.length) {
    el.setAttribute("transform", value);
  }
  if (!this.pointerEvents) {
    el.setAttribute("pointer-events", "none");
  }
  if (null != key) {
    this.processClipPath(el, key, new mxRectangle(x, y, size, width));
  }
  this.root.appendChild(el);
};
/**
 * @param {!Element} node
 * @param {boolean} value
 * @param {!Object} config
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.processClipPath = function(node, value, config) {
  try {
    var element = this.createElement("clipPath");
    element.setAttribute("id", this.createClipPathId(value));
    element.setAttribute("clipPathUnits", "objectBoundingBox");
    var val = this.appendClipPath(element, value, config);
    if (null != val) {
      var state = this.state;
      node.setAttribute("x", config.x * state.scale - config.width * state.scale * val.x / val.width + this.imageOffset);
      node.setAttribute("y", config.y * state.scale - config.height * state.scale * val.y / val.height + this.imageOffset);
      node.setAttribute("width", config.width * state.scale / val.width);
      node.setAttribute("height", config.height * state.scale / val.height);
    }
    this.setClip(node, element);
  } catch (g) {
  }
};
/**
 * @param {!Object} b
 * @return {?}
 */
mxSvgCanvas2D.prototype.convertHtml = function(b) {
  if (this.useDomParser) {
    /** @type {(Document|null)} */
    var result = (new DOMParser).parseFromString(b, "text/html");
    if (null != result) {
      /** @type {string} */
      b = (new XMLSerializer).serializeToString(result.body);
      if ("<body" == b.substring(0, 5)) {
        /** @type {string} */
        b = b.substring(b.indexOf(">", 5) + 1);
      }
      if ("</body>" == b.substring(b.length - 7, b.length)) {
        /** @type {string} */
        b = b.substring(0, b.length - 7);
      }
    }
  } else {
    if (null != document.implementation && null != document.implementation.createDocument) {
      /** @type {(Document|null)} */
      result = document.implementation.createDocument("http://www.w3.org/1999/xhtml", "html", null);
      /** @type {!Element} */
      var div = result.createElement("body");
      result.documentElement.appendChild(div);
      /** @type {!Element} */
      var c = document.createElement("div");
      /** @type {!Object} */
      c.innerHTML = b;
      /** @type {(Node|null)} */
      b = c.firstChild;
      for (; null != b;) {
        /** @type {(Node|null)} */
        c = b.nextSibling;
        div.appendChild(result.adoptNode(b));
        /** @type {(Node|null)} */
        b = c;
      }
      return div.innerHTML;
    }
    /** @type {!Element} */
    result = document.createElement("textarea");
    result.innerHTML = b.replace(/&amp;/g, "&amp;amp;").replace(/&#60;/g, "&amp;lt;").replace(/&#62;/g, "&amp;gt;").replace(/&lt;/g, "&amp;lt;").replace(/&gt;/g, "&amp;gt;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    b = result.value.replace(/&/g, "&amp;").replace(/&amp;lt;/g, "&lt;").replace(/&amp;gt;/g, "&gt;").replace(/&amp;amp;/g, "&amp;").replace(/<br>/g, "<br />").replace(/<hr>/g, "<hr />").replace(/(<img[^>]+)>/gm, "$1 />");
  }
  return b;
};
/**
 * @param {string} value
 * @return {?}
 */
mxSvgCanvas2D.prototype.createDiv = function(value) {
  if (!mxUtils.isNode(value)) {
    /** @type {string} */
    value = "<div><div>" + this.convertHtml(value) + "</div></div>";
  }
  if (mxClient.IS_IE || mxClient.IS_IE11 || !document.createElementNS) {
    return mxUtils.isNode(value) && (value = "<div><div>" + mxUtils.getXml(value) + "</div></div>"), mxUtils.parseXml('<div xmlns="http://www.w3.org/1999/xhtml">' + value + "</div>").documentElement;
  }
  /** @type {!Element} */
  var div = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
  if (mxUtils.isNode(value)) {
    /** @type {!Element} */
    var c = document.createElement("div");
    /** @type {!Element} */
    var d = c.cloneNode(false);
    if (this.root.ownerDocument != document) {
      c.appendChild(value.cloneNode(true));
    } else {
      c.appendChild(value);
    }
    d.appendChild(c);
    div.appendChild(d);
  } else {
    /** @type {string} */
    div.innerHTML = value;
  }
  return div;
};
/**
 * @param {number} d
 * @param {!Function} target
 * @param {number} text
 * @param {!Array} position
 * @param {string} url
 * @param {string} query
 * @param {boolean} params
 * @param {string} e
 * @param {boolean} id
 * @param {undefined} body
 * @param {!Object} node
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.updateText = function(d, target, text, position, url, query, params, e, id, body, node) {
  if (null != node && null != node.firstChild && null != node.firstChild.firstChild) {
    this.updateTextNodes(d, target, text, position, url, query, params, e, id, body, node.firstChild);
  }
};
/**
 * @param {number} x
 * @param {!Object} y
 * @param {?} width
 * @param {?} t
 * @param {boolean} str
 * @param {string} align
 * @param {boolean} valign
 * @param {!Object} wrap
 * @param {string} value
 * @param {string} group
 * @param {boolean} clip
 * @param {number} name
 * @param {!Object} base
 * @param {!Object} element
 * @param {!Object} h
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.addForeignObject = function(x, y, width, t, str, align, valign, wrap, value, group, clip, name, base, element, h) {
  base = this.createElement("g");
  var node = this.createElement("foreignObject");
  this.setCssText(node, "overflow: visible; text-align: left;");
  node.setAttribute("pointer-events", "none");
  if (element.ownerDocument != document) {
    element = mxUtils.importNodeImplementation(node.ownerDocument, element, true);
  }
  node.appendChild(element);
  base.appendChild(node);
  this.updateTextNodes(x, y, width, t, align, valign, wrap, group, clip, name, base);
  if (this.root.ownerDocument != document) {
    x = this.createAlternateContent(node, x, y, width, t, str, align, valign, wrap, value, group, clip, name);
    if (null != x) {
      node.setAttribute("requiredFeatures", "http://www.w3.org/TR/SVG11/feature#Extensibility");
      y = this.createElement("switch");
      y.appendChild(node);
      y.appendChild(x);
      base.appendChild(y);
    }
  }
  h.appendChild(base);
};
/**
 * @param {number} x
 * @param {string} y
 * @param {?} value
 * @param {!Array} position
 * @param {string} align
 * @param {string} valign
 * @param {boolean} callback
 * @param {string} path
 * @param {boolean} val
 * @param {number} name
 * @param {!Object} node
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.updateTextNodes = function(x, y, value, position, align, valign, callback, path, val, name, node) {
  var v = this.state.scale;
  mxSvgCanvas2D.createCss(value + this.foreignObjectPadding, position, align, valign, callback, path, val, null != this.state.fontBackgroundColor ? this.state.fontBackgroundColor : null, null != this.state.fontBorderColor ? this.state.fontBorderColor : null, "display: flex; align-items: unsafe " + (valign == mxConstants.ALIGN_TOP ? "flex-start" : valign == mxConstants.ALIGN_BOTTOM ? "flex-end" : "center") + "; justify-content: unsafe " + (align == mxConstants.ALIGN_LEFT ? "flex-start" : align == 
  mxConstants.ALIGN_RIGHT ? "flex-end" : "center") + "; ", this.getTextCss(), v, mxUtils.bind(this, function(ix, position, names, index, childCompute) {
    x = x + this.state.dx;
    y = y + this.state.dy;
    var body = node.firstChild;
    var div = body.firstChild;
    var svg = div.firstChild;
    var where = (this.rotateHtml ? this.state.rotation : 0) + (null != name ? name : 0);
    /** @type {string} */
    var value = (0 != this.foOffset ? "translate(" + this.foOffset + " " + this.foOffset + ")" : "") + (1 != v ? "scale(" + v + ")" : "");
    this.setCssText(svg.firstChild, childCompute);
    this.setCssText(svg, index);
    svg.setAttribute("data-drawio-colors", "color: " + this.state.fontColor + "; " + (null == this.state.fontBackgroundColor ? "" : "background-color: " + this.state.fontBackgroundColor + "; ") + (null == this.state.fontBorderColor ? "" : "border-color: " + this.state.fontBorderColor + "; "));
    body.setAttribute("width", Math.ceil(1 / Math.min(1, v) * 100) + "%");
    body.setAttribute("height", Math.ceil(1 / Math.min(1, v) * 100) + "%");
    /** @type {number} */
    position = Math.round(y + position);
    if (0 > position) {
      body.setAttribute("y", position);
    } else {
      body.removeAttribute("y");
      /** @type {string} */
      names = names + ("padding-top: " + position + "px; ");
    }
    this.setCssText(div, names + "margin-left: " + Math.round(x + ix) + "px;");
    /** @type {string} */
    value = value + (0 != where ? "rotate(" + where + " " + x + " " + y + ")" : "");
    if ("" != value) {
      node.setAttribute("transform", value);
    } else {
      node.removeAttribute("transform");
    }
    if (1 != this.state.alpha) {
      node.setAttribute("opacity", this.state.alpha);
    } else {
      node.removeAttribute("opacity");
    }
  }));
};
/**
 * @param {number} width
 * @param {number} height
 * @param {string} value
 * @param {string} name
 * @param {boolean} method
 * @param {string} undefined
 * @param {boolean} file
 * @param {?} error
 * @param {?} rules
 * @param {string} rule
 * @param {string} pos
 * @param {string} result
 * @param {?} log
 * @return {undefined}
 */
mxSvgCanvas2D.createCss = function(width, height, value, name, method, undefined, file, error, rules, rule, pos, result, log) {
  /** @type {string} */
  result = "box-sizing: border-box; font-size: 0; text-align: " + (value == mxConstants.ALIGN_LEFT ? "left" : value == mxConstants.ALIGN_RIGHT ? "right" : "center") + "; ";
  var port = mxUtils.getAlignmentAsPoint(value, name);
  /** @type {string} */
  value = "overflow: hidden; ";
  /** @type {string} */
  var prefix = "width: 1px; ";
  /** @type {string} */
  var key = "height: 1px; ";
  /** @type {number} */
  var x = port.x * width;
  /** @type {number} */
  port = port.y * height;
  if (file) {
    /** @type {string} */
    prefix = "width: " + Math.round(width) + "px; ";
    /** @type {string} */
    result = result + ("max-height: " + Math.round(height) + "px; ");
    /** @type {number} */
    port = 0;
  } else {
    if ("fill" == undefined) {
      /** @type {string} */
      prefix = "width: " + Math.round(width) + "px; ";
      /** @type {string} */
      key = "height: " + Math.round(height) + "px; ";
      /** @type {string} */
      pos = pos + "width: 100%; height: 100%; ";
      /** @type {string} */
      result = result + ("width: " + Math.round(width - 2) + "px; " + key);
    } else {
      if ("width" == undefined) {
        /** @type {string} */
        prefix = "width: " + Math.round(width - 2) + "px; ";
        /** @type {string} */
        pos = pos + "width: 100%; ";
        /** @type {string} */
        result = result + prefix;
        /** @type {number} */
        port = 0;
        if (0 < height) {
          /** @type {string} */
          result = result + ("max-height: " + Math.round(height) + "px; ");
        }
      } else {
        if ("block" == undefined) {
          /** @type {string} */
          prefix = "width: " + Math.round(width - 2) + "px; ";
          /** @type {string} */
          pos = pos + "width: 100%; ";
          /** @type {string} */
          value = "";
          /** @type {number} */
          port = 0;
          /** @type {string} */
          result = result + prefix;
          if ("middle" == name) {
            /** @type {string} */
            result = result + ("max-height: " + Math.round(height) + "px; ");
          }
        } else {
          /** @type {string} */
          value = "";
          /** @type {number} */
          port = 0;
        }
      }
    }
  }
  /** @type {string} */
  height = "";
  if (null != error) {
    /** @type {string} */
    height = height + ("background-color: " + error + "; ");
  }
  if (null != rules) {
    /** @type {string} */
    height = height + ("border: 1px solid " + rules + "; ");
  }
  if ("" == value || file) {
    /** @type {string} */
    pos = pos + height;
  } else {
    /** @type {string} */
    result = result + height;
  }
  if (method && 0 < width) {
    /** @type {string} */
    pos = pos + ("white-space: normal; word-wrap: " + mxConstants.WORD_WRAP + "; ");
    /** @type {string} */
    prefix = "width: " + Math.round(width) + "px; ";
    if ("" != value && "fill" != undefined) {
      /** @type {number} */
      port = 0;
    }
  } else {
    /** @type {string} */
    pos = pos + "white-space: nowrap; ";
    if ("" == value && "block" != undefined) {
      /** @type {number} */
      x = 0;
    }
  }
  log(x, port, rule + prefix + key, result + value, pos, value);
};
/**
 * @return {?}
 */
mxSvgCanvas2D.prototype.getTextCss = function() {
  var obj = this.state;
  /** @type {string} */
  var encrypted = "display: inline-block; font-size: " + obj.fontSize + "px; font-family: " + obj.fontFamily + "; color: " + obj.fontColor + "; line-height: " + (mxConstants.ABSOLUTE_LINE_HEIGHT ? obj.fontSize * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT * this.lineHeightCorrection) + "; pointer-events: " + (this.pointerEvents ? this.pointerEventsValue : "none") + "; ";
  if ((obj.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
    /** @type {string} */
    encrypted = encrypted + "font-weight: bold; ";
  }
  if ((obj.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
    /** @type {string} */
    encrypted = encrypted + "font-style: italic; ";
  }
  /** @type {!Array} */
  var textDecorations = [];
  if ((obj.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    textDecorations.push("underline");
  }
  if ((obj.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
    textDecorations.push("line-through");
  }
  if (0 < textDecorations.length) {
    /** @type {string} */
    encrypted = encrypted + ("text-decoration: " + textDecorations.join(" ") + "; ");
  }
  return encrypted;
};
/**
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @param {!Object} str
 * @param {string} align
 * @param {boolean} valign
 * @param {string} wrap
 * @param {string} mode
 * @param {string} group
 * @param {boolean} data
 * @param {number} name
 * @param {?} dir
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.text = function(x, y, w, h, str, align, valign, wrap, mode, group, data, name, dir) {
  if (this.textEnabled && null != str) {
    if (name = null != name ? name : 0, this.foEnabled && "html" == mode) {
      var div = this.createDiv(str);
      if (null != div) {
        if (null != dir) {
          div.setAttribute("dir", dir);
        }
        this.addForeignObject(x, y, w, h, str, align, valign, wrap, mode, group, data, name, dir, div, this.root);
      }
    } else {
      this.plainText(x + this.state.dx, y + this.state.dy, w, h, str, align, valign, wrap, group, data, name, dir);
    }
  }
};
/**
 * @param {?} v
 * @param {?} a
 * @param {?} b
 * @param {?} r
 * @return {?}
 */
mxSvgCanvas2D.prototype.createClip = function(v, a, b, r) {
  /** @type {number} */
  v = Math.round(v);
  /** @type {number} */
  a = Math.round(a);
  /** @type {number} */
  b = Math.round(b);
  /** @type {number} */
  r = Math.round(r);
  /** @type {string} */
  var parent = "mx-clip-" + v + "-" + a + "-" + b + "-" + r;
  /** @type {number} */
  var i = 0;
  /** @type {string} */
  var node = parent + "-" + i;
  for (; null != document.getElementById(node);) {
    /** @type {string} */
    node = parent + "-" + ++i;
  }
  parent = this.createElement("clipPath");
  parent.setAttribute("id", node);
  node = this.createElement("rect");
  node.setAttribute("x", v);
  node.setAttribute("y", a);
  node.setAttribute("width", b);
  node.setAttribute("height", r);
  parent.appendChild(node);
  return parent;
};
/**
 * @param {string} id
 * @return {?}
 */
mxSvgCanvas2D.prototype.createClipPathId = function(id) {
  id = "mx-clippath-" + id.replace(/[^a-zA-Z0-9]+/g, "-");
  /** @type {string} */
  var prefix = "-" == id.charAt(id.length - 1) ? "" : "-";
  /** @type {number} */
  var i = 0;
  /** @type {string} */
  var d = id + prefix + i;
  for (; null != document.getElementById(d);) {
    /** @type {string} */
    d = id + prefix + ++i;
  }
  return d;
};
/**
 * @param {!Object} i
 * @param {string} url
 * @param {!Object} data
 * @return {?}
 */
mxSvgCanvas2D.prototype.appendClipPath = function(i, url, data) {
  var d = url.match(/\(([^)]+)\)/);
  /** @type {null} */
  var barShape = null;
  if ("polygon" == url.substring(0, 7)) {
    barShape = this.appendPolygonClip(d[1], i, data);
  } else {
    if ("circle" == url.substring(0, 6)) {
      barShape = this.appendCircleClip(d[1], i, data);
    } else {
      if ("ellipse" == url.substring(0, 7)) {
        barShape = this.appendEllipseClip(d[1], i, data);
      } else {
        if ("inset" == url.substring(0, 5)) {
          barShape = this.appendInsetClip(d[1], i, data);
        }
      }
    }
  }
  return barShape;
};
/**
 * @param {number} value
 * @param {!Object} $target
 * @param {!Object} $elem
 * @return {?}
 */
mxSvgCanvas2D.prototype.appendPolygonClip = function(value, $target, $elem) {
  $elem = this.createElement("polygon");
  value = value.split(/[ ,]+/);
  /** @type {null} */
  var x = null;
  /** @type {null} */
  var k = null;
  /** @type {null} */
  var len = null;
  /** @type {null} */
  var i = null;
  /** @type {!Array} */
  var _newBet = [];
  /** @type {number} */
  var m = 0;
  for (; m < value.length; m++) {
    var n = this.parseClipValue(value, m);
    if (0 == m % 2) {
      if (null == x || x > n) {
        x = n;
      }
      if (null == len || len < n) {
        len = n;
      }
    } else {
      if (null == k || k > n) {
        k = n;
      }
      if (null == i || i < n) {
        i = n;
      }
    }
    _newBet.push(n);
  }
  $elem.setAttribute("points", _newBet.join(","));
  $target.appendChild($elem);
  return new mxRectangle(x, k, len - x, i - k);
};
/**
 * @param {number} pos
 * @param {!Object} $target
 * @param {!Object} node
 * @return {?}
 */
mxSvgCanvas2D.prototype.appendCircleClip = function(pos, $target, node) {
  node = this.createElement("circle");
  var index = pos.split(/[ ,]+/);
  pos = this.parseClipValue(index, 0);
  var size = this.parseClipValue(index, 2);
  index = this.parseClipValue(index, 3);
  node.setAttribute("r", pos);
  node.setAttribute("cx", size);
  node.setAttribute("cy", index);
  $target.appendChild(node);
  return new mxRectangle(size - pos, index - pos, 2 * pos, 2 * pos);
};
/**
 * @param {number} d
 * @param {!Object} q
 * @param {!Object} el
 * @return {?}
 */
mxSvgCanvas2D.prototype.appendEllipseClip = function(d, q, el) {
  el = this.createElement("ellipse");
  var i = d.split(/[ ,]+/);
  d = this.parseClipValue(i, 0);
  var h = this.parseClipValue(i, 1);
  var s = this.parseClipValue(i, 3);
  i = this.parseClipValue(i, 4);
  el.setAttribute("rx", d);
  el.setAttribute("ry", h);
  el.setAttribute("cx", s);
  el.setAttribute("cy", i);
  q.appendChild(el);
  return new mxRectangle(s - d, i - h, 2 * d, 2 * h);
};
/**
 * @param {number} y
 * @param {!Object} settings
 * @param {!Object} node
 * @return {?}
 */
mxSvgCanvas2D.prototype.appendInsetClip = function(y, settings, node) {
  node = this.createElement("rect");
  var x = y.split(/[ ,]+/);
  y = this.parseClipValue(x, 0);
  var c = this.parseClipValue(x, 1);
  var width = this.parseClipValue(x, 2);
  var b = this.parseClipValue(x, 3);
  /** @type {number} */
  c = 1 - c - b;
  /** @type {number} */
  width = 1 - y - width;
  node.setAttribute("x", b);
  node.setAttribute("y", y);
  node.setAttribute("width", c);
  node.setAttribute("height", width);
  if (4 < x.length && "round" == x[4]) {
    x = this.parseClipValue(x, 5);
    node.setAttribute("rx", x);
    node.setAttribute("ry", x);
  }
  settings.appendChild(node);
  return new mxRectangle(b, y, c, width);
};
/**
 * @param {number} attr
 * @param {string} value
 * @return {?}
 */
mxSvgCanvas2D.prototype.parseClipValue = function(attr, value) {
  value = attr[Math.min(value, attr.length - 1)];
  /** @type {number} */
  attr = 1;
  if ("center" == value) {
    /** @type {number} */
    attr = .5;
  } else {
    if ("top" == value || "left" == value) {
      /** @type {number} */
      attr = 0;
    } else {
      /** @type {number} */
      value = parseFloat(value);
      if (!isNaN(value)) {
        /** @type {number} */
        attr = Math.max(0, Math.min(1, value / 100));
      }
    }
  }
  return attr;
};
/**
 * @param {!Element} rect
 * @param {!Node} element
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.setClip = function(rect, element) {
  if (null != this.defs) {
    this.defs.appendChild(element);
  } else {
    this.root.appendChild(element);
  }
  if (mxClient.IS_CHROMEAPP || mxClient.IS_IE || mxClient.IS_IE11 || mxClient.IS_EDGE || this.root.ownerDocument != document) {
    rect.setAttribute("clip-path", "url(#" + element.getAttribute("id") + ")");
  } else {
    var _ddoc = this.getBaseUrl().replace(/([\(\)])/g, "\\$1");
    rect.setAttribute("clip-path", "url(" + _ddoc + "#" + element.getAttribute("id") + ")");
  }
};
/**
 * @param {number} fontSize
 * @param {string} x
 * @param {number} width
 * @param {number} w
 * @param {!Object} text
 * @param {string} align
 * @param {string} valign
 * @param {!Object} opts
 * @param {string} undefined
 * @param {number} j
 * @param {number} i
 * @param {number} y
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.plainText = function(fontSize, x, width, w, text, align, valign, opts, undefined, j, i, y) {
  i = null != i ? i : 0;
  opts = this.state;
  var h = opts.fontSize;
  var node = this.createElement("g");
  var params = opts.transform || "";
  this.updateFont(node);
  if (!(this.pointerEvents || null != this.originalRoot)) {
    node.setAttribute("pointer-events", "none");
  }
  if (0 != i) {
    /** @type {string} */
    params = params + ("rotate(" + i + "," + this.format(fontSize * opts.scale) + "," + this.format(x * opts.scale) + ")");
  }
  if (null != y) {
    node.setAttribute("direction", y);
  }
  if (j && 0 < width && 0 < w) {
    /** @type {number} */
    y = fontSize;
    /** @type {string} */
    i = x;
    if (align == mxConstants.ALIGN_CENTER) {
      /** @type {number} */
      y = y - width / 2;
    } else {
      if (align == mxConstants.ALIGN_RIGHT) {
        /** @type {number} */
        y = y - width;
      }
    }
    if ("fill" != undefined) {
      if (valign == mxConstants.ALIGN_MIDDLE) {
        /** @type {number} */
        i = i - w / 2;
      } else {
        if (valign == mxConstants.ALIGN_BOTTOM) {
          /** @type {number} */
          i = i - w;
        }
      }
    }
    this.setClip(node, this.createClip(y * opts.scale - 2, i * opts.scale - 2, width * opts.scale + 4, w * opts.scale + 4));
  }
  /** @type {string} */
  i = align == mxConstants.ALIGN_RIGHT ? "end" : align == mxConstants.ALIGN_CENTER ? "middle" : "start";
  if ("start" != i) {
    node.setAttribute("text-anchor", i);
  }
  if (!(this.styleEnabled && h == mxConstants.DEFAULT_FONTSIZE)) {
    node.setAttribute("font-size", h * opts.scale + "px");
  }
  if (0 < params.length) {
    node.setAttribute("transform", params);
  }
  if (1 > opts.alpha) {
    node.setAttribute("opacity", opts.alpha);
  }
  params = text.split("\n");
  /** @type {number} */
  y = Math.round(h * mxConstants.LINE_HEIGHT);
  var height = h + (params.length - 1) * y;
  /** @type {number} */
  i = x + h - 1;
  if (valign == mxConstants.ALIGN_MIDDLE) {
    if ("fill" == undefined) {
      /** @type {number} */
      i = i - w / 2;
    } else {
      /** @type {number} */
      j = (this.matchHtmlAlignment && j && 0 < w ? Math.min(height, w) : height) / 2;
      /** @type {number} */
      i = i - j;
    }
  } else {
    if (valign == mxConstants.ALIGN_BOTTOM) {
      if ("fill" == undefined) {
        /** @type {number} */
        i = i - w;
      } else {
        j = this.matchHtmlAlignment && j && 0 < w ? Math.min(height, w) : height;
        /** @type {number} */
        i = i - (j + 1);
      }
    }
  }
  /** @type {number} */
  j = 0;
  for (; j < params.length; j++) {
    if (0 < params[j].length && 0 < mxUtils.trim(params[j]).length) {
      h = this.createElement("text");
      h.setAttribute("x", this.format(fontSize * opts.scale) + this.textOffset);
      h.setAttribute("y", this.format(i * opts.scale) + this.textOffset);
      mxUtils.write(h, params[j]);
      node.appendChild(h);
    }
    /** @type {number} */
    i = i + y;
  }
  this.root.appendChild(node);
  this.addTextBackground(node, text, fontSize, x, width, "fill" == undefined ? w : height, align, valign, undefined);
};
/**
 * @param {!Element} t
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.updateFont = function(t) {
  var obj = this.state;
  t.setAttribute("fill", obj.fontColor);
  if (!(this.styleEnabled && obj.fontFamily == mxConstants.DEFAULT_FONTFAMILY)) {
    t.setAttribute("font-family", obj.fontFamily);
  }
  if ((obj.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
    t.setAttribute("font-weight", "bold");
  }
  if ((obj.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
    t.setAttribute("font-style", "italic");
  }
  /** @type {!Array} */
  var textDecorations = [];
  if ((obj.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    textDecorations.push("underline");
  }
  if ((obj.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
    textDecorations.push("line-through");
  }
  if (0 < textDecorations.length) {
    t.setAttribute("text-decoration", textDecorations.join(" "));
  }
};
/**
 * @param {!Element} item
 * @param {!Object} element
 * @param {number} y
 * @param {number} x
 * @param {number} h
 * @param {number} size
 * @param {string} align
 * @param {string} valign
 * @param {string} undefined
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.addTextBackground = function(item, element, y, x, h, size, align, valign, undefined) {
  var s = this.state;
  if (null != s.fontBackgroundColor || null != s.fontBorderColor) {
    /** @type {null} */
    var el = null;
    if ("fill" == undefined || "width" == undefined) {
      if (align == mxConstants.ALIGN_CENTER) {
        /** @type {number} */
        y = y - h / 2;
      } else {
        if (align == mxConstants.ALIGN_RIGHT) {
          /** @type {number} */
          y = y - h;
        }
      }
      if (valign == mxConstants.ALIGN_MIDDLE) {
        /** @type {number} */
        x = x - size / 2;
      } else {
        if (valign == mxConstants.ALIGN_BOTTOM) {
          /** @type {number} */
          x = x - size;
        }
      }
      el = new mxRectangle((y + 1) * s.scale, x * s.scale, (h - 2) * s.scale, (size + 2) * s.scale);
    } else {
      if (null != item.getBBox && this.root.ownerDocument == document) {
        try {
          el = item.getBBox();
          var rotate = mxClient.IS_IE && mxClient.IS_SVG;
          el = new mxRectangle(el.x, el.y + (rotate ? 0 : 1), el.width, el.height + (rotate ? 1 : 0));
        } catch (q) {
        }
      }
    }
    if (null == el || 0 == el.width || 0 == el.height) {
      /** @type {!Element} */
      el = document.createElement("div");
      el.style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? s.fontSize * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT;
      /** @type {string} */
      el.style.fontSize = s.fontSize + "px";
      el.style.fontFamily = s.fontFamily;
      /** @type {string} */
      el.style.whiteSpace = "nowrap";
      /** @type {string} */
      el.style.position = "absolute";
      /** @type {string} */
      el.style.visibility = "hidden";
      /** @type {string} */
      el.style.display = "inline-block";
      /** @type {string} */
      el.style.zoom = "1";
      if ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
        /** @type {string} */
        el.style.fontWeight = "bold";
      }
      if ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
        /** @type {string} */
        el.style.fontStyle = "italic";
      }
      element = mxUtils.htmlEntities(element, false);
      el.innerHTML = element.replace(/\n/g, "<br/>");
      document.body.appendChild(el);
      h = el.offsetWidth;
      size = el.offsetHeight;
      el.parentNode.removeChild(el);
      if (align == mxConstants.ALIGN_CENTER) {
        /** @type {number} */
        y = y - h / 2;
      } else {
        if (align == mxConstants.ALIGN_RIGHT) {
          /** @type {number} */
          y = y - h;
        }
      }
      if (valign == mxConstants.ALIGN_MIDDLE) {
        /** @type {number} */
        x = x - size / 2;
      } else {
        if (valign == mxConstants.ALIGN_BOTTOM) {
          /** @type {number} */
          x = x - size;
        }
      }
      el = new mxRectangle((y + 1) * s.scale, (x + 2) * s.scale, h * s.scale, (size + 1) * s.scale);
    }
    if (null != el) {
      element = this.createElement("rect");
      element.setAttribute("fill", s.fontBackgroundColor || "none");
      element.setAttribute("stroke", s.fontBorderColor || "none");
      element.setAttribute("x", Math.floor(el.x - 1));
      element.setAttribute("y", Math.floor(el.y - 1));
      element.setAttribute("width", Math.ceil(el.width + 2));
      element.setAttribute("height", Math.ceil(el.height));
      /** @type {number} */
      s = null != s.fontBorderColor ? Math.max(1, this.format(s.scale)) : 0;
      element.setAttribute("stroke-width", s);
      if (this.root.ownerDocument == document && 1 == mxUtils.mod(s, 2)) {
        element.setAttribute("transform", "translate(0.5, 0.5)");
      }
      item.insertBefore(element, item.firstChild);
    }
  }
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.stroke = function() {
  this.addNode(false, true);
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.fill = function() {
  this.addNode(true, false);
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.fillAndStroke = function() {
  this.addNode(true, true);
};
/**
 * @param {!Object} src
 * @param {!Object} out
 * @return {undefined}
 */
function mxGuide(src, out) {
  /** @type {!Object} */
  this.graph = src;
  this.setStates(out);
}
/** @type {null} */
mxGuide.prototype.graph = null;
/** @type {null} */
mxGuide.prototype.states = null;
/** @type {boolean} */
mxGuide.prototype.horizontal = true;
/** @type {boolean} */
mxGuide.prototype.vertical = true;
/** @type {null} */
mxGuide.prototype.guideX = null;
/** @type {null} */
mxGuide.prototype.guideY = null;
/** @type {boolean} */
mxGuide.prototype.rounded = false;
/** @type {number} */
mxGuide.prototype.tolerance = 2;
/**
 * @param {!Object} states
 * @return {undefined}
 */
mxGuide.prototype.setStates = function(states) {
  /** @type {!Object} */
  this.states = states;
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxGuide.prototype.isEnabledForEvent = function(evt) {
  return true;
};
/**
 * @param {number} targetRadian
 * @return {?}
 */
mxGuide.prototype.getGuideTolerance = function(targetRadian) {
  return targetRadian && this.graph.gridEnabled ? this.graph.gridSize / 2 : this.tolerance;
};
/**
 * @param {string} isIron
 * @return {?}
 */
mxGuide.prototype.createGuideShape = function(isIron) {
  isIron = new mxPolyline([], mxConstants.GUIDE_COLOR, mxConstants.GUIDE_STROKEWIDTH);
  /** @type {boolean} */
  isIron.isDashed = true;
  return isIron;
};
/**
 * @param {!Object} name
 * @return {?}
 */
mxGuide.prototype.isStateIgnored = function(name) {
  return false;
};
/**
 * @param {?} s
 * @param {!Object} t
 * @param {!Object} target
 * @param {!Object} callback
 * @return {?}
 */
mxGuide.prototype.move = function(s, t, target, callback) {
  if (null != this.states && (this.horizontal || this.vertical) && null != s && null != t) {
    /**
     * @param {number} y
     * @param {!Object} name
     * @param {boolean} frame
     * @return {undefined}
     */
    callback = function(y, name, frame) {
      /** @type {boolean} */
      var localModuleProblems = false;
      if (frame && Math.abs(y - heightVal) < start) {
        /** @type {number} */
        t.y = y - s.getCenterY();
        /** @type {number} */
        start = Math.abs(y - heightVal);
        /** @type {boolean} */
        localModuleProblems = true;
      } else {
        if (!frame) {
          if (Math.abs(y - Y) < start) {
            /** @type {number} */
            t.y = y - s.y;
            /** @type {number} */
            start = Math.abs(y - Y);
            /** @type {boolean} */
            localModuleProblems = true;
          } else {
            if (Math.abs(y - yR) < start) {
              /** @type {number} */
              t.y = y - s.y - s.height;
              /** @type {number} */
              start = Math.abs(y - yR);
              /** @type {boolean} */
              localModuleProblems = true;
            }
          }
        }
      }
      if (localModuleProblems) {
        /** @type {!Object} */
        v = name;
        /** @type {number} */
        bottom = y;
        if (null == this.guideY) {
          this.guideY = this.createGuideShape(false);
          this.guideY.dialect = mxConstants.DIALECT_SVG;
          /** @type {boolean} */
          this.guideY.pointerEvents = false;
          this.guideY.init(this.graph.getView().getOverlayPane());
        }
      }
      localProblems = localProblems || localModuleProblems;
    };
    /**
     * @param {number} x
     * @param {!Object} k
     * @param {boolean} n
     * @return {undefined}
     */
    var test = function(x, k, n) {
      /** @type {boolean} */
      var AVERAGE = false;
      if (n && Math.abs(x - intX) < idx) {
        /** @type {number} */
        t.x = x - s.getCenterX();
        /** @type {number} */
        idx = Math.abs(x - intX);
        /** @type {boolean} */
        AVERAGE = true;
      } else {
        if (!n) {
          if (Math.abs(x - X) < idx) {
            /** @type {number} */
            t.x = x - s.x;
            /** @type {number} */
            idx = Math.abs(x - X);
            /** @type {boolean} */
            AVERAGE = true;
          } else {
            if (Math.abs(x - oriX) < idx) {
              /** @type {number} */
              t.x = x - s.x - s.width;
              /** @type {number} */
              idx = Math.abs(x - oriX);
              /** @type {boolean} */
              AVERAGE = true;
            }
          }
        }
      }
      if (AVERAGE) {
        /** @type {!Object} */
        d = k;
        /** @type {number} */
        right = x;
        if (null == this.guideX) {
          this.guideX = this.createGuideShape(true);
          this.guideX.dialect = mxConstants.DIALECT_SVG;
          /** @type {boolean} */
          this.guideX.pointerEvents = false;
          this.guideX.init(this.graph.getView().getOverlayPane());
        }
      }
      cf = cf || AVERAGE;
    };
    var i = this.graph.getView().scale;
    /** @type {number} */
    i = i * this.getGuideTolerance(target);
    var p = s.clone();
    p.x += t.x;
    p.y += t.y;
    /** @type {boolean} */
    var cf = false;
    /** @type {null} */
    var d = null;
    /** @type {null} */
    var right = null;
    /** @type {boolean} */
    var localProblems = false;
    /** @type {null} */
    var v = null;
    /** @type {null} */
    var bottom = null;
    var idx = i;
    var start = i;
    var X = p.x;
    var oriX = p.x + p.width;
    var intX = p.getCenterX();
    var Y = p.y;
    var yR = p.y + p.height;
    var heightVal = p.getCenterY();
    /** @type {number} */
    i = 0;
    for (; i < this.states.length; i++) {
      p = this.states[i];
      if (!(null == p || this.isStateIgnored(p))) {
        if (this.horizontal) {
          test.call(this, p.getCenterX(), p, true);
          test.call(this, p.x, p, false);
          test.call(this, p.x + p.width, p, false);
          if (null == p.cell) {
            test.call(this, p.getCenterX(), p, false);
          }
        }
        if (this.vertical) {
          callback.call(this, p.getCenterY(), p, true);
          callback.call(this, p.y, p, false);
          callback.call(this, p.y + p.height, p, false);
          if (null == p.cell) {
            callback.call(this, p.getCenterY(), p, false);
          }
        }
      }
    }
    this.graph.snapDelta(t, s, !target, cf, localProblems);
    t = this.getDelta(s, d, t.x, v, t.y);
    target = this.graph.container;
    if (cf || null == this.guideX) {
      if (null != this.guideX) {
        /** @type {null} */
        test = callback = null;
        if (null != d && null != s) {
          /** @type {number} */
          callback = Math.min(s.y + t.y - this.graph.panDy, d.y);
          /** @type {number} */
          test = Math.max(s.y + s.height + t.y - this.graph.panDy, d.y + d.height);
        }
        /** @type {!Array} */
        this.guideX.points = null != callback && null != test ? [new mxPoint(right, callback), new mxPoint(right, test)] : [new mxPoint(right, -this.graph.panDy), new mxPoint(right, target.scrollHeight - 3 - this.graph.panDy)];
        this.guideX.stroke = this.getGuideColor(d, true);
        /** @type {string} */
        this.guideX.node.style.visibility = "visible";
        this.guideX.redraw();
      }
    } else {
      /** @type {string} */
      this.guideX.node.style.visibility = "hidden";
    }
    if (localProblems || null == this.guideY) {
      if (null != this.guideY) {
        /** @type {null} */
        test = callback = null;
        if (null != v && null != s) {
          /** @type {number} */
          callback = Math.min(s.x + t.x - this.graph.panDx, v.x);
          /** @type {number} */
          test = Math.max(s.x + s.width + t.x - this.graph.panDx, v.x + v.width);
        }
        /** @type {!Array} */
        this.guideY.points = null != callback && null != test ? [new mxPoint(callback, bottom), new mxPoint(test, bottom)] : [new mxPoint(-this.graph.panDx, bottom), new mxPoint(target.scrollWidth - 3 - this.graph.panDx, bottom)];
        this.guideY.stroke = this.getGuideColor(v, false);
        /** @type {string} */
        this.guideY.node.style.visibility = "visible";
        this.guideY.redraw();
      }
    } else {
      /** @type {string} */
      this.guideY.node.style.visibility = "hidden";
    }
  }
  return t;
};
/**
 * @param {!Object} path
 * @param {?} e
 * @param {number} n
 * @param {?} event
 * @param {number} diff
 * @return {?}
 */
mxGuide.prototype.getDelta = function(path, e, n, event, diff) {
  var ratio = this.graph.view.scale;
  if (this.rounded || null != e && null == e.cell) {
    /** @type {number} */
    n = Math.round((path.x + n) / ratio) * ratio - path.x;
  }
  if (this.rounded || null != event && null == event.cell) {
    /** @type {number} */
    diff = Math.round((path.y + diff) / ratio) * ratio - path.y;
  }
  return new mxPoint(n, diff);
};
/**
 * @param {?} a
 * @param {boolean} be
 * @return {?}
 */
mxGuide.prototype.getGuideColor = function(a, be) {
  return mxConstants.GUIDE_COLOR;
};
/**
 * @return {undefined}
 */
mxGuide.prototype.hide = function() {
  this.setVisible(false);
};
/**
 * @param {boolean} visible
 * @return {undefined}
 */
mxGuide.prototype.setVisible = function(visible) {
  if (null != this.guideX) {
    /** @type {string} */
    this.guideX.node.style.visibility = visible ? "visible" : "hidden";
  }
  if (null != this.guideY) {
    /** @type {string} */
    this.guideY.node.style.visibility = visible ? "visible" : "hidden";
  }
};
/**
 * @return {undefined}
 */
mxGuide.prototype.destroy = function() {
  if (null != this.guideX) {
    this.guideX.destroy();
    /** @type {null} */
    this.guideX = null;
  }
  if (null != this.guideY) {
    this.guideY.destroy();
    /** @type {null} */
    this.guideY = null;
  }
};
/**
 * @param {!Object} enable
 * @return {undefined}
 */
function mxShape(enable) {
  /** @type {!Object} */
  this.stencil = enable;
  this.initStyles();
}
/** @type {null} */
mxShape.prototype.dialect = null;
/** @type {number} */
mxShape.prototype.scale = 1;
/** @type {boolean} */
mxShape.prototype.antiAlias = true;
/** @type {number} */
mxShape.prototype.minSvgStrokeWidth = 1;
/** @type {null} */
mxShape.prototype.bounds = null;
/** @type {null} */
mxShape.prototype.points = null;
/** @type {null} */
mxShape.prototype.node = null;
/** @type {null} */
mxShape.prototype.state = null;
/** @type {null} */
mxShape.prototype.style = null;
/** @type {null} */
mxShape.prototype.boundingBox = null;
/** @type {null} */
mxShape.prototype.stencil = null;
/** @type {number} */
mxShape.prototype.svgStrokeTolerance = 8;
/** @type {boolean} */
mxShape.prototype.pointerEvents = true;
/** @type {string} */
mxShape.prototype.svgPointerEvents = "all";
/** @type {boolean} */
mxShape.prototype.shapePointerEvents = false;
/** @type {boolean} */
mxShape.prototype.stencilPointerEvents = false;
/** @type {boolean} */
mxShape.prototype.outline = false;
/** @type {boolean} */
mxShape.prototype.visible = true;
/** @type {boolean} */
mxShape.prototype.useSvgBoundingBox = false;
/**
 * @param {!Object} node
 * @return {undefined}
 */
mxShape.prototype.init = function(node) {
  if (null == this.node) {
    this.node = this.create(node);
    if (null != node) {
      node.appendChild(this.node);
    }
  }
};
/**
 * @param {?} value
 * @return {undefined}
 */
mxShape.prototype.initStyles = function(value) {
  /** @type {number} */
  this.strokewidth = 1;
  /** @type {number} */
  this.rotation = 0;
  /** @type {number} */
  this.strokeOpacity = this.fillOpacity = this.opacity = 100;
  /** @type {boolean} */
  this.flipV = this.flipH = false;
};
/**
 * @return {?}
 */
mxShape.prototype.isHtmlAllowed = function() {
  return false;
};
/**
 * @return {?}
 */
mxShape.prototype.getSvgScreenOffset = function() {
  return 1 == mxUtils.mod(Math.max(1, Math.round((this.stencil && "inherit" != this.stencil.strokewidth ? Number(this.stencil.strokewidth) : this.strokewidth) * this.scale)), 2) ? .5 : 0;
};
/**
 * @param {!Object} obj
 * @return {?}
 */
mxShape.prototype.create = function(obj) {
  return null != obj && null != obj.ownerSVGElement ? this.createSvg(obj) : this.createHtml(obj);
};
/**
 * @return {?}
 */
mxShape.prototype.createSvg = function() {
  return document.createElementNS(mxConstants.NS_SVG, "g");
};
/**
 * @return {?}
 */
mxShape.prototype.createHtml = function() {
  /** @type {!Element} */
  var b = document.createElement("div");
  /** @type {string} */
  b.style.position = "absolute";
  return b;
};
/**
 * @return {undefined}
 */
mxShape.prototype.reconfigure = function() {
  this.redraw();
};
/**
 * @return {undefined}
 */
mxShape.prototype.redraw = function() {
  this.updateBoundsFromPoints();
  if (this.visible && this.checkBounds()) {
    /** @type {string} */
    this.node.style.visibility = "visible";
    this.clear();
    if ("DIV" == this.node.nodeName) {
      this.redrawHtmlShape();
    } else {
      this.redrawShape();
    }
    this.updateBoundingBox();
  } else {
    /** @type {string} */
    this.node.style.visibility = "hidden";
    /** @type {null} */
    this.boundingBox = null;
  }
};
/**
 * @return {undefined}
 */
mxShape.prototype.clear = function() {
  if (null != this.node.ownerSVGElement) {
    for (; null != this.node.lastChild;) {
      this.node.removeChild(this.node.lastChild);
    }
  } else {
    /** @type {string} */
    this.node.style.cssText = "position:absolute;" + (null != this.cursor ? "cursor:" + this.cursor + ";" : "");
    /** @type {string} */
    this.node.innerText = "";
  }
};
/**
 * @return {undefined}
 */
mxShape.prototype.updateBoundsFromPoints = function() {
  var points = this.points;
  if (null != points && 0 < points.length && null != points[0]) {
    this.bounds = new mxRectangle(Number(points[0].x), Number(points[0].y), 1, 1);
    /** @type {number} */
    var i = 1;
    for (; i < this.points.length; i++) {
      if (null != points[i]) {
        this.bounds.add(new mxRectangle(Number(points[i].x), Number(points[i].y), 1, 1));
      }
    }
  }
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxShape.prototype.getLabelBounds = function(value) {
  var r = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
  /** @type {!Object} */
  var c = value;
  if (r != mxConstants.DIRECTION_SOUTH && r != mxConstants.DIRECTION_NORTH && null != this.state && null != this.state.text && this.state.text.isPaintBoundsInverted()) {
    c = c.clone();
    r = c.width;
    c.width = c.height;
    c.height = r;
  }
  c = this.getLabelMargins(c);
  if (null != c) {
    /** @type {boolean} */
    var root = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, false);
    /** @type {boolean} */
    var rootNode = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, false);
    if (null != this.state && null != this.state.text && this.state.text.isPaintBoundsInverted()) {
      r = c.x;
      c.x = c.height;
      c.height = c.width;
      c.width = c.y;
      c.y = r;
      /** @type {boolean} */
      r = root;
      /** @type {boolean} */
      root = rootNode;
      /** @type {boolean} */
      rootNode = r;
    }
    return mxUtils.getDirectedBounds(value, c, this.style, root, rootNode);
  }
  return value;
};
/**
 * @param {?} n22
 * @return {?}
 */
mxShape.prototype.getLabelMargins = function(n22) {
  return null;
};
/**
 * @return {?}
 */
mxShape.prototype.checkBounds = function() {
  return !isNaN(this.scale) && isFinite(this.scale) && 0 < this.scale && null != this.bounds && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height) && 0 < this.bounds.width && 0 < this.bounds.height;
};
/**
 * @return {undefined}
 */
mxShape.prototype.redrawShape = function() {
  var self = this.createCanvas();
  if (null != self) {
    self.pointerEvents = this.pointerEvents;
    this.beforePaint(self);
    this.paint(self);
    this.afterPaint(self);
    if (this.node != self.root) {
      this.node.insertAdjacentHTML("beforeend", self.root.outerHTML);
    }
    if ("DIV" == this.node.nodeName && 8 == document.documentMode) {
      /** @type {string} */
      this.node.style.filter = "";
      mxUtils.addTransparentBackgroundFilter(this.node);
    }
    this.destroyCanvas(self);
  }
};
/**
 * @return {?}
 */
mxShape.prototype.createCanvas = function() {
  /** @type {null} */
  var ctx = null;
  if (null != this.node.ownerSVGElement) {
    ctx = this.createSvgCanvas();
  }
  if (null != ctx && this.outline) {
    ctx.setStrokeWidth(this.strokewidth);
    ctx.setStrokeColor(this.stroke);
    if (null != this.isDashed) {
      ctx.setDashed(this.isDashed);
    }
    /**
     * @return {undefined}
     */
    ctx.setStrokeWidth = function() {
    };
    /**
     * @return {undefined}
     */
    ctx.setStrokeColor = function() {
    };
    /**
     * @return {undefined}
     */
    ctx.setFillColor = function() {
    };
    /**
     * @return {undefined}
     */
    ctx.setGradient = function() {
    };
    /**
     * @return {undefined}
     */
    ctx.setDashed = function() {
    };
    /**
     * @return {undefined}
     */
    ctx.text = function() {
    };
  }
  return ctx;
};
/**
 * @return {?}
 */
mxShape.prototype.createSvgCanvas = function() {
  var utils = new mxSvgCanvas2D(this.node, false);
  utils.strokeTolerance = this.svgStrokeTolerance;
  utils.pointerEventsValue = this.svgPointerEvents;
  var b = this.getSvgScreenOffset();
  if (0 != b) {
    this.node.setAttribute("transform", "translate(" + b + "," + b + ")");
  } else {
    this.node.removeAttribute("transform");
  }
  utils.minStrokeWidth = this.minSvgStrokeWidth;
  if (!this.antiAlias) {
    /**
     * @param {number} str
     * @return {?}
     */
    utils.format = function(str) {
      return Math.round(parseFloat(str));
    };
  }
  return utils;
};
/**
 * @return {undefined}
 */
mxShape.prototype.redrawHtmlShape = function() {
  this.updateHtmlBounds(this.node);
  this.updateHtmlFilters(this.node);
  this.updateHtmlColors(this.node);
};
/**
 * @param {!Element} a
 * @return {undefined}
 */
mxShape.prototype.updateHtmlFilters = function(a) {
  /** @type {string} */
  var style = "";
  if (100 > this.opacity) {
    /** @type {string} */
    style = style + ("alpha(opacity=" + this.opacity + ")");
  }
  if (this.isShadow) {
    /** @type {string} */
    style = style + ("progid:DXImageTransform.Microsoft.dropShadow (OffX='" + Math.round(mxConstants.SHADOW_OFFSET_X * this.scale) + "', OffY='" + Math.round(mxConstants.SHADOW_OFFSET_Y * this.scale) + "', Color='" + mxConstants.VML_SHADOWCOLOR + "')");
  }
  if (null != this.fill && this.fill != mxConstants.NONE && this.gradient && this.gradient != mxConstants.NONE) {
    var Infinity = this.fill;
    var gradient = this.gradient;
    /** @type {string} */
    var e = "0";
    var bounds = {
      east : 0,
      south : 1,
      west : 2,
      north : 3
    };
    var minX = null != this.direction ? bounds[this.direction] : 0;
    if (null != this.gradientDirection) {
      minX = mxUtils.mod(minX + bounds[this.gradientDirection] - 1, 4);
    }
    if (1 == minX) {
      /** @type {string} */
      e = "1";
      bounds = Infinity;
      Infinity = gradient;
      gradient = bounds;
    } else {
      if (2 == minX) {
        bounds = Infinity;
        Infinity = gradient;
        gradient = bounds;
      } else {
        if (3 == minX) {
          /** @type {string} */
          e = "1";
        }
      }
    }
    /** @type {string} */
    style = style + ("progid:DXImageTransform.Microsoft.gradient(startColorStr='" + Infinity + "', endColorStr='" + gradient + "', gradientType='" + e + "')");
  }
  /** @type {string} */
  a.style.filter = style;
};
/**
 * @param {!Element} e
 * @return {undefined}
 */
mxShape.prototype.updateHtmlColors = function(e) {
  var value = this.stroke;
  if (null != value && value != mxConstants.NONE) {
    e.style.borderColor = value;
    if (this.isDashed) {
      /** @type {string} */
      e.style.borderStyle = "dashed";
    } else {
      if (0 < this.strokewidth) {
        /** @type {string} */
        e.style.borderStyle = "solid";
      }
    }
    /** @type {string} */
    e.style.borderWidth = Math.max(1, Math.ceil(this.strokewidth * this.scale)) + "px";
  } else {
    /** @type {string} */
    e.style.borderWidth = "0px";
  }
  value = this.outline ? null : this.fill;
  if (null != value && value != mxConstants.NONE) {
    e.style.backgroundColor = value;
    /** @type {string} */
    e.style.backgroundImage = "none";
  } else {
    if (this.pointerEvents) {
      /** @type {string} */
      e.style.backgroundColor = "transparent";
    } else {
      if (8 == document.documentMode) {
        mxUtils.addTransparentBackgroundFilter(e);
      } else {
        this.setTransparentBackgroundImage(e);
      }
    }
  }
};
/**
 * @param {!Element} div
 * @return {undefined}
 */
mxShape.prototype.updateHtmlBounds = function(div) {
  /** @type {number} */
  var radius = 9 <= document.documentMode ? 0 : Math.ceil(this.strokewidth * this.scale);
  /** @type {string} */
  div.style.borderWidth = Math.max(1, radius) + "px";
  /** @type {string} */
  div.style.overflow = "hidden";
  /** @type {string} */
  div.style.left = Math.round(this.bounds.x - radius / 2) + "px";
  /** @type {string} */
  div.style.top = Math.round(this.bounds.y - radius / 2) + "px";
  if ("CSS1Compat" == document.compatMode) {
    /** @type {number} */
    radius = -radius;
  }
  /** @type {string} */
  div.style.width = Math.round(Math.max(0, this.bounds.width + radius)) + "px";
  /** @type {string} */
  div.style.height = Math.round(Math.max(0, this.bounds.height + radius)) + "px";
};
/**
 * @param {!AudioNode} self
 * @return {undefined}
 */
mxShape.prototype.destroyCanvas = function(self) {
  if (self instanceof mxSvgCanvas2D) {
    var i;
    for (i in self.gradients) {
      var instanceAndSymbol = self.gradients[i];
      if (null != instanceAndSymbol) {
        instanceAndSymbol.mxRefCount = (instanceAndSymbol.mxRefCount || 0) + 1;
      }
    }
    for (i in self.fillPatterns) {
      instanceAndSymbol = self.fillPatterns[i];
      if (null != instanceAndSymbol) {
        instanceAndSymbol.mxRefCount = (instanceAndSymbol.mxRefCount || 0) + 1;
      }
    }
    this.releaseSvgGradients(this.oldGradients);
    this.releaseSvgFillPatterns(this.oldFillPatterns);
    this.oldGradients = self.gradients;
    this.oldFillPatterns = self.fillPatterns;
  }
};
/**
 * @param {!Object} canvas
 * @return {undefined}
 */
mxShape.prototype.beforePaint = function(canvas) {
};
/**
 * @param {!Object} canvas
 * @return {undefined}
 */
mxShape.prototype.afterPaint = function(canvas) {
};
/**
 * @param {!Object} canvas
 * @return {undefined}
 */
mxShape.prototype.paint = function(canvas) {
  /** @type {boolean} */
  var c = false;
  if (null != canvas && this.outline) {
    var ctx = canvas.stroke;
    /**
     * @return {undefined}
     */
    canvas.stroke = function() {
      /** @type {boolean} */
      c = true;
      ctx.apply(this, arguments);
    };
    var original = canvas.fillAndStroke;
    /**
     * @return {undefined}
     */
    canvas.fillAndStroke = function() {
      /** @type {boolean} */
      c = true;
      original.apply(this, arguments);
    };
  }
  var d = this.scale;
  /** @type {number} */
  var x = this.bounds.x / d;
  /** @type {number} */
  var b = this.bounds.y / d;
  /** @type {number} */
  var y = this.bounds.width / d;
  /** @type {number} */
  var r = this.bounds.height / d;
  if (this.isPaintBoundsInverted()) {
    /** @type {number} */
    var a = (y - r) / 2;
    /** @type {number} */
    x = x + a;
    /** @type {number} */
    b = b - a;
    /** @type {number} */
    a = y;
    /** @type {number} */
    y = r;
    /** @type {number} */
    r = a;
  }
  this.updateTransform(canvas, x, b, y, r);
  this.configureCanvas(canvas, x, b, y, r);
  /** @type {null} */
  a = null;
  if (null == this.stencil && null == this.points && this.shapePointerEvents || null != this.stencil && this.stencilPointerEvents) {
    var b = this.createBoundingBox();
    if (this.dialect == mxConstants.DIALECT_SVG) {
      a = this.createTransparentSvgRectangle(b.x, b.y, b.width, b.height);
      this.node.appendChild(a);
    } else {
      d = canvas.createRect("rect", b.x / d, b.y / d, b.width / d, b.height / d);
      d.appendChild(canvas.createTransparentFill());
      /** @type {string} */
      d.stroked = "false";
      canvas.root.appendChild(d);
    }
  }
  if (null != this.stencil) {
    this.stencil.drawShape(canvas, this, x, b, y, r);
  } else {
    canvas.setStrokeWidth(this.strokewidth);
    d = this.getWaypoints();
    if (null != d) {
      if (1 < d.length) {
        this.paintEdgeShape(canvas, d);
      }
    } else {
      this.paintVertexShape(canvas, x, b, y, r);
    }
  }
  if (null != a && null != canvas.state && null != canvas.state.transform) {
    a.setAttribute("transform", canvas.state.transform);
  }
  if (null != canvas && this.outline && !c) {
    canvas.rect(x, b, y, r);
    canvas.stroke();
  }
};
/**
 * @return {?}
 */
mxShape.prototype.getWaypoints = function() {
  var points = this.points;
  /** @type {null} */
  var latLngs = null;
  if (null != points && (latLngs = [], 0 < points.length)) {
    var scale = this.scale;
    /** @type {number} */
    var $overView = Math.max(scale, 1);
    var point1 = points[0];
    latLngs.push(new mxPoint(point1.x / scale, point1.y / scale));
    /** @type {number} */
    var i = 1;
    for (; i < points.length; i++) {
      var point2 = points[i];
      if (Math.abs(point1.x - point2.x) >= $overView || Math.abs(point1.y - point2.y) >= $overView) {
        latLngs.push(new mxPoint(point2.x / scale, point2.y / scale));
      }
      point1 = point2;
    }
  }
  return latLngs;
};
/**
 * @param {!CanvasRenderingContext2D} ctx
 * @param {number} style
 * @param {number} props
 * @param {number} element
 * @param {number} y
 * @return {undefined}
 */
mxShape.prototype.configureCanvas = function(ctx, style, props, element, y) {
  /** @type {null} */
  var fontSize = null;
  if (null != this.style) {
    fontSize = this.style.dashPattern;
  }
  ctx.setAlpha(this.opacity / 100);
  ctx.setFillAlpha(this.fillOpacity / 100);
  ctx.setStrokeAlpha(this.strokeOpacity / 100);
  if (null != this.isShadow) {
    ctx.setShadow(this.isShadow);
  }
  if (null != this.isDashed) {
    ctx.setDashed(this.isDashed, null != this.style ? 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FIX_DASH, false) : false);
  }
  if (null != fontSize) {
    ctx.setDashPattern(fontSize);
  }
  if (null != this.fill && this.fill != mxConstants.NONE && this.gradient && this.gradient != mxConstants.NONE) {
    style = this.getGradientBounds(ctx, style, props, element, y);
    ctx.setGradient(this.fill, this.gradient, style.x, style.y, style.width, style.height, this.gradientDirection);
  } else {
    ctx.setFillColor(this.fill);
    ctx.setFillStyle(this.fillStyle);
  }
  ctx.setStrokeColor(this.stroke);
  this.configurePointerEvents(ctx);
};
/**
 * @param {!CanvasRenderingContext2D} s
 * @return {undefined}
 */
mxShape.prototype.configurePointerEvents = function(s) {
  if (!(null == this.style || null != this.fill && this.fill != mxConstants.NONE && 0 != this.opacity && 0 != this.fillOpacity || "0" != mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1"))) {
    /** @type {boolean} */
    s.pointerEvents = false;
  }
};
/**
 * @param {!CanvasRenderingContext2D} macro_context
 * @param {number} options
 * @param {number} src
 * @param {number} minWidth
 * @param {number} minHeight
 * @return {?}
 */
mxShape.prototype.getGradientBounds = function(macro_context, options, src, minWidth, minHeight) {
  return new mxRectangle(options, src, minWidth, minHeight);
};
/**
 * @param {!Object} ctx
 * @param {number} x
 * @param {number} y
 * @param {number} t
 * @param {number} e
 * @return {undefined}
 */
mxShape.prototype.updateTransform = function(ctx, x, y, t, e) {
  ctx.scale(this.scale);
  ctx.rotate(this.getShapeRotation(), this.flipH, this.flipV, x + t / 2, y + e / 2);
};
/**
 * @param {string} ctx
 * @param {number} obj
 * @param {number} n
 * @param {number} right
 * @param {number} left
 * @return {undefined}
 */
mxShape.prototype.paintVertexShape = function(ctx, obj, n, right, left) {
  this.paintBackground(ctx, obj, n, right, left);
  if (!(this.outline && null != this.style && 0 != mxUtils.getValue(this.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0))) {
    ctx.setShadow(false);
    this.paintForeground(ctx, obj, n, right, left);
  }
};
/**
 * @param {string} canvas
 * @param {number} area
 * @param {number} g
 * @param {number} h
 * @param {number} x
 * @return {undefined}
 */
mxShape.prototype.paintBackground = function(canvas, area, g, h, x) {
};
/**
 * @param {string} scene
 * @param {number} w
 * @param {number} s
 * @param {number} e
 * @param {number} context
 * @return {undefined}
 */
mxShape.prototype.paintForeground = function(scene, w, s, e, context) {
};
/**
 * @param {!Object} type
 * @param {?} shortName
 * @return {undefined}
 */
mxShape.prototype.paintEdgeShape = function(type, shortName) {
};
/**
 * @param {number} h
 * @param {number} w
 * @return {?}
 */
mxShape.prototype.getArcSize = function(h, w) {
  if ("1" == mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0)) {
    /** @type {number} */
    h = Math.min(h / 2, Math.min(w / 2, mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2));
  } else {
    /** @type {number} */
    var devicePixelRatio = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100;
    /** @type {number} */
    h = Math.min(h * devicePixelRatio, w * devicePixelRatio);
  }
  return h;
};
/**
 * @param {!Object} ctx
 * @param {number} x
 * @param {number} h
 * @param {number} a
 * @param {number} i
 * @param {number} r
 * @return {undefined}
 */
mxShape.prototype.paintGlassEffect = function(ctx, x, h, a, i, r) {
  /** @type {number} */
  var radius = Math.ceil(this.strokewidth / 2);
  ctx.setGradient("#ffffff", "#ffffff", x, h, a, .6 * i, "south", .9, .1);
  ctx.begin();
  r = r + 2 * radius;
  if (this.isRounded) {
    ctx.moveTo(x - radius + r, h - radius);
    ctx.quadTo(x - radius, h - radius, x - radius, h - radius + r);
    ctx.lineTo(x - radius, h + .4 * i);
    ctx.quadTo(x + .5 * a, h + .7 * i, x + a + radius, h + .4 * i);
    ctx.lineTo(x + a + radius, h - radius + r);
    ctx.quadTo(x + a + radius, h - radius, x + a + radius - r, h - radius);
  } else {
    ctx.moveTo(x - radius, h - radius);
    ctx.lineTo(x - radius, h + .4 * i);
    ctx.quadTo(x + .5 * a, h + .7 * i, x + a + radius, h + .4 * i);
    ctx.lineTo(x + a + radius, h - radius);
  }
  ctx.close();
  ctx.fill();
};
/**
 * @param {!Object} path
 * @param {!Object} data
 * @param {string} a
 * @param {number} t
 * @param {boolean} b
 * @param {string} value
 * @param {number} p
 * @return {undefined}
 */
mxShape.prototype.addPoints = function(path, data, a, t, b, value, p) {
  if (null != data && 0 < data.length) {
    p = null != p ? p : true;
    var event = data[data.length - 1];
    if (b && a) {
      data = data.slice();
      var start = data[0];
      start = new mxPoint(event.x + (start.x - event.x) / 2, event.y + (start.y - event.y) / 2);
      data.splice(0, 0, start);
    }
    var r = data[0];
    /** @type {number} */
    start = 1;
    if (p) {
      path.moveTo(r.x, r.y);
    } else {
      path.lineTo(r.x, r.y);
    }
    for (; start < (b ? data.length : data.length - 1);) {
      p = data[mxUtils.mod(start, data.length)];
      /** @type {number} */
      var w = r.x - p.x;
      /** @type {number} */
      r = r.y - p.y;
      if (a && (0 != w || 0 != r) && (null == value || 0 > mxUtils.indexOf(value, start - 1))) {
        /** @type {number} */
        var d = Math.sqrt(w * w + r * r);
        path.lineTo(p.x + w * Math.min(t, d / 2) / d, p.y + r * Math.min(t, d / 2) / d);
        r = data[mxUtils.mod(start + 1, data.length)];
        for (; start < data.length - 2 && 0 == Math.round(r.x - p.x) && 0 == Math.round(r.y - p.y);) {
          r = data[mxUtils.mod(start + 2, data.length)];
          start++;
        }
        /** @type {number} */
        w = r.x - p.x;
        /** @type {number} */
        r = r.y - p.y;
        /** @type {number} */
        d = Math.max(1, Math.sqrt(w * w + r * r));
        w = p.x + w * Math.min(t, d / 2) / d;
        r = p.y + r * Math.min(t, d / 2) / d;
        path.quadTo(p.x, p.y, w, r);
        p = new mxPoint(w, r);
      } else {
        path.lineTo(p.x, p.y);
      }
      /** @type {number} */
      r = p;
      start++;
    }
    if (b) {
      path.close();
    } else {
      path.lineTo(event.x, event.y);
    }
  }
};
/**
 * @return {undefined}
 */
mxShape.prototype.resetStyles = function() {
  this.initStyles();
  /** @type {number} */
  this.spacing = 0;
  delete this.fill;
  delete this.gradient;
  delete this.gradientDirection;
  delete this.stroke;
  delete this.startSize;
  delete this.endSize;
  delete this.startArrow;
  delete this.endArrow;
  delete this.direction;
  delete this.isShadow;
  delete this.isDashed;
  delete this.isRounded;
  delete this.glass;
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxShape.prototype.apply = function(data) {
  /** @type {!Object} */
  this.state = data;
  this.style = data.style;
  if (null != this.style) {
    this.fill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, this.fill);
    this.gradient = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENTCOLOR, this.gradient);
    this.gradientDirection = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENT_DIRECTION, this.gradientDirection);
    this.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_OPACITY, this.opacity);
    this.fillOpacity = mxUtils.getValue(this.style, mxConstants.STYLE_FILL_OPACITY, this.fillOpacity);
    this.fillStyle = mxUtils.getValue(this.style, mxConstants.STYLE_FILL_STYLE, this.fillStyle);
    this.strokeOpacity = mxUtils.getValue(this.style, mxConstants.STYLE_STROKE_OPACITY, this.strokeOpacity);
    this.stroke = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, this.stroke);
    this.strokewidth = mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth);
    this.spacing = mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing);
    this.startSize = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, this.startSize);
    this.endSize = mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, this.endSize);
    this.startArrow = mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, this.startArrow);
    this.endArrow = mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, this.endArrow);
    this.rotation = mxUtils.getValue(this.style, mxConstants.STYLE_ROTATION, this.rotation);
    this.direction = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, this.direction);
    /** @type {boolean} */
    this.flipH = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0);
    /** @type {boolean} */
    this.flipV = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0);
    if (null != this.stencil) {
      /** @type {boolean} */
      this.flipH = 1 == mxUtils.getValue(this.style, "stencilFlipH", 0) || this.flipH;
      /** @type {boolean} */
      this.flipV = 1 == mxUtils.getValue(this.style, "stencilFlipV", 0) || this.flipV;
    }
    if (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH) {
      /** @type {boolean} */
      data = this.flipH;
      /** @type {boolean} */
      this.flipH = this.flipV;
      /** @type {!Object} */
      this.flipV = data;
    }
    /** @type {boolean} */
    this.isShadow = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SHADOW, this.isShadow);
    /** @type {boolean} */
    this.isDashed = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, this.isDashed);
    /** @type {boolean} */
    this.isRounded = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_ROUNDED, this.isRounded);
    /** @type {boolean} */
    this.glass = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_GLASS, this.glass);
    if (this.fill == mxConstants.NONE) {
      /** @type {null} */
      this.fill = null;
    }
    if (this.gradient == mxConstants.NONE) {
      /** @type {null} */
      this.gradient = null;
    }
    if (this.stroke == mxConstants.NONE) {
      /** @type {null} */
      this.stroke = null;
    }
  }
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxShape.prototype.setCursor = function(value) {
  if (null == value) {
    /** @type {string} */
    value = "";
  }
  /** @type {string} */
  this.cursor = value;
  if (null != this.node) {
    /** @type {string} */
    this.node.style.cursor = value;
  }
};
/**
 * @return {?}
 */
mxShape.prototype.getCursor = function() {
  return this.cursor;
};
/**
 * @return {?}
 */
mxShape.prototype.isRoundable = function() {
  return false;
};
/**
 * @return {undefined}
 */
mxShape.prototype.updateBoundingBox = function() {
  if (this.useSvgBoundingBox && null != this.node && null != this.node.ownerSVGElement) {
    try {
      var ret = this.node.getBBox();
      if (0 < ret.width && 0 < ret.height) {
        this.boundingBox = new mxRectangle(ret.x, ret.y, ret.width, ret.height);
        this.boundingBox.grow(this.strokewidth * this.scale / 2);
        return;
      }
    } catch (c) {
    }
  }
  if (null != this.bounds) {
    ret = this.createBoundingBox();
    if (null != ret) {
      this.augmentBoundingBox(ret);
      var value = this.getShapeRotation();
      if (0 != value) {
        ret = mxUtils.getBoundingBox(ret, value);
      }
    }
    this.boundingBox = ret;
  }
};
/**
 * @return {?}
 */
mxShape.prototype.createBoundingBox = function() {
  var utils = this.bounds.clone();
  if (null != this.stencil && (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH) || this.isPaintBoundsInverted()) {
    utils.rotate90();
  }
  return utils;
};
/**
 * @param {!Object} bbox
 * @return {undefined}
 */
mxShape.prototype.augmentBoundingBox = function(bbox) {
  if (this.isShadow) {
    bbox.width += Math.ceil(mxConstants.SHADOW_OFFSET_X * this.scale);
    bbox.height += Math.ceil(mxConstants.SHADOW_OFFSET_Y * this.scale);
  }
  bbox.grow(this.strokewidth * this.scale / 2);
};
/**
 * @return {?}
 */
mxShape.prototype.isPaintBoundsInverted = function() {
  return null == this.stencil && (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH);
};
/**
 * @return {?}
 */
mxShape.prototype.getRotation = function() {
  return null != this.rotation ? this.rotation : 0;
};
/**
 * @return {?}
 */
mxShape.prototype.getTextRotation = function() {
  var rotation = this.getRotation();
  if (1 != mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1)) {
    rotation = rotation + mxText.prototype.verticalTextRotation;
  }
  return rotation;
};
/**
 * @return {?}
 */
mxShape.prototype.getShapeRotation = function() {
  var rotation = this.getRotation();
  if (null != this.direction) {
    if (this.direction == mxConstants.DIRECTION_NORTH) {
      rotation = rotation + 270;
    } else {
      if (this.direction == mxConstants.DIRECTION_WEST) {
        rotation = rotation + 180;
      } else {
        if (this.direction == mxConstants.DIRECTION_SOUTH) {
          rotation = rotation + 90;
        }
      }
    }
  }
  return rotation;
};
/**
 * @param {!Object} a
 * @param {!Object} i
 * @param {!Object} h
 * @param {!Object} media
 * @return {?}
 */
mxShape.prototype.createTransparentSvgRectangle = function(a, i, h, media) {
  /** @type {!Element} */
  var el = document.createElementNS(mxConstants.NS_SVG, "rect");
  el.setAttribute("x", a);
  el.setAttribute("y", i);
  el.setAttribute("width", h);
  el.setAttribute("height", media);
  el.setAttribute("fill", "none");
  el.setAttribute("stroke", "none");
  el.setAttribute("pointer-events", "all");
  return el;
};
/**
 * @param {!Element} el
 * @return {undefined}
 */
mxShape.prototype.setTransparentBackgroundImage = function(el) {
  /** @type {string} */
  el.style.backgroundImage = "url('" + mxClient.imageBasePath + "/transparent.gif')";
};
/**
 * @param {!Object} end
 * @return {?}
 */
mxShape.prototype.intersectsRectangle = function(end) {
  return null != end && null != this.node && "hidden" != this.node.style.visibility && "none" != this.node.style.display && mxUtils.intersects(this.bounds, end);
};
/**
 * @param {!Object} a
 * @return {undefined}
 */
mxShape.prototype.releaseSvgGradients = function(a) {
  if (null != a) {
    var j;
    for (j in a) {
      var e2 = a[j];
      if (null != e2) {
        /** @type {number} */
        e2.mxRefCount = (e2.mxRefCount || 0) - 1;
        if (0 == e2.mxRefCount && null != e2.parentNode) {
          e2.parentNode.removeChild(e2);
        }
      }
    }
  }
};
/**
 * @param {!Object} a
 * @return {undefined}
 */
mxShape.prototype.releaseSvgFillPatterns = function(a) {
  if (null != a) {
    var j;
    for (j in a) {
      var e2 = a[j];
      if (null != e2) {
        /** @type {number} */
        e2.mxRefCount = (e2.mxRefCount || 0) - 1;
        if (0 == e2.mxRefCount && null != e2.parentNode) {
          e2.parentNode.removeChild(e2);
        }
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxShape.prototype.destroy = function() {
  if (null != this.node) {
    mxEvent.release(this.node);
    if (null != this.node.parentNode) {
      this.node.parentNode.removeChild(this.node);
    }
    /** @type {null} */
    this.node = null;
  }
  this.releaseSvgGradients(this.oldGradients);
  this.releaseSvgFillPatterns(this.oldFillPatterns);
  /** @type {null} */
  this.oldFillPatterns = this.oldGradients = null;
};
/**
 * @param {string} ceDescription
 * @return {undefined}
 */
function mxStencil(ceDescription) {
  /** @type {string} */
  this.desc = ceDescription;
  this.parseDescription();
  this.parseConstraints();
}
mxUtils.extend(mxStencil, mxShape);
/** @type {boolean} */
mxStencil.defaultLocalized = false;
/** @type {boolean} */
mxStencil.allowEval = false;
/** @type {null} */
mxStencil.prototype.desc = null;
/** @type {null} */
mxStencil.prototype.constraints = null;
/** @type {null} */
mxStencil.prototype.aspect = null;
/** @type {null} */
mxStencil.prototype.w0 = null;
/** @type {null} */
mxStencil.prototype.h0 = null;
/** @type {null} */
mxStencil.prototype.bgNode = null;
/** @type {null} */
mxStencil.prototype.fgNode = null;
/** @type {null} */
mxStencil.prototype.strokewidth = null;
/**
 * @return {undefined}
 */
mxStencil.prototype.parseDescription = function() {
  this.fgNode = this.desc.getElementsByTagName("foreground")[0];
  this.bgNode = this.desc.getElementsByTagName("background")[0];
  /** @type {number} */
  this.w0 = Number(this.desc.getAttribute("w") || 100);
  /** @type {number} */
  this.h0 = Number(this.desc.getAttribute("h") || 100);
  var position = this.desc.getAttribute("aspect");
  this.aspect = null != position ? position : "variable";
  position = this.desc.getAttribute("strokewidth");
  this.strokewidth = null != position ? position : "1";
};
/**
 * @return {undefined}
 */
mxStencil.prototype.parseConstraints = function() {
  var node = this.desc.getElementsByTagName("connections")[0];
  if (null != node && (node = mxUtils.getChildNodes(node), null != node && 0 < node.length)) {
    /** @type {!Array} */
    this.constraints = [];
    /** @type {number} */
    var ii = 0;
    for (; ii < node.length; ii++) {
      this.constraints.push(this.parseConstraint(node[ii]));
    }
  }
};
/**
 * @param {!Object} line
 * @return {?}
 */
mxStencil.prototype.parseConstraint = function(line) {
  /** @type {number} */
  var x = Number(line.getAttribute("x"));
  /** @type {number} */
  var height = Number(line.getAttribute("y"));
  /** @type {boolean} */
  var d = "1" == line.getAttribute("perimeter");
  line = line.getAttribute("name");
  return new mxConnectionConstraint(new mxPoint(x, height), d, line);
};
/**
 * @param {string} node
 * @param {string} name
 * @param {!Object} loader
 * @return {?}
 */
mxStencil.prototype.evaluateTextAttribute = function(node, name, loader) {
  name = this.evaluateAttribute(node, name, loader);
  node = node.getAttribute("localized");
  if (mxStencil.defaultLocalized && null == node || "1" == node) {
    name = mxResources.get(name);
  }
  return name;
};
/**
 * @param {!Object} s
 * @param {string} x
 * @param {!Object} a
 * @return {?}
 */
mxStencil.prototype.evaluateAttribute = function(s, x, a) {
  x = s.getAttribute(x);
  if (null == x) {
    s = mxUtils.getTextContent(s);
    if (null != s && mxStencil.allowEval) {
      s = mxUtils.eval(s);
      if ("function" == typeof s) {
        x = s(a);
      }
    }
  }
  return x;
};
/**
 * @param {!Object} ctx
 * @param {!Object} s
 * @param {number} x
 * @param {number} y
 * @param {number} h
 * @param {number} w
 * @return {undefined}
 */
mxStencil.prototype.drawShape = function(ctx, s, x, y, h, w) {
  var res = ctx.states.slice();
  var p = mxUtils.getValue(s.style, mxConstants.STYLE_DIRECTION, null);
  p = this.computeAspect(s.style, x, y, h, w, p);
  /** @type {number} */
  var borderWidth = Math.min(p.width, p.height);
  /** @type {number} */
  borderWidth = "inherit" == this.strokewidth ? Number(mxUtils.getNumber(s.style, mxConstants.STYLE_STROKEWIDTH, 1)) : Number(this.strokewidth) * borderWidth;
  ctx.setStrokeWidth(borderWidth);
  if (null != s.style && "1" == mxUtils.getValue(s.style, mxConstants.STYLE_POINTER_EVENTS, "0")) {
    ctx.setStrokeColor(mxConstants.NONE);
    ctx.rect(x, y, h, w);
    ctx.stroke();
    ctx.setStrokeColor(s.stroke);
  }
  this.drawChildren(ctx, s, x, y, h, w, this.bgNode, p, false, true);
  this.drawChildren(ctx, s, x, y, h, w, this.fgNode, p, true, !s.outline || null == s.style || 0 == mxUtils.getValue(s.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0));
  if (ctx.states.length != res.length) {
    ctx.states = res;
  }
};
/**
 * @param {!Object} node
 * @param {!Object} o
 * @param {!Object} n
 * @param {number} depth
 * @param {number} context
 * @param {number} el
 * @param {!Object} list
 * @param {undefined} parent
 * @param {string} box
 * @param {boolean} left
 * @return {undefined}
 */
mxStencil.prototype.drawChildren = function(node, o, n, depth, context, el, list, parent, box, left) {
  if (null != list && 0 < context && 0 < el) {
    n = list.firstChild;
    for (; null != n;) {
      if (n.nodeType == mxConstants.NODETYPE_ELEMENT) {
        this.drawNode(node, o, n, parent, box, left);
      }
      n = n.nextSibling;
    }
  }
};
/**
 * @param {number} width
 * @param {number} minWidth
 * @param {number} period
 * @param {number} index
 * @param {number} step
 * @param {number} scale
 * @return {?}
 */
mxStencil.prototype.computeAspect = function(width, minWidth, period, index, step, scale) {
  /** @type {number} */
  width = minWidth;
  /** @type {number} */
  minWidth = index / this.w0;
  /** @type {number} */
  var maxWidth = step / this.h0;
  if (scale = scale == mxConstants.DIRECTION_NORTH || scale == mxConstants.DIRECTION_SOUTH) {
    /** @type {number} */
    maxWidth = index / this.h0;
    /** @type {number} */
    minWidth = step / this.w0;
    /** @type {number} */
    var value = (index - step) / 2;
    width = width + value;
    /** @type {number} */
    period = period - value;
  }
  if ("fixed" == this.aspect) {
    /** @type {number} */
    minWidth = maxWidth = Math.min(minWidth, maxWidth);
    if (scale) {
      width = width + (step - this.w0 * minWidth) / 2;
      period = period + (index - this.h0 * maxWidth) / 2;
    } else {
      width = width + (index - this.w0 * minWidth) / 2;
      period = period + (step - this.h0 * maxWidth) / 2;
    }
  }
  return new mxRectangle(width, period, minWidth, maxWidth);
};
/**
 * @param {!Object} string
 * @param {!Object} s
 * @param {!Object} str
 * @param {string} color
 * @return {?}
 */
mxStencil.prototype.parseColor = function(string, s, str, color) {
  if ("stroke" == color) {
    color = s.stroke;
  } else {
    if ("fill" == color) {
      color = s.fill;
    }
  }
  return color;
};
/**
 * @param {!Object} ctx
 * @param {!Object} s
 * @param {!Object} node
 * @param {number} d
 * @param {string} obj
 * @param {number} h
 * @return {undefined}
 */
mxStencil.prototype.drawNode = function(ctx, s, node, d, obj, h) {
  var undefined = node.nodeName;
  var x = d.x;
  var y = d.y;
  var i = d.width;
  var r = d.height;
  /** @type {number} */
  var c = Math.min(i, r);
  if ("save" == undefined) {
    ctx.save();
  } else {
    if ("restore" == undefined) {
      ctx.restore();
    } else {
      if (h) {
        if ("path" == undefined) {
          ctx.begin();
          /** @type {boolean} */
          c = true;
          if ("1" == node.getAttribute("rounded")) {
            /** @type {boolean} */
            c = false;
            /** @type {number} */
            var m = Number(node.getAttribute("arcSize"));
            /** @type {number} */
            var z = 0;
            /** @type {!Array} */
            var listeners = [];
            var child = node.firstChild;
            for (; null != child;) {
              if (child.nodeType == mxConstants.NODETYPE_ELEMENT) {
                var nodeName = child.nodeName;
                if ("move" == nodeName || "line" == nodeName) {
                  if (!("move" != nodeName && 0 != listeners.length)) {
                    listeners.push([]);
                  }
                  listeners[listeners.length - 1].push(new mxPoint(x + Number(child.getAttribute("x")) * i, y + Number(child.getAttribute("y")) * r));
                  z++;
                } else {
                  /** @type {boolean} */
                  c = true;
                  break;
                }
              }
              child = child.nextSibling;
            }
            if (!c && 0 < z) {
              /** @type {number} */
              i = 0;
              for (; i < listeners.length; i++) {
                /** @type {boolean} */
                r = false;
                y = listeners[i][0];
                x = listeners[i][listeners[i].length - 1];
                if (y.x == x.x && y.y == x.y) {
                  listeners[i].pop();
                  /** @type {boolean} */
                  r = true;
                }
                this.addPoints(ctx, listeners[i], true, m, r);
              }
            } else {
              /** @type {boolean} */
              c = true;
            }
          }
          if (c) {
            child = node.firstChild;
            for (; null != child;) {
              if (child.nodeType == mxConstants.NODETYPE_ELEMENT) {
                this.drawNode(ctx, s, child, d, obj, h);
              }
              child = child.nextSibling;
            }
          }
        } else {
          if ("close" == undefined) {
            ctx.close();
          } else {
            if ("move" == undefined) {
              ctx.moveTo(x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r);
            } else {
              if ("line" == undefined) {
                ctx.lineTo(x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r);
              } else {
                if ("quad" == undefined) {
                  ctx.quadTo(x + Number(node.getAttribute("x1")) * i, y + Number(node.getAttribute("y1")) * r, x + Number(node.getAttribute("x2")) * i, y + Number(node.getAttribute("y2")) * r);
                } else {
                  if ("curve" == undefined) {
                    ctx.curveTo(x + Number(node.getAttribute("x1")) * i, y + Number(node.getAttribute("y1")) * r, x + Number(node.getAttribute("x2")) * i, y + Number(node.getAttribute("y2")) * r, x + Number(node.getAttribute("x3")) * i, y + Number(node.getAttribute("y3")) * r);
                  } else {
                    if ("arc" == undefined) {
                      ctx.arcTo(Number(node.getAttribute("rx")) * i, Number(node.getAttribute("ry")) * r, Number(node.getAttribute("x-axis-rotation")), Number(node.getAttribute("large-arc-flag")), Number(node.getAttribute("sweep-flag")), x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r);
                    } else {
                      if ("rect" == undefined) {
                        ctx.rect(x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r, Number(node.getAttribute("w")) * i, Number(node.getAttribute("h")) * r);
                      } else {
                        if ("roundrect" == undefined) {
                          /** @type {number} */
                          s = Number(node.getAttribute("arcsize"));
                          if (0 == s) {
                            /** @type {number} */
                            s = 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR;
                          }
                          /** @type {number} */
                          d = Number(node.getAttribute("w")) * i;
                          /** @type {number} */
                          h = Number(node.getAttribute("h")) * r;
                          /** @type {number} */
                          s = Number(s) / 100;
                          /** @type {number} */
                          s = Math.min(d * s, h * s);
                          ctx.roundrect(x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r, d, h, s, s);
                        } else {
                          if ("ellipse" == undefined) {
                            ctx.ellipse(x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r, Number(node.getAttribute("w")) * i, Number(node.getAttribute("h")) * r);
                          } else {
                            if ("image" == undefined) {
                              if (!s.outline) {
                                s = this.evaluateAttribute(node, "src", s);
                                ctx.image(x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r, Number(node.getAttribute("w")) * i, Number(node.getAttribute("h")) * r, s, false, "1" == node.getAttribute("flipH"), "1" == node.getAttribute("flipV"));
                              }
                            } else {
                              if ("text" == undefined) {
                                if (!s.outline) {
                                  d = this.evaluateTextAttribute(node, "str", s);
                                  /** @type {number} */
                                  h = "1" == node.getAttribute("vertical") ? -90 : 0;
                                  if ("0" == node.getAttribute("align-shape")) {
                                    c = s.rotation;
                                    /** @type {boolean} */
                                    m = 1 == mxUtils.getValue(s.style, mxConstants.STYLE_FLIPH, 0);
                                    /** @type {boolean} */
                                    s = 1 == mxUtils.getValue(s.style, mxConstants.STYLE_FLIPV, 0);
                                    h = m && s ? h - c : m || s ? h + c : h - c;
                                  }
                                  /** @type {number} */
                                  h = h - node.getAttribute("rotation");
                                  ctx.text(x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r, 0, 0, d, node.getAttribute("align") || "left", node.getAttribute("valign") || "top", false, "", null, false, h);
                                }
                              } else {
                                if ("include-shape" == undefined) {
                                  c = mxStencilRegistry.getStencil(node.getAttribute("name"));
                                  if (null != c) {
                                    x = x + Number(node.getAttribute("x")) * i;
                                    y = y + Number(node.getAttribute("y")) * r;
                                    /** @type {number} */
                                    d = Number(node.getAttribute("w")) * i;
                                    /** @type {number} */
                                    h = Number(node.getAttribute("h")) * r;
                                    c.drawShape(ctx, s, x, y, d, h);
                                  }
                                } else {
                                  if ("fillstroke" == undefined) {
                                    ctx.fillAndStroke();
                                  } else {
                                    if ("fill" == undefined) {
                                      ctx.fill();
                                    } else {
                                      if ("stroke" == undefined) {
                                        ctx.stroke();
                                      } else {
                                        if ("strokewidth" == undefined) {
                                          /** @type {number} */
                                          i = "1" == node.getAttribute("fixed") ? 1 : c;
                                          ctx.setStrokeWidth(Number(node.getAttribute("width")) * i);
                                        } else {
                                          if ("dashed" == undefined) {
                                            ctx.setDashed("1" == node.getAttribute("dashed"));
                                          } else {
                                            if ("dashpattern" == undefined) {
                                              if (node = node.getAttribute("pattern"), null != node) {
                                                node = node.split(" ");
                                                /** @type {!Array} */
                                                r = [];
                                                /** @type {number} */
                                                i = 0;
                                                for (; i < node.length; i++) {
                                                  if (0 < node[i].length) {
                                                    r.push(Number(node[i]) * c);
                                                  }
                                                }
                                                /** @type {string} */
                                                node = r.join(" ");
                                                ctx.setDashPattern(node);
                                              }
                                            } else {
                                              if ("strokecolor" == undefined) {
                                                ctx.setStrokeColor(this.parseColor(ctx, s, node, node.getAttribute("color")));
                                              } else {
                                                if ("linecap" == undefined) {
                                                  ctx.setLineCap(node.getAttribute("cap"));
                                                } else {
                                                  if ("linejoin" == undefined) {
                                                    ctx.setLineJoin(node.getAttribute("join"));
                                                  } else {
                                                    if ("miterlimit" == undefined) {
                                                      ctx.setMiterLimit(Number(node.getAttribute("limit")));
                                                    } else {
                                                      if ("fillcolor" == undefined) {
                                                        ctx.setFillColor(this.parseColor(ctx, s, node, node.getAttribute("color")));
                                                      } else {
                                                        if ("alpha" == undefined) {
                                                          ctx.setAlpha(node.getAttribute("alpha"));
                                                        } else {
                                                          if ("fillalpha" == undefined) {
                                                            ctx.setAlpha(node.getAttribute("alpha"));
                                                          } else {
                                                            if ("strokealpha" == undefined) {
                                                              ctx.setAlpha(node.getAttribute("alpha"));
                                                            } else {
                                                              if ("fontcolor" == undefined) {
                                                                ctx.setFontColor(this.parseColor(ctx, s, node, node.getAttribute("color")));
                                                              } else {
                                                                if ("fontstyle" == undefined) {
                                                                  ctx.setFontStyle(node.getAttribute("style"));
                                                                } else {
                                                                  if ("fontfamily" == undefined) {
                                                                    ctx.setFontFamily(node.getAttribute("family"));
                                                                  } else {
                                                                    if ("fontsize" == undefined) {
                                                                      ctx.setFontSize(Number(node.getAttribute("size")) * c);
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (!(!obj || "fillstroke" != undefined && "fill" != undefined && "stroke" != undefined)) {
          ctx.setShadow(false);
        }
      }
    }
  }
};
var mxStencilRegistry = {
  stencils : {},
  addStencil : function(name, options) {
    mxStencilRegistry.stencils[name] = options;
  },
  getStencil : function(name) {
    return mxStencilRegistry.stencils[name];
  }
};
var mxMarker = {
  markers : [],
  addMarker : function(name, cb) {
    /** @type {!Function} */
    mxMarker.markers[name] = cb;
  },
  createMarker : function(index, options, name, d, e, i, loc, item, target, type) {
    var callback = mxMarker.markers[name];
    return null != callback ? callback(index, options, name, d, e, i, loc, item, target, type) : null;
  }
};
(function() {
  /**
   * @param {number} length
   * @return {?}
   */
  function noDuplicatePointCollector(length) {
    length = null != length ? length : 2;
    return function(ctx, w, r, p, i, width, height, h, x, canCreateDiscussions) {
      /** @type {number} */
      w = i * x * 1.118;
      /** @type {number} */
      h = width * x * 1.118;
      /** @type {number} */
      i = i * (height + x);
      /** @type {number} */
      width = width * (height + x);
      var pos = p.clone();
      pos.x -= w;
      pos.y -= h;
      /** @type {number} */
      height = r != mxConstants.ARROW_CLASSIC && r != mxConstants.ARROW_CLASSIC_THIN ? 1 : .75;
      p.x += -i * height - w;
      p.y += -width * height - h;
      return function() {
        ctx.begin();
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(pos.x - i - width / length, pos.y - width + i / length);
        if (!(r != mxConstants.ARROW_CLASSIC && r != mxConstants.ARROW_CLASSIC_THIN)) {
          ctx.lineTo(pos.x - 3 * i / 4, pos.y - 3 * width / 4);
        }
        ctx.lineTo(pos.x + width / length - i, pos.y - width - i / length);
        ctx.close();
        if (canCreateDiscussions) {
          ctx.fillAndStroke();
        } else {
          ctx.stroke();
        }
      };
    };
  }
  /**
   * @param {number} length
   * @return {?}
   */
  function updateFlowIcons(length) {
    length = null != length ? length : 2;
    return function(ctx, horzSpeed, vertSpeed, objectToMeasure, d, i, fontSize, p, size, canCreateDiscussions) {
      /** @type {number} */
      horzSpeed = d * size * 1.118;
      /** @type {number} */
      vertSpeed = i * size * 1.118;
      /** @type {number} */
      d = d * (fontSize + size);
      /** @type {number} */
      i = i * (fontSize + size);
      var s = objectToMeasure.clone();
      s.x -= horzSpeed;
      s.y -= vertSpeed;
      objectToMeasure.x += 2 * -horzSpeed;
      objectToMeasure.y += 2 * -vertSpeed;
      return function() {
        ctx.begin();
        ctx.moveTo(s.x - d - i / length, s.y - i + d / length);
        ctx.lineTo(s.x, s.y);
        ctx.lineTo(s.x + i / length - d, s.y - i - d / length);
        ctx.stroke();
      };
    };
  }
  /**
   * @param {!Object} ctx
   * @param {number} x
   * @param {?} _
   * @param {!Object} o
   * @param {number} w
   * @param {number} h
   * @param {number} i
   * @param {number} count
   * @param {number} size
   * @param {?} archivedHubData
   * @return {?}
   */
  function render(ctx, x, _, o, w, h, i, count, size, archivedHubData) {
    /** @type {number} */
    count = _ == mxConstants.ARROW_DIAMOND ? .7071 : .9862;
    /** @type {number} */
    x = w * size * count;
    /** @type {number} */
    count = count * (h * size);
    /** @type {number} */
    w = w * (i + size);
    /** @type {number} */
    h = h * (i + size);
    var pos = o.clone();
    pos.x -= x;
    pos.y -= count;
    o.x += -w - x;
    o.y += -h - count;
    /** @type {number} */
    var scale = _ == mxConstants.ARROW_DIAMOND ? 2 : 3.4;
    return function() {
      ctx.begin();
      ctx.moveTo(pos.x, pos.y);
      ctx.lineTo(pos.x - w / 2 - h / scale, pos.y + w / scale - h / 2);
      ctx.lineTo(pos.x - w, pos.y - h);
      ctx.lineTo(pos.x - w / 2 + h / scale, pos.y - h / 2 - w / scale);
      ctx.close();
      if (archivedHubData) {
        ctx.fillAndStroke();
      } else {
        ctx.stroke();
      }
    };
  }
  mxMarker.addMarker("classic", noDuplicatePointCollector(2));
  mxMarker.addMarker("classicThin", noDuplicatePointCollector(3));
  mxMarker.addMarker("block", noDuplicatePointCollector(2));
  mxMarker.addMarker("blockThin", noDuplicatePointCollector(3));
  mxMarker.addMarker("open", updateFlowIcons(2));
  mxMarker.addMarker("openThin", updateFlowIcons(3));
  mxMarker.addMarker("oval", function(canvas, canCreateDiscussions, isSlidingUp, bounds, delta, sign, w, n, p, dontForceConstraints) {
    /** @type {number} */
    var r = w / 2;
    var rp = bounds.clone();
    bounds.x -= delta * r;
    bounds.y -= sign * r;
    return function() {
      canvas.ellipse(rp.x - r, rp.y - r, w, w);
      if (dontForceConstraints) {
        canvas.fillAndStroke();
      } else {
        canvas.stroke();
      }
    };
  });
  mxMarker.addMarker("baseDash", function(context, canCreateDiscussions, isSlidingUp, p1, rotation, val, n, dontForceConstraints, p, forceExecution) {
    /** @type {number} */
    var r = rotation * (n + p + 1);
    /** @type {number} */
    var w = val * (n + p + 1);
    return function() {
      context.begin();
      context.moveTo(p1.x - w / 2, p1.y + r / 2);
      context.lineTo(p1.x + w / 2, p1.y - r / 2);
      context.stroke();
    };
  });
  mxMarker.addMarker("doubleBlock", function(ctx, w, f, p, a, offset, i, h, k, canCreateDiscussions) {
    /** @type {number} */
    w = a * k * 1.118;
    /** @type {number} */
    h = offset * k * 1.118;
    /** @type {number} */
    a = a * (i + k);
    /** @type {number} */
    offset = offset * (i + k);
    var pos = p.clone();
    pos.x -= w;
    pos.y -= h;
    /** @type {number} */
    f = f != mxConstants.ARROW_CLASSIC && f != mxConstants.ARROW_CLASSIC_THIN ? 1 : .75;
    p.x += -a * f * 2 - w;
    p.y += -offset * f * 2 - h;
    return function() {
      ctx.begin();
      ctx.moveTo(pos.x, pos.y);
      ctx.lineTo(pos.x - a - offset / 2, pos.y - offset + a / 2);
      ctx.lineTo(pos.x + offset / 2 - a, pos.y - offset - a / 2);
      ctx.close();
      ctx.moveTo(pos.x - a, pos.y - offset);
      ctx.lineTo(pos.x - 2 * a - .5 * offset, pos.y + .5 * a - 2 * offset);
      ctx.lineTo(pos.x - 2 * a + .5 * offset, pos.y - .5 * a - 2 * offset);
      ctx.close();
      if (canCreateDiscussions) {
        ctx.fillAndStroke();
      } else {
        ctx.stroke();
      }
    };
  });
  mxMarker.addMarker("diamond", render);
  mxMarker.addMarker("diamondThin", render);
})();
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxActor(bounds, value, size, intSetSource) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxActor, mxShape);
/**
 * @param {!Object} c
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @return {undefined}
 */
mxActor.prototype.paintVertexShape = function(c, x, y, w, h) {
  c.translate(x, y);
  c.begin();
  this.redrawPath(c, x, y, w, h);
  c.fillAndStroke();
};
/**
 * @param {!Object} path
 * @param {number} width
 * @param {number} height
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxActor.prototype.redrawPath = function(path, width, height, x, y) {
  /** @type {number} */
  width = x / 3;
  path.moveTo(0, y);
  path.curveTo(0, 3 * y / 5, 0, 2 * y / 5, x / 2, 2 * y / 5);
  path.curveTo(x / 2 - width, 2 * y / 5, x / 2 - width, 0, x / 2, 0);
  path.curveTo(x / 2 + width, 0, x / 2 + width, 2 * y / 5, x / 2, 2 * y / 5);
  path.curveTo(x, 2 * y / 5, x, 3 * y / 5, x, y);
  path.close();
};
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxCloud(bounds, value, size, intSetSource) {
  mxActor.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxCloud, mxActor);
/**
 * @param {!Object} context
 * @param {number} width
 * @param {number} height
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxCloud.prototype.redrawPath = function(context, width, height, x, y) {
  context.moveTo(.25 * x, .25 * y);
  context.curveTo(.05 * x, .25 * y, 0, .5 * y, .16 * x, .55 * y);
  context.curveTo(0, .66 * y, .18 * x, .9 * y, .31 * x, .8 * y);
  context.curveTo(.4 * x, y, .7 * x, y, .8 * x, .8 * y);
  context.curveTo(x, .8 * y, x, .6 * y, .875 * x, .5 * y);
  context.curveTo(x, .3 * y, .8 * x, .1 * y, .625 * x, .2 * y);
  context.curveTo(.5 * x, .05 * y, .3 * x, .05 * y, .25 * x, .25 * y);
  context.close();
};
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxRectangleShape(bounds, value, size, intSetSource) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxRectangleShape, mxShape);
/**
 * @return {?}
 */
mxRectangleShape.prototype.isHtmlAllowed = function() {
  /** @type {boolean} */
  var a = true;
  if (null != this.style) {
    /** @type {boolean} */
    a = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1");
  }
  return !this.isRounded && !this.glass && 0 == this.rotation && (a || null != this.fill && this.fill != mxConstants.NONE);
};
/**
 * @param {!Object} canvas
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @return {undefined}
 */
mxRectangleShape.prototype.paintBackground = function(canvas, x, y, w, h) {
  if (this.isRounded) {
    if ("1" == mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0)) {
      /** @type {number} */
      var r = Math.min(w / 2, Math.min(h / 2, mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2));
    } else {
      /** @type {number} */
      r = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100;
      /** @type {number} */
      r = Math.min(w * r, h * r);
    }
    canvas.roundrect(x, y, w, h, r, r);
  } else {
    canvas.rect(x, y, w, h);
  }
  canvas.fillAndStroke();
};
/**
 * @return {?}
 */
mxRectangleShape.prototype.isRoundable = function() {
  return true;
};
/**
 * @param {!Object} s
 * @param {number} t
 * @param {number} scale
 * @param {number} e
 * @param {number} context
 * @return {undefined}
 */
mxRectangleShape.prototype.paintForeground = function(s, t, scale, e, context) {
  if (this.glass && !this.outline && null != this.fill && this.fill != mxConstants.NONE) {
    this.paintGlassEffect(s, t, scale, e, context, this.getArcSize(e + this.strokewidth, context + this.strokewidth));
  }
};
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxEllipse(bounds, value, size, intSetSource) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxEllipse, mxShape);
/**
 * @param {!Entity} canvas
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @return {undefined}
 */
mxEllipse.prototype.paintVertexShape = function(canvas, x, y, w, h) {
  canvas.ellipse(x, y, w, h);
  canvas.fillAndStroke();
};
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxDoubleEllipse(bounds, value, size, intSetSource) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxDoubleEllipse, mxShape);
/**
 * @param {!Entity} canvas
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @return {undefined}
 */
mxDoubleEllipse.prototype.paintBackground = function(canvas, x, y, w, h) {
  canvas.ellipse(x, y, w, h);
  canvas.fillAndStroke();
};
/**
 * @param {!Object} context
 * @param {number} x
 * @param {number} y
 * @param {number} h
 * @param {number} w
 * @return {undefined}
 */
mxDoubleEllipse.prototype.paintForeground = function(context, x, y, h, w) {
  if (!this.outline) {
    var gap = mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(h / 5, w / 5)));
    x = x + gap;
    y = y + gap;
    /** @type {number} */
    h = h - 2 * gap;
    /** @type {number} */
    w = w - 2 * gap;
    if (0 < h && 0 < w) {
      context.ellipse(x, y, h, w);
    }
    context.stroke();
  }
};
/**
 * @param {!Object} b
 * @return {?}
 */
mxDoubleEllipse.prototype.getLabelBounds = function(b) {
  /** @type {number} */
  var s = mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(b.width / 5 / this.scale, b.height / 5 / this.scale))) * this.scale;
  return new mxRectangle(b.x + s, b.y + s, b.width - 2 * s, b.height - 2 * s);
};
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxRhombus(bounds, value, size, intSetSource) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxRhombus, mxShape);
/**
 * @return {?}
 */
mxRhombus.prototype.isRoundable = function() {
  return true;
};
/**
 * @param {!Object} data
 * @param {number} x
 * @param {number} y
 * @param {number} d
 * @param {number} l
 * @return {undefined}
 */
mxRhombus.prototype.paintVertexShape = function(data, x, y, d, l) {
  /** @type {number} */
  var speed = d / 2;
  /** @type {number} */
  var size = l / 2;
  /** @type {number} */
  var nameArgs = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  data.begin();
  this.addPoints(data, [new mxPoint(x + speed, y), new mxPoint(x + d, y + size), new mxPoint(x + speed, y + l), new mxPoint(x, y + size)], this.isRounded, nameArgs, true);
  data.fillAndStroke();
};
/**
 * @param {?} points
 * @param {!Object} stroke
 * @param {number} strokewidth
 * @return {undefined}
 */
function mxPolyline(points, stroke, strokewidth) {
  mxShape.call(this);
  this.points = points;
  /** @type {!Object} */
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
}
mxUtils.extend(mxPolyline, mxShape);
/**
 * @return {?}
 */
mxPolyline.prototype.getRotation = function() {
  return 0;
};
/**
 * @return {?}
 */
mxPolyline.prototype.getShapeRotation = function() {
  return 0;
};
/**
 * @return {?}
 */
mxPolyline.prototype.isPaintBoundsInverted = function() {
  return false;
};
/**
 * @param {!Object} context
 * @param {!Object} arg
 * @return {undefined}
 */
mxPolyline.prototype.paintEdgeShape = function(context, arg) {
  var firstSelector = context.pointerEventsValue;
  /** @type {string} */
  context.pointerEventsValue = "stroke";
  if (null == this.style || 1 != this.style[mxConstants.STYLE_CURVED]) {
    this.paintLine(context, arg, this.isRounded);
  } else {
    this.paintCurvedLine(context, arg);
  }
  context.pointerEventsValue = firstSelector;
};
/**
 * @param {!Object} path
 * @param {!Object} f
 * @param {string} context
 * @return {undefined}
 */
mxPolyline.prototype.paintLine = function(path, f, context) {
  /** @type {number} */
  var nameArgs = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  path.begin();
  this.addPoints(path, f, context, nameArgs, false);
  path.stroke();
};
/**
 * @param {!Object} path
 * @param {!Object} args
 * @return {undefined}
 */
mxPolyline.prototype.paintCurvedLine = function(path, args) {
  path.begin();
  var arg = args[0];
  var argsLength = args.length;
  path.moveTo(arg.x, arg.y);
  /** @type {number} */
  arg = 1;
  for (; arg < argsLength - 2; arg++) {
    var node = args[arg];
    var p = args[arg + 1];
    path.quadTo(node.x, node.y, (node.x + p.x) / 2, (node.y + p.y) / 2);
  }
  node = args[argsLength - 2];
  p = args[argsLength - 1];
  path.quadTo(node.x, node.y, p.x, p.y);
  path.stroke();
};
/**
 * @param {?} coords
 * @param {string} value
 * @param {!Object} size
 * @param {number} status
 * @param {number} e
 * @param {number} p
 * @param {number} altCss
 * @return {undefined}
 */
function mxArrow(coords, value, size, status, e, p, altCss) {
  mxShape.call(this);
  this.points = coords;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != status ? status : 1;
  this.arrowWidth = null != e ? e : mxConstants.ARROW_WIDTH;
  this.spacing = null != p ? p : mxConstants.ARROW_SPACING;
  this.endSize = null != altCss ? altCss : mxConstants.ARROW_SIZE;
}
mxUtils.extend(mxArrow, mxShape);
/**
 * @param {?} bbox
 * @return {undefined}
 */
mxArrow.prototype.augmentBoundingBox = function(bbox) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  bbox.grow((Math.max(this.arrowWidth, this.endSize) / 2 + this.strokewidth) * this.scale);
};
/**
 * @param {!Object} ctx
 * @param {!Object} pos
 * @return {undefined}
 */
mxArrow.prototype.paintEdgeShape = function(ctx, pos) {
  var w = mxConstants.ARROW_SPACING;
  var radius = mxConstants.ARROW_WIDTH;
  var p = pos[0];
  pos = pos[pos.length - 1];
  /** @type {number} */
  var a = pos.x - p.x;
  /** @type {number} */
  var d = pos.y - p.y;
  /** @type {number} */
  var i = Math.sqrt(a * a + d * d);
  /** @type {number} */
  var j = i - 2 * w - mxConstants.ARROW_SIZE;
  /** @type {number} */
  a = a / i;
  /** @type {number} */
  d = d / i;
  /** @type {number} */
  i = radius * d / 3;
  /** @type {number} */
  radius = -radius * a / 3;
  /** @type {number} */
  var x0 = p.x - i / 2 + w * a;
  /** @type {number} */
  p = p.y - radius / 2 + w * d;
  /** @type {number} */
  var x = x0 + i;
  /** @type {number} */
  var r = p + radius;
  /** @type {number} */
  var t = x + j * a;
  /** @type {number} */
  j = r + j * d;
  /** @type {number} */
  var c = t + i;
  /** @type {number} */
  var y = j + radius;
  /** @type {number} */
  var offset = c - 3 * i;
  /** @type {number} */
  var cy = y - 3 * radius;
  ctx.begin();
  ctx.moveTo(x0, p);
  ctx.lineTo(x, r);
  ctx.lineTo(t, j);
  ctx.lineTo(c, y);
  ctx.lineTo(pos.x - w * a, pos.y - w * d);
  ctx.lineTo(offset, cy);
  ctx.lineTo(offset + i, cy + radius);
  ctx.close();
  ctx.fillAndStroke();
};
/**
 * @param {?} coords
 * @param {string} value
 * @param {!Object} size
 * @param {number} status
 * @param {number} e
 * @param {number} p
 * @param {?} altCss
 * @return {undefined}
 */
function mxArrowConnector(coords, value, size, status, e, p, altCss) {
  mxShape.call(this);
  this.points = coords;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != status ? status : 1;
  this.arrowWidth = null != e ? e : mxConstants.ARROW_WIDTH;
  this.arrowSpacing = null != p ? p : mxConstants.ARROW_SPACING;
  /** @type {number} */
  this.startSize = mxConstants.ARROW_SIZE / 5;
  /** @type {number} */
  this.endSize = mxConstants.ARROW_SIZE / 5;
}
mxUtils.extend(mxArrowConnector, mxShape);
/** @type {boolean} */
mxArrowConnector.prototype.useSvgBoundingBox = true;
/**
 * @return {?}
 */
mxArrowConnector.prototype.isRoundable = function() {
  return true;
};
/**
 * @return {undefined}
 */
mxArrowConnector.prototype.resetStyles = function() {
  mxShape.prototype.resetStyles.apply(this, arguments);
  this.arrowSpacing = mxConstants.ARROW_SPACING;
};
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxArrowConnector.prototype.apply = function(obj) {
  mxShape.prototype.apply.apply(this, arguments);
  if (null != this.style) {
    /** @type {number} */
    this.startSize = 3 * mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.ARROW_SIZE / 5);
    /** @type {number} */
    this.endSize = 3 * mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.ARROW_SIZE / 5);
  }
};
/**
 * @param {?} bbox
 * @return {undefined}
 */
mxArrowConnector.prototype.augmentBoundingBox = function(bbox) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  var widestInView = this.getEdgeWidth();
  if (this.isMarkerStart()) {
    /** @type {number} */
    widestInView = Math.max(widestInView, this.getStartArrowWidth());
  }
  if (this.isMarkerEnd()) {
    /** @type {number} */
    widestInView = Math.max(widestInView, this.getEndArrowWidth());
  }
  bbox.grow((widestInView / 2 + this.strokewidth) * this.scale);
};
/**
 * @param {!Object} ctx
 * @param {!Object} array
 * @return {undefined}
 */
mxArrowConnector.prototype.paintEdgeShape = function(ctx, array) {
  var delta = this.strokewidth;
  if (this.outline) {
    /** @type {number} */
    delta = Math.max(1, mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth));
  }
  var newWidth = this.getStartArrowWidth() + delta;
  var newSize = this.getEndArrowWidth() + delta;
  var r = this.outline ? this.getEdgeWidth() + delta : this.getEdgeWidth();
  var object = this.isOpenEnded();
  var isFunc = this.isMarkerStart();
  var property = this.isMarkerEnd();
  var m = object ? 0 : this.arrowSpacing + delta / 2;
  var start = this.startSize + delta;
  delta = this.endSize + delta;
  var progressElement = this.isArrowRounded();
  var segment = array[array.length - 1];
  /** @type {number} */
  var labelWidth = array[1].x - array[0].x;
  /** @type {number} */
  var size = array[1].y - array[0].y;
  /** @type {number} */
  var a = Math.sqrt(labelWidth * labelWidth + size * size);
  if (0 != a) {
    /** @type {number} */
    var t = labelWidth / a;
    /** @type {number} */
    var y = t;
    /** @type {number} */
    var s = size / a;
    /** @type {number} */
    var h = s;
    /** @type {number} */
    a = r * s;
    /** @type {number} */
    var radius = -r * t;
    /** @type {!Array} */
    var vertices = [];
    if (progressElement) {
      ctx.setLineJoin("round");
    } else {
      if (2 < array.length) {
        ctx.setMiterLimit(1.42);
      }
    }
    ctx.begin();
    /** @type {number} */
    labelWidth = t;
    /** @type {number} */
    size = s;
    if (isFunc && !object) {
      this.paintMarker(ctx, array[0].x, array[0].y, t, s, start, newWidth, r, m, true);
    } else {
      var x = array[0].x + a / 2 + m * t;
      var w = array[0].y + radius / 2 + m * s;
      /** @type {number} */
      var indicatorX = array[0].x - a / 2 + m * t;
      /** @type {number} */
      var transformY = array[0].y - radius / 2 + m * s;
      if (object) {
        ctx.moveTo(x, w);
        vertices.push(function() {
          ctx.lineTo(indicatorX, transformY);
        });
      } else {
        ctx.moveTo(indicatorX, transformY);
        ctx.lineTo(x, w);
      }
    }
    /** @type {number} */
    var d = w = x = 0;
    /** @type {number} */
    a = 0;
    for (; a < array.length - 2; a++) {
      if (radius = mxUtils.relativeCcw(array[a].x, array[a].y, array[a + 1].x, array[a + 1].y, array[a + 2].x, array[a + 2].y), x = array[a + 2].x - array[a + 1].x, w = array[a + 2].y - array[a + 1].y, d = Math.sqrt(x * x + w * w), 0 != d) {
        /** @type {number} */
        y = x / d;
        /** @type {number} */
        h = w / d;
        /** @type {number} */
        d = Math.max(Math.sqrt((t * y + s * h + 1) / 2), .04);
        /** @type {number} */
        x = t + y;
        /** @type {number} */
        w = s + h;
        /** @type {number} */
        var scale = Math.sqrt(x * x + w * w);
        if (0 != scale) {
          /** @type {number} */
          x = x / scale;
          /** @type {number} */
          w = w / scale;
          /** @type {number} */
          scale = Math.max(d, Math.min(this.strokewidth / 200 + .04, .35));
          /** @type {number} */
          d = 0 != radius && progressElement ? Math.max(.1, scale) : Math.max(d, .06);
          var width = array[a + 1].x + w * r / 2 / d;
          /** @type {number} */
          var y0 = array[a + 1].y - x * r / 2 / d;
          /** @type {number} */
          w = array[a + 1].x - w * r / 2 / d;
          x = array[a + 1].y + x * r / 2 / d;
          if (0 != radius && progressElement) {
            if (-1 == radius) {
              /** @type {number} */
              radius = w + h * r;
              /** @type {number} */
              d = x - y * r;
              ctx.lineTo(w + s * r, x - t * r);
              ctx.quadTo(width, y0, radius, d);
              (function(dim, tx) {
                vertices.push(function() {
                  ctx.lineTo(dim, tx);
                });
              })(w, x);
            } else {
              ctx.lineTo(width, y0);
              (function(tagName, tx) {
                /** @type {number} */
                var w = width - s * r;
                /** @type {number} */
                var b = y0 + t * r;
                /** @type {number} */
                var minx = width - h * r;
                /** @type {number} */
                var newY = y0 + y * r;
                vertices.push(function() {
                  ctx.quadTo(tagName, tx, w, b);
                });
                vertices.push(function() {
                  ctx.lineTo(minx, newY);
                });
              })(w, x);
            }
          } else {
            ctx.lineTo(width, y0);
            (function(dim, tx) {
              vertices.push(function() {
                ctx.lineTo(dim, tx);
              });
            })(w, x);
          }
          /** @type {number} */
          t = y;
          /** @type {number} */
          s = h;
        }
      }
    }
    /** @type {number} */
    a = r * h;
    /** @type {number} */
    radius = -r * y;
    if (property && !object) {
      this.paintMarker(ctx, segment.x, segment.y, -t, -s, delta, newSize, r, m, false);
    } else {
      ctx.lineTo(segment.x - m * y + a / 2, segment.y - m * h + radius / 2);
      /** @type {number} */
      var indicatorX = segment.x - m * y - a / 2;
      /** @type {number} */
      var transformY = segment.y - m * h - radius / 2;
      if (object) {
        ctx.moveTo(indicatorX, transformY);
        vertices.splice(0, 0, function() {
          ctx.moveTo(indicatorX, transformY);
        });
      } else {
        ctx.lineTo(indicatorX, transformY);
      }
    }
    /** @type {number} */
    a = vertices.length - 1;
    for (; 0 <= a; a--) {
      vertices[a]();
    }
    if (object) {
      ctx.end();
      ctx.stroke();
    } else {
      ctx.close();
      ctx.fillAndStroke();
    }
    ctx.setShadow(false);
    ctx.setMiterLimit(4);
    if (progressElement) {
      ctx.setLineJoin("flat");
    }
    if (2 < array.length) {
      ctx.setMiterLimit(4);
      if (isFunc && !object) {
        ctx.begin();
        this.paintMarker(ctx, array[0].x, array[0].y, labelWidth, size, start, newWidth, r, m, true);
        ctx.stroke();
        ctx.end();
      }
      if (property && !object) {
        ctx.begin();
        this.paintMarker(ctx, segment.x, segment.y, -t, -s, delta, newSize, r, m, true);
        ctx.stroke();
        ctx.end();
      }
    }
  }
};
/**
 * @param {!Object} ctx
 * @param {number} x
 * @param {number} top
 * @param {number} size
 * @param {number} scale
 * @param {number} offset
 * @param {number} width
 * @param {number} height
 * @param {number} y
 * @param {boolean} isHorizontal
 * @return {undefined}
 */
mxArrowConnector.prototype.paintMarker = function(ctx, x, top, size, scale, offset, width, height, y, isHorizontal) {
  /** @type {number} */
  width = height / width;
  /** @type {number} */
  var dx = height * scale / 2;
  /** @type {number} */
  height = -height * size / 2;
  /** @type {number} */
  var r = (y + offset) * size;
  /** @type {number} */
  offset = (y + offset) * scale;
  if (isHorizontal) {
    ctx.moveTo(x - dx + r, top - height + offset);
  } else {
    ctx.lineTo(x - dx + r, top - height + offset);
  }
  ctx.lineTo(x - dx / width + r, top - height / width + offset);
  ctx.lineTo(x + y * size, top + y * scale);
  ctx.lineTo(x + dx / width + r, top + height / width + offset);
  ctx.lineTo(x + dx + r, top + height + offset);
};
/**
 * @return {?}
 */
mxArrowConnector.prototype.isArrowRounded = function() {
  return this.isRounded;
};
/**
 * @return {?}
 */
mxArrowConnector.prototype.getStartArrowWidth = function() {
  return mxConstants.ARROW_WIDTH;
};
/**
 * @return {?}
 */
mxArrowConnector.prototype.getEndArrowWidth = function() {
  return mxConstants.ARROW_WIDTH;
};
/**
 * @return {?}
 */
mxArrowConnector.prototype.getEdgeWidth = function() {
  return mxConstants.ARROW_WIDTH / 3;
};
/**
 * @return {?}
 */
mxArrowConnector.prototype.isOpenEnded = function() {
  return false;
};
/**
 * @return {?}
 */
mxArrowConnector.prototype.isMarkerStart = function() {
  return mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE;
};
/**
 * @return {?}
 */
mxArrowConnector.prototype.isMarkerEnd = function() {
  return mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE;
};
/**
 * @param {!Object} b
 * @param {!Object} bounds
 * @param {string} position
 * @param {string} defAngle
 * @param {string} color
 * @param {string} family
 * @param {number} size
 * @param {string} total
 * @param {number} duration
 * @param {number} value
 * @param {number} option
 * @param {number} i
 * @param {number} val
 * @param {number} name
 * @param {string} background
 * @param {?} border
 * @param {string} length
 * @param {string} data
 * @param {string} speed
 * @param {number} to
 * @param {?} topspeed
 * @return {undefined}
 */
function mxText(b, bounds, position, defAngle, color, family, size, total, duration, value, option, i, val, name, background, border, length, data, speed, to, topspeed) {
  mxShape.call(this);
  /** @type {!Object} */
  this.value = b;
  /** @type {!Object} */
  this.bounds = bounds;
  this.color = null != color ? color : "black";
  this.align = null != position ? position : mxConstants.ALIGN_CENTER;
  this.valign = null != defAngle ? defAngle : mxConstants.ALIGN_MIDDLE;
  this.family = null != family ? family : mxConstants.DEFAULT_FONTFAMILY;
  this.size = null != size ? size : mxConstants.DEFAULT_FONTSIZE;
  this.fontStyle = null != total ? total : mxConstants.DEFAULT_FONTSTYLE;
  /** @type {number} */
  this.spacing = parseInt(duration || 2);
  /** @type {number} */
  this.spacingTop = this.spacing + parseInt(value || 0);
  /** @type {number} */
  this.spacingRight = this.spacing + parseInt(option || 0);
  /** @type {number} */
  this.spacingBottom = this.spacing + parseInt(i || 0);
  /** @type {number} */
  this.spacingLeft = this.spacing + parseInt(val || 0);
  this.horizontal = null != name ? name : true;
  /** @type {string} */
  this.background = background;
  this.border = border;
  this.wrap = null != length ? length : false;
  this.clipped = null != data ? data : false;
  this.overflow = null != speed ? speed : "visible";
  this.labelPadding = null != to ? to : 0;
  this.textDirection = topspeed;
  /** @type {number} */
  this.rotation = 0;
  this.updateMargin();
}
mxUtils.extend(mxText, mxShape);
/** @type {number} */
mxText.prototype.baseSpacingTop = 0;
/** @type {number} */
mxText.prototype.baseSpacingBottom = 0;
/** @type {number} */
mxText.prototype.baseSpacingLeft = 0;
/** @type {number} */
mxText.prototype.baseSpacingRight = 0;
/** @type {boolean} */
mxText.prototype.replaceLinefeeds = true;
/** @type {number} */
mxText.prototype.verticalTextRotation = -90;
/** @type {boolean} */
mxText.prototype.ignoreClippedStringSize = true;
/** @type {boolean} */
mxText.prototype.ignoreStringSize = false;
/** @type {number} */
mxText.prototype.textWidthPadding = 8 != document.documentMode || mxClient.IS_EM ? 3 : 4;
/** @type {null} */
mxText.prototype.lastValue = null;
/** @type {boolean} */
mxText.prototype.cacheEnabled = true;
/**
 * @return {?}
 */
mxText.prototype.isHtmlAllowed = function() {
  return 8 != document.documentMode || mxClient.IS_EM;
};
/**
 * @return {?}
 */
mxText.prototype.getSvgScreenOffset = function() {
  return 0;
};
/**
 * @return {?}
 */
mxText.prototype.checkBounds = function() {
  return !isNaN(this.scale) && isFinite(this.scale) && 0 < this.scale && null != this.bounds && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height);
};
/**
 * @param {!CanvasRenderingContext2D} macro_context
 * @return {undefined}
 */
mxText.prototype.configurePointerEvents = function(macro_context) {
};
/**
 * @param {!Object} self
 * @param {string} data
 * @return {undefined}
 */
mxText.prototype.paint = function(self, data) {
  var r = this.scale;
  /** @type {number} */
  var d = this.bounds.x / r;
  /** @type {number} */
  var value = this.bounds.y / r;
  /** @type {number} */
  var t = this.bounds.width / r;
  /** @type {number} */
  r = this.bounds.height / r;
  this.updateTransform(self, d, value, t, r);
  this.configureCanvas(self, d, value, t, r);
  if (data) {
    self.updateText(d, value, t, r, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.getTextRotation(), this.node);
  } else {
    /** @type {string} */
    var undefined = (data = mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML) ? "html" : "";
    var key = this.value;
    if (!(data || "html" != undefined)) {
      key = mxUtils.htmlEntities(key, false);
    }
    if (!("html" != undefined || mxUtils.isNode(this.value))) {
      key = mxUtils.replaceTrailingNewlines(key, "<div><br></div>");
    }
    key = !mxUtils.isNode(this.value) && this.replaceLinefeeds && "html" == undefined ? key.replace(/\n/g, "<br/>") : key;
    var file = this.textDirection;
    if (!(file != mxConstants.TEXT_DIRECTION_AUTO || data)) {
      file = this.getAutoDirection();
    }
    if (file != mxConstants.TEXT_DIRECTION_LTR && file != mxConstants.TEXT_DIRECTION_RTL) {
      /** @type {null} */
      file = null;
    }
    self.text(d, value, t, r, key, this.align, this.valign, this.wrap, undefined, this.overflow, this.clipped, this.getTextRotation(), file);
  }
};
/**
 * @return {undefined}
 */
mxText.prototype.redraw = function() {
  if (this.visible && this.checkBounds() && this.cacheEnabled && this.lastValue == this.value && (mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML)) {
    if ("DIV" == this.node.nodeName) {
      if (mxClient.IS_SVG) {
        this.redrawHtmlShapeWithCss3();
      } else {
        this.updateSize(this.node, null == this.state || null == this.state.view.textDiv);
        if (mxClient.IS_IE && (null == document.documentMode || 8 >= document.documentMode)) {
          this.updateHtmlFilter();
        } else {
          this.updateHtmlTransform();
        }
      }
      this.updateBoundingBox();
    } else {
      var self = this.createCanvas();
      if (null != self && null != self.updateText) {
        self.pointerEvents = this.pointerEvents;
        this.paint(self, true);
        this.destroyCanvas(self);
        this.updateBoundingBox();
      } else {
        mxShape.prototype.redraw.apply(this, arguments);
      }
    }
  } else {
    mxShape.prototype.redraw.apply(this, arguments);
    if (mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML) {
      this.lastValue = this.value;
    } else {
      /** @type {null} */
      this.lastValue = null;
    }
  }
};
/**
 * @return {undefined}
 */
mxText.prototype.resetStyles = function() {
  mxShape.prototype.resetStyles.apply(this, arguments);
  /** @type {string} */
  this.color = "black";
  this.align = mxConstants.ALIGN_CENTER;
  this.valign = mxConstants.ALIGN_MIDDLE;
  this.family = mxConstants.DEFAULT_FONTFAMILY;
  this.size = mxConstants.DEFAULT_FONTSIZE;
  this.fontStyle = mxConstants.DEFAULT_FONTSTYLE;
  /** @type {number} */
  this.spacingLeft = this.spacingBottom = this.spacingRight = this.spacingTop = this.spacing = 2;
  /** @type {boolean} */
  this.horizontal = true;
  delete this.background;
  delete this.border;
  this.textDirection = mxConstants.DEFAULT_TEXT_DIRECTION;
  delete this.margin;
};
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxText.prototype.apply = function(obj) {
  var spacing = this.spacing;
  mxShape.prototype.apply.apply(this, arguments);
  if (null != this.style) {
    this.fontStyle = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSTYLE, this.fontStyle);
    this.family = mxUtils.getValue(this.style, mxConstants.STYLE_FONTFAMILY, this.family);
    this.size = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, this.size);
    this.color = mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, this.color);
    this.align = mxUtils.getValue(this.style, mxConstants.STYLE_ALIGN, this.align);
    this.valign = mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_ALIGN, this.valign);
    /** @type {number} */
    this.spacing = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing));
    /** @type {number} */
    this.spacingTop = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_TOP, this.spacingTop - spacing)) + this.spacing;
    /** @type {number} */
    this.spacingRight = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_RIGHT, this.spacingRight - spacing)) + this.spacing;
    /** @type {number} */
    this.spacingBottom = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_BOTTOM, this.spacingBottom - spacing)) + this.spacing;
    /** @type {number} */
    this.spacingLeft = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_LEFT, this.spacingLeft - spacing)) + this.spacing;
    this.horizontal = mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, this.horizontal);
    this.background = mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_BACKGROUNDCOLOR, this.background);
    this.border = mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_BORDERCOLOR, this.border);
    this.textDirection = mxUtils.getValue(this.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);
    this.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_TEXT_OPACITY, 100);
    this.updateMargin();
  }
  /** @type {null} */
  this.flipH = this.flipV = null;
};
/**
 * @return {?}
 */
mxText.prototype.getAutoDirection = function() {
  /** @type {(Array<string>|null)} */
  var s = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(this.value);
  return null != s && 0 < s.length && "z" < s[0] ? mxConstants.TEXT_DIRECTION_RTL : mxConstants.TEXT_DIRECTION_LTR;
};
/**
 * @return {?}
 */
mxText.prototype.getContentNode = function() {
  var container = this.node;
  if (null != container) {
    container = null == container.ownerSVGElement ? this.node.firstChild.firstChild : container.firstChild.firstChild.firstChild.firstChild.firstChild;
  }
  return container;
};
/**
 * @return {undefined}
 */
mxText.prototype.updateBoundingBox = function() {
  var node = this.node;
  this.boundingBox = this.bounds.clone();
  var d = this.getTextRotation();
  var p = null != this.style ? mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER) : null;
  var s = null != this.style ? mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE) : null;
  if (!(this.ignoreStringSize || null == node || "fill" == this.overflow || this.clipped && this.ignoreClippedStringSize && p == mxConstants.ALIGN_CENTER && s == mxConstants.ALIGN_MIDDLE)) {
    /** @type {null} */
    s = p = null;
    if (null != node.ownerSVGElement) {
      if (null != node.firstChild && null != node.firstChild.firstChild && "foreignObject" == node.firstChild.firstChild.nodeName) {
        node = node.firstChild.firstChild.firstChild.firstChild;
        /** @type {number} */
        s = node.offsetHeight * this.scale;
        p = "width" == this.overflow ? this.boundingBox.width : node.offsetWidth * this.scale;
      } else {
        try {
          var table = node.getBBox();
          if ("string" == typeof this.value && 0 == mxUtils.trim(this.value)) {
            /** @type {null} */
            this.boundingBox = null;
          } else {
            this.boundingBox = 0 == table.width && 0 == table.height ? null : new mxRectangle(table.x, table.y, table.width, table.height);
          }
          return;
        } catch (f) {
        }
      }
    } else {
      p = null != this.state ? this.state.view.textDiv : null;
      if (null == this.offsetWidth || null == this.offsetHeight) {
        if (null != p) {
          this.updateFont(p);
          this.updateSize(p, false);
          this.updateInnerHtml(p);
          node = p;
        }
        table = node;
        if (8 != document.documentMode || mxClient.IS_EM) {
          if (null != table.firstChild && "DIV" == table.firstChild.nodeName) {
            table = table.firstChild;
          }
        } else {
          /** @type {number} */
          s = Math.round(this.bounds.width / this.scale);
          if (this.wrap && 0 < s) {
            node.style.wordWrap = mxConstants.WORD_WRAP;
            /** @type {string} */
            node.style.whiteSpace = "normal";
            if ("break-word" != node.style.wordWrap) {
              node = table.getElementsByTagName("div");
              if (0 < node.length) {
                table = node[node.length - 1];
              }
              p = table.offsetWidth + 2;
              node = this.node.getElementsByTagName("div");
              if (this.clipped) {
                /** @type {number} */
                p = Math.min(s, p);
              }
              if (1 < node.length) {
                /** @type {string} */
                node[node.length - 2].style.width = p + "px";
              }
            }
          } else {
            /** @type {string} */
            node.style.whiteSpace = "nowrap";
          }
        }
        this.offsetWidth = table.offsetWidth + this.textWidthPadding;
        this.offsetHeight = table.offsetHeight;
      }
      /** @type {number} */
      p = this.offsetWidth * this.scale;
      /** @type {number} */
      s = this.offsetHeight * this.scale;
    }
    if (null != p && null != s) {
      this.boundingBox = new mxRectangle(this.bounds.x, this.bounds.y, p, s);
    }
  }
  if (null != this.boundingBox) {
    if (0 != d) {
      d = mxUtils.getBoundingBox(new mxRectangle(this.margin.x * this.boundingBox.width, this.margin.y * this.boundingBox.height, this.boundingBox.width, this.boundingBox.height), d, new mxPoint(0, 0));
      this.unrotatedBoundingBox = mxRectangle.fromRectangle(this.boundingBox);
      this.unrotatedBoundingBox.x += this.margin.x * this.unrotatedBoundingBox.width;
      this.unrotatedBoundingBox.y += this.margin.y * this.unrotatedBoundingBox.height;
      this.boundingBox.x += d.x;
      this.boundingBox.y += d.y;
      this.boundingBox.width = d.width;
      this.boundingBox.height = d.height;
    } else {
      this.boundingBox.x += this.margin.x * this.boundingBox.width;
      this.boundingBox.y += this.margin.y * this.boundingBox.height;
      /** @type {null} */
      this.unrotatedBoundingBox = null;
    }
  }
};
/**
 * @return {?}
 */
mxText.prototype.getShapeRotation = function() {
  return 0;
};
/**
 * @return {?}
 */
mxText.prototype.getTextRotation = function() {
  return null != this.state && null != this.state.shape ? this.state.shape.getTextRotation() : 0;
};
/**
 * @return {?}
 */
mxText.prototype.isPaintBoundsInverted = function() {
  return !this.horizontal && null != this.state && this.state.view.graph.model.isVertex(this.state.cell);
};
/**
 * @param {!Object} context
 * @param {number} d
 * @param {number} props
 * @param {number} method
 * @param {number} options
 * @return {undefined}
 */
mxText.prototype.configureCanvas = function(context, d, props, method, options) {
  mxShape.prototype.configureCanvas.apply(this, arguments);
  context.setFontColor(this.color);
  context.setFontBackgroundColor(this.background);
  context.setFontBorderColor(this.border);
  context.setFontFamily(this.family);
  context.setFontSize(this.size);
  context.setFontStyle(this.fontStyle);
};
/**
 * @return {?}
 */
mxText.prototype.getHtmlValue = function() {
  var value = this.value;
  if (this.dialect != mxConstants.DIALECT_STRICTHTML) {
    value = mxUtils.htmlEntities(value, false);
  }
  value = mxUtils.replaceTrailingNewlines(value, "<div><br></div>");
  return value = this.replaceLinefeeds ? value.replace(/\n/g, "<br/>") : value;
};
/**
 * @return {?}
 */
mxText.prototype.getTextCss = function() {
  /** @type {string} */
  var chunkIndex = "display: inline-block; font-size: " + this.size + "px; font-family: " + this.family + "; color: " + this.color + "; line-height: " + (mxConstants.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT) + "; pointer-events: " + (this.pointerEvents ? "all" : "none") + "; ";
  if ((this.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
    /** @type {string} */
    chunkIndex = chunkIndex + "font-weight: bold; ";
  }
  if ((this.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
    /** @type {string} */
    chunkIndex = chunkIndex + "font-style: italic; ";
  }
  /** @type {!Array} */
  var textDecorations = [];
  if ((this.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    textDecorations.push("underline");
  }
  if ((this.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
    textDecorations.push("line-through");
  }
  if (0 < textDecorations.length) {
    /** @type {string} */
    chunkIndex = chunkIndex + ("text-decoration: " + textDecorations.join(" ") + "; ");
  }
  return chunkIndex;
};
/**
 * @return {undefined}
 */
mxText.prototype.redrawHtmlShape = function() {
  if (mxClient.IS_SVG) {
    this.redrawHtmlShapeWithCss3();
  } else {
    var style = this.node.style;
    /** @type {string} */
    style.whiteSpace = "normal";
    /** @type {string} */
    style.overflow = "";
    /** @type {string} */
    style.width = "";
    /** @type {string} */
    style.height = "";
    this.updateValue();
    this.updateFont(this.node);
    this.updateSize(this.node, null == this.state || null == this.state.view.textDiv);
    /** @type {null} */
    this.offsetHeight = this.offsetWidth = null;
    if (mxClient.IS_IE && (null == document.documentMode || 8 >= document.documentMode)) {
      this.updateHtmlFilter();
    } else {
      this.updateHtmlTransform();
    }
  }
};
/**
 * @return {undefined}
 */
mxText.prototype.redrawHtmlShapeWithCss3 = function() {
  /** @type {number} */
  var a = Math.max(0, Math.round(this.bounds.width / this.scale));
  /** @type {number} */
  var IMG_HEIGHT = Math.max(0, Math.round(this.bounds.height / this.scale));
  /** @type {string} */
  var scriptrule = "position: absolute; left: " + Math.round(this.bounds.x) + "px; top: " + Math.round(this.bounds.y) + "px; pointer-events: none; ";
  var el_l = this.getTextCss();
  mxSvgCanvas2D.createCss(a + 2, IMG_HEIGHT, this.align, this.valign, this.wrap, this.overflow, this.clipped, null != this.background ? mxUtils.htmlEntities(this.background) : null, null != this.border ? mxUtils.htmlEntities(this.border) : null, scriptrule, el_l, this.scale, mxUtils.bind(this, function(result, canCreateDiscussions, cssText, css, value, name) {
    result = this.getTextRotation();
    /** @type {string} */
    result = (1 != this.scale ? "scale(" + this.scale + ") " : "") + (0 != result ? "rotate(" + result + "deg) " : "") + (0 != this.margin.x || 0 != this.margin.y ? "translate(" + 100 * this.margin.x + "%," + 100 * this.margin.y + "%)" : "");
    if ("" != result) {
      /** @type {string} */
      result = "transform-origin: 0 0; transform: " + result + "; ";
    }
    if ("block" == this.overflow && this.valign == mxConstants.ALIGN_MIDDLE) {
      /** @type {string} */
      result = result + ("max-height: " + (IMG_HEIGHT + 1) + "px;");
    }
    if ("" == name) {
      cssText = cssText + css;
      /** @type {string} */
      css = "display:inline-block; min-width: 100%; " + result;
    } else {
      /** @type {string} */
      css = css + result;
      if (mxClient.IS_SF) {
        /** @type {string} */
        css = css + "-webkit-clip-path: content-box;";
      }
    }
    if ("block" == this.overflow) {
      /** @type {string} */
      css = css + "width: 100%; ";
    }
    if (100 > this.opacity) {
      /** @type {string} */
      value = value + ("opacity: " + this.opacity / 100 + "; ");
    }
    this.node.setAttribute("style", cssText);
    cssText = mxUtils.isNode(this.value) ? this.value.outerHTML : this.getHtmlValue();
    if (null == this.node.firstChild) {
      /** @type {string} */
      this.node.innerHTML = "<div><div>" + cssText + "</div></div>";
      if (mxClient.IS_IE11) {
        this.fixFlexboxForIe11(this.node);
      }
    }
    this.node.firstChild.firstChild.setAttribute("style", value);
    this.node.firstChild.setAttribute("style", css);
  }));
};
/**
 * @param {?} verticalMargin
 * @return {undefined}
 */
mxText.prototype.fixFlexboxForIe11 = function(verticalMargin) {
  var addedImgs = verticalMargin.querySelectorAll('div[style*="display: flex; justify-content: flex-end;"]');
  /** @type {number} */
  var i = 0;
  for (; i < addedImgs.length; i++) {
    /** @type {string} */
    addedImgs[i].style.justifyContent = "flex-start";
    /** @type {string} */
    addedImgs[i].style.flexDirection = "row-reverse";
  }
  if (!this.wrap) {
    addedImgs = verticalMargin.querySelectorAll('div[style*="display: flex; justify-content: center;"]');
    /** @type {number} */
    verticalMargin = -window.innerWidth;
    /** @type {number} */
    i = 0;
    for (; i < addedImgs.length; i++) {
      /** @type {string} */
      addedImgs[i].style.marginLeft = verticalMargin + "px";
      /** @type {string} */
      addedImgs[i].style.marginRight = verticalMargin + "px";
    }
  }
};
/**
 * @return {undefined}
 */
mxText.prototype.updateHtmlTransform = function() {
  var a = this.getTextRotation();
  var style = this.node.style;
  var x = this.margin.x;
  var cy = this.margin.y;
  if (0 != a) {
    mxUtils.setPrefixedStyle(style, "transformOrigin", 100 * -x + "% " + 100 * -cy + "%");
    mxUtils.setPrefixedStyle(style, "transform", "translate(" + 100 * x + "%," + 100 * cy + "%) scale(" + this.scale + ") rotate(" + a + "deg)");
  } else {
    mxUtils.setPrefixedStyle(style, "transformOrigin", "0% 0%");
    mxUtils.setPrefixedStyle(style, "transform", "scale(" + this.scale + ") translate(" + 100 * x + "%," + 100 * cy + "%)");
  }
  /** @type {string} */
  style.left = Math.round(this.bounds.x - Math.ceil(x * ("fill" != this.overflow && "width" != this.overflow ? 3 : 1))) + "px";
  /** @type {string} */
  style.top = Math.round(this.bounds.y - cy * ("fill" != this.overflow ? 3 : 1)) + "px";
  /** @type {(number|string)} */
  style.opacity = 100 > this.opacity ? this.opacity / 100 : "";
};
/**
 * @param {!Object} p
 * @return {undefined}
 */
mxText.prototype.updateInnerHtml = function(p) {
  if (mxUtils.isNode(this.value)) {
    p.innerHTML = this.value.outerHTML;
  } else {
    var value = this.value;
    if (this.dialect != mxConstants.DIALECT_STRICTHTML) {
      value = mxUtils.htmlEntities(value, false);
    }
    value = mxUtils.replaceTrailingNewlines(value, "<div>&nbsp;</div>");
    value = this.replaceLinefeeds ? value.replace(/\n/g, "<br/>") : value;
    /** @type {string} */
    p.innerHTML = '<div style="display:inline-block;_display:inline;">' + value + "</div>";
  }
};
/**
 * @return {undefined}
 */
mxText.prototype.updateHtmlFilter = function() {
  var s = this.node.style;
  var x = this.margin.x;
  var yy = this.margin.y;
  var scale = this.scale;
  mxUtils.setOpacity(this.node, this.opacity);
  /** @type {number} */
  var h = 0;
  var y = null != this.state ? this.state.view.textDiv : null;
  var a = this.node;
  if (null != y) {
    /** @type {string} */
    y.style.overflow = "";
    /** @type {string} */
    y.style.height = "";
    /** @type {string} */
    y.style.width = "";
    this.updateFont(y);
    this.updateSize(y, false);
    this.updateInnerHtml(y);
    /** @type {number} */
    var i = Math.round(this.bounds.width / this.scale);
    if (this.wrap && 0 < i) {
      /** @type {string} */
      y.style.whiteSpace = "normal";
      y.style.wordWrap = mxConstants.WORD_WRAP;
      /** @type {number} */
      var c = i;
      if (this.clipped) {
        /** @type {number} */
        c = Math.min(c, this.bounds.width);
      }
      /** @type {string} */
      y.style.width = c + "px";
    } else {
      /** @type {string} */
      y.style.whiteSpace = "nowrap";
    }
    a = y;
    if (null != a.firstChild && "DIV" == a.firstChild.nodeName) {
      a = a.firstChild;
      if (this.wrap && "break-word" == y.style.wordWrap) {
        /** @type {string} */
        a.style.width = "100%";
      }
    }
    if (!this.clipped && this.wrap && 0 < i) {
      c = a.offsetWidth + this.textWidthPadding;
      /** @type {string} */
      y.style.width = c + "px";
    }
    h = a.offsetHeight + 2;
  } else {
    if (null != a.firstChild && "DIV" == a.firstChild.nodeName) {
      a = a.firstChild;
      h = a.offsetHeight;
    }
  }
  c = a.offsetWidth + this.textWidthPadding;
  if (this.clipped) {
    /** @type {number} */
    h = Math.min(h, this.bounds.height);
  }
  /** @type {number} */
  i = this.bounds.width / scale;
  /** @type {number} */
  y = this.bounds.height / scale;
  if ("fill" == this.overflow) {
    /** @type {number} */
    h = y;
    /** @type {number} */
    c = i;
  } else {
    if ("width" == this.overflow) {
      h = a.scrollHeight;
      /** @type {number} */
      c = i;
    }
  }
  this.offsetWidth = c;
  this.offsetHeight = h;
  if ("fill" != this.overflow && "width" != this.overflow) {
    if (this.clipped) {
      /** @type {number} */
      c = Math.min(i, c);
    }
    i = c;
    if (this.wrap) {
      /** @type {string} */
      s.width = Math.round(i) + "px";
    }
  }
  /** @type {number} */
  y = h * scale;
  /** @type {number} */
  i = i * scale;
  /** @type {number} */
  var angle = this.getTextRotation() * (Math.PI / 180);
  /** @type {number} */
  c = parseFloat(parseFloat(Math.cos(angle)).toFixed(8));
  /** @type {number} */
  h = parseFloat(parseFloat(Math.sin(-angle)).toFixed(8));
  /** @type {number} */
  angle = angle % (2 * Math.PI);
  if (0 > angle) {
    /** @type {number} */
    angle = angle + 2 * Math.PI;
  }
  /** @type {number} */
  angle = angle % Math.PI;
  if (angle > Math.PI / 2) {
    /** @type {number} */
    angle = Math.PI - angle;
  }
  /** @type {number} */
  a = Math.cos(angle);
  /** @type {number} */
  var spacing = Math.sin(-angle);
  /** @type {number} */
  x = i * -(x + .5);
  /** @type {number} */
  yy = y * -(yy + .5);
  if (0 != angle) {
    /** @type {string} */
    angle = "progid:DXImageTransform.Microsoft.Matrix(M11=" + c + ", M12=" + h + ", M21=" + -h + ", M22=" + c + ", sizingMethod='auto expand')";
    /** @type {string} */
    s.filter = null != s.filter && 0 < s.filter.length ? s.filter + (" " + angle) : angle;
  }
  s.zoom = scale;
  /** @type {string} */
  s.left = Math.round(this.bounds.x + ((i - i * a + y * spacing) / 2 - c * x - h * yy) - i / 2) + "px";
  /** @type {string} */
  s.top = Math.round(this.bounds.y + ((y - y * a + i * spacing) / 2 + h * x - c * yy) - y / 2) + "px";
};
/**
 * @return {undefined}
 */
mxText.prototype.updateValue = function() {
  if (mxUtils.isNode(this.value)) {
    /** @type {string} */
    this.node.innerText = "";
    this.node.appendChild(this.value);
  } else {
    var text = this.value;
    if (this.dialect != mxConstants.DIALECT_STRICTHTML) {
      text = mxUtils.htmlEntities(text, false);
    }
    text = mxUtils.replaceTrailingNewlines(text, "<div><br></div>");
    text = this.replaceLinefeeds ? text.replace(/\n/g, "<br/>") : text;
    var value = null != this.background && this.background != mxConstants.NONE ? this.background : null;
    var emoji = null != this.border && this.border != mxConstants.NONE ? this.border : null;
    if ("fill" == this.overflow || "width" == this.overflow) {
      if (null != value) {
        this.node.style.backgroundColor = value;
      }
      if (null != emoji) {
        /** @type {string} */
        this.node.style.border = "1px solid " + emoji;
      }
    } else {
      /** @type {string} */
      var pix_color = "";
      if (null != value) {
        /** @type {string} */
        pix_color = pix_color + ("background-color:" + mxUtils.htmlEntities(value) + ";");
      }
      if (null != emoji) {
        /** @type {string} */
        pix_color = pix_color + ("border:1px solid " + mxUtils.htmlEntities(emoji) + ";");
      }
      /** @type {string} */
      text = '<div style="zoom:1;' + pix_color + "display:inline-block;_display:inline;text-decoration:inherit;padding-bottom:1px;padding-right:1px;line-height:" + (mxConstants.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT) + '">' + text + "</div>";
    }
    this.node.innerHTML = text;
    text = this.node.getElementsByTagName("div");
    if (0 < text.length) {
      value = this.textDirection;
      if (value == mxConstants.TEXT_DIRECTION_AUTO && this.dialect != mxConstants.DIALECT_STRICTHTML) {
        value = this.getAutoDirection();
      }
      if (value == mxConstants.TEXT_DIRECTION_LTR || value == mxConstants.TEXT_DIRECTION_RTL) {
        text[text.length - 1].setAttribute("dir", value);
      } else {
        text[text.length - 1].removeAttribute("dir");
      }
    }
  }
};
/**
 * @param {!Object} style
 * @return {undefined}
 */
mxText.prototype.updateFont = function(style) {
  style = style.style;
  style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT;
  /** @type {string} */
  style.fontSize = this.size + "px";
  style.fontFamily = this.family;
  /** @type {string} */
  style.verticalAlign = "top";
  style.color = this.color;
  /** @type {string} */
  style.fontWeight = (this.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD ? "bold" : "";
  /** @type {string} */
  style.fontStyle = (this.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC ? "italic" : "";
  /** @type {!Array} */
  var textDecorations = [];
  if ((this.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    textDecorations.push("underline");
  }
  if ((this.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
    textDecorations.push("line-through");
  }
  /** @type {string} */
  style.textDecoration = textDecorations.join(" ");
  /** @type {string} */
  style.textAlign = this.align == mxConstants.ALIGN_CENTER ? "center" : this.align == mxConstants.ALIGN_RIGHT ? "right" : "left";
};
/**
 * @param {!Object} t
 * @param {!Object} b
 * @return {undefined}
 */
mxText.prototype.updateSize = function(t, b) {
  /** @type {number} */
  var width = Math.max(0, Math.round(this.bounds.width / this.scale));
  /** @type {number} */
  var maxWidth = Math.max(0, Math.round(this.bounds.height / this.scale));
  var style = t.style;
  if (this.clipped) {
    /** @type {string} */
    style.overflow = "hidden";
    /** @type {string} */
    style.maxHeight = maxWidth + "px";
    /** @type {string} */
    style.maxWidth = width + "px";
  } else {
    if ("fill" == this.overflow) {
      /** @type {string} */
      style.width = width + 1 + "px";
      /** @type {string} */
      style.height = maxWidth + 1 + "px";
      /** @type {string} */
      style.overflow = "hidden";
    } else {
      if ("width" == this.overflow) {
        /** @type {string} */
        style.width = width + 1 + "px";
        /** @type {string} */
        style.maxHeight = maxWidth + 1 + "px";
        /** @type {string} */
        style.overflow = "hidden";
      } else {
        if ("block" == this.overflow) {
          /** @type {string} */
          style.width = width + 1 + "px";
        }
      }
    }
  }
  if (this.wrap && 0 < width) {
    if (style.wordWrap = mxConstants.WORD_WRAP, style.whiteSpace = "normal", style.width = width + "px", b && "fill" != this.overflow && "width" != this.overflow) {
      /** @type {!Object} */
      b = t;
      if (null != b.firstChild && "DIV" == b.firstChild.nodeName) {
        b = b.firstChild;
        if ("break-word" == t.style.wordWrap) {
          /** @type {string} */
          b.style.width = "100%";
        }
      }
      maxWidth = b.offsetWidth;
      if (0 == maxWidth) {
        var f = t.parentNode;
        /** @type {string} */
        t.style.visibility = "hidden";
        document.body.appendChild(t);
        maxWidth = b.offsetWidth;
        /** @type {string} */
        t.style.visibility = "";
        f.appendChild(t);
      }
      maxWidth = maxWidth + 3;
      if (this.clipped) {
        /** @type {number} */
        maxWidth = Math.min(maxWidth, width);
      }
      /** @type {string} */
      style.width = maxWidth + "px";
    }
  } else {
    /** @type {string} */
    style.whiteSpace = "nowrap";
  }
};
/**
 * @return {undefined}
 */
mxText.prototype.updateMargin = function() {
  this.margin = mxUtils.getAlignmentAsPoint(this.align, this.valign);
};
/**
 * @param {boolean} type
 * @return {?}
 */
mxText.prototype.getSpacing = function(type) {
  return new mxPoint(this.align == mxConstants.ALIGN_CENTER ? (this.spacingLeft - this.spacingRight) / 2 : this.align == mxConstants.ALIGN_RIGHT ? -this.spacingRight - (type ? 0 : this.baseSpacingRight) : this.spacingLeft + (type ? 0 : this.baseSpacingLeft), this.valign == mxConstants.ALIGN_MIDDLE ? (this.spacingTop - this.spacingBottom) / 2 : this.valign == mxConstants.ALIGN_BOTTOM ? -this.spacingBottom - (type ? 0 : this.baseSpacingBottom) : this.spacingTop + (type ? 0 : this.baseSpacingTop));
};
/**
 * @return {undefined}
 */
function mxTriangle() {
  mxActor.call(this);
}
mxUtils.extend(mxTriangle, mxActor);
/**
 * @return {?}
 */
mxTriangle.prototype.isRoundable = function() {
  return true;
};
/**
 * @param {!Object} path
 * @param {number} c
 * @param {number} arg
 * @param {number} width
 * @param {number} height
 * @return {undefined}
 */
mxTriangle.prototype.redrawPath = function(path, c, arg, width, height) {
  /** @type {number} */
  c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  this.addPoints(path, [new mxPoint(0, 0), new mxPoint(width, .5 * height), new mxPoint(0, height)], this.isRounded, c, true);
};
/**
 * @return {undefined}
 */
function mxHexagon() {
  mxActor.call(this);
}
mxUtils.extend(mxHexagon, mxActor);
/**
 * @param {!Object} path
 * @param {number} c
 * @param {number} arg
 * @param {number} width
 * @param {number} height
 * @return {undefined}
 */
mxHexagon.prototype.redrawPath = function(path, c, arg, width, height) {
  /** @type {number} */
  c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  this.addPoints(path, [new mxPoint(.25 * width, 0), new mxPoint(.75 * width, 0), new mxPoint(width, .5 * height), new mxPoint(.75 * width, height), new mxPoint(.25 * width, height), new mxPoint(0, .5 * height)], this.isRounded, c, true);
};
/**
 * @param {!Object} bounds
 * @param {!Object} size
 * @param {number} c
 * @param {number} initlength
 * @return {undefined}
 */
function mxLine(bounds, size, c, initlength) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != c ? c : 1;
  this.vertical = null != initlength ? initlength : this.vertical;
}
mxUtils.extend(mxLine, mxShape);
/** @type {boolean} */
mxLine.prototype.vertical = false;
/**
 * @param {!Object} ctx
 * @param {number} x
 * @param {number} t
 * @param {number} w
 * @param {number} h
 * @return {undefined}
 */
mxLine.prototype.paintVertexShape = function(ctx, x, t, w, h) {
  ctx.begin();
  if (this.vertical) {
    var r = x + w / 2;
    ctx.moveTo(r, t);
    ctx.lineTo(r, t + h);
  } else {
    r = t + h / 2;
    ctx.moveTo(x, r);
    ctx.lineTo(x + w, r);
  }
  ctx.stroke();
};
/**
 * @param {!Object} radius
 * @param {string} canvas
 * @param {string} fill
 * @param {!Object} stroke
 * @param {number} strokewidth
 * @return {undefined}
 */
function mxImageShape(radius, canvas, fill, stroke, strokewidth) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = radius;
  /** @type {string} */
  this.image = canvas;
  /** @type {string} */
  this.fill = fill;
  /** @type {!Object} */
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
  /** @type {boolean} */
  this.shadow = false;
}
mxUtils.extend(mxImageShape, mxRectangleShape);
/** @type {boolean} */
mxImageShape.prototype.preserveImageAspect = true;
/**
 * @return {?}
 */
mxImageShape.prototype.getSvgScreenOffset = function() {
  return 0;
};
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxImageShape.prototype.apply = function(obj) {
  mxShape.prototype.apply.apply(this, arguments);
  /** @type {null} */
  this.gradient = this.stroke = this.fill = null;
  if (null != this.style) {
    /** @type {boolean} */
    this.preserveImageAspect = 1 == mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_ASPECT, 1);
    this.imageBackground = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, null);
    this.imageBorder = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, null);
    this.flipH = this.flipH || 1 == mxUtils.getValue(this.style, "imageFlipH", 0);
    this.flipV = this.flipV || 1 == mxUtils.getValue(this.style, "imageFlipV", 0);
    this.clipPath = mxUtils.getValue(this.style, mxConstants.STYLE_CLIP_PATH, null);
  }
};
/**
 * @return {?}
 */
mxImageShape.prototype.isHtmlAllowed = function() {
  return !this.preserveImageAspect;
};
/**
 * @return {?}
 */
mxImageShape.prototype.createHtml = function() {
  /** @type {!Element} */
  var b = document.createElement("div");
  /** @type {string} */
  b.style.position = "absolute";
  return b;
};
/**
 * @return {?}
 */
mxImageShape.prototype.isRoundable = function() {
  return false;
};
/**
 * @return {?}
 */
mxImageShape.prototype.getImageDataUri = function() {
  return this.image;
};
/**
 * @param {!CanvasRenderingContext2D} macro_context
 * @return {undefined}
 */
mxImageShape.prototype.configurePointerEvents = function(macro_context) {
};
/**
 * @param {!Object} ctx
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @return {undefined}
 */
mxImageShape.prototype.paintVertexShape = function(ctx, x, y, width, height) {
  if (null != this.image) {
    if (null != this.imageBackground) {
      ctx.setFillColor(this.imageBackground);
      ctx.setStrokeColor(this.imageBorder);
      ctx.rect(x, y, width, height);
      ctx.fillAndStroke();
    }
    ctx.image(x, y, width, height, this.getImageDataUri(), this.preserveImageAspect, false, false, this.clipPath);
    if (null != this.imageBorder) {
      ctx.setShadow(false);
      ctx.setStrokeColor(this.imageBorder);
      ctx.rect(x, y, width, height);
      ctx.stroke();
    }
  } else {
    mxRectangleShape.prototype.paintBackground.apply(this, arguments);
  }
};
/**
 * @return {undefined}
 */
mxImageShape.prototype.redrawHtmlShape = function() {
  /** @type {string} */
  this.node.style.left = Math.round(this.bounds.x) + "px";
  /** @type {string} */
  this.node.style.top = Math.round(this.bounds.y) + "px";
  /** @type {string} */
  this.node.style.width = Math.max(0, Math.round(this.bounds.width)) + "px";
  /** @type {string} */
  this.node.style.height = Math.max(0, Math.round(this.bounds.height)) + "px";
  /** @type {string} */
  this.node.innerText = "";
  if (null != this.image) {
    var node = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, "");
    var value = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, "");
    this.node.style.backgroundColor = node;
    this.node.style.borderColor = value;
    /** @type {!Element} */
    node = document.createElement("img");
    node.setAttribute("border", "0");
    /** @type {string} */
    node.style.position = "absolute";
    node.src = this.image;
    /** @type {string} */
    value = 100 > this.opacity ? "alpha(opacity=" + this.opacity + ")" : "";
    /** @type {string} */
    this.node.style.filter = value;
    if (this.flipH && this.flipV) {
      /** @type {string} */
      value = value + "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";
    } else {
      if (this.flipH) {
        /** @type {string} */
        value = value + "progid:DXImageTransform.Microsoft.BasicImage(mirror=1)";
      } else {
        if (this.flipV) {
          /** @type {string} */
          value = value + "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
        }
      }
    }
    if (node.style.filter != value) {
      /** @type {string} */
      node.style.filter = value;
    }
    if ("image" == node.nodeName) {
      node.style.rotation = this.rotation;
    } else {
      if (0 != this.rotation) {
        mxUtils.setPrefixedStyle(node.style, "transform", "rotate(" + this.rotation + "deg)");
      } else {
        mxUtils.setPrefixedStyle(node.style, "transform", "");
      }
    }
    /** @type {string} */
    node.style.width = this.node.style.width;
    /** @type {string} */
    node.style.height = this.node.style.height;
    /** @type {string} */
    this.node.style.backgroundImage = "";
    this.node.appendChild(node);
  } else {
    this.setTransparentBackgroundImage(this.node);
  }
};
/**
 * @param {?} a
 * @param {?} b
 * @param {?} c
 * @param {?} quality
 * @return {undefined}
 */
function mxLabel(a, b, c, quality) {
  mxRectangleShape.call(this, a, b, c, quality);
}
mxUtils.extend(mxLabel, mxRectangleShape);
/** @type {number} */
mxLabel.prototype.imageSize = mxConstants.DEFAULT_IMAGESIZE;
/** @type {number} */
mxLabel.prototype.spacing = 2;
/** @type {number} */
mxLabel.prototype.indicatorSize = 10;
/** @type {number} */
mxLabel.prototype.indicatorSpacing = 2;
/**
 * @param {!Node} testId
 * @return {undefined}
 */
mxLabel.prototype.init = function(testId) {
  mxShape.prototype.init.apply(this, arguments);
  if (null != this.indicatorShape) {
    this.indicator = new this.indicatorShape;
    this.indicator.dialect = this.dialect;
    this.indicator.init(this.node);
  }
};
/**
 * @return {undefined}
 */
mxLabel.prototype.redraw = function() {
  if (null != this.indicator) {
    this.indicator.fill = this.indicatorColor;
    this.indicator.stroke = this.indicatorStrokeColor;
    this.indicator.gradient = this.indicatorGradientColor;
    this.indicator.direction = this.indicatorDirection;
    this.indicator.redraw();
  }
  mxShape.prototype.redraw.apply(this, arguments);
};
/**
 * @return {?}
 */
mxLabel.prototype.isHtmlAllowed = function() {
  return mxRectangleShape.prototype.isHtmlAllowed.apply(this, arguments) && null == this.indicatorColor && null == this.indicatorShape;
};
/**
 * @param {!Object} ctx
 * @param {number} context
 * @param {number} t
 * @param {number} w
 * @param {number} x
 * @return {undefined}
 */
mxLabel.prototype.paintForeground = function(ctx, context, t, w, x) {
  this.paintImage(ctx, context, t, w, x);
  this.paintIndicator(ctx, context, t, w, x);
  mxRectangleShape.prototype.paintForeground.apply(this, arguments);
};
/**
 * @param {!Object} ctx
 * @param {number} self
 * @param {number} w
 * @param {number} h
 * @param {number} x
 * @return {undefined}
 */
mxLabel.prototype.paintImage = function(ctx, self, w, h, x) {
  if (null != this.image) {
    self = this.getImageBounds(self, w, h, x);
    w = mxUtils.getValue(this.style, mxConstants.STYLE_CLIP_PATH, null);
    ctx.image(self.x, self.y, self.width, self.height, this.image, false, false, false, w);
  }
};
/**
 * @param {number} x
 * @param {number} d
 * @param {number} b
 * @param {number} c
 * @return {?}
 */
mxLabel.prototype.getImageBounds = function(x, d, b, c) {
  var align = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT);
  var valign = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
  var t = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_WIDTH, mxConstants.DEFAULT_IMAGESIZE);
  var s = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_HEIGHT, mxConstants.DEFAULT_IMAGESIZE);
  var a = mxUtils.getNumber(this.style, mxConstants.STYLE_SPACING, this.spacing) + 5;
  x = align == mxConstants.ALIGN_CENTER ? x + (b - t) / 2 : align == mxConstants.ALIGN_RIGHT ? x + (b - t - a) : x + a;
  d = valign == mxConstants.ALIGN_TOP ? d + a : valign == mxConstants.ALIGN_BOTTOM ? d + (c - s - a) : d + (c - s) / 2;
  return new mxRectangle(x, d, t, s);
};
/**
 * @param {!Object} ctx
 * @param {number} data
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @return {undefined}
 */
mxLabel.prototype.paintIndicator = function(ctx, data, y, w, h) {
  if (null != this.indicator) {
    this.indicator.bounds = this.getIndicatorBounds(data, y, w, h);
    this.indicator.paint(ctx);
  } else {
    if (null != this.indicatorImage) {
      data = this.getIndicatorBounds(data, y, w, h);
      ctx.image(data.x, data.y, data.width, data.height, this.indicatorImage, false, false, false);
    }
  }
};
/**
 * @param {number} y
 * @param {number} y0
 * @param {number} width
 * @param {number} height
 * @return {?}
 */
mxLabel.prototype.getIndicatorBounds = function(y, y0, width, height) {
  var align = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT);
  var numNeurons = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
  var length = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_WIDTH, this.indicatorSize);
  var size = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_HEIGHT, this.indicatorSize);
  var offset = this.spacing + 5;
  y = align == mxConstants.ALIGN_RIGHT ? y + (width - length - offset) : align == mxConstants.ALIGN_CENTER ? y + (width - length) / 2 : y + offset;
  y0 = numNeurons == mxConstants.ALIGN_BOTTOM ? y0 + (height - size - offset) : numNeurons == mxConstants.ALIGN_TOP ? y0 + offset : y0 + (height - size) / 2;
  return new mxRectangle(y, y0, length, size);
};
/**
 * @return {undefined}
 */
mxLabel.prototype.redrawHtmlShape = function() {
  mxRectangleShape.prototype.redrawHtmlShape.apply(this, arguments);
  for (; this.node.hasChildNodes();) {
    this.node.removeChild(this.node.lastChild);
  }
  if (null != this.image) {
    /** @type {!Element} */
    var img = document.createElement("img");
    /** @type {string} */
    img.style.position = "relative";
    img.setAttribute("border", "0");
    var size = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
    size.x -= this.bounds.x;
    size.y -= this.bounds.y;
    /** @type {string} */
    img.style.left = Math.round(size.x) + "px";
    /** @type {string} */
    img.style.top = Math.round(size.y) + "px";
    /** @type {string} */
    img.style.width = Math.round(size.width) + "px";
    /** @type {string} */
    img.style.height = Math.round(size.height) + "px";
    img.src = this.image;
    this.node.appendChild(img);
  }
};
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxCylinder(bounds, value, size, intSetSource) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxCylinder, mxShape);
/** @type {number} */
mxCylinder.prototype.maxHeight = 40;
/**
 * @param {!Object} context
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @return {undefined}
 */
mxCylinder.prototype.paintVertexShape = function(context, x, y, w, h) {
  context.translate(x, y);
  context.begin();
  this.redrawPath(context, x, y, w, h, false);
  context.fillAndStroke();
  if (!(this.outline && null != this.style && 0 != mxUtils.getValue(this.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0))) {
    context.setShadow(false);
    context.begin();
    this.redrawPath(context, x, y, w, h, true);
    context.stroke();
  }
};
/**
 * @param {number} val
 * @param {number} dim
 * @param {number} n
 * @param {number} units
 * @return {?}
 */
mxCylinder.prototype.getCylinderSize = function(val, dim, n, units) {
  return Math.min(this.maxHeight, Math.round(units / 5));
};
/**
 * @param {!Object} path
 * @param {number} r
 * @param {number} h
 * @param {number} x
 * @param {number} y
 * @param {string} width
 * @return {undefined}
 */
mxCylinder.prototype.redrawPath = function(path, r, h, x, y, width) {
  r = this.getCylinderSize(r, h, x, y);
  if (width && null != this.fill || !width && null == this.fill) {
    path.moveTo(0, r);
    path.curveTo(0, 2 * r, x, 2 * r, x, r);
    if (!width) {
      path.stroke();
      path.begin();
    }
  }
  if (!width) {
    path.moveTo(0, r);
    path.curveTo(0, -r / 3, x, -r / 3, x, r);
    path.lineTo(x, y - r);
    path.curveTo(x, y + r / 3, 0, y + r / 3, 0, y - r);
    path.close();
  }
};
/**
 * @param {?} a
 * @param {?} b
 * @param {?} rev
 * @return {undefined}
 */
function mxConnector(a, b, rev) {
  mxPolyline.call(this, a, b, rev);
}
mxUtils.extend(mxConnector, mxPolyline);
/**
 * @return {undefined}
 */
mxConnector.prototype.updateBoundingBox = function() {
  /** @type {boolean} */
  this.useSvgBoundingBox = null != this.style && 1 == this.style[mxConstants.STYLE_CURVED];
  mxShape.prototype.updateBoundingBox.apply(this, arguments);
};
/**
 * @param {!Object} pos
 * @param {!Object} i
 * @return {undefined}
 */
mxConnector.prototype.paintEdgeShape = function(pos, i) {
  var end = this.createMarker(pos, i, true);
  var tmp = this.createMarker(pos, i, false);
  mxPolyline.prototype.paintEdgeShape.apply(this, arguments);
  pos.setFillColor(this.stroke);
  pos.setShadow(false);
  pos.setDashed(false);
  if (null != end) {
    end();
  }
  if (null != tmp) {
    tmp();
  }
};
/**
 * @param {!Object} i
 * @param {!Object} data
 * @param {string} id
 * @return {?}
 */
mxConnector.prototype.createMarker = function(i, data, id) {
  /** @type {null} */
  var y = null;
  var x = data.length;
  var dot = mxUtils.getValue(this.style, id ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW);
  var v = id ? data[1] : data[x - 2];
  data = id ? data[0] : data[x - 1];
  if (null != dot && null != v && null != data) {
    /** @type {number} */
    y = data.x - v.x;
    /** @type {number} */
    x = data.y - v.y;
    /** @type {number} */
    var len = Math.sqrt(y * y + x * x);
    /** @type {number} */
    v = y / len;
    /** @type {number} */
    y = x / len;
    x = mxUtils.getNumber(this.style, id ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE);
    y = mxMarker.createMarker(i, this, dot, data, v, y, x, id, this.strokewidth, 0 != this.style[id ? mxConstants.STYLE_STARTFILL : mxConstants.STYLE_ENDFILL]);
  }
  return y;
};
/**
 * @param {?} bbox
 * @return {undefined}
 */
mxConnector.prototype.augmentBoundingBox = function(bbox) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  /** @type {number} */
  var radius = 0;
  if (mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE) {
    radius = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_MARKERSIZE) + 1;
  }
  if (mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE) {
    /** @type {number} */
    radius = Math.max(radius, mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE)) + 1;
  }
  bbox.grow(radius * this.scale);
};
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxSwimlane(bounds, value, size, intSetSource) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxSwimlane, mxShape);
/** @type {number} */
mxSwimlane.prototype.imageSize = 16;
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxSwimlane.prototype.apply = function(obj) {
  mxShape.prototype.apply.apply(this, arguments);
  if (null != this.style) {
    this.laneFill = mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_FILLCOLOR, mxConstants.NONE);
  }
};
/**
 * @return {?}
 */
mxSwimlane.prototype.isRoundable = function() {
  return true;
};
/**
 * @return {?}
 */
mxSwimlane.prototype.getTitleSize = function() {
  return Math.max(0, mxUtils.getValue(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
};
/**
 * @param {!Object} bounds
 * @return {?}
 */
mxSwimlane.prototype.getLabelBounds = function(bounds) {
  /** @type {boolean} */
  var b = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0);
  /** @type {boolean} */
  var c = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0);
  bounds = new mxRectangle(bounds.x, bounds.y, bounds.width, bounds.height);
  var variable = this.isHorizontal();
  var width = this.getTitleSize();
  /** @type {boolean} */
  var undefined = this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH;
  /** @type {boolean} */
  variable = variable == !undefined;
  /** @type {boolean} */
  b = !variable && b != (this.direction == mxConstants.DIRECTION_SOUTH || this.direction == mxConstants.DIRECTION_WEST);
  /** @type {boolean} */
  c = variable && c != (this.direction == mxConstants.DIRECTION_SOUTH || this.direction == mxConstants.DIRECTION_WEST);
  if (undefined) {
    /** @type {number} */
    width = Math.min(bounds.width, width * this.scale);
    if (b || c) {
      bounds.x += bounds.width - width;
    }
    /** @type {number} */
    bounds.width = width;
  } else {
    /** @type {number} */
    width = Math.min(bounds.height, width * this.scale);
    if (b || c) {
      bounds.y += bounds.height - width;
    }
    /** @type {number} */
    bounds.height = width;
  }
  return bounds;
};
/**
 * @param {!CanvasRenderingContext2D} hash
 * @param {number} target
 * @param {number} src
 * @param {number} minWidth
 * @param {number} minHeight
 * @return {?}
 */
mxSwimlane.prototype.getGradientBounds = function(hash, target, src, minWidth, minHeight) {
  hash = this.getTitleSize();
  return this.isHorizontal() ? new mxRectangle(target, src, minWidth, Math.min(hash, minHeight)) : new mxRectangle(target, src, Math.min(hash, minWidth), minHeight);
};
/**
 * @param {number} y
 * @param {number} val
 * @param {number} prop
 * @return {?}
 */
mxSwimlane.prototype.getSwimlaneArcSize = function(y, val, prop) {
  if ("1" == mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0)) {
    return Math.min(y / 2, Math.min(val / 2, mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2));
  }
  /** @type {number} */
  y = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100;
  return prop * y * 3;
};
/**
 * @return {?}
 */
mxSwimlane.prototype.isHorizontal = function() {
  return 1 == mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1);
};
/**
 * @param {!Object} ctx
 * @param {number} m
 * @param {number} b
 * @param {number} n
 * @param {number} a
 * @return {undefined}
 */
mxSwimlane.prototype.paintVertexShape = function(ctx, m, b, n, a) {
  if (!this.outline) {
    var i = this.getTitleSize();
    /** @type {number} */
    var value = 0;
    /** @type {number} */
    i = this.isHorizontal() ? Math.min(i, a) : Math.min(i, n);
    ctx.translate(m, b);
    if (this.isRounded) {
      value = this.getSwimlaneArcSize(n, a, i);
      /** @type {number} */
      value = Math.min((this.isHorizontal() ? a : n) - i, Math.min(i, value));
      this.paintRoundedSwimlane(ctx, m, b, n, a, i, value);
    } else {
      this.paintSwimlane(ctx, m, b, n, a, i);
    }
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_SEPARATORCOLOR, mxConstants.NONE);
    this.paintSeparator(ctx, m, b, n, a, i, strokeColor);
    if (null != this.image) {
      a = this.getImageBounds(m, b, n, a);
      strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_CLIP_PATH, null);
      ctx.image(a.x - m, a.y - b, a.width, a.height, this.image, false, false, false, strokeColor);
    }
    if (this.glass) {
      ctx.setShadow(false);
      this.paintGlassEffect(ctx, 0, 0, n, i, value);
    }
  }
};
/**
 * @param {!CanvasRenderingContext2D} macro_context
 * @return {undefined}
 */
mxSwimlane.prototype.configurePointerEvents = function(macro_context) {
  /** @type {boolean} */
  var b = true;
  /** @type {boolean} */
  var c = true;
  /** @type {boolean} */
  var __NONE = true;
  if (null != this.style) {
    /** @type {boolean} */
    b = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1");
    /** @type {boolean} */
    c = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_HEAD, 1);
    /** @type {boolean} */
    __NONE = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_BODY, 1);
  }
  if (b || c || __NONE) {
    mxShape.prototype.configurePointerEvents.apply(this, arguments);
  }
};
/**
 * @param {!Object} doc
 * @param {number} position
 * @param {number} c
 * @param {number} d
 * @param {number} s
 * @param {undefined} p
 * @return {undefined}
 */
mxSwimlane.prototype.paintSwimlane = function(doc, position, c, d, s, p) {
  var align = this.laneFill;
  /** @type {boolean} */
  var k = true;
  /** @type {boolean} */
  var l = true;
  /** @type {boolean} */
  var m = true;
  /** @type {boolean} */
  var t = true;
  if (null != this.style) {
    /** @type {boolean} */
    k = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1");
    /** @type {boolean} */
    l = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_LINE, 1);
    /** @type {boolean} */
    m = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_HEAD, 1);
    /** @type {boolean} */
    t = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_BODY, 1);
  }
  if (this.isHorizontal()) {
    doc.begin();
    doc.moveTo(0, p);
    doc.lineTo(0, 0);
    doc.lineTo(d, 0);
    doc.lineTo(d, p);
    if (m) {
      doc.fillAndStroke();
    } else {
      doc.fill();
    }
    if (p < s) {
      if (!(align != mxConstants.NONE && k)) {
        /** @type {boolean} */
        doc.pointerEvents = false;
      }
      if (align != mxConstants.NONE) {
        doc.setFillColor(align);
      }
      doc.begin();
      doc.moveTo(0, p);
      doc.lineTo(0, s);
      doc.lineTo(d, s);
      doc.lineTo(d, p);
      if (t) {
        if (align == mxConstants.NONE) {
          doc.stroke();
        } else {
          if (t) {
            doc.fillAndStroke();
          }
        }
      } else {
        if (align != mxConstants.NONE) {
          doc.fill();
        }
      }
    }
  } else {
    doc.begin();
    doc.moveTo(p, 0);
    doc.lineTo(0, 0);
    doc.lineTo(0, s);
    doc.lineTo(p, s);
    if (m) {
      doc.fillAndStroke();
    } else {
      doc.fill();
    }
    if (p < d) {
      if (!(align != mxConstants.NONE && k)) {
        /** @type {boolean} */
        doc.pointerEvents = false;
      }
      if (align != mxConstants.NONE) {
        doc.setFillColor(align);
      }
      doc.begin();
      doc.moveTo(p, 0);
      doc.lineTo(d, 0);
      doc.lineTo(d, s);
      doc.lineTo(p, s);
      if (t) {
        if (align == mxConstants.NONE) {
          doc.stroke();
        } else {
          if (t) {
            doc.fillAndStroke();
          }
        }
      } else {
        if (align != mxConstants.NONE) {
          doc.fill();
        }
      }
    }
  }
  if (l) {
    this.paintDivider(doc, position, c, d, s, p, align == mxConstants.NONE);
  }
};
/**
 * @param {!Object} ctx
 * @param {number} a
 * @param {number} f
 * @param {number} x
 * @param {number} h
 * @param {undefined} r
 * @param {number} w
 * @return {undefined}
 */
mxSwimlane.prototype.paintRoundedSwimlane = function(ctx, a, f, x, h, r, w) {
  var align = this.laneFill;
  /** @type {boolean} */
  var l = true;
  /** @type {boolean} */
  var m = true;
  /** @type {boolean} */
  var n = true;
  /** @type {boolean} */
  var p = true;
  if (null != this.style) {
    /** @type {boolean} */
    l = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1");
    /** @type {boolean} */
    m = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_LINE, 1);
    /** @type {boolean} */
    n = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_HEAD, 1);
    /** @type {boolean} */
    p = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_BODY, 1);
  }
  if (this.isHorizontal()) {
    ctx.begin();
    ctx.moveTo(x, r);
    ctx.lineTo(x, w);
    ctx.quadTo(x, 0, x - Math.min(x / 2, w), 0);
    ctx.lineTo(Math.min(x / 2, w), 0);
    ctx.quadTo(0, 0, 0, w);
    ctx.lineTo(0, r);
    if (n) {
      ctx.fillAndStroke();
    } else {
      ctx.fill();
    }
    if (r < h) {
      if (!(align != mxConstants.NONE && l)) {
        /** @type {boolean} */
        ctx.pointerEvents = false;
      }
      if (align != mxConstants.NONE) {
        ctx.setFillColor(align);
      }
      ctx.begin();
      ctx.moveTo(0, r);
      ctx.lineTo(0, h - w);
      ctx.quadTo(0, h, Math.min(x / 2, w), h);
      ctx.lineTo(x - Math.min(x / 2, w), h);
      ctx.quadTo(x, h, x, h - w);
      ctx.lineTo(x, r);
      if (p) {
        if (align == mxConstants.NONE) {
          ctx.stroke();
        } else {
          if (p) {
            ctx.fillAndStroke();
          }
        }
      } else {
        if (align != mxConstants.NONE) {
          ctx.fill();
        }
      }
    }
  } else {
    ctx.begin();
    ctx.moveTo(r, 0);
    ctx.lineTo(w, 0);
    ctx.quadTo(0, 0, 0, Math.min(h / 2, w));
    ctx.lineTo(0, h - Math.min(h / 2, w));
    ctx.quadTo(0, h, w, h);
    ctx.lineTo(r, h);
    if (n) {
      ctx.fillAndStroke();
    } else {
      ctx.fill();
    }
    if (r < x) {
      if (!(align != mxConstants.NONE && l)) {
        /** @type {boolean} */
        ctx.pointerEvents = false;
      }
      if (align != mxConstants.NONE) {
        ctx.setFillColor(align);
      }
      ctx.begin();
      ctx.moveTo(r, h);
      ctx.lineTo(x - w, h);
      ctx.quadTo(x, h, x, h - Math.min(h / 2, w));
      ctx.lineTo(x, Math.min(h / 2, w));
      ctx.quadTo(x, 0, x - w, 0);
      ctx.lineTo(r, 0);
      if (p) {
        if (align == mxConstants.NONE) {
          ctx.stroke();
        } else {
          if (p) {
            ctx.fillAndStroke();
          }
        }
      } else {
        if (align != mxConstants.NONE) {
          ctx.fill();
        }
      }
    }
  }
  if (m) {
    this.paintDivider(ctx, a, f, x, h, r, align == mxConstants.NONE);
  }
};
/**
 * @param {!Object} context
 * @param {number} elem
 * @param {number} n
 * @param {number} i
 * @param {number} b
 * @param {number} r
 * @param {boolean} agumentsArr
 * @return {undefined}
 */
mxSwimlane.prototype.paintDivider = function(context, elem, n, i, b, r, agumentsArr) {
  if (0 != r) {
    if (!agumentsArr) {
      context.setShadow(false);
    }
    context.begin();
    if (this.isHorizontal()) {
      context.moveTo(0, r);
      context.lineTo(i, r);
    } else {
      context.moveTo(r, 0);
      context.lineTo(r, b);
    }
    context.stroke();
  }
};
/**
 * @param {!Object} ctx
 * @param {number} layer
 * @param {number} type
 * @param {number} i
 * @param {number} n
 * @param {undefined} position
 * @param {string} stroke
 * @return {undefined}
 */
mxSwimlane.prototype.paintSeparator = function(ctx, layer, type, i, n, position, stroke) {
  if (stroke != mxConstants.NONE) {
    ctx.setStrokeColor(stroke);
    ctx.setDashed(true);
    ctx.begin();
    if (this.isHorizontal()) {
      ctx.moveTo(i, position);
      ctx.lineTo(i, n);
    } else {
      ctx.moveTo(position, 0);
      ctx.lineTo(i, 0);
    }
    ctx.stroke();
    ctx.setDashed(false);
  }
};
/**
 * @param {number} p
 * @param {number} p2
 * @param {number} t
 * @param {number} url
 * @return {?}
 */
mxSwimlane.prototype.getImageBounds = function(p, p2, t, url) {
  return this.isHorizontal() ? new mxRectangle(p + t - this.imageSize, p2, this.imageSize, this.imageSize) : new mxRectangle(p, p2, this.imageSize, this.imageSize);
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxGraphLayout(targetGraph) {
  /** @type {!Object} */
  this.graph = targetGraph;
}
/** @type {null} */
mxGraphLayout.prototype.graph = null;
/** @type {boolean} */
mxGraphLayout.prototype.useBoundingBox = true;
/** @type {null} */
mxGraphLayout.prototype.parent = null;
/**
 * @param {?} index
 * @param {?} id
 * @param {?} destinationId
 * @return {undefined}
 */
mxGraphLayout.prototype.moveCell = function(index, id, destinationId) {
};
/**
 * @param {!Object} index
 * @param {?} height
 * @return {undefined}
 */
mxGraphLayout.prototype.resizeCell = function(index, height) {
};
/**
 * @param {!Object} ast
 * @return {undefined}
 */
mxGraphLayout.prototype.execute = function(ast) {
};
/**
 * @return {?}
 */
mxGraphLayout.prototype.getGraph = function() {
  return this.graph;
};
/**
 * @param {?} name
 * @param {?} node
 * @param {?} attributeViewModelBindings
 * @param {?} templateType
 * @return {?}
 */
mxGraphLayout.prototype.getConstraint = function(name, node, attributeViewModelBindings, templateType) {
  return this.graph.getCurrentCellStyle(node)[name];
};
/**
 * @param {?} object
 * @param {?} data
 * @param {?} f
 * @param {number} o
 * @param {!Object} value
 * @return {undefined}
 */
mxGraphLayout.traverse = function(object, data, f, o, value) {
  if (null != f && null != object && (data = null != data ? data : true, value = value || new mxDictionary, !value.get(object) && (value.put(object, true), o = f(object, o), null == o || o)) && (o = this.graph.model.getEdgeCount(object), 0 < o)) {
    /** @type {number} */
    var e = 0;
    for (; e < o; e++) {
      var p = this.graph.model.getEdgeAt(object, e);
      /** @type {boolean} */
      var error = this.graph.model.getTerminal(p, true) == object;
      if (!data || error) {
        error = this.graph.view.getVisibleTerminal(p, !error);
        this.traverse(error, data, f, p, value);
      }
    }
  }
};
/**
 * @param {!Object} b
 * @param {!Object} a
 * @param {?} p
 * @return {?}
 */
mxGraphLayout.prototype.isAncestor = function(b, a, p) {
  if (!p) {
    return this.graph.model.getParent(a) == b;
  }
  if (a == b) {
    return false;
  }
  for (; null != a && a != b;) {
    a = this.graph.model.getParent(a);
  }
  return a == b;
};
/**
 * @param {boolean} t
 * @return {?}
 */
mxGraphLayout.prototype.isVertexMovable = function(t) {
  return this.graph.isCellMovable(t);
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxGraphLayout.prototype.isVertexIgnored = function(e) {
  return !this.graph.getModel().isVertex(e) || !this.graph.getModel().isVisible(e);
};
/**
 * @param {string} e
 * @return {?}
 */
mxGraphLayout.prototype.isEdgeIgnored = function(e) {
  var self = this.graph.getModel();
  return !self.isEdge(e) || !this.graph.getModel().isVisible(e) || null == self.getTerminal(e, true) || null == self.getTerminal(e, false);
};
/**
 * @param {?} text
 * @param {string} isHeavy
 * @return {undefined}
 */
mxGraphLayout.prototype.setEdgeStyleEnabled = function(text, isHeavy) {
  this.graph.setCellStyles(mxConstants.STYLE_NOEDGESTYLE, isHeavy ? "0" : "1", [text]);
};
/**
 * @param {?} cell
 * @param {string} is_resize
 * @return {undefined}
 */
mxGraphLayout.prototype.setOrthogonalEdge = function(cell, is_resize) {
  this.graph.setCellStyles(mxConstants.STYLE_ORTHOGONAL, is_resize ? "1" : "0", [cell]);
};
/**
 * @param {?} element
 * @return {?}
 */
mxGraphLayout.prototype.getParentOffset = function(element) {
  var pt = new mxPoint;
  if (null != element && element != this.parent) {
    var dom = this.graph.getModel();
    if (dom.isAncestor(this.parent, element)) {
      var d = dom.getGeometry(element);
      for (; element != this.parent;) {
        pt.x += d.x;
        pt.y += d.y;
        element = dom.getParent(element);
        d = dom.getGeometry(element);
      }
    }
  }
  return pt;
};
/**
 * @param {!Object} target
 * @param {?} points
 * @return {undefined}
 */
mxGraphLayout.prototype.setEdgePoints = function(target, points) {
  if (null != target) {
    var layer = this.graph.model;
    var item = layer.getGeometry(target);
    if (null == item) {
      item = new mxGeometry;
      item.setRelative(true);
    } else {
      item = item.clone();
    }
    if (null != this.parent && null != points) {
      var about = layer.getParent(target);
      about = this.getParentOffset(about);
      /** @type {number} */
      var i = 0;
      for (; i < points.length; i++) {
        points[i].x -= about.x;
        points[i].y -= about.y;
      }
    }
    item.points = points;
    layer.setGeometry(target, item);
  }
};
/**
 * @param {!Object} element
 * @param {number} x
 * @param {number} y
 * @return {?}
 */
mxGraphLayout.prototype.setVertexLocation = function(element, x, y) {
  var m = this.graph.getModel();
  var c = m.getGeometry(element);
  /** @type {null} */
  var box = null;
  if (null != c) {
    box = new mxRectangle(x, y, c.width, c.height);
    if (this.useBoundingBox) {
      var e = this.graph.getView().getState(element);
      if (null != e && null != e.text && null != e.text.boundingBox) {
        var scale = this.graph.getView().scale;
        var bbox = e.text.boundingBox;
        if (e.text.boundingBox.x < e.x) {
          x = x + (e.x - bbox.x) / scale;
          box.width = bbox.width;
        }
        if (e.text.boundingBox.y < e.y) {
          y = y + (e.y - bbox.y) / scale;
          box.height = bbox.height;
        }
      }
    }
    if (null != this.parent) {
      e = m.getParent(element);
      if (null != e && e != this.parent) {
        e = this.getParentOffset(e);
        /** @type {number} */
        x = x - e.x;
        /** @type {number} */
        y = y - e.y;
      }
    }
    if (c.x != x || c.y != y) {
      c = c.clone();
      /** @type {number} */
      c.x = x;
      /** @type {number} */
      c.y = y;
      m.setGeometry(element, c);
    }
  }
  return box;
};
/**
 * @param {?} el
 * @return {?}
 */
mxGraphLayout.prototype.getVertexBounds = function(el) {
  var pos = this.graph.getModel().getGeometry(el);
  if (this.useBoundingBox) {
    var obj = this.graph.getView().getState(el);
    if (null != obj && null != obj.text && null != obj.text.boundingBox) {
      var rows = this.graph.getView().scale;
      var bb = obj.text.boundingBox;
      /** @type {number} */
      var a = Math.max(obj.x - bb.x, 0) / rows;
      /** @type {number} */
      var height = Math.max(obj.y - bb.y, 0) / rows;
      pos = new mxRectangle(pos.x - a, pos.y - height, pos.width + a + Math.max(bb.x + bb.width - (obj.x + obj.width), 0) / rows, pos.height + height + Math.max(bb.y + bb.height - (obj.y + obj.height), 0) / rows);
    }
  }
  if (null != this.parent) {
    el = this.graph.getModel().getParent(el);
    pos = pos.clone();
    if (null != el && el != this.parent) {
      el = this.getParentOffset(el);
      pos.x += el.x;
      pos.y += el.y;
    }
  }
  return new mxRectangle(pos.x, pos.y, pos.width, pos.height);
};
/**
 * @param {!Object} link
 * @param {undefined} label
 * @param {undefined} callback
 * @param {undefined} obj
 * @param {undefined} start
 * @param {undefined} end
 * @return {?}
 */
mxGraphLayout.prototype.arrangeGroups = function(link, label, callback, obj, start, end) {
  return this.graph.updateGroupBounds(link, label, true, callback, obj, start, end);
};
/**
 * @param {?} cell
 * @param {!Function} heightProbeCell
 * @return {undefined}
 */
function WeightedCellSorter(cell, heightProbeCell) {
  this.cell = cell;
  /** @type {!Function} */
  this.weightedValue = heightProbeCell;
}
/** @type {number} */
WeightedCellSorter.prototype.weightedValue = 0;
/** @type {boolean} */
WeightedCellSorter.prototype.nudge = false;
/** @type {boolean} */
WeightedCellSorter.prototype.visited = false;
/** @type {null} */
WeightedCellSorter.prototype.rankIndex = null;
/** @type {null} */
WeightedCellSorter.prototype.cell = null;
/**
 * @param {string} a
 * @param {?} b
 * @return {?}
 */
WeightedCellSorter.prototype.compare = function(a, b) {
  return null != a && null != b ? b.weightedValue > a.weightedValue ? -1 : b.weightedValue < a.weightedValue ? 1 : b.nudge ? -1 : 1 : 0;
};
/**
 * @param {?} result
 * @param {number} continuation
 * @param {number} name
 * @param {number} status
 * @param {number} e
 * @param {number} islongclick
 * @return {undefined}
 */
function mxStackLayout(result, continuation, name, status, e, islongclick) {
  mxGraphLayout.call(this, result);
  this.horizontal = null != continuation ? continuation : true;
  this.spacing = null != name ? name : 0;
  this.x0 = null != status ? status : 0;
  this.y0 = null != e ? e : 0;
  this.border = null != islongclick ? islongclick : 0;
}
mxStackLayout.prototype = new mxGraphLayout;
/** @type {function(?, number, number, number, number, number): undefined} */
mxStackLayout.prototype.constructor = mxStackLayout;
/** @type {null} */
mxStackLayout.prototype.horizontal = null;
/** @type {null} */
mxStackLayout.prototype.spacing = null;
/** @type {null} */
mxStackLayout.prototype.x0 = null;
/** @type {null} */
mxStackLayout.prototype.y0 = null;
/** @type {number} */
mxStackLayout.prototype.border = 0;
/** @type {number} */
mxStackLayout.prototype.marginTop = 0;
/** @type {number} */
mxStackLayout.prototype.marginLeft = 0;
/** @type {number} */
mxStackLayout.prototype.marginRight = 0;
/** @type {number} */
mxStackLayout.prototype.marginBottom = 0;
/** @type {boolean} */
mxStackLayout.prototype.keepFirstLocation = false;
/** @type {boolean} */
mxStackLayout.prototype.fill = false;
/** @type {boolean} */
mxStackLayout.prototype.resizeParent = false;
/** @type {boolean} */
mxStackLayout.prototype.resizeParentMax = false;
/** @type {boolean} */
mxStackLayout.prototype.resizeLast = false;
/** @type {null} */
mxStackLayout.prototype.wrap = null;
/** @type {boolean} */
mxStackLayout.prototype.borderCollapse = true;
/** @type {boolean} */
mxStackLayout.prototype.allowGaps = false;
/** @type {number} */
mxStackLayout.prototype.gridSize = 0;
/**
 * @return {?}
 */
mxStackLayout.prototype.isHorizontal = function() {
  return this.horizontal;
};
/**
 * @param {(Object|string)} id
 * @param {number} end
 * @param {number} index
 * @return {undefined}
 */
mxStackLayout.prototype.moveCell = function(id, end, index) {
  var self = this.graph.getModel();
  var cell = self.getParent(id);
  var last = this.isHorizontal();
  if (null != id && null != cell) {
    /** @type {number} */
    var exist = 0;
    var max = self.getChildCount(cell);
    index = last ? end : index;
    end = this.graph.getView().getState(cell);
    if (null != end) {
      /** @type {number} */
      index = index - (last ? end.x : end.y);
    }
    /** @type {number} */
    index = index / this.graph.view.scale;
    /** @type {number} */
    end = 0;
    for (; end < max; end++) {
      var value = self.getChildAt(cell, end);
      if (value != id && (value = self.getGeometry(value), null != value)) {
        value = last ? value.x + value.width / 2 : value.y + value.height / 2;
        if (exist <= index && value > index) {
          break;
        }
        exist = value;
      }
    }
    last = cell.getIndex(id);
    /** @type {number} */
    last = Math.max(0, end - (end > last ? 1 : 0));
    self.add(cell, id, last);
  }
};
/**
 * @param {(Object|string)} value
 * @return {?}
 */
mxStackLayout.prototype.getParentSize = function(value) {
  var shape = this.graph.getModel();
  var operator = shape.getGeometry(value);
  if (null != this.graph.container && (null == operator && shape.isLayer(value) || value == this.graph.getView().currentRoot)) {
    operator = new mxRectangle(0, 0, this.graph.container.offsetWidth - 1, this.graph.container.offsetHeight - 1);
  }
  return operator;
};
/**
 * @param {!Object} cell
 * @return {?}
 */
mxStackLayout.prototype.getLayoutCells = function(cell) {
  var content = this.graph.getModel();
  var d2 = content.getChildCount(cell);
  /** @type {!Array} */
  var c = [];
  /** @type {number} */
  var y = 0;
  for (; y < d2; y++) {
    var i = content.getChildAt(cell, y);
    if (!this.isVertexIgnored(i) && this.isVertexMovable(i)) {
      c.push(i);
    }
  }
  if (this.allowGaps) {
    c.sort(mxUtils.bind(this, function(point, rect) {
      point = this.graph.getCellGeometry(point);
      rect = this.graph.getCellGeometry(rect);
      return this.horizontal ? point.x == rect.x ? 0 : point.x > rect.x > 0 ? 1 : -1 : point.y == rect.y ? 0 : point.y > rect.y > 0 ? 1 : -1;
    }));
  }
  return c;
};
/**
 * @param {number} pos
 * @return {?}
 */
mxStackLayout.prototype.snap = function(pos) {
  if (null != this.gridSize && 0 < this.gridSize && (pos = Math.max(pos, this.gridSize), 1 < pos / this.gridSize)) {
    /** @type {number} */
    var b = pos % this.gridSize;
    /** @type {number} */
    pos = pos + (b > this.gridSize / 2 ? this.gridSize - b : -b);
  }
  return pos;
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxStackLayout.prototype.execute = function(value) {
  if (null != value) {
    var target = this.getParentSize(value);
    var v = this.isHorizontal();
    var me = this.graph.getModel();
    /** @type {null} */
    var height = null;
    if (null != target) {
      /** @type {number} */
      height = v ? target.height - this.marginTop - this.marginBottom : target.width - this.marginLeft - this.marginRight;
    }
    /** @type {number} */
    height = height - 2 * this.border;
    var x = this.x0 + this.border + this.marginLeft;
    var y = this.y0 + this.border + this.marginTop;
    if (this.graph.isSwimlane(value)) {
      var d = this.graph.getCellStyle(value);
      var h = mxUtils.getNumber(d, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE);
      /** @type {boolean} */
      d = 1 == mxUtils.getValue(d, mxConstants.STYLE_HORIZONTAL, true);
      if (null != target) {
        /** @type {number} */
        h = d ? Math.min(h, target.height) : Math.min(h, target.width);
      }
      if (v == d) {
        /** @type {number} */
        height = height - h;
      }
      if (d) {
        y = y + h;
      } else {
        x = x + h;
      }
    }
    me.beginUpdate();
    try {
      /** @type {number} */
      h = 0;
      /** @type {null} */
      d = null;
      /** @type {number} */
      var rowSize = 0;
      /** @type {null} */
      var cover = null;
      var cells = this.getLayoutCells(value);
      /** @type {number} */
      var i = 0;
      for (; i < cells.length; i++) {
        var cell = cells[i];
        var o = me.getGeometry(cell);
        if (null != o) {
          o = o.clone();
          if (null != this.wrap && null != d && (v && d.x + d.width + o.width + 2 * this.spacing > this.wrap || !v && d.y + d.height + o.height + 2 * this.spacing > this.wrap)) {
            /** @type {null} */
            d = null;
            if (v) {
              y = y + (h + this.spacing);
            } else {
              x = x + (h + this.spacing);
            }
            /** @type {number} */
            h = 0;
          }
          /** @type {number} */
          h = Math.max(h, v ? o.height : o.width);
          /** @type {number} */
          var day = 0;
          if (!this.borderCollapse) {
            var d = this.graph.getCellStyle(cell);
            day = mxUtils.getNumber(d, mxConstants.STYLE_STROKEWIDTH, 1);
          }
          if (null != d) {
            var widestInView = rowSize + this.spacing + Math.floor(day / 2);
            if (v) {
              o.x = this.snap((this.allowGaps ? Math.max(widestInView, o.x) : widestInView) - this.marginLeft) + this.marginLeft;
            } else {
              o.y = this.snap((this.allowGaps ? Math.max(widestInView, o.y) : widestInView) - this.marginTop) + this.marginTop;
            }
          } else {
            if (!this.keepFirstLocation) {
              if (v) {
                o.x = this.allowGaps && o.x > x ? Math.max(this.snap(o.x - this.marginLeft) + this.marginLeft, x) : x;
              } else {
                o.y = this.allowGaps && o.y > y ? Math.max(this.snap(o.y - this.marginTop) + this.marginTop, y) : y;
              }
            }
          }
          if (v) {
            o.y = y;
          } else {
            o.x = x;
          }
          if (this.fill && null != height) {
            if (v) {
              /** @type {number} */
              o.height = height;
            } else {
              /** @type {number} */
              o.width = height;
            }
          }
          if (v) {
            o.width = this.snap(o.width);
          } else {
            o.height = this.snap(o.height);
          }
          this.setChildGeometry(cell, o);
          cover = cell;
          d = o;
          rowSize = v ? d.x + d.width + Math.floor(day / 2) : d.y + d.height + Math.floor(day / 2);
        }
      }
      if (this.resizeParent && null != target && null != d && !this.graph.isCellCollapsed(value)) {
        this.updateParentGeometry(value, target, d);
      } else {
        if (this.resizeLast && null != target && null != d && null != cover) {
          if (v) {
            /** @type {number} */
            d.width = target.width - d.x - this.spacing - this.marginRight - this.marginLeft;
          } else {
            /** @type {number} */
            d.height = target.height - d.y - this.spacing - this.marginBottom;
          }
          this.setChildGeometry(cover, d);
        }
      }
    } finally {
      me.endUpdate();
    }
  }
};
/**
 * @param {!Object} name
 * @param {!Object} a
 * @return {undefined}
 */
mxStackLayout.prototype.setChildGeometry = function(name, a) {
  var b = this.graph.getCellGeometry(name);
  if (!(null != b && a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height)) {
    this.graph.getModel().setGeometry(name, a);
  }
};
/**
 * @param {!Object} p
 * @param {!Object} a
 * @param {!Object} c
 * @return {undefined}
 */
mxStackLayout.prototype.updateParentGeometry = function(p, a, c) {
  var isHorizontal = this.isHorizontal();
  var mesh = this.graph.getModel();
  var b = a.clone();
  if (isHorizontal) {
    c = c.x + c.width + this.marginRight + this.border;
    b.width = this.resizeParentMax ? Math.max(b.width, c) : c;
  } else {
    c = c.y + c.height + this.marginBottom + this.border;
    b.height = this.resizeParentMax ? Math.max(b.height, c) : c;
  }
  if (!(a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height)) {
    mesh.setGeometry(p, b);
  }
};
/**
 * @param {?} dbName
 * @param {number} name
 * @param {number} size
 * @param {string} border
 * @return {undefined}
 */
function mxPartitionLayout(dbName, name, size, border) {
  mxGraphLayout.call(this, dbName);
  this.horizontal = null != name ? name : true;
  this.spacing = size || 0;
  this.border = border || 0;
}
mxPartitionLayout.prototype = new mxGraphLayout;
/** @type {function(?, number, number, string): undefined} */
mxPartitionLayout.prototype.constructor = mxPartitionLayout;
/** @type {null} */
mxPartitionLayout.prototype.horizontal = null;
/** @type {null} */
mxPartitionLayout.prototype.spacing = null;
/** @type {null} */
mxPartitionLayout.prototype.border = null;
/** @type {boolean} */
mxPartitionLayout.prototype.resizeVertices = true;
/**
 * @return {?}
 */
mxPartitionLayout.prototype.isHorizontal = function() {
  return this.horizontal;
};
/**
 * @param {(Object|string)} id
 * @param {number} p
 * @param {!Object} layer
 * @return {undefined}
 */
mxPartitionLayout.prototype.moveCell = function(id, p, layer) {
  layer = this.graph.getModel();
  var cell = layer.getParent(id);
  if (null != id && null != cell) {
    var i;
    /** @type {number} */
    var c = 0;
    var childCount = layer.getChildCount(cell);
    /** @type {number} */
    i = 0;
    for (; i < childCount; i++) {
      var n = layer.getChildAt(cell, i);
      n = this.getVertexBounds(n);
      if (null != n) {
        n = n.x + n.width / 2;
        if (c < p && n > p) {
          break;
        }
        c = n;
      }
    }
    p = cell.getIndex(id);
    /** @type {number} */
    p = Math.max(0, i - (i > p ? 1 : 0));
    layer.add(cell, id, p);
  }
};
/**
 * @param {number} node
 * @return {undefined}
 */
mxPartitionLayout.prototype.execute = function(node) {
  var isVertical = this.isHorizontal();
  var item = this.graph.getModel();
  var t = item.getGeometry(node);
  if (null != this.graph.container && (null == t && item.isLayer(node) || node == this.graph.getView().currentRoot)) {
    t = new mxRectangle(0, 0, this.graph.container.offsetWidth - 1, this.graph.container.offsetHeight - 1);
  }
  if (null != t) {
    /** @type {!Array} */
    var e = [];
    var width = item.getChildCount(node);
    /** @type {number} */
    var i = 0;
    for (; i < width; i++) {
      var p = item.getChildAt(node, i);
      if (!this.isVertexIgnored(p) && this.isVertexMovable(p)) {
        e.push(p);
      }
    }
    /** @type {number} */
    width = e.length;
    if (0 < width) {
      var x = this.border;
      var y = this.border;
      var value = isVertical ? t.height : t.width;
      /** @type {number} */
      value = value - 2 * this.border;
      node = this.graph.isSwimlane(node) ? this.graph.getStartSize(node) : new mxRectangle;
      /** @type {number} */
      value = value - (isVertical ? node.height : node.width);
      x = x + node.width;
      y = y + node.height;
      node = this.border + (width - 1) * this.spacing;
      /** @type {number} */
      t = isVertical ? (t.width - x - node) / width : (t.height - y - node) / width;
      if (0 < t) {
        item.beginUpdate();
        try {
          /** @type {number} */
          i = 0;
          for (; i < width; i++) {
            p = e[i];
            var input = item.getGeometry(p);
            if (null != input) {
              input = input.clone();
              input.x = x;
              input.y = y;
              if (isVertical) {
                if (this.resizeVertices) {
                  /** @type {number} */
                  input.width = t;
                  input.height = value;
                }
                x = x + (t + this.spacing);
              } else {
                if (this.resizeVertices) {
                  /** @type {number} */
                  input.height = t;
                  input.width = value;
                }
                y = y + (t + this.spacing);
              }
              item.setGeometry(p, input);
            }
          }
        } finally {
          item.endUpdate();
        }
      }
    }
  }
};
/**
 * @param {?} promiseOrResolver
 * @param {number} name
 * @param {string} prefixAgnostic
 * @return {undefined}
 */
function mxCompactTreeLayout(promiseOrResolver, name, prefixAgnostic) {
  mxGraphLayout.call(this, promiseOrResolver);
  this.horizontal = null != name ? name : true;
  this.invert = null != prefixAgnostic ? prefixAgnostic : false;
}
mxCompactTreeLayout.prototype = new mxGraphLayout;
/** @type {function(?, number, string): undefined} */
mxCompactTreeLayout.prototype.constructor = mxCompactTreeLayout;
/** @type {null} */
mxCompactTreeLayout.prototype.horizontal = null;
/** @type {null} */
mxCompactTreeLayout.prototype.invert = null;
/** @type {boolean} */
mxCompactTreeLayout.prototype.resizeParent = true;
/** @type {boolean} */
mxCompactTreeLayout.prototype.maintainParentLocation = false;
/** @type {number} */
mxCompactTreeLayout.prototype.groupPadding = 10;
/** @type {number} */
mxCompactTreeLayout.prototype.groupPaddingTop = 0;
/** @type {number} */
mxCompactTreeLayout.prototype.groupPaddingRight = 0;
/** @type {number} */
mxCompactTreeLayout.prototype.groupPaddingBottom = 0;
/** @type {number} */
mxCompactTreeLayout.prototype.groupPaddingLeft = 0;
/** @type {null} */
mxCompactTreeLayout.prototype.parentsChanged = null;
/** @type {boolean} */
mxCompactTreeLayout.prototype.moveTree = false;
/** @type {null} */
mxCompactTreeLayout.prototype.visited = null;
/** @type {number} */
mxCompactTreeLayout.prototype.levelDistance = 10;
/** @type {number} */
mxCompactTreeLayout.prototype.nodeDistance = 20;
/** @type {boolean} */
mxCompactTreeLayout.prototype.resetEdges = true;
/** @type {number} */
mxCompactTreeLayout.prototype.prefHozEdgeSep = 5;
/** @type {number} */
mxCompactTreeLayout.prototype.prefVertEdgeOff = 4;
/** @type {number} */
mxCompactTreeLayout.prototype.minEdgeJetty = 8;
/** @type {number} */
mxCompactTreeLayout.prototype.channelBuffer = 4;
/** @type {boolean} */
mxCompactTreeLayout.prototype.edgeRouting = true;
/** @type {boolean} */
mxCompactTreeLayout.prototype.sortEdges = false;
/** @type {boolean} */
mxCompactTreeLayout.prototype.alignRanks = false;
/** @type {null} */
mxCompactTreeLayout.prototype.maxRankHeight = null;
/** @type {null} */
mxCompactTreeLayout.prototype.root = null;
/** @type {null} */
mxCompactTreeLayout.prototype.node = null;
/**
 * @param {!Object} id
 * @return {?}
 */
mxCompactTreeLayout.prototype.isVertexIgnored = function(id) {
  return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || 0 == this.graph.getConnections(id).length;
};
/**
 * @return {?}
 */
mxCompactTreeLayout.prototype.isHorizontal = function() {
  return this.horizontal;
};
/**
 * @param {string} parent
 * @param {number} value
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.execute = function(parent, value) {
  /** @type {string} */
  this.parent = parent;
  var model = this.graph.getModel();
  if (null == value) {
    if (0 < this.graph.getEdges(parent, model.getParent(parent), this.invert, !this.invert, false).length) {
      /** @type {string} */
      this.root = parent;
    } else {
      if (value = this.graph.findTreeRoots(parent, true, this.invert), 0 < value.length) {
        /** @type {number} */
        var j = 0;
        for (; j < value.length; j++) {
          if (!this.isVertexIgnored(value[j]) && 0 < this.graph.getEdges(value[j], null, this.invert, !this.invert, false).length) {
            this.root = value[j];
            break;
          }
        }
      }
    }
  } else {
    /** @type {number} */
    this.root = value;
  }
  if (null != this.root) {
    /** @type {(null|{})} */
    this.parentsChanged = this.resizeParent ? {} : null;
    /** @type {null} */
    this.parentY = this.parentX = null;
    if (parent != this.root && null != model.isVertex(parent) && this.maintainParentLocation) {
      var res = this.graph.getCellGeometry(parent);
      if (null != res) {
        this.parentX = res.x;
        this.parentY = res.y;
      }
    }
    model.beginUpdate();
    try {
      if (this.visited = {}, this.node = this.dfs(this.root, parent), this.alignRanks && (this.maxRankHeight = [], this.findRankHeights(this.node, 0), this.setCellHeights(this.node, 0)), null != this.node) {
        this.layout(this.node);
        var x = this.graph.gridSize;
        value = x;
        if (!this.moveTree) {
          var node = this.getVertexBounds(this.root);
          if (null != node) {
            x = node.x;
            value = node.y;
          }
        }
        /** @type {null} */
        node = null;
        node = this.isHorizontal() ? this.horizontalLayout(this.node, x, value) : this.verticalLayout(this.node, null, x, value);
        if (null != node) {
          /** @type {number} */
          var i = j = 0;
          if (0 > node.x) {
            /** @type {number} */
            j = Math.abs(x - node.x);
          }
          if (0 > node.y) {
            /** @type {number} */
            i = Math.abs(value - node.y);
          }
          if (!(0 == j && 0 == i)) {
            this.moveNode(this.node, j, i);
          }
          if (this.resizeParent) {
            this.adjustParents();
          }
          if (this.edgeRouting) {
            this.localEdgeProcessing(this.node);
          }
        }
        if (null != this.parentX && null != this.parentY) {
          res = this.graph.getCellGeometry(parent);
          if (null != res) {
            res = res.clone();
            res.x = this.parentX;
            res.y = this.parentY;
            model.setGeometry(parent, res);
          }
        }
      }
    } finally {
      model.endUpdate();
    }
  }
};
/**
 * @param {!Object} node
 * @param {number} offset
 * @param {number} delta
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.moveNode = function(node, offset, delta) {
  node.x += offset;
  node.y += delta;
  this.apply(node);
  node = node.child;
  for (; null != node;) {
    this.moveNode(node, offset, delta);
    node = node.next;
  }
};
/**
 * @param {?} text
 * @param {!Array} init
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.sortOutgoingEdges = function(text, init) {
  var c = new mxDictionary;
  init.sort(function(o, obj) {
    var f = o.getTerminal(o.getTerminal(false) == text);
    o = c.get(f);
    if (null == o) {
      o = mxCellPath.create(f).split(mxCellPath.PATH_SEPARATOR);
      c.put(f, o);
    }
    obj = obj.getTerminal(obj.getTerminal(false) == text);
    f = c.get(obj);
    if (null == f) {
      f = mxCellPath.create(obj).split(mxCellPath.PATH_SEPARATOR);
      c.put(obj, f);
    }
    return mxCellPath.compare(o, f);
  });
};
/**
 * @param {!Object} b
 * @param {number} i
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.findRankHeights = function(b, i) {
  if (null == this.maxRankHeight[i] || this.maxRankHeight[i] < b.height) {
    this.maxRankHeight[i] = b.height;
  }
  b = b.child;
  for (; null != b;) {
    this.findRankHeights(b, i + 1);
    b = b.next;
  }
};
/**
 * @param {!Object} child
 * @param {number} i
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.setCellHeights = function(child, i) {
  if (null != this.maxRankHeight[i] && this.maxRankHeight[i] > child.height) {
    child.height = this.maxRankHeight[i];
  }
  child = child.child;
  for (; null != child;) {
    this.setCellHeights(child, i + 1);
    child = child.next;
  }
};
/**
 * @param {?} id
 * @param {string} i
 * @return {?}
 */
mxCompactTreeLayout.prototype.dfs = function(id, i) {
  var link = mxCellPath.create(id);
  /** @type {null} */
  var node = null;
  if (null != id && null == this.visited[link] && !this.isVertexIgnored(id)) {
    this.visited[link] = id;
    node = this.createNode(id);
    link = this.graph.getModel();
    /** @type {null} */
    var layer = null;
    var data = this.graph.getEdges(id, i, this.invert, !this.invert, false, true);
    var morph = this.graph.getView();
    if (this.sortEdges) {
      this.sortOutgoingEdges(id, data);
    }
    /** @type {number} */
    id = 0;
    for (; id < data.length; id++) {
      var element = data[id];
      if (!this.isEdgeIgnored(element)) {
        if (this.resetEdges) {
          this.setEdgePoints(element, null);
        }
        if (this.edgeRouting) {
          this.setEdgeStyleEnabled(element, false);
          this.setEdgePoints(element, null);
        }
        var child = morph.getState(element);
        element = null != child ? child.getVisibleTerminal(this.invert) : morph.getVisibleTerminal(element, this.invert);
        child = this.dfs(element, i);
        if (null != child && null != link.getGeometry(element)) {
          if (null == layer) {
            node.child = child;
          } else {
            layer.next = child;
          }
          layer = child;
        }
      }
    }
  }
  return node;
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.layout = function(value) {
  if (null != value) {
    var item = value.child;
    for (; null != item;) {
      this.layout(item);
      item = item.next;
    }
    if (null != value.child) {
      this.attachParent(value, this.join(value));
    } else {
      this.layoutLeaf(value);
    }
  }
};
/**
 * @param {!Object} self
 * @param {!Object} s
 * @param {number} key
 * @param {?} value
 * @return {?}
 */
mxCompactTreeLayout.prototype.horizontalLayout = function(self, s, key, value) {
  self.x += s + self.offsetX;
  self.y += key + self.offsetY;
  value = this.apply(self, value);
  s = self.child;
  if (null != s) {
    value = this.horizontalLayout(s, self.x, self.y, value);
    key = self.y + s.offsetY;
    var node = s.next;
    for (; null != node;) {
      value = this.horizontalLayout(node, self.x + s.offsetX, key, value);
      key = key + node.offsetY;
      node = node.next;
    }
  }
  return value;
};
/**
 * @param {!Object} self
 * @param {!Object} o
 * @param {number} w
 * @param {!Object} r
 * @param {?} value
 * @return {?}
 */
mxCompactTreeLayout.prototype.verticalLayout = function(self, o, w, r, value) {
  self.x += w + self.offsetY;
  self.y += r + self.offsetX;
  value = this.apply(self, value);
  o = self.child;
  if (null != o) {
    value = this.verticalLayout(o, self, self.x, self.y, value);
    w = self.x + o.offsetY;
    r = o.next;
    for (; null != r;) {
      value = this.verticalLayout(r, self, w, self.y + o.offsetX, value);
      w = w + r.offsetY;
      r = r.next;
    }
  }
  return value;
};
/**
 * @param {!Object} data
 * @param {number} offset
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.attachParent = function(data, offset) {
  var start = this.nodeDistance + this.levelDistance;
  /** @type {number} */
  var x1 = (offset - data.width) / 2 - this.nodeDistance;
  /** @type {number} */
  offset = x1 + data.width + 2 * this.nodeDistance - offset;
  data.child.offsetX = start + data.height;
  /** @type {number} */
  data.child.offsetY = offset;
  data.contour.upperHead = this.createLine(data.height, 0, this.createLine(start, offset, data.contour.upperHead));
  data.contour.lowerHead = this.createLine(data.height, 0, this.createLine(start, x1, data.contour.lowerHead));
};
/**
 * @param {!Object} c
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.layoutLeaf = function(c) {
  /** @type {number} */
  var gap = 2 * this.nodeDistance;
  c.contour.upperTail = this.createLine(c.height + gap, 0);
  c.contour.upperHead = c.contour.upperTail;
  c.contour.lowerTail = this.createLine(0, -c.width - gap);
  c.contour.lowerHead = this.createLine(c.height + gap, 0, c.contour.lowerTail);
};
/**
 * @param {!Object} params
 * @return {?}
 */
mxCompactTreeLayout.prototype.join = function(params) {
  /** @type {number} */
  var router = 2 * this.nodeDistance;
  var options = params.child;
  params.contour = options.contour;
  var name = options.width + router;
  var output = name;
  options = options.next;
  for (; null != options;) {
    var _ = this.merge(params.contour, options.contour);
    options.offsetY = _ + name;
    /** @type {number} */
    options.offsetX = 0;
    name = options.width + router;
    output = output + (_ + name);
    options = options.next;
  }
  return output;
};
/**
 * @param {?} r
 * @param {?} s
 * @return {?}
 */
mxCompactTreeLayout.prototype.merge = function(r, s) {
  /** @type {number} */
  var x = 0;
  /** @type {number} */
  var y = 0;
  /** @type {number} */
  var origin = 0;
  var c = r.lowerHead;
  var p = s.upperHead;
  for (; null != p && null != c;) {
    var offset = this.offset(x, y, p.dx, p.dy, c.dx, c.dy);
    y = y + offset;
    origin = origin + offset;
    if (x + p.dx <= c.dx) {
      x = x + p.dx;
      y = y + p.dy;
      p = p.next;
    } else {
      /** @type {number} */
      x = x - c.dx;
      /** @type {number} */
      y = y - c.dy;
      c = c.next;
    }
  }
  if (null != p) {
    x = this.bridge(r.upperTail, 0, 0, p, x, y);
    r.upperTail = null != x.next ? s.upperTail : x;
    r.lowerTail = s.lowerTail;
  } else {
    x = this.bridge(s.lowerTail, x, y, c, 0, 0);
    if (null == x.next) {
      r.lowerTail = x;
    }
  }
  r.lowerHead = s.lowerHead;
  return origin;
};
/**
 * @param {number} b
 * @param {number} x
 * @param {number} c
 * @param {number} d
 * @param {number} a
 * @param {number} e
 * @return {?}
 */
mxCompactTreeLayout.prototype.offset = function(b, x, c, d, a, e) {
  if (a <= b || 0 >= b + c) {
    return 0;
  }
  /** @type {number} */
  b = 0 < a * d - c * e ? 0 > b ? b * d / c - x : 0 < b ? b * e / a - x : -x : a < b + c ? e - (x + (a - b) * d / c) : a > b + c ? (c + b) * e / a - (x + d) : e - (x + d);
  return 0 < b ? b : 0;
};
/**
 * @param {!Node} p
 * @param {number} r
 * @param {number} s
 * @param {!Object} config
 * @param {number} width
 * @param {number} name
 * @return {?}
 */
mxCompactTreeLayout.prototype.bridge = function(p, r, s, config, width, name) {
  /** @type {number} */
  r = width + config.dx - r;
  if (0 == config.dx) {
    width = config.dy;
  } else {
    /** @type {number} */
    width = r * config.dy;
    /** @type {number} */
    width = width / config.dx;
  }
  r = this.createLine(r, width, config.next);
  p.next = this.createLine(0, name + config.dy - width - s, r);
  return r;
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxCompactTreeLayout.prototype.createNode = function(node) {
  var p = {};
  /** @type {!Object} */
  p.cell = node;
  /** @type {number} */
  p.x = 0;
  /** @type {number} */
  p.y = 0;
  /** @type {number} */
  p.width = 0;
  /** @type {number} */
  p.height = 0;
  node = this.getVertexBounds(node);
  if (null != node) {
    if (this.isHorizontal()) {
      p.width = node.height;
      p.height = node.width;
    } else {
      p.width = node.width;
      p.height = node.height;
    }
  }
  /** @type {number} */
  p.offsetX = 0;
  /** @type {number} */
  p.offsetY = 0;
  p.contour = {};
  return p;
};
/**
 * @param {!Object} a
 * @param {?} val
 * @return {?}
 */
mxCompactTreeLayout.prototype.apply = function(a, val) {
  var m = this.graph.getModel();
  var element = a.cell;
  var rect = m.getGeometry(element);
  if (null != element && null != rect) {
    if (this.isVertexMovable(element)) {
      rect = this.setVertexLocation(element, a.x, a.y);
      if (this.resizeParent) {
        a = m.getParent(element);
        m = mxCellPath.create(a);
        if (null == this.parentsChanged[m]) {
          /** @type {!Object} */
          this.parentsChanged[m] = a;
        }
      }
    }
    val = null == val ? new mxRectangle(rect.x, rect.y, rect.width, rect.height) : new mxRectangle(Math.min(val.x, rect.x), Math.min(val.y, rect.y), Math.max(val.x + val.width, rect.x + rect.width), Math.max(val.y + val.height, rect.y + rect.height));
  }
  return val;
};
/**
 * @param {number} a
 * @param {number} v
 * @param {!Function} t
 * @return {?}
 */
mxCompactTreeLayout.prototype.createLine = function(a, v, t) {
  var target = {};
  /** @type {number} */
  target.dx = a;
  /** @type {number} */
  target.dy = v;
  /** @type {!Function} */
  target.next = t;
  return target;
};
/**
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.adjustParents = function() {
  /** @type {!Array} */
  var pt = [];
  var i;
  for (i in this.parentsChanged) {
    pt.push(this.parentsChanged[i]);
  }
  this.arrangeGroups(mxUtils.sortCells(pt, true), this.groupPadding, this.groupPaddingTop, this.groupPaddingRight, this.groupPaddingBottom, this.groupPaddingLeft);
};
/**
 * @param {!Object} c
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.localEdgeProcessing = function(c) {
  this.processNodeOutgoing(c);
  c = c.child;
  for (; null != c;) {
    this.localEdgeProcessing(c);
    c = c.next;
  }
};
/**
 * @param {!Object} r
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.processNodeOutgoing = function(r) {
  var x = r.child;
  var n = r.cell;
  /** @type {number} */
  var count = 0;
  /** @type {!Array} */
  var a = [];
  for (; null != x;) {
    count++;
    var t = x.x;
    if (this.horizontal) {
      t = x.y;
    }
    a.push(new WeightedCellSorter(x, t));
    x = x.next;
  }
  a.sort(WeightedCellSorter.prototype.compare);
  t = r.width;
  /** @type {number} */
  var b = (count + 1) * this.prefHozEdgeSep;
  if (t > b + 2 * this.prefHozEdgeSep) {
    /** @type {number} */
    t = t - 2 * this.prefHozEdgeSep;
  }
  /** @type {number} */
  r = t / count;
  /** @type {number} */
  x = r / 2;
  if (t > b + 2 * this.prefHozEdgeSep) {
    x = x + this.prefHozEdgeSep;
  }
  /** @type {number} */
  t = this.minEdgeJetty - this.prefVertEdgeOff;
  b = this.getVertexBounds(n);
  /** @type {number} */
  var i = 0;
  for (; i < a.length; i++) {
    var c = a[i].cell.cell;
    var ic = this.getVertexBounds(c);
    c = this.graph.getEdgesBetween(n, c, false);
    /** @type {!Array} */
    var vectors = [];
    var p;
    var v;
    /** @type {number} */
    var ci = 0;
    for (; ci < c.length; ci++) {
      if (this.horizontal) {
        p = b.x + b.width;
        v = b.y + x;
        vectors.push(new mxPoint(p, v));
        p = b.x + b.width + t;
        vectors.push(new mxPoint(p, v));
        v = ic.y + ic.height / 2;
      } else {
        p = b.x + x;
        v = b.y + b.height;
        vectors.push(new mxPoint(p, v));
        v = b.y + b.height + t;
        vectors.push(new mxPoint(p, v));
        p = ic.x + ic.width / 2;
      }
      vectors.push(new mxPoint(p, v));
      this.setEdgePoints(c[ci], vectors);
    }
    if (i < count / 2) {
      t = t + this.prefVertEdgeOff;
    } else {
      if (i > count / 2) {
        /** @type {number} */
        t = t - this.prefVertEdgeOff;
      }
    }
    x = x + r;
  }
};
/**
 * @param {?} p1__3354_SHARP_
 * @return {undefined}
 */
function mxRadialTreeLayout(p1__3354_SHARP_) {
  mxCompactTreeLayout.call(this, p1__3354_SHARP_, false);
}
mxUtils.extend(mxRadialTreeLayout, mxCompactTreeLayout);
/** @type {number} */
mxRadialTreeLayout.prototype.angleOffset = .5;
/** @type {number} */
mxRadialTreeLayout.prototype.rootx = 0;
/** @type {number} */
mxRadialTreeLayout.prototype.rooty = 0;
/** @type {number} */
mxRadialTreeLayout.prototype.levelDistance = 120;
/** @type {number} */
mxRadialTreeLayout.prototype.nodeDistance = 10;
/** @type {boolean} */
mxRadialTreeLayout.prototype.autoRadius = false;
/** @type {boolean} */
mxRadialTreeLayout.prototype.sortEdges = false;
/** @type {!Array} */
mxRadialTreeLayout.prototype.rowMinX = [];
/** @type {!Array} */
mxRadialTreeLayout.prototype.rowMaxX = [];
/** @type {!Array} */
mxRadialTreeLayout.prototype.rowMinCenX = [];
/** @type {!Array} */
mxRadialTreeLayout.prototype.rowMaxCenX = [];
/** @type {!Array} */
mxRadialTreeLayout.prototype.rowRadi = [];
/** @type {!Array} */
mxRadialTreeLayout.prototype.row = [];
/**
 * @param {!Object} id
 * @return {?}
 */
mxRadialTreeLayout.prototype.isVertexIgnored = function(id) {
  return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || 0 == this.graph.getConnections(id).length;
};
/**
 * @param {!Object} o
 * @param {?} $that
 * @return {undefined}
 */
mxRadialTreeLayout.prototype.execute = function(o, $that) {
  /** @type {!Object} */
  this.parent = o;
  /** @type {boolean} */
  this.edgeRouting = this.useBoundingBox = false;
  mxCompactTreeLayout.prototype.execute.apply(this, arguments);
  /** @type {null} */
  var index = null;
  var p = this.getVertexBounds(this.root);
  this.centerX = p.x + p.width / 2;
  this.centerY = p.y + p.height / 2;
  var n;
  for (n in this.visited) {
    var s = this.getVertexBounds(this.visited[n]);
    index = null != index ? index : s.clone();
    index.add(s);
  }
  this.calcRowDims([this.node], 0);
  /** @type {number} */
  var i = 0;
  /** @type {number} */
  var bytes = 0;
  /** @type {number} */
  index = 0;
  for (; index < this.row.length; index++) {
    /** @type {number} */
    n = (this.rowMaxX[index] - this.centerX - this.nodeDistance) / this.rowRadi[index];
    /** @type {number} */
    i = Math.max(i, (this.centerX - this.rowMinX[index] - this.nodeDistance) / this.rowRadi[index]);
    /** @type {number} */
    bytes = Math.max(bytes, n);
  }
  /** @type {number} */
  index = 0;
  for (; index < this.row.length; index++) {
    /** @type {number} */
    var accumulator = this.centerX - this.nodeDistance - i * this.rowRadi[index];
    /** @type {number} */
    var bevelSegments = this.centerX + this.nodeDistance + bytes * this.rowRadi[index] - accumulator;
    /** @type {number} */
    n = 0;
    for (; n < this.row[index].length; n++) {
      s = this.row[index];
      p = s[n];
      s = this.getVertexBounds(p.cell);
      /** @type {number} */
      p.theta = (s.x + s.width / 2 - accumulator) / bevelSegments * Math.PI * 2;
    }
  }
  /** @type {number} */
  index = this.row.length - 2;
  for (; 0 <= index; index--) {
    s = this.row[index];
    /** @type {number} */
    n = 0;
    for (; n < s.length; n++) {
      p = s[n];
      i = p.child;
      /** @type {number} */
      accumulator = bytes = 0;
      for (; null != i;) {
        accumulator = accumulator + i.theta;
        bytes++;
        i = i.next;
      }
      if (0 < bytes) {
        /** @type {number} */
        i = accumulator / bytes;
        if (i > p.theta && n < s.length - 1) {
          /** @type {number} */
          p.theta = Math.min(i, s[n + 1].theta - Math.PI / 10);
        } else {
          if (i < p.theta && 0 < n) {
            /** @type {number} */
            p.theta = Math.max(i, s[n - 1].theta + Math.PI / 10);
          }
        }
      }
    }
  }
  /** @type {number} */
  index = 0;
  for (; index < this.row.length; index++) {
    /** @type {number} */
    n = 0;
    for (; n < this.row[index].length; n++) {
      s = this.row[index];
      p = s[n];
      s = this.getVertexBounds(p.cell);
      this.setVertexLocation(p.cell, this.centerX - s.width / 2 + this.rowRadi[index] * Math.cos(p.theta), this.centerY - s.height / 2 + this.rowRadi[index] * Math.sin(p.theta));
    }
  }
};
/**
 * @param {!Object} data
 * @param {number} index
 * @return {undefined}
 */
mxRadialTreeLayout.prototype.calcRowDims = function(data, index) {
  if (null != data && 0 != data.length) {
    this.rowMinX[index] = this.centerX;
    this.rowMaxX[index] = this.centerX;
    this.rowMinCenX[index] = this.centerX;
    this.rowMaxCenX[index] = this.centerX;
    /** @type {!Array} */
    this.row[index] = [];
    /** @type {boolean} */
    var c = false;
    /** @type {number} */
    var i = 0;
    for (; i < data.length; i++) {
      var t = null != data[i] ? data[i].child : null;
      for (; null != t;) {
        var f = this.getVertexBounds(t.cell);
        /** @type {number} */
        this.rowMinX[index] = Math.min(f.x, this.rowMinX[index]);
        /** @type {number} */
        this.rowMaxX[index] = Math.max(f.x + f.width, this.rowMaxX[index]);
        /** @type {number} */
        this.rowMinCenX[index] = Math.min(f.x + f.width / 2, this.rowMinCenX[index]);
        /** @type {number} */
        this.rowMaxCenX[index] = Math.max(f.x + f.width / 2, this.rowMaxCenX[index]);
        /** @type {number} */
        this.rowRadi[index] = f.y - this.getVertexBounds(this.root).y;
        if (null != t.child) {
          /** @type {boolean} */
          c = true;
        }
        this.row[index].push(t);
        t = t.next;
      }
    }
    if (c) {
      this.calcRowDims(this.row[index], index + 1);
    }
  }
};
/**
 * @param {?} p1__3354_SHARP_
 * @return {undefined}
 */
function mxFastOrganicLayout(p1__3354_SHARP_) {
  mxGraphLayout.call(this, p1__3354_SHARP_);
}
mxFastOrganicLayout.prototype = new mxGraphLayout;
/** @type {function(?): undefined} */
mxFastOrganicLayout.prototype.constructor = mxFastOrganicLayout;
/** @type {boolean} */
mxFastOrganicLayout.prototype.useInputOrigin = true;
/** @type {boolean} */
mxFastOrganicLayout.prototype.resetEdges = true;
/** @type {boolean} */
mxFastOrganicLayout.prototype.disableEdgeStyle = true;
/** @type {number} */
mxFastOrganicLayout.prototype.forceConstant = 50;
/** @type {number} */
mxFastOrganicLayout.prototype.forceConstantSquared = 0;
/** @type {number} */
mxFastOrganicLayout.prototype.minDistanceLimit = 2;
/** @type {number} */
mxFastOrganicLayout.prototype.maxDistanceLimit = 500;
/** @type {number} */
mxFastOrganicLayout.prototype.minDistanceLimitSquared = 4;
/** @type {number} */
mxFastOrganicLayout.prototype.initialTemp = 200;
/** @type {number} */
mxFastOrganicLayout.prototype.temperature = 0;
/** @type {number} */
mxFastOrganicLayout.prototype.maxIterations = 0;
/** @type {number} */
mxFastOrganicLayout.prototype.iteration = 0;
/** @type {boolean} */
mxFastOrganicLayout.prototype.allowedToRun = true;
/**
 * @param {!Object} id
 * @return {?}
 */
mxFastOrganicLayout.prototype.isVertexIgnored = function(id) {
  return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || 0 == this.graph.getConnections(id).length;
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxFastOrganicLayout.prototype.execute = function(value) {
  var targetFragment = this.graph.getModel();
  /** @type {!Array} */
  this.vertexArray = [];
  var val = this.graph.getChildVertices(value);
  /** @type {number} */
  var i = 0;
  for (; i < val.length; i++) {
    if (!this.isVertexIgnored(val[i])) {
      this.vertexArray.push(val[i]);
    }
  }
  var props = this.useInputOrigin ? this.graph.getBoundingBoxFromGeometry(this.vertexArray) : null;
  /** @type {number} */
  var f = this.vertexArray.length;
  /** @type {!Array} */
  this.indices = [];
  /** @type {!Array} */
  this.dispX = [];
  /** @type {!Array} */
  this.dispY = [];
  /** @type {!Array} */
  this.cellLocation = [];
  /** @type {!Array} */
  this.isMoveable = [];
  /** @type {!Array} */
  this.neighbours = [];
  /** @type {!Array} */
  this.radius = [];
  /** @type {!Array} */
  this.radiusSquared = [];
  if (.001 > this.forceConstant) {
    /** @type {number} */
    this.forceConstant = .001;
  }
  /** @type {number} */
  this.forceConstantSquared = this.forceConstant * this.forceConstant;
  /** @type {number} */
  i = 0;
  for (; i < this.vertexArray.length; i++) {
    var s = this.vertexArray[i];
    /** @type {!Array} */
    this.cellLocation[i] = [];
    var a = mxObjectIdentity.get(s);
    /** @type {number} */
    this.indices[a] = i;
    var m = this.getVertexBounds(s);
    var j = m.width;
    var distance = m.height;
    var max = m.x;
    var size = m.y;
    this.cellLocation[i][0] = max + j / 2;
    this.cellLocation[i][1] = size + distance / 2;
    /** @type {number} */
    this.radius[i] = Math.min(j, distance);
    /** @type {number} */
    this.radiusSquared[i] = this.radius[i] * this.radius[i];
  }
  targetFragment.beginUpdate();
  try {
    /** @type {number} */
    i = 0;
    for (; i < f; i++) {
      /** @type {number} */
      this.dispX[i] = 0;
      /** @type {number} */
      this.dispY[i] = 0;
      this.isMoveable[i] = this.isVertexMovable(this.vertexArray[i]);
      var index = this.graph.getConnections(this.vertexArray[i], value);
      val = this.graph.getOpposites(index, this.vertexArray[i]);
      /** @type {!Array} */
      this.neighbours[i] = [];
      /** @type {number} */
      j = 0;
      for (; j < val.length; j++) {
        if (this.resetEdges) {
          this.graph.resetEdge(index[j]);
        }
        if (this.disableEdgeStyle) {
          this.setEdgeStyleEnabled(index[j], false);
        }
        a = mxObjectIdentity.get(val[j]);
        var index = this.indices[a];
        this.neighbours[i][j] = null != index ? index : i;
      }
    }
    this.temperature = this.initialTemp;
    if (0 == this.maxIterations) {
      /** @type {number} */
      this.maxIterations = 20 * Math.sqrt(f);
    }
    /** @type {number} */
    this.iteration = 0;
    for (; this.iteration < this.maxIterations; this.iteration++) {
      if (!this.allowedToRun) {
        return;
      }
      this.calcRepulsion();
      this.calcAttraction();
      this.calcPositions();
      this.reduceTemperature();
    }
    /** @type {null} */
    value = val = null;
    /** @type {number} */
    i = 0;
    for (; i < this.vertexArray.length; i++) {
      s = this.vertexArray[i];
      if (this.isVertexMovable(s)) {
        m = this.getVertexBounds(s);
        if (null != m) {
          this.cellLocation[i][0] -= m.width / 2;
          this.cellLocation[i][1] -= m.height / 2;
          max = this.graph.snap(Math.round(this.cellLocation[i][0]));
          size = this.graph.snap(Math.round(this.cellLocation[i][1]));
          this.setVertexLocation(s, max, size);
          val = null == val ? max : Math.min(val, max);
          value = null == value ? size : Math.min(value, size);
        }
      }
    }
    /** @type {number} */
    i = -(val || 0) + 1;
    /** @type {number} */
    s = -(value || 0) + 1;
    if (null != props) {
      i = i + props.x;
      s = s + props.y;
    }
    this.graph.moveCells(this.vertexArray, i, s);
  } finally {
    targetFragment.endUpdate();
  }
};
/**
 * @return {undefined}
 */
mxFastOrganicLayout.prototype.calcPositions = function() {
  /** @type {number} */
  var i = 0;
  for (; i < this.vertexArray.length; i++) {
    if (this.isMoveable[i]) {
      /** @type {number} */
      var n = Math.sqrt(this.dispX[i] * this.dispX[i] + this.dispY[i] * this.dispY[i]);
      if (.001 > n) {
        /** @type {number} */
        n = .001;
      }
      /** @type {number} */
      var c = this.dispX[i] / n * Math.min(n, this.temperature);
      /** @type {number} */
      n = this.dispY[i] / n * Math.min(n, this.temperature);
      /** @type {number} */
      this.dispX[i] = 0;
      /** @type {number} */
      this.dispY[i] = 0;
      this.cellLocation[i][0] += c;
      this.cellLocation[i][1] += n;
    }
  }
};
/**
 * @return {undefined}
 */
mxFastOrganicLayout.prototype.calcAttraction = function() {
  /** @type {number} */
  var p = 0;
  for (; p < this.vertexArray.length; p++) {
    /** @type {number} */
    var i = 0;
    for (; i < this.neighbours[p].length; i++) {
      var root = this.neighbours[p][i];
      if (p != root && this.isMoveable[p] && this.isMoveable[root]) {
        /** @type {number} */
        var lightI = this.cellLocation[p][0] - this.cellLocation[root][0];
        /** @type {number} */
        var lightJ = this.cellLocation[p][1] - this.cellLocation[root][1];
        /** @type {number} */
        var x = lightI * lightI + lightJ * lightJ - this.radiusSquared[p] - this.radiusSquared[root];
        if (x < this.minDistanceLimitSquared) {
          x = this.minDistanceLimitSquared;
        }
        /** @type {number} */
        var y = Math.sqrt(x);
        /** @type {number} */
        x = x / this.forceConstant;
        /** @type {number} */
        lightI = lightI / y * x;
        /** @type {number} */
        lightJ = lightJ / y * x;
        this.dispX[p] -= lightI;
        this.dispY[p] -= lightJ;
        this.dispX[root] += lightI;
        this.dispY[root] += lightJ;
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxFastOrganicLayout.prototype.calcRepulsion = function() {
  var numSpawners = this.vertexArray.length;
  /** @type {number} */
  var i = 0;
  for (; i < numSpawners; i++) {
    /** @type {number} */
    var j = i;
    for (; j < numSpawners; j++) {
      if (!this.allowedToRun) {
        return;
      }
      if (j != i && this.isMoveable[i] && this.isMoveable[j]) {
        /** @type {number} */
        var x = this.cellLocation[i][0] - this.cellLocation[j][0];
        /** @type {number} */
        var y = this.cellLocation[i][1] - this.cellLocation[j][1];
        if (0 == x) {
          /** @type {number} */
          x = .01 + Math.random();
        }
        if (0 == y) {
          /** @type {number} */
          y = .01 + Math.random();
        }
        /** @type {number} */
        var h = Math.sqrt(x * x + y * y);
        /** @type {number} */
        var d = h - this.radius[i] - this.radius[j];
        if (!(d > this.maxDistanceLimit)) {
          if (d < this.minDistanceLimit) {
            d = this.minDistanceLimit;
          }
          /** @type {number} */
          d = this.forceConstantSquared / d;
          /** @type {number} */
          x = x / h * d;
          /** @type {number} */
          y = y / h * d;
          this.dispX[i] += x;
          this.dispY[i] += y;
          this.dispX[j] -= x;
          this.dispY[j] -= y;
        }
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxFastOrganicLayout.prototype.reduceTemperature = function() {
  /** @type {number} */
  this.temperature = this.initialTemp * (1 - this.iteration / this.maxIterations);
};
/**
 * @param {?} conn
 * @param {number} maxRadius
 * @return {undefined}
 */
function mxCircleLayout(conn, maxRadius) {
  mxGraphLayout.call(this, conn);
  this.radius = null != maxRadius ? maxRadius : 100;
}
mxCircleLayout.prototype = new mxGraphLayout;
/** @type {function(?, number): undefined} */
mxCircleLayout.prototype.constructor = mxCircleLayout;
/** @type {null} */
mxCircleLayout.prototype.radius = null;
/** @type {boolean} */
mxCircleLayout.prototype.moveCircle = false;
/** @type {number} */
mxCircleLayout.prototype.x0 = 0;
/** @type {number} */
mxCircleLayout.prototype.y0 = 0;
/** @type {boolean} */
mxCircleLayout.prototype.resetEdges = true;
/** @type {boolean} */
mxCircleLayout.prototype.disableEdgeStyle = true;
/**
 * @param {!Object} parent
 * @return {undefined}
 */
mxCircleLayout.prototype.execute = function(parent) {
  var node = this.graph.getModel();
  node.beginUpdate();
  try {
    /** @type {number} */
    var padding = 0;
    /** @type {null} */
    var n = null;
    /** @type {null} */
    var r = null;
    /** @type {!Array} */
    var left = [];
    var newParentTag = node.getChildCount(parent);
    /** @type {number} */
    var i = 0;
    for (; i < newParentTag; i++) {
      var l = node.getChildAt(parent, i);
      if (this.isVertexIgnored(l)) {
        if (!this.isEdgeIgnored(l)) {
          if (this.resetEdges) {
            this.graph.resetEdge(l);
          }
          if (this.disableEdgeStyle) {
            this.setEdgeStyleEnabled(l, false);
          }
        }
      } else {
        left.push(l);
        var s = this.getVertexBounds(l);
        n = null == n ? s.y : Math.min(n, s.y);
        r = null == r ? s.x : Math.min(r, s.x);
        /** @type {number} */
        padding = Math.max(padding, Math.max(s.width, s.height));
      }
    }
    var options = this.getRadius(left.length, padding);
    if (this.moveCircle) {
      r = this.x0;
      n = this.y0;
    }
    this.circle(left, options, r, n);
  } finally {
    node.endUpdate();
  }
};
/**
 * @param {number} a
 * @param {number} b
 * @return {?}
 */
mxCircleLayout.prototype.getRadius = function(a, b) {
  return Math.max(a * b / Math.PI, this.radius);
};
/**
 * @param {!Array} p
 * @param {number} r
 * @param {string} c
 * @param {string} y
 * @return {undefined}
 */
mxCircleLayout.prototype.circle = function(p, r, c, y) {
  var count = p.length;
  /** @type {number} */
  var width = 2 * Math.PI / count;
  /** @type {number} */
  var j = 0;
  for (; j < count; j++) {
    if (this.isVertexMovable(p[j])) {
      this.setVertexLocation(p[j], Math.round(c + r + r * Math.cos(j * width - Math.PI / 2)), Math.round(y + r + r * Math.sin(j * width - Math.PI / 2)));
    }
  }
};
/**
 * @param {?} p1__3354_SHARP_
 * @return {undefined}
 */
function mxParallelEdgeLayout(p1__3354_SHARP_) {
  mxGraphLayout.call(this, p1__3354_SHARP_);
}
mxParallelEdgeLayout.prototype = new mxGraphLayout;
/** @type {function(?): undefined} */
mxParallelEdgeLayout.prototype.constructor = mxParallelEdgeLayout;
/** @type {number} */
mxParallelEdgeLayout.prototype.spacing = 20;
/** @type {boolean} */
mxParallelEdgeLayout.prototype.checkOverlap = false;
/**
 * @param {!Object} data
 * @param {undefined} list
 * @return {undefined}
 */
mxParallelEdgeLayout.prototype.execute = function(data, list) {
  data = this.findParallels(data, list);
  this.graph.model.beginUpdate();
  try {
    var dataKey;
    for (dataKey in data) {
      var items = data[dataKey];
      if (1 < items.length) {
        this.layout(items);
      }
    }
  } finally {
    this.graph.model.endUpdate();
  }
};
/**
 * @param {!Object} i
 * @param {number} node
 * @return {?}
 */
mxParallelEdgeLayout.prototype.findParallels = function(i, node) {
  /** @type {!Array} */
  var dispenses_by_med = [];
  var $ = mxUtils.bind(this, function(range) {
    if (!this.isEdgeIgnored(range)) {
      var k = this.getEdgeId(range);
      if (null != k) {
        if (null == dispenses_by_med[k]) {
          /** @type {!Array} */
          dispenses_by_med[k] = [];
        }
        dispenses_by_med[k].push(range);
      }
    }
  });
  if (null != node) {
    /** @type {number} */
    var y = 0;
    for (; y < node.length; y++) {
      $(node[y]);
    }
  } else {
    node = this.graph.getModel();
    var $sendIcon = node.getChildCount(i);
    /** @type {number} */
    y = 0;
    for (; y < $sendIcon; y++) {
      $(node.getChildAt(i, y));
    }
  }
  return dispenses_by_med;
};
/**
 * @param {string} r
 * @return {?}
 */
mxParallelEdgeLayout.prototype.getEdgeId = function(r) {
  var a = this.graph.getView();
  var b = a.getVisibleTerminal(r, true);
  a = a.getVisibleTerminal(r, false);
  /** @type {string} */
  var tVertexLocations = "";
  if (null != b && null != a) {
    b = mxObjectIdentity.get(b);
    a = mxObjectIdentity.get(a);
    if (this.checkOverlap && (r = this.graph.view.getState(r), null != r && null != r.absolutePoints)) {
      /** @type {!Array} */
      tVertexLocations = [];
      /** @type {number} */
      var page = 0;
      for (; page < r.absolutePoints.length; page++) {
        var tPrevVertex = r.absolutePoints[page];
        if (null != tPrevVertex) {
          tVertexLocations.push(tPrevVertex.x, tPrevVertex.y);
        }
      }
      /** @type {string} */
      tVertexLocations = tVertexLocations.join(",");
    }
    return (b > a ? a + "-" + b : b + "-" + a) + tVertexLocations;
  }
  return null;
};
/**
 * @param {!Array} v
 * @return {undefined}
 */
mxParallelEdgeLayout.prototype.layout = function(v) {
  var y = v[0];
  var msg = this.graph.getView();
  var x = this.graph.getModel();
  var p = x.getGeometry(msg.getVisibleTerminal(y, true));
  x = x.getGeometry(msg.getVisibleTerminal(y, false));
  if (p == x) {
    y = p.x + p.width + this.spacing;
    msg = p.y + p.height / 2;
    /** @type {number} */
    var i = 0;
    for (; i < v.length; i++) {
      this.route(v[i], y, msg);
      y = y + this.spacing;
    }
  } else {
    if (null != p && null != x) {
      y = p.x + p.width / 2;
      msg = p.y + p.height / 2;
      /** @type {number} */
      i = x.x + x.width / 2 - y;
      /** @type {number} */
      var j = x.y + x.height / 2 - msg;
      /** @type {number} */
      x = Math.sqrt(i * i + j * j);
      if (0 < x) {
        /** @type {number} */
        p = j * this.spacing / x;
        /** @type {number} */
        x = i * this.spacing / x;
        y = y + i / 2 + p * (v.length - 1) / 2;
        /** @type {number} */
        msg = msg + j / 2 - x * (v.length - 1) / 2;
        /** @type {number} */
        i = 0;
        for (; i < v.length; i++) {
          this.route(v[i], y, msg);
          /** @type {number} */
          y = y - p;
          /** @type {number} */
          msg = msg + x;
        }
      }
    }
  }
};
/**
 * @param {undefined} config
 * @param {?} type
 * @param {boolean} name
 * @return {undefined}
 */
mxParallelEdgeLayout.prototype.route = function(config, type, name) {
  if (this.graph.isCellMovable(config)) {
    this.setEdgePoints(config, [new mxPoint(type, name)]);
  }
};
/**
 * @param {?} categories
 * @param {!Object} next
 * @param {boolean} server
 * @return {undefined}
 */
function mxCompositeLayout(categories, next, server) {
  mxGraphLayout.call(this, categories);
  /** @type {!Object} */
  this.layouts = next;
  /** @type {boolean} */
  this.master = server;
}
mxCompositeLayout.prototype = new mxGraphLayout;
/** @type {function(?, !Object, boolean): undefined} */
mxCompositeLayout.prototype.constructor = mxCompositeLayout;
/** @type {null} */
mxCompositeLayout.prototype.layouts = null;
/** @type {null} */
mxCompositeLayout.prototype.master = null;
/**
 * @param {?} index
 * @param {?} id
 * @param {?} destinationId
 * @return {undefined}
 */
mxCompositeLayout.prototype.moveCell = function(index, id, destinationId) {
  if (null != this.master) {
    this.master.moveCell.apply(this.master, arguments);
  } else {
    this.layouts[0].moveCell.apply(this.layouts[0], arguments);
  }
};
/**
 * @param {!Object} ast
 * @return {undefined}
 */
mxCompositeLayout.prototype.execute = function(ast) {
  var targetFragment = this.graph.getModel();
  targetFragment.beginUpdate();
  try {
    /** @type {number} */
    var i = 0;
    for (; i < this.layouts.length; i++) {
      this.layouts[i].execute.apply(this.layouts[i], arguments);
    }
  } finally {
    targetFragment.endUpdate();
  }
};
/**
 * @param {?} a
 * @param {?} b
 * @return {undefined}
 */
function mxEdgeLabelLayout(a, b) {
  mxGraphLayout.call(this, a);
}
mxEdgeLabelLayout.prototype = new mxGraphLayout;
/** @type {function(?, ?): undefined} */
mxEdgeLabelLayout.prototype.constructor = mxEdgeLabelLayout;
/**
 * @param {!Object} n
 * @return {undefined}
 */
mxEdgeLabelLayout.prototype.execute = function(n) {
  var thisView = this.graph.view;
  var menu = this.graph.getModel();
  /** @type {!Array} */
  var d = [];
  /** @type {!Array} */
  var e = [];
  var requestsToPerform = menu.getChildCount(n);
  /** @type {number} */
  var i = 0;
  for (; i < requestsToPerform; i++) {
    var id = menu.getChildAt(n, i);
    var l = thisView.getState(id);
    if (null != l) {
      if (this.isVertexIgnored(id)) {
        if (!this.isEdgeIgnored(id)) {
          d.push(l);
        }
      } else {
        e.push(l);
      }
    }
  }
  this.placeLabels(e, d);
};
/**
 * @param {!Array} d
 * @param {!Array} s
 * @return {undefined}
 */
mxEdgeLabelLayout.prototype.placeLabels = function(d, s) {
  var targetFragment = this.graph.getModel();
  targetFragment.beginUpdate();
  try {
    /** @type {number} */
    var i = 0;
    for (; i < s.length; i++) {
      var e = s[i];
      if (null != e && null != e.text && null != e.text.boundingBox) {
        /** @type {number} */
        var i = 0;
        for (; i < d.length; i++) {
          var week = d[i];
          if (null != week) {
            this.avoid(e, week);
          }
        }
      }
    }
  } finally {
    targetFragment.endUpdate();
  }
};
/**
 * @param {!Object} e
 * @param {!Object} value
 * @return {undefined}
 */
mxEdgeLabelLayout.prototype.avoid = function(e, value) {
  var layer = this.graph.getModel();
  var data = e.text.boundingBox;
  if (mxUtils.intersects(data, value)) {
    var height = -data.y - data.height + value.y;
    var minPointSize = -data.y + value.y + value.height;
    height = Math.abs(height) < Math.abs(minPointSize) ? height : minPointSize;
    minPointSize = -data.x - data.width + value.x;
    value = -data.x + value.x + value.width;
    value = Math.abs(minPointSize) < Math.abs(value) ? minPointSize : value;
    if (Math.abs(value) < Math.abs(height)) {
      /** @type {number} */
      height = 0;
    } else {
      /** @type {number} */
      value = 0;
    }
    data = layer.getGeometry(e.cell);
    if (null != data) {
      data = data.clone();
      if (null != data.offset) {
        data.offset.x += value;
        data.offset.y += height;
      } else {
        data.offset = new mxPoint(value, height);
      }
      layer.setGeometry(e.cell, data);
    }
  }
};
/**
 * @return {undefined}
 */
function mxGraphAbstractHierarchyCell() {
  /** @type {!Array} */
  this.x = [];
  /** @type {!Array} */
  this.y = [];
  /** @type {!Array} */
  this.temp = [];
}
/** @type {number} */
mxGraphAbstractHierarchyCell.prototype.maxRank = -1;
/** @type {number} */
mxGraphAbstractHierarchyCell.prototype.minRank = -1;
/** @type {null} */
mxGraphAbstractHierarchyCell.prototype.x = null;
/** @type {null} */
mxGraphAbstractHierarchyCell.prototype.y = null;
/** @type {number} */
mxGraphAbstractHierarchyCell.prototype.width = 0;
/** @type {number} */
mxGraphAbstractHierarchyCell.prototype.height = 0;
/** @type {null} */
mxGraphAbstractHierarchyCell.prototype.nextLayerConnectedCells = null;
/** @type {null} */
mxGraphAbstractHierarchyCell.prototype.previousLayerConnectedCells = null;
/** @type {null} */
mxGraphAbstractHierarchyCell.prototype.temp = null;
/**
 * @param {number} targetChar
 * @return {?}
 */
mxGraphAbstractHierarchyCell.prototype.getNextLayerConnectedCells = function(targetChar) {
  return null;
};
/**
 * @param {?} targetChar
 * @return {?}
 */
mxGraphAbstractHierarchyCell.prototype.getPreviousLayerConnectedCells = function(targetChar) {
  return null;
};
/**
 * @return {?}
 */
mxGraphAbstractHierarchyCell.prototype.isEdge = function() {
  return false;
};
/**
 * @return {?}
 */
mxGraphAbstractHierarchyCell.prototype.isVertex = function() {
  return false;
};
/**
 * @param {number} propertyName
 * @return {?}
 */
mxGraphAbstractHierarchyCell.prototype.getGeneralPurposeVariable = function(propertyName) {
  return null;
};
/**
 * @param {number} b
 * @param {number} t
 * @return {?}
 */
mxGraphAbstractHierarchyCell.prototype.setGeneralPurposeVariable = function(b, t) {
  return null;
};
/**
 * @param {number} value
 * @param {number} i
 * @return {undefined}
 */
mxGraphAbstractHierarchyCell.prototype.setX = function(value, i) {
  if (this.isVertex()) {
    /** @type {number} */
    this.x[0] = i;
  } else {
    if (this.isEdge()) {
      /** @type {number} */
      this.x[value - this.minRank - 1] = i;
    }
  }
};
/**
 * @param {number} val
 * @return {?}
 */
mxGraphAbstractHierarchyCell.prototype.getX = function(val) {
  return this.isVertex() ? this.x[0] : this.isEdge() ? this.x[val - this.minRank - 1] : 0;
};
/**
 * @param {number} value
 * @param {number} el
 * @return {undefined}
 */
mxGraphAbstractHierarchyCell.prototype.setY = function(value, el) {
  if (this.isVertex()) {
    /** @type {number} */
    this.y[0] = el;
  } else {
    if (this.isEdge()) {
      /** @type {number} */
      this.y[value - this.minRank - 1] = el;
    }
  }
};
/**
 * @param {!Object} el
 * @return {undefined}
 */
function mxGraphHierarchyNode(el) {
  mxGraphAbstractHierarchyCell.apply(this, arguments);
  /** @type {!Object} */
  this.cell = el;
  this.id = mxObjectIdentity.get(el);
  /** @type {!Array} */
  this.connectsAsTarget = [];
  /** @type {!Array} */
  this.connectsAsSource = [];
}
mxGraphHierarchyNode.prototype = new mxGraphAbstractHierarchyCell;
/** @type {function(!Object): undefined} */
mxGraphHierarchyNode.prototype.constructor = mxGraphHierarchyNode;
/** @type {null} */
mxGraphHierarchyNode.prototype.cell = null;
/** @type {null} */
mxGraphHierarchyNode.prototype.id = null;
/** @type {null} */
mxGraphHierarchyNode.prototype.connectsAsTarget = null;
/** @type {null} */
mxGraphHierarchyNode.prototype.connectsAsSource = null;
/** @type {boolean} */
mxGraphHierarchyNode.prototype.hashCode = false;
/**
 * @param {?} a
 * @return {?}
 */
mxGraphHierarchyNode.prototype.getRankValue = function(a) {
  return this.maxRank;
};
/**
 * @param {number} targetChar
 * @return {?}
 */
mxGraphHierarchyNode.prototype.getNextLayerConnectedCells = function(targetChar) {
  if (null == this.nextLayerConnectedCells) {
    /** @type {!Array} */
    this.nextLayerConnectedCells = [];
    /** @type {!Array} */
    this.nextLayerConnectedCells[0] = [];
    /** @type {number} */
    var cI = 0;
    for (; cI < this.connectsAsTarget.length; cI++) {
      var value = this.connectsAsTarget[cI];
      if (-1 == value.maxRank || value.maxRank == targetChar + 1) {
        this.nextLayerConnectedCells[0].push(value.source);
      } else {
        this.nextLayerConnectedCells[0].push(value);
      }
    }
  }
  return this.nextLayerConnectedCells[0];
};
/**
 * @param {number} start
 * @return {?}
 */
mxGraphHierarchyNode.prototype.getPreviousLayerConnectedCells = function(start) {
  if (null == this.previousLayerConnectedCells) {
    /** @type {!Array} */
    this.previousLayerConnectedCells = [];
    /** @type {!Array} */
    this.previousLayerConnectedCells[0] = [];
    /** @type {number} */
    var child = 0;
    for (; child < this.connectsAsSource.length; child++) {
      var node = this.connectsAsSource[child];
      if (-1 == node.minRank || node.minRank == start - 1) {
        this.previousLayerConnectedCells[0].push(node.target);
      } else {
        this.previousLayerConnectedCells[0].push(node);
      }
    }
  }
  return this.previousLayerConnectedCells[0];
};
/**
 * @return {?}
 */
mxGraphHierarchyNode.prototype.isVertex = function() {
  return true;
};
/**
 * @param {number} propertyName
 * @return {?}
 */
mxGraphHierarchyNode.prototype.getGeneralPurposeVariable = function(propertyName) {
  return this.temp[0];
};
/**
 * @param {number} b
 * @param {number} t
 * @return {undefined}
 */
mxGraphHierarchyNode.prototype.setGeneralPurposeVariable = function(b, t) {
  /** @type {number} */
  this.temp[0] = t;
};
/**
 * @param {!Function} parent
 * @return {?}
 */
mxGraphHierarchyNode.prototype.isAncestor = function(parent) {
  if (null != parent && null != this.hashCode && null != parent.hashCode && this.hashCode.length < parent.hashCode.length) {
    if (this.hashCode == parent.hashCode) {
      return true;
    }
    if (null == this.hashCode || null == this.hashCode) {
      return false;
    }
    /** @type {number} */
    var i = 0;
    for (; i < this.hashCode.length; i++) {
      if (this.hashCode[i] != parent.hashCode[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
};
/**
 * @return {?}
 */
mxGraphHierarchyNode.prototype.getCoreCell = function() {
  return this.cell;
};
/**
 * @param {string} chunkIds
 * @return {undefined}
 */
function mxGraphHierarchyEdge(chunkIds) {
  mxGraphAbstractHierarchyCell.apply(this, arguments);
  /** @type {string} */
  this.edges = chunkIds;
  /** @type {!Array} */
  this.ids = [];
  /** @type {number} */
  var i = 0;
  for (; i < chunkIds.length; i++) {
    this.ids.push(mxObjectIdentity.get(chunkIds[i]));
  }
}
mxGraphHierarchyEdge.prototype = new mxGraphAbstractHierarchyCell;
/** @type {function(string): undefined} */
mxGraphHierarchyEdge.prototype.constructor = mxGraphHierarchyEdge;
/** @type {null} */
mxGraphHierarchyEdge.prototype.edges = null;
/** @type {null} */
mxGraphHierarchyEdge.prototype.ids = null;
/** @type {null} */
mxGraphHierarchyEdge.prototype.source = null;
/** @type {null} */
mxGraphHierarchyEdge.prototype.target = null;
/** @type {boolean} */
mxGraphHierarchyEdge.prototype.isReversed = false;
/**
 * @param {string} target
 * @return {undefined}
 */
mxGraphHierarchyEdge.prototype.invert = function(target) {
  target = this.source;
  this.source = this.target;
  /** @type {string} */
  this.target = target;
  /** @type {boolean} */
  this.isReversed = !this.isReversed;
};
/**
 * @param {number} targetChar
 * @return {?}
 */
mxGraphHierarchyEdge.prototype.getNextLayerConnectedCells = function(targetChar) {
  if (null == this.nextLayerConnectedCells) {
    /** @type {!Array} */
    this.nextLayerConnectedCells = [];
    /** @type {number} */
    var b = 0;
    for (; b < this.temp.length; b++) {
      /** @type {!Array} */
      this.nextLayerConnectedCells[b] = [];
      if (b == this.temp.length - 1) {
        this.nextLayerConnectedCells[b].push(this.source);
      } else {
        this.nextLayerConnectedCells[b].push(this);
      }
    }
  }
  return this.nextLayerConnectedCells[targetChar - this.minRank - 1];
};
/**
 * @param {number} targetChar
 * @return {?}
 */
mxGraphHierarchyEdge.prototype.getPreviousLayerConnectedCells = function(targetChar) {
  if (null == this.previousLayerConnectedCells) {
    /** @type {!Array} */
    this.previousLayerConnectedCells = [];
    /** @type {number} */
    var b = 0;
    for (; b < this.temp.length; b++) {
      /** @type {!Array} */
      this.previousLayerConnectedCells[b] = [];
      if (0 == b) {
        this.previousLayerConnectedCells[b].push(this.target);
      } else {
        this.previousLayerConnectedCells[b].push(this);
      }
    }
  }
  return this.previousLayerConnectedCells[targetChar - this.minRank - 1];
};
/**
 * @return {?}
 */
mxGraphHierarchyEdge.prototype.isEdge = function() {
  return true;
};
/**
 * @param {number} propertyName
 * @return {?}
 */
mxGraphHierarchyEdge.prototype.getGeneralPurposeVariable = function(propertyName) {
  return this.temp[propertyName - this.minRank - 1];
};
/**
 * @param {number} b
 * @param {number} t
 * @return {undefined}
 */
mxGraphHierarchyEdge.prototype.setGeneralPurposeVariable = function(b, t) {
  /** @type {number} */
  this.temp[b - this.minRank - 1] = t;
};
/**
 * @return {?}
 */
mxGraphHierarchyEdge.prototype.getCoreCell = function() {
  return null != this.edges && 0 < this.edges.length ? this.edges[0] : null;
};
/**
 * @param {string} n
 * @param {string} val
 * @param {string} arr
 * @param {number} i
 * @param {number} e
 * @return {undefined}
 */
function mxGraphHierarchyModel(n, val, arr, i, e) {
  n.getGraph();
  /** @type {number} */
  this.tightenToSource = e;
  /** @type {string} */
  this.roots = arr;
  /** @type {number} */
  this.parent = i;
  this.vertexMapper = new mxDictionary;
  this.edgeMapper = new mxDictionary;
  /** @type {number} */
  this.maxRank = 0;
  /** @type {!Array} */
  arr = [];
  if (null == val) {
    val = this.graph.getChildVertices(i);
  }
  this.maxRank = this.SOURCESCANSTARTRANK;
  this.createInternalCells(n, val, arr);
  /** @type {number} */
  i = 0;
  for (; i < val.length; i++) {
    e = arr[i].connectsAsSource;
    /** @type {number} */
    var j = 0;
    for (; j < e.length; j++) {
      var value = e[j];
      var selector = value.edges;
      if (null != selector && 0 < selector.length) {
        selector = selector[0];
        var obj = n.getVisibleTerminal(selector, false);
        obj = this.vertexMapper.get(obj);
        if (arr[i] == obj) {
          obj = n.getVisibleTerminal(selector, true);
          obj = this.vertexMapper.get(obj);
        }
        if (null != obj && arr[i] != obj) {
          value.target = obj;
          if (0 == obj.connectsAsTarget.length) {
            /** @type {!Array} */
            obj.connectsAsTarget = [];
          }
          if (0 > mxUtils.indexOf(obj.connectsAsTarget, value)) {
            obj.connectsAsTarget.push(value);
          }
        }
      }
    }
    /** @type {number} */
    arr[i].temp[0] = 1;
  }
}
/** @type {null} */
mxGraphHierarchyModel.prototype.maxRank = null;
/** @type {null} */
mxGraphHierarchyModel.prototype.vertexMapper = null;
/** @type {null} */
mxGraphHierarchyModel.prototype.edgeMapper = null;
/** @type {null} */
mxGraphHierarchyModel.prototype.ranks = null;
/** @type {null} */
mxGraphHierarchyModel.prototype.roots = null;
/** @type {null} */
mxGraphHierarchyModel.prototype.parent = null;
/** @type {number} */
mxGraphHierarchyModel.prototype.dfsCount = 0;
/** @type {number} */
mxGraphHierarchyModel.prototype.SOURCESCANSTARTRANK = 1E8;
/** @type {boolean} */
mxGraphHierarchyModel.prototype.tightenToSource = false;
/**
 * @param {string} a
 * @param {string} s
 * @param {string} results
 * @return {undefined}
 */
mxGraphHierarchyModel.prototype.createInternalCells = function(a, s, results) {
  var mapEditor = a.getGraph();
  /** @type {number} */
  var i = 0;
  for (; i < s.length; i++) {
    results[i] = new mxGraphHierarchyNode(s[i]);
    this.vertexMapper.put(s[i], results[i]);
    var dupArray = a.getEdges(s[i]);
    /** @type {!Array} */
    results[i].connectsAsSource = [];
    /** @type {number} */
    var j = 0;
    for (; j < dupArray.length; j++) {
      var value = a.getVisibleTerminal(dupArray[j], false);
      if (value != s[i] && a.graph.model.isVertex(value) && !a.isVertexIgnored(value)) {
        var args = a.getEdgesBetween(s[i], value, false);
        value = a.getEdgesBetween(s[i], value, true);
        if (null != args && 0 < args.length && null == this.edgeMapper.get(args[0]) && 2 * value.length >= args.length) {
          value = new mxGraphHierarchyEdge(args);
          /** @type {number} */
          var index = 0;
          for (; index < args.length; index++) {
            var t = args[index];
            this.edgeMapper.put(t, value);
            mapEditor.resetEdge(t);
            if (a.disableEdgeStyle) {
              a.setEdgeStyleEnabled(t, false);
              a.setOrthogonalEdge(t, true);
            }
          }
          value.source = results[i];
          if (0 > mxUtils.indexOf(results[i].connectsAsSource, value)) {
            results[i].connectsAsSource.push(value);
          }
        }
      }
    }
    /** @type {number} */
    results[i].temp[0] = 0;
  }
};
/**
 * @return {undefined}
 */
mxGraphHierarchyModel.prototype.initialRank = function() {
  /** @type {!Array} */
  var a = [];
  if (null != this.roots) {
    /** @type {number} */
    var i = 0;
    for (; i < this.roots.length; i++) {
      var t = this.vertexMapper.get(this.roots[i]);
      if (null != t) {
        a.push(t);
      }
    }
  }
  var p = this.vertexMapper.getValues();
  /** @type {number} */
  i = 0;
  for (; i < p.length; i++) {
    /** @type {number} */
    p[i].temp[0] = -1;
  }
  /** @type {!Array<?>} */
  var tagsAny = a.slice();
  for (; 0 < a.length;) {
    t = a[0];
    var h = t.connectsAsTarget;
    var completionItems = t.connectsAsSource;
    /** @type {boolean} */
    var k = true;
    var endTime = this.SOURCESCANSTARTRANK;
    /** @type {number} */
    i = 0;
    for (; i < h.length; i++) {
      var value = h[i];
      if (5270620 == value.temp[0]) {
        value = value.source;
        /** @type {number} */
        endTime = Math.min(endTime, value.temp[0] - 1);
      } else {
        /** @type {boolean} */
        k = false;
        break;
      }
    }
    if (k) {
      t.temp[0] = endTime;
      /** @type {number} */
      this.maxRank = Math.min(this.maxRank, endTime);
      if (null != completionItems) {
        /** @type {number} */
        i = 0;
        for (; i < completionItems.length; i++) {
          value = completionItems[i];
          /** @type {number} */
          value.temp[0] = 5270620;
          value = value.target;
          if (-1 == value.temp[0]) {
            a.push(value);
            /** @type {number} */
            value.temp[0] = -2;
          }
        }
      }
      a.shift();
    } else {
      if (i = a.shift(), a.push(t), i == t && 1 == a.length) {
        break;
      }
    }
  }
  /** @type {number} */
  i = 0;
  for (; i < p.length; i++) {
    p[i].temp[0] -= this.maxRank;
  }
  /** @type {number} */
  i = 0;
  for (; i < tagsAny.length; i++) {
    t = tagsAny[i];
    /** @type {number} */
    a = 0;
    h = t.connectsAsSource;
    /** @type {number} */
    p = 0;
    for (; p < h.length; p++) {
      value = h[p];
      value = value.target;
      /** @type {number} */
      t.temp[0] = Math.max(a, value.temp[0] + 1);
      a = t.temp[0];
    }
  }
  /** @type {number} */
  this.maxRank = this.SOURCESCANSTARTRANK - this.maxRank;
};
/**
 * @return {undefined}
 */
mxGraphHierarchyModel.prototype.fixRanks = function() {
  /** @type {!Array} */
  var values = [];
  /** @type {!Array} */
  this.ranks = [];
  /** @type {number} */
  var i = 0;
  for (; i < this.maxRank + 1; i++) {
    /** @type {!Array} */
    values[i] = [];
    this.ranks[i] = values[i];
  }
  /** @type {null} */
  var left = null;
  if (null != this.roots) {
    var childrenGUIDs = this.roots;
    /** @type {!Array} */
    left = [];
    /** @type {number} */
    i = 0;
    for (; i < childrenGUIDs.length; i++) {
      var item_b = this.vertexMapper.get(childrenGUIDs[i]);
      left[i] = item_b;
    }
  }
  this.visit(function(n, value, node, canCreateDiscussions, isSlidingUp) {
    if (0 == isSlidingUp && 0 > value.maxRank && 0 > value.minRank) {
      values[value.temp[0]].push(value);
      value.maxRank = value.temp[0];
      value.minRank = value.temp[0];
      /** @type {number} */
      value.temp[0] = values[value.maxRank].length - 1;
    }
    if (null != n && null != node && 1 < n.maxRank - value.maxRank) {
      node.maxRank = n.maxRank;
      node.minRank = value.maxRank;
      /** @type {!Array} */
      node.temp = [];
      /** @type {!Array} */
      node.x = [];
      /** @type {!Array} */
      node.y = [];
      n = node.minRank + 1;
      for (; n < node.maxRank; n++) {
        values[n].push(node);
        node.setGeneralPurposeVariable(n, values[n].length - 1);
      }
    }
  }, left, false, null);
};
/**
 * @param {!Function} fn
 * @param {!Object} b
 * @param {boolean} c
 * @param {!Object} position
 * @return {undefined}
 */
mxGraphHierarchyModel.prototype.visit = function(fn, b, c, position) {
  if (null != b) {
    /** @type {number} */
    var i = 0;
    for (; i < b.length; i++) {
      var a = b[i];
      if (null != a) {
        if (null == position) {
          position = {};
        }
        if (c) {
          /** @type {!Array} */
          a.hashCode = [];
          a.hashCode[0] = this.dfsCount;
          /** @type {number} */
          a.hashCode[1] = i;
          this.extendedDfs(null, a, null, fn, position, a.hashCode, i, 0);
        } else {
          this.dfs(null, a, null, fn, position, 0);
        }
      }
    }
    this.dfsCount++;
  }
};
/**
 * @param {!Object} arr
 * @param {!Object} p
 * @param {number} i
 * @param {!Function} callback
 * @param {!Function} index
 * @param {number} height
 * @return {undefined}
 */
mxGraphHierarchyModel.prototype.dfs = function(arr, p, i, callback, index, height) {
  if (null != p) {
    var v = p.id;
    if (null == index[v]) {
      /** @type {!Object} */
      index[v] = p;
      callback(arr, p, i, height, 0);
      arr = p.connectsAsSource.slice();
      /** @type {number} */
      i = 0;
      for (; i < arr.length; i++) {
        v = arr[i];
        this.dfs(p, v.target, v, callback, index, height + 1);
      }
    } else {
      callback(arr, p, i, height, 1);
    }
  }
};
/**
 * @param {string} a
 * @param {!Function} c
 * @param {number} n
 * @param {!Function} f
 * @param {!Object} b
 * @param {number} step
 * @param {!Object} i
 * @param {number} W
 * @return {undefined}
 */
mxGraphHierarchyModel.prototype.extendedDfs = function(a, c, n, f, b, step, i, W) {
  if (null != c) {
    if (null == a || null != c.hashCode && c.hashCode[0] == a.hashCode[0] || (step = a.hashCode.length + 1, c.hashCode = a.hashCode.slice(), c.hashCode[step - 1] = i), i = c.id, null == b[i]) {
      /** @type {!Function} */
      b[i] = c;
      f(a, c, n, W, 0);
      a = c.connectsAsSource.slice();
      /** @type {number} */
      n = 0;
      for (; n < a.length; n++) {
        i = a[n];
        this.extendedDfs(c, i.target, i, f, b, c.hashCode, n, W + 1);
      }
    } else {
      f(a, c, n, W, 1);
    }
  }
};
/**
 * @param {string} n
 * @param {string} val
 * @param {string} arr
 * @param {number} i
 * @param {number} e
 * @return {undefined}
 */
function mxSwimlaneModel(n, val, arr, i, e) {
  n.getGraph();
  /** @type {number} */
  this.tightenToSource = e;
  /** @type {string} */
  this.roots = arr;
  /** @type {number} */
  this.parent = i;
  this.vertexMapper = new mxDictionary;
  this.edgeMapper = new mxDictionary;
  /** @type {number} */
  this.maxRank = 0;
  /** @type {!Array} */
  arr = [];
  if (null == val) {
    val = this.graph.getChildVertices(i);
  }
  this.maxRank = this.SOURCESCANSTARTRANK;
  this.createInternalCells(n, val, arr);
  /** @type {number} */
  i = 0;
  for (; i < val.length; i++) {
    e = arr[i].connectsAsSource;
    /** @type {number} */
    var j = 0;
    for (; j < e.length; j++) {
      var value = e[j];
      var selector = value.edges;
      if (null != selector && 0 < selector.length) {
        selector = selector[0];
        var obj = n.getVisibleTerminal(selector, false);
        obj = this.vertexMapper.get(obj);
        if (arr[i] == obj) {
          obj = n.getVisibleTerminal(selector, true);
          obj = this.vertexMapper.get(obj);
        }
        if (null != obj && arr[i] != obj) {
          value.target = obj;
          if (0 == obj.connectsAsTarget.length) {
            /** @type {!Array} */
            obj.connectsAsTarget = [];
          }
          if (0 > mxUtils.indexOf(obj.connectsAsTarget, value)) {
            obj.connectsAsTarget.push(value);
          }
        }
      }
    }
    /** @type {number} */
    arr[i].temp[0] = 1;
  }
}
/** @type {null} */
mxSwimlaneModel.prototype.maxRank = null;
/** @type {null} */
mxSwimlaneModel.prototype.vertexMapper = null;
/** @type {null} */
mxSwimlaneModel.prototype.edgeMapper = null;
/** @type {null} */
mxSwimlaneModel.prototype.ranks = null;
/** @type {null} */
mxSwimlaneModel.prototype.roots = null;
/** @type {null} */
mxSwimlaneModel.prototype.parent = null;
/** @type {number} */
mxSwimlaneModel.prototype.dfsCount = 0;
/** @type {number} */
mxSwimlaneModel.prototype.SOURCESCANSTARTRANK = 1E8;
/** @type {boolean} */
mxSwimlaneModel.prototype.tightenToSource = false;
/** @type {null} */
mxSwimlaneModel.prototype.ranksPerGroup = null;
/**
 * @param {string} self
 * @param {string} nodes
 * @param {string} results
 * @return {undefined}
 */
mxSwimlaneModel.prototype.createInternalCells = function(self, nodes, results) {
  var thread = self.getGraph();
  var groups = self.swimlanes;
  /** @type {number} */
  var i = 0;
  for (; i < nodes.length; i++) {
    results[i] = new mxGraphHierarchyNode(nodes[i]);
    this.vertexMapper.put(nodes[i], results[i]);
    /** @type {number} */
    results[i].swimlaneIndex = -1;
    /** @type {number} */
    var g = 0;
    for (; g < groups.length; g++) {
      if (thread.model.getParent(nodes[i]) == groups[g]) {
        /** @type {number} */
        results[i].swimlaneIndex = g;
        break;
      }
    }
    g = self.getEdges(nodes[i]);
    /** @type {!Array} */
    results[i].connectsAsSource = [];
    /** @type {number} */
    var j = 0;
    for (; j < g.length; j++) {
      var value = self.getVisibleTerminal(g[j], false);
      if (value != nodes[i] && self.graph.model.isVertex(value) && !self.isVertexIgnored(value)) {
        var data = self.getEdgesBetween(nodes[i], value, false);
        value = self.getEdgesBetween(nodes[i], value, true);
        if (null != data && 0 < data.length && null == this.edgeMapper.get(data[0]) && 2 * value.length >= data.length) {
          value = new mxGraphHierarchyEdge(data);
          /** @type {number} */
          var page = 0;
          for (; page < data.length; page++) {
            var p = data[page];
            this.edgeMapper.put(p, value);
            thread.resetEdge(p);
            if (self.disableEdgeStyle) {
              self.setEdgeStyleEnabled(p, false);
              self.setOrthogonalEdge(p, true);
            }
          }
          value.source = results[i];
          if (0 > mxUtils.indexOf(results[i].connectsAsSource, value)) {
            results[i].connectsAsSource.push(value);
          }
        }
      }
    }
    /** @type {number} */
    results[i].temp[0] = 0;
  }
};
/**
 * @return {undefined}
 */
mxSwimlaneModel.prototype.initialRank = function() {
  /** @type {!Array} */
  this.ranksPerGroup = [];
  /** @type {!Array} */
  var pool = [];
  var data = {};
  if (null != this.roots) {
    /** @type {number} */
    var i = 0;
    for (; i < this.roots.length; i++) {
      var o = this.vertexMapper.get(this.roots[i]);
      this.maxChainDfs(null, o, null, data, 0);
      if (null != o) {
        pool.push(o);
      }
    }
  }
  /** @type {!Array} */
  o = [];
  /** @type {!Array} */
  data = [];
  /** @type {number} */
  i = this.ranksPerGroup.length - 1;
  for (; 0 <= i; i--) {
    o[i] = i == this.ranksPerGroup.length - 1 ? 0 : data[i + 1] + 1;
    data[i] = o[i] + this.ranksPerGroup[i];
  }
  this.maxRank = data[0];
  o = this.vertexMapper.getValues();
  /** @type {number} */
  i = 0;
  for (; i < o.length; i++) {
    /** @type {number} */
    o[i].temp[0] = -1;
  }
  pool.slice();
  for (; 0 < pool.length;) {
    o = pool[0];
    var args = o.connectsAsTarget;
    var r = o.connectsAsSource;
    /** @type {boolean} */
    var g = true;
    var min = data[0];
    /** @type {number} */
    i = 0;
    for (; i < args.length; i++) {
      var value = args[i];
      if (5270620 == value.temp[0]) {
        value = value.source;
        /** @type {number} */
        min = Math.min(min, value.temp[0] - 1);
      } else {
        /** @type {boolean} */
        g = false;
        break;
      }
    }
    if (g) {
      if (min > data[o.swimlaneIndex]) {
        min = data[o.swimlaneIndex];
      }
      o.temp[0] = min;
      if (null != r) {
        /** @type {number} */
        i = 0;
        for (; i < r.length; i++) {
          value = r[i];
          /** @type {number} */
          value.temp[0] = 5270620;
          value = value.target;
          if (-1 == value.temp[0]) {
            pool.push(value);
            /** @type {number} */
            value.temp[0] = -2;
          }
        }
      }
      pool.shift();
    } else {
      if (i = pool.shift(), pool.push(o), i == o && 1 == pool.length) {
        break;
      }
    }
  }
};
/**
 * @param {string} a
 * @param {!Object} b
 * @param {number} i
 * @param {!Object} data
 * @param {number} key
 * @return {undefined}
 */
mxSwimlaneModel.prototype.maxChainDfs = function(a, b, i, data, key) {
  if (null != b && (a = mxCellPath.create(b.cell), null == data[a])) {
    /** @type {!Object} */
    data[a] = b;
    a = b.swimlaneIndex;
    if (null == this.ranksPerGroup[a] || this.ranksPerGroup[a] < key) {
      /** @type {number} */
      this.ranksPerGroup[a] = key;
    }
    a = b.connectsAsSource.slice();
    /** @type {number} */
    i = 0;
    for (; i < a.length; i++) {
      var p = a[i];
      var button = p.target;
      if (b.swimlaneIndex < button.swimlaneIndex) {
        this.maxChainDfs(b, button, p, mxUtils.clone(data, null, true), 0);
      } else {
        if (b.swimlaneIndex == button.swimlaneIndex) {
          this.maxChainDfs(b, button, p, mxUtils.clone(data, null, true), key + 1);
        }
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxSwimlaneModel.prototype.fixRanks = function() {
  /** @type {!Array} */
  var values = [];
  /** @type {!Array} */
  this.ranks = [];
  /** @type {number} */
  var i = 0;
  for (; i < this.maxRank + 1; i++) {
    /** @type {!Array} */
    values[i] = [];
    this.ranks[i] = values[i];
  }
  /** @type {null} */
  var left = null;
  if (null != this.roots) {
    var childrenGUIDs = this.roots;
    /** @type {!Array} */
    left = [];
    /** @type {number} */
    i = 0;
    for (; i < childrenGUIDs.length; i++) {
      var item_b = this.vertexMapper.get(childrenGUIDs[i]);
      left[i] = item_b;
    }
  }
  this.visit(function(n, value, node, canCreateDiscussions, isSlidingUp) {
    if (0 == isSlidingUp && 0 > value.maxRank && 0 > value.minRank) {
      values[value.temp[0]].push(value);
      value.maxRank = value.temp[0];
      value.minRank = value.temp[0];
      /** @type {number} */
      value.temp[0] = values[value.maxRank].length - 1;
    }
    if (null != n && null != node && 1 < n.maxRank - value.maxRank) {
      node.maxRank = n.maxRank;
      node.minRank = value.maxRank;
      /** @type {!Array} */
      node.temp = [];
      /** @type {!Array} */
      node.x = [];
      /** @type {!Array} */
      node.y = [];
      n = node.minRank + 1;
      for (; n < node.maxRank; n++) {
        values[n].push(node);
        node.setGeneralPurposeVariable(n, values[n].length - 1);
      }
    }
  }, left, false, null);
};
/**
 * @param {!Function} fn
 * @param {!Object} b
 * @param {boolean} c
 * @param {!Object} position
 * @return {undefined}
 */
mxSwimlaneModel.prototype.visit = function(fn, b, c, position) {
  if (null != b) {
    /** @type {number} */
    var i = 0;
    for (; i < b.length; i++) {
      var a = b[i];
      if (null != a) {
        if (null == position) {
          position = {};
        }
        if (c) {
          /** @type {!Array} */
          a.hashCode = [];
          a.hashCode[0] = this.dfsCount;
          /** @type {number} */
          a.hashCode[1] = i;
          this.extendedDfs(null, a, null, fn, position, a.hashCode, i, 0);
        } else {
          this.dfs(null, a, null, fn, position, 0);
        }
      }
    }
    this.dfsCount++;
  }
};
/**
 * @param {!Object} path
 * @param {!Object} node
 * @param {number} n
 * @param {!Function} f
 * @param {!Function} arr
 * @param {number} index
 * @return {undefined}
 */
mxSwimlaneModel.prototype.dfs = function(path, node, n, f, arr, index) {
  if (null != node) {
    var parent = node.id;
    if (null == arr[parent]) {
      /** @type {!Object} */
      arr[parent] = node;
      f(path, node, n, index, 0);
      path = node.connectsAsSource.slice();
      /** @type {number} */
      n = 0;
      for (; n < path.length; n++) {
        parent = path[n];
        this.dfs(node, parent.target, parent, f, arr, index + 1);
      }
    } else {
      f(path, node, n, index, 1);
    }
  }
};
/**
 * @param {!Function} a
 * @param {!Function} b
 * @param {!Object} result
 * @param {!Function} callback
 * @param {!Object} expected
 * @param {string} n
 * @param {string} i
 * @param {number} name
 * @return {undefined}
 */
mxSwimlaneModel.prototype.extendedDfs = function(a, b, result, callback, expected, n, i, name) {
  if (null != b) {
    if (null == a || null != b.hashCode && b.hashCode[0] == a.hashCode[0] || (n = a.hashCode.length + 1, b.hashCode = a.hashCode.slice(), b.hashCode[n - 1] = i), i = b.id, null == expected[i]) {
      /** @type {!Function} */
      expected[i] = b;
      callback(a, b, result, name, 0);
      a = b.connectsAsSource.slice();
      result = b.connectsAsTarget.slice();
      /** @type {number} */
      i = 0;
      for (; i < a.length; i++) {
        n = a[i];
        var c = n.target;
        if (b.swimlaneIndex <= c.swimlaneIndex) {
          this.extendedDfs(b, c, n, callback, expected, b.hashCode, i, name + 1);
        }
      }
      /** @type {number} */
      i = 0;
      for (; i < result.length; i++) {
        n = result[i];
        c = n.source;
        if (b.swimlaneIndex < c.swimlaneIndex) {
          this.extendedDfs(b, c, n, callback, expected, b.hashCode, i, name + 1);
        }
      }
    } else {
      callback(a, b, result, name, 1);
    }
  }
};
/**
 * @return {undefined}
 */
function mxHierarchicalLayoutStage() {
}
/**
 * @param {!Object} ast
 * @return {undefined}
 */
mxHierarchicalLayoutStage.prototype.execute = function(ast) {
};
/**
 * @param {!Object} layoutParam
 * @return {undefined}
 */
function mxMedianHybridCrossingReduction(layoutParam) {
  /** @type {!Object} */
  this.layout = layoutParam;
}
mxMedianHybridCrossingReduction.prototype = new mxHierarchicalLayoutStage;
/** @type {function(!Object): undefined} */
mxMedianHybridCrossingReduction.prototype.constructor = mxMedianHybridCrossingReduction;
/** @type {null} */
mxMedianHybridCrossingReduction.prototype.layout = null;
/** @type {number} */
mxMedianHybridCrossingReduction.prototype.maxIterations = 24;
/** @type {null} */
mxMedianHybridCrossingReduction.prototype.nestedBestRanks = null;
/** @type {number} */
mxMedianHybridCrossingReduction.prototype.currentBestCrossings = 0;
/** @type {number} */
mxMedianHybridCrossingReduction.prototype.iterationsWithoutImprovement = 0;
/** @type {number} */
mxMedianHybridCrossingReduction.prototype.maxNoImprovementIterations = 2;
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxMedianHybridCrossingReduction.prototype.execute = function(value) {
  value = this.layout.getModel();
  /** @type {!Array} */
  this.nestedBestRanks = [];
  /** @type {number} */
  var i = 0;
  for (; i < value.ranks.length; i++) {
    this.nestedBestRanks[i] = value.ranks[i].slice();
  }
  /** @type {number} */
  var e = 0;
  var a = this.calculateCrossings(value);
  /** @type {number} */
  i = 0;
  for (; i < this.maxIterations && e < this.maxNoImprovementIterations; i++) {
    this.weightedMedian(i, value);
    this.transpose(i, value);
    var n = this.calculateCrossings(value);
    if (n < a) {
      a = n;
      /** @type {number} */
      n = e = 0;
      for (; n < this.nestedBestRanks.length; n++) {
        var o = value.ranks[n];
        /** @type {number} */
        var j = 0;
        for (; j < o.length; j++) {
          var s = o[j];
          this.nestedBestRanks[n][s.getGeneralPurposeVariable(n)] = s;
        }
      }
    } else {
      e++;
      /** @type {number} */
      n = 0;
      for (; n < this.nestedBestRanks.length; n++) {
        o = value.ranks[n];
        /** @type {number} */
        j = 0;
        for (; j < o.length; j++) {
          s = o[j];
          s.setGeneralPurposeVariable(n, j);
        }
      }
    }
    if (0 == a) {
      break;
    }
  }
  /** @type {!Array} */
  e = [];
  /** @type {!Array} */
  a = [];
  /** @type {number} */
  i = 0;
  for (; i < value.maxRank + 1; i++) {
    /** @type {!Array} */
    a[i] = [];
    e[i] = a[i];
  }
  /** @type {number} */
  i = 0;
  for (; i < this.nestedBestRanks.length; i++) {
    /** @type {number} */
    n = 0;
    for (; n < this.nestedBestRanks[i].length; n++) {
      a[i].push(this.nestedBestRanks[i][n]);
    }
  }
  /** @type {!Array} */
  value.ranks = e;
};
/**
 * @param {boolean} n
 * @return {?}
 */
mxMedianHybridCrossingReduction.prototype.calculateCrossings = function(n) {
  var gLen = n.ranks.length;
  /** @type {number} */
  var str = 0;
  /** @type {number} */
  var g = 1;
  for (; g < gLen; g++) {
    str = str + this.calculateRankCrossing(g, n);
  }
  return str;
};
/**
 * @param {string} j
 * @param {number} i
 * @return {?}
 */
mxMedianHybridCrossingReduction.prototype.calculateRankCrossing = function(j, i) {
  /** @type {number} */
  var s_menu = 0;
  var d = i.ranks[j];
  var e = i.ranks[j - 1];
  /** @type {!Array} */
  var m = [];
  /** @type {number} */
  i = 0;
  for (; i < d.length; i++) {
    var row = d[i];
    var p = row.getGeneralPurposeVariable(j);
    row = row.getPreviousLayerConnectedCells(j);
    /** @type {!Array} */
    var result = [];
    /** @type {number} */
    var CR_index = 0;
    for (; CR_index < row.length; CR_index++) {
      var globalnewline = row[CR_index].getGeneralPurposeVariable(j - 1);
      result.push(globalnewline);
    }
    result.sort(function(p, _arc) {
      return p - _arc;
    });
    /** @type {!Array} */
    m[p] = result;
  }
  /** @type {!Array} */
  j = [];
  /** @type {number} */
  i = 0;
  for (; i < m.length; i++) {
    /** @type {!Array<?>} */
    j = j.concat(m[i]);
  }
  /** @type {number} */
  d = 1;
  for (; d < e.length;) {
    /** @type {number} */
    d = d << 1;
  }
  /** @type {number} */
  m = 2 * d - 1;
  --d;
  /** @type {!Array} */
  e = [];
  /** @type {number} */
  i = 0;
  for (; i < m; ++i) {
    /** @type {number} */
    e[i] = 0;
  }
  /** @type {number} */
  i = 0;
  for (; i < j.length; i++) {
    m = j[i] + d;
    ++e[m];
    for (; 0 < m;) {
      if (m % 2) {
        s_menu = s_menu + e[m + 1];
      }
      /** @type {number} */
      m = m - 1 >> 1;
      ++e[m];
    }
  }
  return s_menu;
};
/**
 * @param {number} array
 * @param {!Object} results
 * @return {undefined}
 */
mxMedianHybridCrossingReduction.prototype.transpose = function(array, results) {
  /** @type {boolean} */
  var c = true;
  /** @type {number} */
  var d = 0;
  for (; c && 10 > d++;) {
    /** @type {boolean} */
    var ie = 1 == array % 2 && 1 == d % 2;
    /** @type {boolean} */
    c = false;
    /** @type {number} */
    var i = 0;
    for (; i < results.ranks.length; i++) {
      var map = results.ranks[i];
      /** @type {!Array} */
      var buffer = [];
      /** @type {number} */
      var n = 0;
      for (; n < map.length; n++) {
        var s = map[n];
        var pos = s.getGeneralPurposeVariable(i);
        if (0 > pos) {
          /** @type {number} */
          pos = n;
        }
        buffer[pos] = s;
      }
      /** @type {null} */
      var h = null;
      /** @type {null} */
      var end = null;
      /** @type {null} */
      var a = null;
      /** @type {null} */
      var items = null;
      /** @type {null} */
      var t = null;
      /** @type {number} */
      n = 0;
      for (; n < map.length - 1; n++) {
        if (0 == n) {
          var x = buffer[n];
          s = x.getNextLayerConnectedCells(i);
          pos = x.getPreviousLayerConnectedCells(i);
          /** @type {!Array} */
          var b = [];
          /** @type {!Array} */
          var result = [];
          /** @type {number} */
          var j = 0;
          for (; j < s.length; j++) {
            b[j] = s[j].getGeneralPurposeVariable(i + 1);
          }
          /** @type {number} */
          j = 0;
          for (; j < pos.length; j++) {
            result[j] = pos[j].getGeneralPurposeVariable(i - 1);
          }
        } else {
          s = h;
          pos = end;
          /** @type {(Array|null)} */
          b = a;
          /** @type {(Array|null)} */
          result = items;
          x = t;
        }
        t = buffer[n + 1];
        h = t.getNextLayerConnectedCells(i);
        end = t.getPreviousLayerConnectedCells(i);
        /** @type {!Array} */
        a = [];
        /** @type {!Array} */
        items = [];
        /** @type {number} */
        j = 0;
        for (; j < h.length; j++) {
          a[j] = h[j].getGeneralPurposeVariable(i + 1);
        }
        /** @type {number} */
        j = 0;
        for (; j < end.length; j++) {
          items[j] = end[j].getGeneralPurposeVariable(i - 1);
        }
        /** @type {number} */
        var PRV_M = 0;
        /** @type {number} */
        var current_privilege_level = 0;
        /** @type {number} */
        j = 0;
        for (; j < b.length; j++) {
          /** @type {number} */
          var i = 0;
          for (; i < a.length; i++) {
            if (b[j] > a[i]) {
              PRV_M++;
            }
            if (b[j] < a[i]) {
              current_privilege_level++;
            }
          }
        }
        /** @type {number} */
        j = 0;
        for (; j < result.length; j++) {
          /** @type {number} */
          i = 0;
          for (; i < items.length; i++) {
            if (result[j] > items[i]) {
              PRV_M++;
            }
            if (result[j] < items[i]) {
              current_privilege_level++;
            }
          }
        }
        if (current_privilege_level < PRV_M || current_privilege_level == PRV_M && ie) {
          h = x.getGeneralPurposeVariable(i);
          x.setGeneralPurposeVariable(i, t.getGeneralPurposeVariable(i));
          t.setGeneralPurposeVariable(i, h);
          h = s;
          end = pos;
          /** @type {!Array} */
          a = b;
          /** @type {!Array} */
          items = result;
          t = x;
          if (!ie) {
            /** @type {boolean} */
            c = true;
          }
        }
      }
    }
  }
};
/**
 * @param {number} m
 * @param {!Object} value
 * @return {undefined}
 */
mxMedianHybridCrossingReduction.prototype.weightedMedian = function(m, value) {
  if (m = 0 == m % 2) {
    /** @type {number} */
    var i = value.maxRank - 1;
    for (; 0 <= i; i--) {
      this.medianRank(i, m);
    }
  } else {
    /** @type {number} */
    i = 1;
    for (; i < value.maxRank; i++) {
      this.medianRank(i, m);
    }
  }
};
/**
 * @param {number} b
 * @param {number} a
 * @return {undefined}
 */
mxMedianHybridCrossingReduction.prototype.medianRank = function(b, a) {
  var styleDefLen = this.nestedBestRanks[b].length;
  /** @type {!Array} */
  var results = [];
  /** @type {!Array} */
  var types = [];
  /** @type {number} */
  var t = 0;
  for (; t < styleDefLen; t++) {
    var i = this.nestedBestRanks[b][t];
    var v = new MedianCellSorter;
    v.cell = i;
    var k = a ? i.getNextLayerConnectedCells(b) : i.getPreviousLayerConnectedCells(b);
    var column = a ? b + 1 : b - 1;
    if (null != k && 0 != k.length) {
      v.medianValue = this.medianValue(k, column);
      results.push(v);
    } else {
      /** @type {boolean} */
      types[i.getGeneralPurposeVariable(b)] = true;
    }
  }
  results.sort(MedianCellSorter.prototype.compare);
  /** @type {number} */
  t = 0;
  for (; t < styleDefLen; t++) {
    if (null == types[t]) {
      i = results.shift().cell;
      i.setGeneralPurposeVariable(b, t);
    }
  }
};
/**
 * @param {number} k
 * @param {number} c
 * @return {?}
 */
mxMedianHybridCrossingReduction.prototype.medianValue = function(k, c) {
  /** @type {!Array} */
  var x = [];
  /** @type {number} */
  var i = 0;
  /** @type {number} */
  var j = 0;
  for (; j < k.length; j++) {
    var type = k[j];
    x[i++] = type.getGeneralPurposeVariable(c);
  }
  x.sort(function(lowestMaxZoom, k) {
    return lowestMaxZoom - k;
  });
  if (1 == i % 2) {
    return x[Math.floor(i / 2)];
  }
  if (2 == i) {
    return (x[0] + x[1]) / 2;
  }
  /** @type {number} */
  k = i / 2;
  /** @type {number} */
  c = x[k - 1] - x[0];
  /** @type {number} */
  i = x[i - 1] - x[k];
  return (x[k - 1] * i + x[k] * c) / (c + i);
};
/**
 * @return {undefined}
 */
function MedianCellSorter() {
}
/** @type {number} */
MedianCellSorter.prototype.medianValue = 0;
/** @type {boolean} */
MedianCellSorter.prototype.cell = false;
/**
 * @param {string} a
 * @param {?} b
 * @return {?}
 */
MedianCellSorter.prototype.compare = function(a, b) {
  return null != a && null != b ? b.medianValue > a.medianValue ? -1 : b.medianValue < a.medianValue ? 1 : 0 : 0;
};
/**
 * @param {!Object} layoutParam
 * @return {undefined}
 */
function mxMinimumCycleRemover(layoutParam) {
  /** @type {!Object} */
  this.layout = layoutParam;
}
mxMinimumCycleRemover.prototype = new mxHierarchicalLayoutStage;
/** @type {function(!Object): undefined} */
mxMinimumCycleRemover.prototype.constructor = mxMinimumCycleRemover;
/** @type {null} */
mxMinimumCycleRemover.prototype.layout = null;
/**
 * @param {!Object} handler
 * @return {undefined}
 */
mxMinimumCycleRemover.prototype.execute = function(handler) {
  handler = this.layout.getModel();
  var tmp = {};
  var options = handler.vertexMapper.getValues();
  var x = {};
  /** @type {number} */
  var i = 0;
  for (; i < options.length; i++) {
    x[options[i].id] = options[i];
  }
  /** @type {null} */
  options = null;
  if (null != handler.roots) {
    var args = handler.roots;
    /** @type {!Array} */
    options = [];
    /** @type {number} */
    i = 0;
    for (; i < args.length; i++) {
      options[i] = handler.vertexMapper.get(args[i]);
    }
  }
  handler.visit(function(node, item, result, canCreateDiscussions, n) {
    if (item.isAncestor(node)) {
      result.invert();
      mxUtils.remove(result, node.connectsAsSource);
      node.connectsAsTarget.push(result);
      mxUtils.remove(result, item.connectsAsTarget);
      item.connectsAsSource.push(result);
    }
    /** @type {!Node} */
    tmp[item.id] = item;
    delete x[item.id];
  }, options, true, null);
  i = mxUtils.clone(tmp, null, true);
  handler.visit(function(node, item, result, canCreateDiscussions, n) {
    if (item.isAncestor(node)) {
      result.invert();
      mxUtils.remove(result, node.connectsAsSource);
      item.connectsAsSource.push(result);
      node.connectsAsTarget.push(result);
      mxUtils.remove(result, item.connectsAsTarget);
    }
    /** @type {!Node} */
    tmp[item.id] = item;
    delete x[item.id];
  }, x, true, i);
};
/**
 * @param {!Object} layoutParam
 * @param {number} textStyleModel
 * @param {number} aMetadata
 * @param {string} aOrientation
 * @param {number} aPanel_height
 * @param {number} aInstance_id
 * @return {undefined}
 */
function mxCoordinateAssignment(layoutParam, textStyleModel, aMetadata, aOrientation, aPanel_height, aInstance_id) {
  /** @type {!Object} */
  this.layout = layoutParam;
  /** @type {number} */
  this.intraCellSpacing = textStyleModel;
  /** @type {number} */
  this.interRankCellSpacing = aMetadata;
  /** @type {string} */
  this.orientation = aOrientation;
  /** @type {number} */
  this.initialX = aPanel_height;
  /** @type {number} */
  this.parallelEdgeSpacing = aInstance_id;
}
mxCoordinateAssignment.prototype = new mxHierarchicalLayoutStage;
/** @type {function(!Object, number, number, string, number, number): undefined} */
mxCoordinateAssignment.prototype.constructor = mxCoordinateAssignment;
/** @type {null} */
mxCoordinateAssignment.prototype.layout = null;
/** @type {number} */
mxCoordinateAssignment.prototype.intraCellSpacing = 30;
/** @type {number} */
mxCoordinateAssignment.prototype.interRankCellSpacing = 100;
/** @type {number} */
mxCoordinateAssignment.prototype.parallelEdgeSpacing = 10;
/** @type {number} */
mxCoordinateAssignment.prototype.maxIterations = 8;
/** @type {number} */
mxCoordinateAssignment.prototype.prefHozEdgeSep = 5;
/** @type {number} */
mxCoordinateAssignment.prototype.prefVertEdgeOff = 2;
/** @type {number} */
mxCoordinateAssignment.prototype.minEdgeJetty = 12;
/** @type {number} */
mxCoordinateAssignment.prototype.channelBuffer = 4;
/** @type {null} */
mxCoordinateAssignment.prototype.jettyPositions = null;
/** @type {string} */
mxCoordinateAssignment.prototype.orientation = mxConstants.DIRECTION_NORTH;
/** @type {null} */
mxCoordinateAssignment.prototype.initialX = null;
/** @type {null} */
mxCoordinateAssignment.prototype.limitX = null;
/** @type {null} */
mxCoordinateAssignment.prototype.currentXDelta = null;
/** @type {null} */
mxCoordinateAssignment.prototype.widestRank = null;
/** @type {null} */
mxCoordinateAssignment.prototype.rankTopY = null;
/** @type {null} */
mxCoordinateAssignment.prototype.rankBottomY = null;
/** @type {null} */
mxCoordinateAssignment.prototype.widestRankValue = null;
/** @type {null} */
mxCoordinateAssignment.prototype.rankWidths = null;
/** @type {null} */
mxCoordinateAssignment.prototype.rankY = null;
/** @type {boolean} */
mxCoordinateAssignment.prototype.fineTuning = true;
/** @type {null} */
mxCoordinateAssignment.prototype.nextLayerConnectedCache = null;
/** @type {null} */
mxCoordinateAssignment.prototype.previousLayerConnectedCache = null;
/** @type {number} */
mxCoordinateAssignment.prototype.groupPadding = 10;
/**
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.printStatus = function() {
  var other = this.layout.getModel();
  mxLog.show();
  mxLog.writeln("======Coord assignment debug=======");
  /** @type {number} */
  var i = 0;
  for (; i < other.ranks.length; i++) {
    mxLog.write("Rank ", i, " : ");
    var month_name = other.ranks[i];
    /** @type {number} */
    var month_full_i = 0;
    for (; month_full_i < month_name.length; month_full_i++) {
      mxLog.write(month_name[month_full_i].getGeneralPurposeVariable(i), "  ");
    }
    mxLog.writeln();
  }
  mxLog.writeln("====================================");
};
/**
 * @param {!Object} n
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.execute = function(n) {
  this.jettyPositions = {};
  n = this.layout.getModel();
  /** @type {number} */
  this.currentXDelta = 0;
  this.initialCoords(this.layout.getGraph(), n);
  if (this.fineTuning) {
    this.minNode(n);
  }
  /** @type {number} */
  var b = 1E8;
  if (this.fineTuning) {
    /** @type {number} */
    var valueProgess = 0;
    for (; valueProgess < this.maxIterations; valueProgess++) {
      if (0 != valueProgess) {
        this.medianPos(valueProgess, n);
        this.minNode(n);
      }
      if (this.currentXDelta < b) {
        /** @type {number} */
        var j = 0;
        for (; j < n.ranks.length; j++) {
          var q = n.ranks[j];
          /** @type {number} */
          var i = 0;
          for (; i < q.length; i++) {
            var view = q[i];
            view.setX(j, view.getGeneralPurposeVariable(j));
          }
        }
        /** @type {number} */
        b = this.currentXDelta;
      } else {
        /** @type {number} */
        j = 0;
        for (; j < n.ranks.length; j++) {
          q = n.ranks[j];
          /** @type {number} */
          i = 0;
          for (; i < q.length; i++) {
            view = q[i];
            view.setGeneralPurposeVariable(j, view.getX(j));
          }
        }
      }
      this.minPath(this.layout.getGraph(), n);
      /** @type {number} */
      this.currentXDelta = 0;
    }
  }
  this.setCellLocations(this.layout.getGraph(), n);
};
/**
 * @param {string} n
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.minNode = function(n) {
  /** @type {!Array} */
  var removeHandles = [];
  var row = new mxDictionary;
  /** @type {!Array} */
  var data = [];
  /** @type {number} */
  var i = 0;
  for (; i <= n.maxRank; i++) {
    data[i] = n.ranks[i];
    /** @type {number} */
    var j = 0;
    for (; j < data[i].length; j++) {
      var p = data[i][j];
      var c = new WeightedCellSorter(p, i);
      /** @type {number} */
      c.rankIndex = j;
      /** @type {boolean} */
      c.visited = true;
      removeHandles.push(c);
      row.put(p, c);
    }
  }
  /** @type {number} */
  n = 10 * removeHandles.length;
  /** @type {number} */
  j = 0;
  for (; 0 < removeHandles.length && j <= n;) {
    p = removeHandles.shift();
    i = p.cell;
    var n = p.weightedValue;
    /** @type {number} */
    var x = parseInt(p.rankIndex);
    c = i.getNextLayerConnectedCells(n);
    var v = i.getPreviousLayerConnectedCells(n);
    var s = c.length;
    var y = v.length;
    var r = this.medianXValue(c, n + 1);
    var g = this.medianXValue(v, n - 1);
    var dy = s + y;
    var b = i.getGeneralPurposeVariable(n);
    var a = b;
    if (0 < dy) {
      /** @type {number} */
      a = (r * s + g * y) / dy;
    }
    /** @type {boolean} */
    s = false;
    if (a < b - 1) {
      if (0 == x) {
        i.setGeneralPurposeVariable(n, a);
        /** @type {boolean} */
        s = true;
      } else {
        x = data[n][x - 1];
        b = x.getGeneralPurposeVariable(n);
        b = b + x.width / 2 + this.intraCellSpacing + i.width / 2;
        if (b < a) {
          i.setGeneralPurposeVariable(n, a);
          /** @type {boolean} */
          s = true;
        } else {
          if (b < i.getGeneralPurposeVariable(n) - 1) {
            i.setGeneralPurposeVariable(n, b);
            /** @type {boolean} */
            s = true;
          }
        }
      }
    } else {
      if (a > b + 1) {
        if (x == data[n].length - 1) {
          i.setGeneralPurposeVariable(n, a);
          /** @type {boolean} */
          s = true;
        } else {
          x = data[n][x + 1];
          b = x.getGeneralPurposeVariable(n);
          /** @type {number} */
          b = b - x.width / 2 - this.intraCellSpacing - i.width / 2;
          if (b > a) {
            i.setGeneralPurposeVariable(n, a);
            /** @type {boolean} */
            s = true;
          } else {
            if (b > i.getGeneralPurposeVariable(n) + 1) {
              i.setGeneralPurposeVariable(n, b);
              /** @type {boolean} */
              s = true;
            }
          }
        }
      }
    }
    if (s) {
      /** @type {number} */
      i = 0;
      for (; i < c.length; i++) {
        n = c[i];
        n = row.get(n);
        if (null != n && 0 == n.visited) {
          /** @type {boolean} */
          n.visited = true;
          removeHandles.push(n);
        }
      }
      /** @type {number} */
      i = 0;
      for (; i < v.length; i++) {
        n = v[i];
        n = row.get(n);
        if (null != n && 0 == n.visited) {
          /** @type {boolean} */
          n.visited = true;
          removeHandles.push(n);
        }
      }
    }
    /** @type {boolean} */
    p.visited = false;
    j++;
  }
};
/**
 * @param {number} a
 * @param {?} value
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.medianPos = function(a, value) {
  if (0 == a % 2) {
    a = value.maxRank;
    for (; 0 < a; a--) {
      this.rankMedianPosition(a - 1, value, a);
    }
  } else {
    /** @type {number} */
    a = 0;
    for (; a < value.maxRank - 1; a++) {
      this.rankMedianPosition(a + 1, value, a);
    }
  }
};
/**
 * @param {number} i
 * @param {!Array} c
 * @param {number} n
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.rankMedianPosition = function(i, c, n) {
  c = c.ranks[i];
  /** @type {!Array} */
  var children = [];
  var queue = {};
  /** @type {number} */
  var j = 0;
  for (; j < c.length; j++) {
    var cell = c[j];
    children[j] = new WeightedCellSorter;
    children[j].cell = cell;
    /** @type {number} */
    children[j].rankIndex = j;
    queue[cell.id] = children[j];
    var end = n < i ? cell.getPreviousLayerConnectedCells(i) : cell.getNextLayerConnectedCells(i);
    children[j].weightedValue = this.calculatedWeightedValue(cell, end);
  }
  children.sort(WeightedCellSorter.prototype.compare);
  /** @type {number} */
  j = 0;
  for (; j < children.length; j++) {
    cell = children[j].cell;
    /** @type {number} */
    var value = 0;
    end = n < i ? cell.getPreviousLayerConnectedCells(i).slice() : cell.getNextLayerConnectedCells(i).slice();
    if (null != end) {
      value = end.length;
      value = 0 < value ? this.medianXValue(end, n) : cell.getGeneralPurposeVariable(i);
    }
    /** @type {number} */
    var ret = 0;
    /** @type {number} */
    end = -1E8;
    /** @type {number} */
    var index = children[j].rankIndex - 1;
    for (; 0 <= index;) {
      var data = queue[c[index].id];
      if (null != data) {
        var start = data.cell;
        if (data.visited) {
          end = start.getGeneralPurposeVariable(i) + start.width / 2 + this.intraCellSpacing + ret + cell.width / 2;
          /** @type {number} */
          index = -1;
        } else {
          ret = ret + (start.width + this.intraCellSpacing);
          index--;
        }
      }
    }
    /** @type {number} */
    ret = 0;
    /** @type {number} */
    start = 1E8;
    index = children[j].rankIndex + 1;
    for (; index < children.length;) {
      if (data = queue[c[index].id], null != data) {
        var content = data.cell;
        if (data.visited) {
          /** @type {number} */
          start = content.getGeneralPurposeVariable(i) - content.width / 2 - this.intraCellSpacing - ret - cell.width / 2;
          /** @type {number} */
          index = children.length;
        } else {
          ret = ret + (content.width + this.intraCellSpacing);
          index++;
        }
      }
    }
    if (value >= end && value <= start) {
      cell.setGeneralPurposeVariable(i, value);
    } else {
      if (value < end) {
        cell.setGeneralPurposeVariable(i, end);
        this.currentXDelta += end - value;
      } else {
        if (value > start) {
          cell.setGeneralPurposeVariable(i, start);
          this.currentXDelta += value - start;
        }
      }
    }
    /** @type {boolean} */
    children[j].visited = true;
  }
};
/**
 * @param {?} model
 * @param {!NodeList} value
 * @return {?}
 */
mxCoordinateAssignment.prototype.calculatedWeightedValue = function(model, value) {
  /** @type {number} */
  var c = 0;
  /** @type {number} */
  var idx = 0;
  for (; idx < value.length; idx++) {
    var V = value[idx];
    if (model.isVertex() && V.isVertex()) {
      c++;
    } else {
      /** @type {number} */
      c = model.isEdge() && V.isEdge() ? c + 8 : c + 2;
    }
  }
  return c;
};
/**
 * @param {number} x
 * @param {number} fn
 * @return {?}
 */
mxCoordinateAssignment.prototype.medianXValue = function(x, fn) {
  if (0 == x.length) {
    return 0;
  }
  /** @type {!Array} */
  var result = [];
  /** @type {number} */
  var i = 0;
  for (; i < x.length; i++) {
    result[i] = x[i].getGeneralPurposeVariable(fn);
  }
  result.sort(function(n, deletedCount) {
    return n - deletedCount;
  });
  if (1 == x.length % 2) {
    return result[Math.floor(x.length / 2)];
  }
  /** @type {number} */
  x = x.length / 2;
  return (result[x - 1] + result[x]) / 2;
};
/**
 * @param {undefined} n
 * @param {boolean} value
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.initialCoords = function(n, value) {
  this.calculateWidestRank(n, value);
  var j = this.widestRank;
  for (; 0 <= j; j--) {
    if (j < value.maxRank) {
      this.rankCoordinates(j, n, value);
    }
  }
  j = this.widestRank + 1;
  for (; j <= value.maxRank; j++) {
    if (0 < j) {
      this.rankCoordinates(j, n, value);
    }
  }
};
/**
 * @param {undefined} i
 * @param {number} s
 * @param {number} n
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.rankCoordinates = function(i, s, n) {
  s = n.ranks[i];
  n = this.initialX + (this.widestRankValue - this.rankWidths[i]) / 2;
  /** @type {boolean} */
  var d = false;
  /** @type {number} */
  var j = 0;
  for (; j < s.length; j++) {
    var v = s[j];
    if (v.isVertex()) {
      var c = this.layout.getVertexBounds(v.cell);
      if (null != c) {
        if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
          v.width = c.width;
          v.height = c.height;
        } else {
          v.width = c.height;
          v.height = c.width;
        }
      } else {
        /** @type {boolean} */
        d = true;
      }
    } else {
      if (v.isEdge()) {
        /** @type {number} */
        c = 1;
        if (null != v.edges) {
          c = v.edges.length;
        } else {
          mxLog.warn("edge.edges is null");
        }
        /** @type {number} */
        v.width = (c - 1) * this.parallelEdgeSpacing;
      }
    }
    n = n + v.width / 2;
    v.setX(i, n);
    v.setGeneralPurposeVariable(i, n);
    n = n + v.width / 2;
    n = n + this.intraCellSpacing;
  }
  if (1 == d) {
    mxLog.warn("At least one cell has no bounds");
  }
};
/**
 * @param {number} y
 * @param {boolean} value
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.calculateWidestRank = function(y, value) {
  /** @type {number} */
  y = -this.interRankCellSpacing;
  /** @type {number} */
  var height = 0;
  /** @type {!Array} */
  this.rankWidths = [];
  /** @type {!Array} */
  this.rankY = [];
  var j = value.maxRank;
  for (; 0 <= j; j--) {
    /** @type {number} */
    var width = 0;
    var children = value.ranks[j];
    var i = this.initialX;
    /** @type {boolean} */
    var k = false;
    /** @type {number} */
    var childIndex = 0;
    for (; childIndex < children.length; childIndex++) {
      var node = children[childIndex];
      if (node.isVertex()) {
        var n = this.layout.getVertexBounds(node.cell);
        if (null != n) {
          if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
            node.width = n.width;
            node.height = n.height;
          } else {
            node.width = n.height;
            node.height = n.width;
          }
        } else {
          /** @type {boolean} */
          k = true;
        }
        /** @type {number} */
        width = Math.max(width, node.height);
      } else {
        if (node.isEdge()) {
          /** @type {number} */
          n = 1;
          if (null != node.edges) {
            n = node.edges.length;
          } else {
            mxLog.warn("edge.edges is null");
          }
          /** @type {number} */
          node.width = (n - 1) * this.parallelEdgeSpacing;
        }
      }
      i = i + node.width / 2;
      node.setX(j, i);
      node.setGeneralPurposeVariable(j, i);
      i = i + node.width / 2;
      i = i + this.intraCellSpacing;
      if (i > this.widestRankValue) {
        this.widestRankValue = i;
        this.widestRank = j;
      }
      this.rankWidths[j] = i;
    }
    if (1 == k) {
      mxLog.warn("At least one cell has no bounds");
    }
    /** @type {number} */
    this.rankY[j] = y;
    i = width / 2 + height / 2 + this.interRankCellSpacing;
    /** @type {number} */
    height = width;
    y = this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_WEST ? y + i : y - i;
    /** @type {number} */
    childIndex = 0;
    for (; childIndex < children.length; childIndex++) {
      children[childIndex].setY(j, y);
    }
  }
};
/**
 * @param {number} result
 * @param {!Object} r
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.minPath = function(result, r) {
  result = r.edgeMapper.getValues();
  /** @type {number} */
  var i = 0;
  for (; i < result.length; i++) {
    var node = result[i];
    if (!(1 > node.maxRank - node.minRank - 1)) {
      var dy = node.getGeneralPurposeVariable(node.minRank + 1);
      /** @type {boolean} */
      var dx = true;
      /** @type {number} */
      var maximumDiff = 0;
      var i = node.minRank + 2;
      for (; i < node.maxRank; i++) {
        var top = node.getGeneralPurposeVariable(i);
        if (dy != top) {
          /** @type {boolean} */
          dx = false;
          dy = top;
        } else {
          maximumDiff++;
        }
      }
      if (!dx) {
        /** @type {number} */
        dx = dy = 0;
        /** @type {!Array} */
        top = [];
        /** @type {!Array} */
        var align = [];
        var v = node.getGeneralPurposeVariable(node.minRank + 1);
        i = node.minRank + 1;
        for (; i < node.maxRank - 1; i++) {
          var value = node.getX(i + 1);
          if (v == value) {
            top[i - node.minRank - 1] = v;
            dy++;
          } else {
            if (this.repositionValid(r, node, i + 1, v)) {
              top[i - node.minRank - 1] = v;
              dy++;
            } else {
              v = top[i - node.minRank - 1] = value;
            }
          }
        }
        v = node.getX(i);
        /** @type {number} */
        i = node.maxRank - 1;
        for (; i > node.minRank + 1; i--) {
          value = node.getX(i - 1);
          if (v == value) {
            align[i - node.minRank - 2] = v;
            dx++;
          } else {
            if (this.repositionValid(r, node, i - 1, v)) {
              align[i - node.minRank - 2] = v;
              dx++;
            } else {
              align[i - node.minRank - 2] = node.getX(i - 1);
              v = value;
            }
          }
        }
        if (dx > maximumDiff || dy > maximumDiff) {
          if (dx >= dy) {
            /** @type {number} */
            i = node.maxRank - 2;
            for (; i > node.minRank; i--) {
              node.setX(i, align[i - node.minRank - 1]);
            }
          } else {
            if (dy > dx) {
              i = node.minRank + 2;
              for (; i < node.maxRank; i++) {
                node.setX(i, top[i - node.minRank - 2]);
              }
            }
          }
        }
      }
    }
  }
};
/**
 * @param {!Object} n
 * @param {!Object} e
 * @param {number} x
 * @param {number} min
 * @return {?}
 */
mxCoordinateAssignment.prototype.repositionValid = function(n, e, x, min) {
  n = n.ranks[x];
  /** @type {number} */
  var l = -1;
  /** @type {number} */
  var i = 0;
  for (; i < n.length; i++) {
    if (e == n[i]) {
      /** @type {number} */
      l = i;
      break;
    }
  }
  if (0 > l) {
    return false;
  }
  i = e.getGeneralPurposeVariable(x);
  if (min < i) {
    if (0 == l) {
      return true;
    }
    n = n[l - 1];
    x = n.getGeneralPurposeVariable(x);
    x = x + n.width / 2 + this.intraCellSpacing + e.width / 2;
    if (!(x <= min)) {
      return false;
    }
  } else {
    if (min > i) {
      if (l == n.length - 1) {
        return true;
      }
      n = n[l + 1];
      x = n.getGeneralPurposeVariable(x);
      /** @type {number} */
      x = x - n.width / 2 - this.intraCellSpacing - e.width / 2;
      if (!(x >= min)) {
        return false;
      }
    }
  }
  return true;
};
/**
 * @param {number} i
 * @param {!Object} self
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.setCellLocations = function(i, self) {
  /** @type {!Array} */
  this.rankTopY = [];
  /** @type {!Array} */
  this.rankBottomY = [];
  /** @type {number} */
  i = 0;
  for (; i < self.ranks.length; i++) {
    /** @type {number} */
    this.rankTopY[i] = Number.MAX_VALUE;
    /** @type {number} */
    this.rankBottomY[i] = -Number.MAX_VALUE;
  }
  var keywordResults = self.vertexMapper.getValues();
  /** @type {number} */
  i = 0;
  for (; i < keywordResults.length; i++) {
    this.setVertexLocation(keywordResults[i]);
  }
  if (!(this.layout.edgeStyle != mxHierarchicalEdgeStyle.ORTHOGONAL && this.layout.edgeStyle != mxHierarchicalEdgeStyle.POLYLINE && this.layout.edgeStyle != mxHierarchicalEdgeStyle.CURVE)) {
    this.localEdgeProcessing(self);
  }
  self = self.edgeMapper.getValues();
  /** @type {number} */
  i = 0;
  for (; i < self.length; i++) {
    this.setEdgePosition(self[i]);
  }
};
/**
 * @param {!Object} other
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.localEdgeProcessing = function(other) {
  /** @type {number} */
  var i = 0;
  for (; i < other.ranks.length; i++) {
    var track = other.ranks[i];
    /** @type {number} */
    var j = 0;
    for (; j < track.length; j++) {
      var segment = track[j];
      if (segment.isVertex()) {
        var count = segment.getPreviousLayerConnectedCells(i);
        /** @type {number} */
        var index = i - 1;
        /** @type {number} */
        var connected_anchor_id = 0;
        for (; 2 > connected_anchor_id; connected_anchor_id++) {
          if (-1 < index && index < other.ranks.length && null != count && 0 < count.length) {
            /** @type {!Array} */
            var r = [];
            /** @type {number} */
            var i = 0;
            for (; i < count.length; i++) {
              var y = new WeightedCellSorter(count[i], count[i].getX(index));
              r.push(y);
            }
            r.sort(WeightedCellSorter.prototype.compare);
            /** @type {number} */
            y = segment.x[0] - segment.width / 2;
            var height = y + segment.width;
            /** @type {number} */
            var tableslen = count = 0;
            /** @type {!Array} */
            index = [];
            /** @type {number} */
            i = 0;
            for (; i < r.length; i++) {
              var obj = r[i].cell;
              if (obj.isVertex()) {
                var values = 0 == connected_anchor_id ? segment.connectsAsSource : segment.connectsAsTarget;
                /** @type {number} */
                var i = 0;
                for (; i < values.length; i++) {
                  if (values[i].source == obj || values[i].target == obj) {
                    count = count + values[i].edges.length;
                    tableslen++;
                    index.push(values[i]);
                  }
                }
              } else {
                count = count + obj.edges.length;
                tableslen++;
                index.push(obj);
              }
            }
            if (segment.width > (count + 1) * this.prefHozEdgeSep + 2 * this.prefHozEdgeSep) {
              y = y + this.prefHozEdgeSep;
              /** @type {number} */
              height = height - this.prefHozEdgeSep;
            }
            /** @type {number} */
            r = (height - y) / count;
            y = y + r / 2;
            /** @type {number} */
            height = this.minEdgeJetty - this.prefVertEdgeOff;
            /** @type {number} */
            i = 0;
            for (; i < index.length; i++) {
              tableslen = index[i].edges.length;
              obj = this.jettyPositions[index[i].ids[0]];
              if (null == obj) {
                /** @type {!Array} */
                obj = [];
                /** @type {!Array} */
                this.jettyPositions[index[i].ids[0]] = obj;
              }
              if (i < count / 2) {
                height = height + this.prefVertEdgeOff;
              } else {
                if (i > count / 2) {
                  /** @type {number} */
                  height = height - this.prefVertEdgeOff;
                }
              }
              /** @type {number} */
              values = 0;
              for (; values < tableslen; values++) {
                obj[4 * values + 2 * connected_anchor_id] = y;
                y = y + r;
                /** @type {number} */
                obj[4 * values + 2 * connected_anchor_id + 1] = height;
              }
            }
          }
          count = segment.getNextLayerConnectedCells(i);
          /** @type {number} */
          index = i + 1;
        }
      }
    }
  }
};
/**
 * @param {!Object} node
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.setEdgePosition = function(node) {
  /** @type {number} */
  var _ = 0;
  if (101207 != node.temp[0]) {
    var key = node.maxRank;
    var rank = node.minRank;
    if (key == rank) {
      key = node.source.maxRank;
      rank = node.target.minRank;
    }
    /** @type {number} */
    var UPDATE_BATCH = 0;
    var args = this.jettyPositions[node.ids[0]];
    var teeWalletId = node.isReversed ? node.target.cell : node.source.cell;
    var options = this.layout.graph;
    /** @type {boolean} */
    var cache = this.orientation == mxConstants.DIRECTION_EAST || this.orientation == mxConstants.DIRECTION_SOUTH;
    /** @type {number} */
    var index = 0;
    for (; index < node.edges.length; index++) {
      var text = node.edges[index];
      var result = this.layout.getVisibleTerminal(text, true);
      /** @type {!Array} */
      var points = [];
      var s = node.isReversed;
      if (result != teeWalletId) {
        /** @type {boolean} */
        s = !s;
      }
      if (null != args) {
        /** @type {number} */
        var i = s ? 2 : 0;
        var y = s ? cache ? this.rankBottomY[rank] : this.rankTopY[rank] : cache ? this.rankTopY[key] : this.rankBottomY[key];
        var size = args[4 * UPDATE_BATCH + 1 + i];
        if (s != cache) {
          /** @type {number} */
          size = -size;
        }
        y = y + size;
        i = args[4 * UPDATE_BATCH + i];
        var item = options.model.getTerminal(text, true);
        if (this.layout.isPort(item) && options.model.getParent(item) == result) {
          i = options.view.getState(item);
          i = null != i ? i.x : result.geometry.x + node.source.width * item.geometry.x;
        }
        if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
          points.push(new mxPoint(i, y));
          if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
            points.push(new mxPoint(i, y + size));
          }
        } else {
          points.push(new mxPoint(y, i));
          if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
            points.push(new mxPoint(y + size, i));
          }
        }
      }
      /** @type {number} */
      i = node.x.length - 1;
      /** @type {number} */
      y = size = -1;
      /** @type {number} */
      result = node.maxRank - 1;
      if (s) {
        /** @type {number} */
        i = 0;
        size = node.x.length;
        /** @type {number} */
        y = 1;
        result = node.minRank + 1;
      }
      for (; node.maxRank != node.minRank && i != size; i = i + y) {
        item = node.x[i] + _;
        /** @type {number} */
        var x = (this.rankTopY[result] + this.rankBottomY[result + 1]) / 2;
        /** @type {number} */
        var width = (this.rankTopY[result - 1] + this.rankBottomY[result]) / 2;
        if (s) {
          /** @type {number} */
          var draggableAxis = x;
          /** @type {number} */
          x = width;
          /** @type {number} */
          width = draggableAxis;
        }
        if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
          points.push(new mxPoint(item, x));
          points.push(new mxPoint(item, width));
        } else {
          points.push(new mxPoint(x, item));
          points.push(new mxPoint(width, item));
        }
        /** @type {number} */
        this.limitX = Math.max(this.limitX, item);
        result = result + y;
      }
      if (null != args) {
        /** @type {number} */
        i = s ? 2 : 0;
        y = s ? cache ? this.rankTopY[key] : this.rankBottomY[key] : cache ? this.rankBottomY[rank] : this.rankTopY[rank];
        size = args[4 * UPDATE_BATCH + 3 - i];
        if (s != cache) {
          /** @type {number} */
          size = -size;
        }
        /** @type {number} */
        y = y - size;
        i = args[4 * UPDATE_BATCH + 2 - i];
        s = options.model.getTerminal(text, false);
        result = this.layout.getVisibleTerminal(text, false);
        if (this.layout.isPort(s) && options.model.getParent(s) == result) {
          i = options.view.getState(s);
          i = null != i ? i.x : result.geometry.x + node.target.width * s.geometry.x;
        }
        if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
          if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
            points.push(new mxPoint(i, y - size));
          }
          points.push(new mxPoint(i, y));
        } else {
          if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
            points.push(new mxPoint(y - size, i));
          }
          points.push(new mxPoint(y, i));
        }
      }
      if (node.isReversed) {
        this.processReversedEdge(node, text);
      }
      this.layout.setEdgePoints(text, points);
      _ = 0 == _ ? this.parallelEdgeSpacing : 0 < _ ? -_ : -_ + this.parallelEdgeSpacing;
      UPDATE_BATCH++;
    }
    /** @type {number} */
    node.temp[0] = 101207;
  }
};
/**
 * @param {!Object} o
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.setVertexLocation = function(o) {
  var content = o.cell;
  /** @type {number} */
  var y = o.x[0] - o.width / 2;
  /** @type {number} */
  var top = o.y[0] - o.height / 2;
  /** @type {number} */
  this.rankTopY[o.minRank] = Math.min(this.rankTopY[o.minRank], top);
  /** @type {number} */
  this.rankBottomY[o.minRank] = Math.max(this.rankBottomY[o.minRank], top + o.height);
  if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
    this.layout.setVertexLocation(content, y, top);
  } else {
    this.layout.setVertexLocation(content, top, y);
  }
  /** @type {number} */
  this.limitX = Math.max(this.limitX, y + o.width);
};
/**
 * @param {!Object} fragment
 * @param {?} template
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.processReversedEdge = function(fragment, template) {
};
/**
 * @param {!Object} layoutParam
 * @return {undefined}
 */
function mxSwimlaneOrdering(layoutParam) {
  /** @type {!Object} */
  this.layout = layoutParam;
}
mxSwimlaneOrdering.prototype = new mxHierarchicalLayoutStage;
/** @type {function(!Object): undefined} */
mxSwimlaneOrdering.prototype.constructor = mxSwimlaneOrdering;
/** @type {null} */
mxSwimlaneOrdering.prototype.layout = null;
/**
 * @param {!Object} node
 * @return {undefined}
 */
mxSwimlaneOrdering.prototype.execute = function(node) {
  node = this.layout.getModel();
  var topdict = mxUtils.clone(node.vertexMapper, null, true);
  /** @type {null} */
  var path = null;
  if (null != node.roots) {
    var childrenIds = node.roots;
    /** @type {!Array} */
    path = [];
    /** @type {number} */
    var i = 0;
    for (; i < childrenIds.length; i++) {
      path[i] = node.vertexMapper.get(childrenIds[i]);
    }
  }
  node.visit(function(p, c, e, canCreateDiscussions, isSlidingUp) {
    canCreateDiscussions = null != p && p.swimlaneIndex == c.swimlaneIndex && c.isAncestor(p);
    /** @type {boolean} */
    isSlidingUp = null != p && null != e && p.swimlaneIndex < c.swimlaneIndex && e.source == c;
    if (canCreateDiscussions) {
      e.invert();
      mxUtils.remove(e, p.connectsAsSource);
      c.connectsAsSource.push(e);
      p.connectsAsTarget.push(e);
      mxUtils.remove(e, c.connectsAsTarget);
    } else {
      if (isSlidingUp) {
        e.invert();
        mxUtils.remove(e, p.connectsAsTarget);
        c.connectsAsTarget.push(e);
        p.connectsAsSource.push(e);
        mxUtils.remove(e, c.connectsAsSource);
      }
    }
    p = mxCellPath.create(c.cell);
    delete topdict[p];
  }, path, true, null);
};
/**
 * @param {?} game
 * @param {string} orientation
 * @param {?} min
 * @return {undefined}
 */
function mxHierarchicalLayout(game, orientation, min) {
  mxGraphLayout.call(this, game);
  this.orientation = null != orientation ? orientation : mxConstants.DIRECTION_NORTH;
  this.deterministic = null != min ? min : true;
}
var mxHierarchicalEdgeStyle = {
  ORTHOGONAL : 1,
  POLYLINE : 2,
  STRAIGHT : 3,
  CURVE : 4
};
mxHierarchicalLayout.prototype = new mxGraphLayout;
/** @type {function(?, string, ?): undefined} */
mxHierarchicalLayout.prototype.constructor = mxHierarchicalLayout;
/** @type {null} */
mxHierarchicalLayout.prototype.roots = null;
/** @type {boolean} */
mxHierarchicalLayout.prototype.resizeParent = false;
/** @type {boolean} */
mxHierarchicalLayout.prototype.maintainParentLocation = false;
/** @type {boolean} */
mxHierarchicalLayout.prototype.moveParent = false;
/** @type {number} */
mxHierarchicalLayout.prototype.parentBorder = 0;
/** @type {number} */
mxHierarchicalLayout.prototype.intraCellSpacing = 30;
/** @type {number} */
mxHierarchicalLayout.prototype.interRankCellSpacing = 100;
/** @type {number} */
mxHierarchicalLayout.prototype.interHierarchySpacing = 60;
/** @type {number} */
mxHierarchicalLayout.prototype.parallelEdgeSpacing = 10;
/** @type {string} */
mxHierarchicalLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;
/** @type {boolean} */
mxHierarchicalLayout.prototype.fineTuning = true;
/** @type {boolean} */
mxHierarchicalLayout.prototype.tightenToSource = true;
/** @type {boolean} */
mxHierarchicalLayout.prototype.disableEdgeStyle = true;
/** @type {boolean} */
mxHierarchicalLayout.prototype.traverseAncestors = true;
/** @type {null} */
mxHierarchicalLayout.prototype.model = null;
/** @type {null} */
mxHierarchicalLayout.prototype.edgesCache = null;
/** @type {null} */
mxHierarchicalLayout.prototype.edgeSourceTermCache = null;
/** @type {null} */
mxHierarchicalLayout.prototype.edgesTargetTermCache = null;
/** @type {number} */
mxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;
/**
 * @return {?}
 */
mxHierarchicalLayout.prototype.getModel = function() {
  return this.model;
};
/**
 * @param {string} element
 * @param {!Object} args
 * @return {undefined}
 */
mxHierarchicalLayout.prototype.execute = function(element, args) {
  /** @type {string} */
  this.parent = element;
  var model = this.graph.model;
  this.edgesCache = new mxDictionary;
  this.edgeSourceTermCache = new mxDictionary;
  this.edgesTargetTermCache = new mxDictionary;
  if (!(null == args || args instanceof Array)) {
    /** @type {!Array} */
    args = [args];
  }
  if (null != args || null != element) {
    /** @type {null} */
    this.parentY = this.parentX = null;
    if (element != this.root && null != model.isVertex(element) && this.maintainParentLocation) {
      var res = this.graph.getCellGeometry(element);
      if (null != res) {
        this.parentX = res.x;
        this.parentY = res.y;
      }
    }
    if (null != args) {
      /** @type {!Array} */
      var command_line_args = [];
      /** @type {number} */
      var i = 0;
      for (; i < args.length; i++) {
        if ((null != element ? model.isAncestor(element, args[i]) : 1) && model.isVertex(args[i])) {
          command_line_args.push(args[i]);
        }
      }
      /** @type {!Array} */
      this.roots = command_line_args;
    }
    model.beginUpdate();
    try {
      this.run(element);
      if (this.resizeParent && !this.graph.isCellCollapsed(element)) {
        this.graph.updateGroupBounds([element], this.parentBorder, this.moveParent);
      }
      if (null != this.parentX && null != this.parentY) {
        res = this.graph.getCellGeometry(element);
        if (null != res) {
          res = res.clone();
          res.x = this.parentX;
          res.y = this.parentY;
          model.setGeometry(element, res);
        }
      }
    } finally {
      model.endUpdate();
    }
  }
};
/**
 * @param {string} a
 * @param {?} b
 * @return {?}
 */
mxHierarchicalLayout.prototype.findRoots = function(a, b) {
  /** @type {!Array} */
  var res = [];
  if (null != a && null != b) {
    a = this.graph.model;
    /** @type {null} */
    var d = null;
    /** @type {number} */
    var tempHighScore = -1E5;
    var prop;
    for (prop in b) {
      var value = b[prop];
      if (a.isVertex(value) && this.graph.isCellVisible(value)) {
        var s = this.getEdges(value);
        /** @type {number} */
        var b = 0;
        /** @type {number} */
        var c = 0;
        /** @type {number} */
        var i = 0;
        for (; i < s.length; i++) {
          if (this.getVisibleTerminal(s[i], true) == value) {
            b++;
          } else {
            c++;
          }
        }
        if (0 == c && 0 < b) {
          res.push(value);
        }
        /** @type {number} */
        s = b - c;
        if (s > tempHighScore) {
          /** @type {number} */
          tempHighScore = s;
          d = value;
        }
      }
    }
    if (0 == res.length && null != d) {
      res.push(d);
    }
  }
  return res;
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxHierarchicalLayout.prototype.getEdges = function(node) {
  var options = this.edgesCache.get(node);
  if (null != options) {
    return options;
  }
  var model = this.graph.model;
  /** @type {!Array} */
  options = [];
  var target = this.graph.isCellCollapsed(node);
  var n = model.getChildCount(node);
  /** @type {number} */
  var i = 0;
  for (; i < n; i++) {
    var a = model.getChildAt(node, i);
    if (this.isPort(a)) {
      /** @type {!Array<?>} */
      options = options.concat(model.getEdges(a, true, true));
    } else {
      if (target || !this.graph.isCellVisible(a)) {
        /** @type {!Array<?>} */
        options = options.concat(model.getEdges(a, true, true));
      }
    }
  }
  /** @type {!Array<?>} */
  options = options.concat(model.getEdges(node, true, true));
  /** @type {!Array} */
  model = [];
  /** @type {number} */
  i = 0;
  for (; i < options.length; i++) {
    target = this.getVisibleTerminal(options[i], true);
    n = this.getVisibleTerminal(options[i], false);
    if (target == n || target != n && (n == node && (null == this.parent || this.isAncestor(this.parent, target, this.traverseAncestors)) || target == node && (null == this.parent || this.isAncestor(this.parent, n, this.traverseAncestors)))) {
      model.push(options[i]);
    }
  }
  this.edgesCache.put(node, model);
  return model;
};
/**
 * @param {string} s
 * @param {boolean} b
 * @return {?}
 */
mxHierarchicalLayout.prototype.getVisibleTerminal = function(s, b) {
  var c = this.edgesTargetTermCache;
  if (b) {
    c = this.edgeSourceTermCache;
  }
  var e = c.get(s);
  if (null != e) {
    return e;
  }
  e = this.graph.view.getState(s);
  var d = null != e ? e.getVisibleTerminal(b) : this.graph.view.getVisibleTerminal(s, b);
  if (null == d) {
    d = null != e ? e.getVisibleTerminal(b) : this.graph.view.getVisibleTerminal(s, b);
  }
  if (null != d) {
    if (this.isPort(d)) {
      d = this.graph.model.getParent(d);
    }
    c.put(s, d);
  }
  return d;
};
/**
 * @param {string} data
 * @return {undefined}
 */
mxHierarchicalLayout.prototype.run = function(data) {
  /** @type {!Array} */
  var p = [];
  /** @type {!Array} */
  var v = [];
  if (null == this.roots && null != data) {
    var value = {};
    this.filterDescendants(data, value);
    /** @type {!Array} */
    this.roots = [];
    /** @type {boolean} */
    var i = true;
    var prop;
    for (prop in value) {
      if (null != value[prop]) {
        /** @type {boolean} */
        i = false;
        break;
      }
    }
    for (; !i;) {
      var object = this.findRoots(data, value);
      /** @type {number} */
      i = 0;
      for (; i < object.length; i++) {
        var n = {};
        p.push(n);
        this.traverse(object[i], true, null, v, n, p, value);
      }
      /** @type {number} */
      i = 0;
      for (; i < object.length; i++) {
        this.roots.push(object[i]);
      }
      /** @type {boolean} */
      i = true;
      for (prop in value) {
        if (null != value[prop]) {
          /** @type {boolean} */
          i = false;
          break;
        }
      }
    }
  } else {
    /** @type {number} */
    i = 0;
    for (; i < this.roots.length; i++) {
      n = {};
      p.push(n);
      this.traverse(this.roots[i], true, null, v, n, p, null);
    }
  }
  /** @type {number} */
  i = v = 0;
  for (; i < p.length; i++) {
    n = p[i];
    /** @type {!Array} */
    value = [];
    for (prop in n) {
      value.push(n[prop]);
    }
    this.model = new mxGraphHierarchyModel(this, value, this.roots, data, this.tightenToSource);
    this.cycleStage(data);
    this.layeringStage();
    this.crossingStage(data);
    v = this.placementStage(v, data);
  }
};
/**
 * @param {string} parent
 * @param {string} obj
 * @return {undefined}
 */
mxHierarchicalLayout.prototype.filterDescendants = function(parent, obj) {
  var model = this.graph.model;
  if (model.isVertex(parent) && parent != this.parent && this.graph.isCellVisible(parent)) {
    /** @type {string} */
    obj[mxObjectIdentity.get(parent)] = parent;
  }
  if (this.traverseAncestors || parent == this.parent && this.graph.isCellVisible(parent)) {
    var d = model.getChildCount(parent);
    /** @type {number} */
    var i = 0;
    for (; i < d; i++) {
      var f = model.getChildAt(parent, i);
      if (!this.isPort(f)) {
        this.filterDescendants(f, obj);
      }
    }
  }
};
/**
 * @param {string} x
 * @return {?}
 */
mxHierarchicalLayout.prototype.isPort = function(x) {
  return null != x && null != x.geometry ? x.geometry.relative : false;
};
/**
 * @param {!Object} a
 * @param {!Object} b
 * @param {string} status
 * @return {?}
 */
mxHierarchicalLayout.prototype.getEdgesBetween = function(a, b, status) {
  status = null != status ? status : false;
  var edges = this.getEdges(a);
  /** @type {!Array} */
  var visited = [];
  /** @type {number} */
  var i = 0;
  for (; i < edges.length; i++) {
    var bP = this.getVisibleTerminal(edges[i], true);
    var comp = this.getVisibleTerminal(edges[i], false);
    if (bP == a && comp == b || !status && bP == b && comp == a) {
      visited.push(edges[i]);
    }
  }
  return visited;
};
/**
 * @param {?} value
 * @param {boolean} data
 * @param {number} n
 * @param {?} current
 * @param {!Object} next
 * @param {!Object} obj
 * @param {!Object} f
 * @return {?}
 */
mxHierarchicalLayout.prototype.traverse = function(value, data, n, current, next, obj, f) {
  if (null != value && null != current) {
    var key = mxObjectIdentity.get(value);
    if (null == current[key] && (null == f || null != f[key])) {
      if (null == next[key]) {
        next[key] = value;
      }
      if (null == current[key]) {
        current[key] = value;
      }
      if (null !== f) {
        delete f[key];
      }
      var i = this.getEdges(value);
      /** @type {!Array} */
      key = [];
      /** @type {number} */
      n = 0;
      for (; n < i.length; n++) {
        /** @type {boolean} */
        key[n] = this.getVisibleTerminal(i[n], true) == value;
      }
      /** @type {number} */
      n = 0;
      for (; n < i.length; n++) {
        if (!data || key[n]) {
          value = this.getVisibleTerminal(i[n], !key[n]);
          /** @type {number} */
          var m = 1;
          /** @type {number} */
          var t = 0;
          for (; t < i.length; t++) {
            if (t != n) {
              var type = key[t];
              if (this.getVisibleTerminal(i[t], !type) == value) {
                if (type) {
                  m++;
                } else {
                  m--;
                }
              }
            }
          }
          if (0 <= m) {
            next = this.traverse(value, data, i[n], current, next, obj, f);
          }
        }
      }
    } else {
      if (null == next[key]) {
        /** @type {number} */
        n = 0;
        for (; n < obj.length; n++) {
          if (data = obj[n], null != data[key]) {
            for (i in data) {
              next[i] = data[i];
            }
            obj.splice(n, 1);
            break;
          }
        }
      }
    }
  }
  return next;
};
/**
 * @param {!Object} a
 * @return {undefined}
 */
mxHierarchicalLayout.prototype.cycleStage = function(a) {
  (new mxMinimumCycleRemover(this)).execute(a);
};
/**
 * @return {undefined}
 */
mxHierarchicalLayout.prototype.layeringStage = function() {
  this.model.initialRank();
  this.model.fixRanks();
};
/**
 * @param {!Object} a
 * @return {undefined}
 */
mxHierarchicalLayout.prototype.crossingStage = function(a) {
  (new mxMedianHybridCrossingReduction(this)).execute(a);
};
/**
 * @param {number} target
 * @param {!Object} a
 * @return {?}
 */
mxHierarchicalLayout.prototype.placementStage = function(target, a) {
  target = new mxCoordinateAssignment(this, this.intraCellSpacing, this.interRankCellSpacing, this.orientation, target, this.parallelEdgeSpacing);
  target.fineTuning = this.fineTuning;
  target.execute(a);
  return target.limitX + this.interHierarchySpacing;
};
/**
 * @param {?} game
 * @param {string} orientation
 * @param {?} min
 * @return {undefined}
 */
function mxSwimlaneLayout(game, orientation, min) {
  mxGraphLayout.call(this, game);
  this.orientation = null != orientation ? orientation : mxConstants.DIRECTION_NORTH;
  this.deterministic = null != min ? min : true;
}
mxSwimlaneLayout.prototype = new mxGraphLayout;
/** @type {function(?, string, ?): undefined} */
mxSwimlaneLayout.prototype.constructor = mxSwimlaneLayout;
/** @type {null} */
mxSwimlaneLayout.prototype.roots = null;
/** @type {null} */
mxSwimlaneLayout.prototype.swimlanes = null;
/** @type {number} */
mxSwimlaneLayout.prototype.dummyVertexWidth = 50;
/** @type {boolean} */
mxSwimlaneLayout.prototype.resizeParent = false;
/** @type {boolean} */
mxSwimlaneLayout.prototype.maintainParentLocation = false;
/** @type {boolean} */
mxSwimlaneLayout.prototype.moveParent = false;
/** @type {number} */
mxSwimlaneLayout.prototype.parentBorder = 30;
/** @type {number} */
mxSwimlaneLayout.prototype.intraCellSpacing = 30;
/** @type {number} */
mxSwimlaneLayout.prototype.interRankCellSpacing = 100;
/** @type {number} */
mxSwimlaneLayout.prototype.interHierarchySpacing = 60;
/** @type {number} */
mxSwimlaneLayout.prototype.parallelEdgeSpacing = 10;
/** @type {string} */
mxSwimlaneLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;
/** @type {boolean} */
mxSwimlaneLayout.prototype.fineTuning = true;
/** @type {boolean} */
mxSwimlaneLayout.prototype.tightenToSource = true;
/** @type {boolean} */
mxSwimlaneLayout.prototype.disableEdgeStyle = true;
/** @type {boolean} */
mxSwimlaneLayout.prototype.traverseAncestors = true;
/** @type {null} */
mxSwimlaneLayout.prototype.model = null;
/** @type {null} */
mxSwimlaneLayout.prototype.edgesCache = null;
/** @type {null} */
mxHierarchicalLayout.prototype.edgeSourceTermCache = null;
/** @type {null} */
mxHierarchicalLayout.prototype.edgesTargetTermCache = null;
/** @type {number} */
mxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;
/**
 * @return {?}
 */
mxSwimlaneLayout.prototype.getModel = function() {
  return this.model;
};
/**
 * @param {string} element
 * @param {!Object} args
 * @return {undefined}
 */
mxSwimlaneLayout.prototype.execute = function(element, args) {
  /** @type {string} */
  this.parent = element;
  var model = this.graph.model;
  this.edgesCache = new mxDictionary;
  this.edgeSourceTermCache = new mxDictionary;
  this.edgesTargetTermCache = new mxDictionary;
  if (!(null == args || 1 > args.length)) {
    if (null == element) {
      element = model.getParent(args[0]);
    }
    /** @type {null} */
    this.parentY = this.parentX = null;
    if (element != this.root && null != model.isVertex(element) && this.maintainParentLocation) {
      var res = this.graph.getCellGeometry(element);
      if (null != res) {
        this.parentX = res.x;
        this.parentY = res.y;
      }
    }
    /** @type {!Object} */
    this.swimlanes = args;
    /** @type {!Array} */
    var cells = [];
    /** @type {number} */
    var i = 0;
    for (; i < args.length; i++) {
      var col = this.graph.getChildCells(args[i]);
      if (null == col || 0 == col.length) {
        col = this.graph.insertVertex(args[i], null, null, 0, 0, this.dummyVertexWidth, 0);
        cells.push(col);
      }
    }
    model.beginUpdate();
    try {
      this.run(element);
      if (this.resizeParent && !this.graph.isCellCollapsed(element)) {
        this.graph.updateGroupBounds([element], this.parentBorder, this.moveParent);
      }
      if (null != this.parentX && null != this.parentY) {
        res = this.graph.getCellGeometry(element);
        if (null != res) {
          res = res.clone();
          res.x = this.parentX;
          res.y = this.parentY;
          model.setGeometry(element, res);
        }
      }
      this.graph.removeCells(cells);
    } finally {
      model.endUpdate();
    }
  }
};
/**
 * @return {undefined}
 */
mxSwimlaneLayout.prototype.updateGroupBounds = function() {
  /** @type {!Array} */
  var a = [];
  var data = this.model;
  for (b in data.edgeMapper) {
    var c = data.edgeMapper[b];
    /** @type {number} */
    var i = 0;
    for (; i < c.edges.length; i++) {
      a.push(c.edges[i]);
    }
  }
  a = this.graph.getBoundingBoxFromGeometry(a, true);
  /** @type {!Array} */
  data = [];
  /** @type {number} */
  i = 0;
  for (; i < this.swimlanes.length; i++) {
    var d = this.swimlanes[i];
    var b = this.graph.getCellGeometry(d);
    if (null != b) {
      var cells = this.graph.getChildCells(d);
      c = this.graph.isSwimlane(d) ? this.graph.getStartSize(d) : new mxRectangle;
      d = this.graph.getBoundingBoxFromGeometry(cells);
      data[i] = d;
      /** @type {number} */
      c = d.y + b.y - c.height - this.parentBorder;
      b = d.y + b.y + d.height;
      if (null == a) {
        a = new mxRectangle(0, c, 0, b - c);
      } else {
        /** @type {number} */
        a.y = Math.min(a.y, c);
        /** @type {number} */
        a.height = Math.max(a.y + a.height, b) - a.y;
      }
    }
  }
  /** @type {number} */
  i = 0;
  for (; i < this.swimlanes.length; i++) {
    if (d = this.swimlanes[i], b = this.graph.getCellGeometry(d), null != b) {
      cells = this.graph.getChildCells(d);
      c = this.graph.isSwimlane(d) ? this.graph.getStartSize(d) : new mxRectangle;
      var res = b.clone();
      var offsetLeft = c.width + (0 == i ? this.parentBorder : this.interRankCellSpacing / 2);
      /** @type {number} */
      var x = data[i].x - offsetLeft;
      /** @type {number} */
      var height = a.y - this.parentBorder;
      res.x += x;
      /** @type {number} */
      res.y = height;
      res.width = data[i].width + offsetLeft + this.interRankCellSpacing / 2;
      res.height = a.height + c.height + 2 * this.parentBorder;
      this.graph.model.setGeometry(d, res);
      this.graph.moveCells(cells, -x, b.y - height);
    }
  }
};
/**
 * @param {!Object} node
 * @param {?} obj
 * @return {?}
 */
mxSwimlaneLayout.prototype.findRoots = function(node, obj) {
  /** @type {!Array} */
  var r = [];
  if (null != node && null != obj) {
    var model = this.graph.model;
    /** @type {null} */
    var e = null;
    /** @type {number} */
    var theHeight = -1E5;
    var prop;
    for (prop in obj) {
      var element = obj[prop];
      if (null != element && model.isVertex(element) && this.graph.isCellVisible(element) && model.isAncestor(node, element)) {
        var h = this.getEdges(element);
        /** @type {number} */
        var m = 0;
        /** @type {number} */
        var n = 0;
        /** @type {number} */
        var i = 0;
        for (; i < h.length; i++) {
          var parent = this.getVisibleTerminal(h[i], true);
          if (parent == element) {
            parent = this.getVisibleTerminal(h[i], false);
            if (model.isAncestor(node, parent)) {
              m++;
            }
          } else {
            if (model.isAncestor(node, parent)) {
              n++;
            }
          }
        }
        if (0 == n && 0 < m) {
          r.push(element);
        }
        /** @type {number} */
        h = m - n;
        if (h > theHeight) {
          /** @type {number} */
          theHeight = h;
          e = element;
        }
      }
    }
    if (0 == r.length && null != e) {
      r.push(e);
    }
  }
  return r;
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxSwimlaneLayout.prototype.getEdges = function(node) {
  var options = this.edgesCache.get(node);
  if (null != options) {
    return options;
  }
  var model = this.graph.model;
  /** @type {!Array} */
  options = [];
  var n = this.graph.isCellCollapsed(node);
  var value = model.getChildCount(node);
  /** @type {number} */
  var i = 0;
  for (; i < value; i++) {
    var a = model.getChildAt(node, i);
    if (this.isPort(a)) {
      /** @type {!Array<?>} */
      options = options.concat(model.getEdges(a, true, true));
    } else {
      if (n || !this.graph.isCellVisible(a)) {
        /** @type {!Array<?>} */
        options = options.concat(model.getEdges(a, true, true));
      }
    }
  }
  /** @type {!Array<?>} */
  options = options.concat(model.getEdges(node, true, true));
  /** @type {!Array} */
  model = [];
  /** @type {number} */
  i = 0;
  for (; i < options.length; i++) {
    n = this.getVisibleTerminal(options[i], true);
    value = this.getVisibleTerminal(options[i], false);
    if (n == value || n != value && (value == node && (null == this.parent || this.graph.isValidAncestor(n, this.parent, this.traverseAncestors)) || n == node && (null == this.parent || this.graph.isValidAncestor(value, this.parent, this.traverseAncestors)))) {
      model.push(options[i]);
    }
  }
  this.edgesCache.put(node, model);
  return model;
};
/**
 * @param {string} s
 * @param {boolean} b
 * @return {?}
 */
mxSwimlaneLayout.prototype.getVisibleTerminal = function(s, b) {
  var c = this.edgesTargetTermCache;
  if (b) {
    c = this.edgeSourceTermCache;
  }
  var e = c.get(s);
  if (null != e) {
    return e;
  }
  e = this.graph.view.getState(s);
  var d = null != e ? e.getVisibleTerminal(b) : this.graph.view.getVisibleTerminal(s, b);
  if (null == d) {
    d = null != e ? e.getVisibleTerminal(b) : this.graph.view.getVisibleTerminal(s, b);
  }
  if (null != d) {
    if (this.isPort(d)) {
      d = this.graph.model.getParent(d);
    }
    c.put(s, d);
  }
  return d;
};
/**
 * @param {number} item
 * @return {undefined}
 */
mxSwimlaneLayout.prototype.run = function(item) {
  /** @type {!Array} */
  var target = [];
  var current = {};
  if (null != this.swimlanes && 0 < this.swimlanes.length && null != item) {
    var d = {};
    /** @type {number} */
    var i = 0;
    for (; i < this.swimlanes.length; i++) {
      this.filterDescendants(this.swimlanes[i], d);
    }
    /** @type {!Array} */
    this.roots = [];
    /** @type {boolean} */
    i = true;
    var p;
    for (p in d) {
      if (null != d[p]) {
        /** @type {boolean} */
        i = false;
        break;
      }
    }
    /** @type {number} */
    var rank = 0;
    for (; !i && rank < this.swimlanes.length;) {
      var url = this.findRoots(this.swimlanes[rank], d);
      if (0 == url.length) {
        rank++;
      } else {
        /** @type {number} */
        i = 0;
        for (; i < url.length; i++) {
          var val = {};
          target.push(val);
          this.traverse(url[i], true, null, current, val, target, d, rank);
        }
        /** @type {number} */
        i = 0;
        for (; i < url.length; i++) {
          this.roots.push(url[i]);
        }
        /** @type {boolean} */
        i = true;
        for (p in d) {
          if (null != d[p]) {
            /** @type {boolean} */
            i = false;
            break;
          }
        }
      }
    }
  } else {
    /** @type {number} */
    i = 0;
    for (; i < this.roots.length; i++) {
      val = {};
      target.push(val);
      this.traverse(this.roots[i], true, null, current, val, target, null);
    }
  }
  /** @type {!Array} */
  target = [];
  for (p in current) {
    target.push(current[p]);
  }
  this.model = new mxSwimlaneModel(this, target, this.roots, item, this.tightenToSource);
  this.cycleStage(item);
  this.layeringStage();
  this.crossingStage(item);
  this.placementStage(0, item);
};
/**
 * @param {string} parent
 * @param {string} obj
 * @return {undefined}
 */
mxSwimlaneLayout.prototype.filterDescendants = function(parent, obj) {
  var model = this.graph.model;
  if (model.isVertex(parent) && parent != this.parent && model.getParent(parent) != this.parent && this.graph.isCellVisible(parent)) {
    /** @type {string} */
    obj[mxObjectIdentity.get(parent)] = parent;
  }
  if (this.traverseAncestors || parent == this.parent && this.graph.isCellVisible(parent)) {
    var d = model.getChildCount(parent);
    /** @type {number} */
    var i = 0;
    for (; i < d; i++) {
      var f = model.getChildAt(parent, i);
      if (!this.isPort(f)) {
        this.filterDescendants(f, obj);
      }
    }
  }
};
/**
 * @param {string} x
 * @return {?}
 */
mxSwimlaneLayout.prototype.isPort = function(x) {
  return x.geometry.relative ? true : false;
};
/**
 * @param {!Object} a
 * @param {!Object} b
 * @param {string} status
 * @return {?}
 */
mxSwimlaneLayout.prototype.getEdgesBetween = function(a, b, status) {
  status = null != status ? status : false;
  var edges = this.getEdges(a);
  /** @type {!Array} */
  var visited = [];
  /** @type {number} */
  var i = 0;
  for (; i < edges.length; i++) {
    var bP = this.getVisibleTerminal(edges[i], true);
    var comp = this.getVisibleTerminal(edges[i], false);
    if (bP == a && comp == b || !status && bP == b && comp == a) {
      visited.push(edges[i]);
    }
  }
  return visited;
};
/**
 * @param {?} value
 * @param {boolean} data
 * @param {number} n
 * @param {?} current
 * @param {!Object} next
 * @param {!Object} p
 * @param {!Object} f
 * @param {number} val
 * @return {?}
 */
mxSwimlaneLayout.prototype.traverse = function(value, data, n, current, next, p, f, val) {
  if (null != value && null != current) {
    var item = mxObjectIdentity.get(value);
    if (null == current[item] && (null == f || null != f[item])) {
      if (null == next[item]) {
        next[item] = value;
      }
      if (null == current[item]) {
        current[item] = value;
      }
      if (null !== f) {
        delete f[item];
      }
      var key = this.getEdges(value);
      item = this.graph.model;
      /** @type {number} */
      n = 0;
      for (; n < key.length; n++) {
        var name = this.getVisibleTerminal(key[n], true);
        /** @type {boolean} */
        var isValue = name == value;
        if (isValue) {
          name = this.getVisibleTerminal(key[n], false);
        }
        /** @type {number} */
        var i = 0;
        for (; i < this.swimlanes.length && !item.isAncestor(this.swimlanes[i], name);) {
          i++;
        }
        if (!(i >= this.swimlanes.length || !(i > val || (!data || isValue) && i == val))) {
          next = this.traverse(name, data, key[n], current, next, p, f, i);
        }
      }
    } else {
      if (null == next[item]) {
        /** @type {number} */
        n = 0;
        for (; n < p.length; n++) {
          if (value = p[n], null != value[item]) {
            for (key in value) {
              next[key] = value[key];
            }
            p.splice(n, 1);
            break;
          }
        }
      }
    }
  }
  return next;
};
/**
 * @param {!Object} a
 * @return {undefined}
 */
mxSwimlaneLayout.prototype.cycleStage = function(a) {
  (new mxSwimlaneOrdering(this)).execute(a);
};
/**
 * @return {undefined}
 */
mxSwimlaneLayout.prototype.layeringStage = function() {
  this.model.initialRank();
  this.model.fixRanks();
};
/**
 * @param {!Object} a
 * @return {undefined}
 */
mxSwimlaneLayout.prototype.crossingStage = function(a) {
  (new mxMedianHybridCrossingReduction(this)).execute(a);
};
/**
 * @param {number} target
 * @param {!Object} a
 * @return {?}
 */
mxSwimlaneLayout.prototype.placementStage = function(target, a) {
  target = new mxCoordinateAssignment(this, this.intraCellSpacing, this.interRankCellSpacing, this.orientation, target, this.parallelEdgeSpacing);
  target.fineTuning = this.fineTuning;
  target.execute(a);
  return target.limitX + this.interHierarchySpacing;
};
/**
 * @param {!Object} newRoot
 * @return {undefined}
 */
function mxGraphModel(newRoot) {
  this.currentEdit = this.createUndoableEdit();
  if (null != newRoot) {
    this.setRoot(newRoot);
  } else {
    this.clear();
  }
}
mxGraphModel.prototype = new mxEventSource;
/** @type {function(!Object): undefined} */
mxGraphModel.prototype.constructor = mxGraphModel;
/** @type {null} */
mxGraphModel.prototype.root = null;
/** @type {null} */
mxGraphModel.prototype.cells = null;
/** @type {boolean} */
mxGraphModel.prototype.maintainEdgeParent = true;
/** @type {boolean} */
mxGraphModel.prototype.ignoreRelativeEdgeParent = true;
/** @type {boolean} */
mxGraphModel.prototype.createIds = true;
/** @type {string} */
mxGraphModel.prototype.prefix = "";
/** @type {string} */
mxGraphModel.prototype.postfix = "";
/** @type {number} */
mxGraphModel.prototype.nextId = 0;
/** @type {null} */
mxGraphModel.prototype.currentEdit = null;
/** @type {number} */
mxGraphModel.prototype.updateLevel = 0;
/** @type {boolean} */
mxGraphModel.prototype.endingUpdate = false;
/**
 * @return {undefined}
 */
mxGraphModel.prototype.clear = function() {
  this.setRoot(this.createRoot());
};
/**
 * @return {?}
 */
mxGraphModel.prototype.isCreateIds = function() {
  return this.createIds;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraphModel.prototype.setCreateIds = function(a) {
  /** @type {boolean} */
  this.createIds = a;
};
/**
 * @return {?}
 */
mxGraphModel.prototype.createRoot = function() {
  var svg = new mxCell;
  svg.insert(new mxCell);
  return svg;
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxGraphModel.prototype.getCell = function(value) {
  return null != this.cells ? this.cells[value] : null;
};
/**
 * @param {!Object} value
 * @param {?} ready
 * @return {?}
 */
mxGraphModel.prototype.filterCells = function(value, ready) {
  /** @type {null} */
  var existingValue = null;
  if (null != value) {
    /** @type {!Array} */
    existingValue = [];
    /** @type {number} */
    var i = 0;
    for (; i < value.length; i++) {
      if (ready(value[i])) {
        existingValue.push(value[i]);
      }
    }
  }
  return existingValue;
};
/**
 * @param {boolean} id
 * @return {?}
 */
mxGraphModel.prototype.getDescendants = function(id) {
  return this.filterDescendants(null, id);
};
/**
 * @param {string} node
 * @param {string} id
 * @return {?}
 */
mxGraphModel.prototype.filterDescendants = function(node, id) {
  /** @type {!Array} */
  var cell = [];
  id = id || this.getRoot();
  if (null == node || node(id)) {
    cell.push(id);
  }
  var count = this.getChildCount(id);
  /** @type {number} */
  var i = 0;
  for (; i < count; i++) {
    var text = this.getChildAt(id, i);
    /** @type {!Array<?>} */
    cell = cell.concat(this.filterDescendants(node, text));
  }
  return cell;
};
/**
 * @param {string} node
 * @return {?}
 */
mxGraphModel.prototype.getRoot = function(node) {
  var n = node || this.root;
  if (null != node) {
    for (; null != node;) {
      /** @type {string} */
      n = node;
      node = this.getParent(node);
    }
  }
  return n;
};
/**
 * @param {!Object} root
 * @return {?}
 */
mxGraphModel.prototype.setRoot = function(root) {
  this.execute(new mxRootChange(this, root));
  return root;
};
/**
 * @param {?} root
 * @return {?}
 */
mxGraphModel.prototype.rootChanged = function(root) {
  var mesh = this.root;
  this.root = root;
  /** @type {number} */
  this.nextId = 0;
  /** @type {null} */
  this.cells = null;
  this.cellAdded(root);
  return mesh;
};
/**
 * @param {?} next
 * @return {?}
 */
mxGraphModel.prototype.isRoot = function(next) {
  return null != next && this.root == next;
};
/**
 * @param {!Object} two
 * @return {?}
 */
mxGraphModel.prototype.isLayer = function(two) {
  return this.isRoot(this.getParent(two));
};
/**
 * @param {!Object} parent
 * @param {!Object} node
 * @return {?}
 */
mxGraphModel.prototype.isAncestor = function(parent, node) {
  for (; null != node && node != parent;) {
    node = this.getParent(node);
  }
  return node == parent;
};
/**
 * @param {!Object} el
 * @return {?}
 */
mxGraphModel.prototype.contains = function(el) {
  return this.isAncestor(this.root, el);
};
/**
 * @param {!Object} obj
 * @return {?}
 */
mxGraphModel.prototype.getParent = function(obj) {
  return null != obj ? obj.getParent() : null;
};
/**
 * @param {string} el
 * @param {?} child
 * @param {!Function} index
 * @return {?}
 */
mxGraphModel.prototype.add = function(el, child, index) {
  if (child != el && null != el && null != child) {
    if (null == index) {
      index = this.getChildCount(el);
    }
    /** @type {boolean} */
    var d = el != this.getParent(child);
    this.execute(new mxChildChange(this, el, child, index));
    if (this.maintainEdgeParent && d) {
      this.updateEdgeParents(child);
    }
  }
  return child;
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxGraphModel.prototype.cellAdded = function(value) {
  if (null != value) {
    if (null == value.getId() && this.createIds) {
      value.setId(this.createId(value));
    }
    if (null != value.getId()) {
      var obj = this.getCell(value.getId());
      if (obj != value) {
        for (; null != obj;) {
          value.setId(this.createId(value));
          obj = this.getCell(value.getId());
        }
        if (null == this.cells) {
          this.cells = {};
        }
        /** @type {!Object} */
        this.cells[value.getId()] = value;
      }
    }
    if (mxUtils.isNumeric(value.getId())) {
      /** @type {number} */
      this.nextId = Math.max(this.nextId, value.getId());
    }
    obj = this.getChildCount(value);
    /** @type {number} */
    var to = 0;
    for (; to < obj; to++) {
      this.cellAdded(this.getChildAt(value, to));
    }
  }
};
/**
 * @param {?} name
 * @return {?}
 */
mxGraphModel.prototype.createId = function(name) {
  name = this.nextId;
  this.nextId++;
  return this.prefix + name + this.postfix;
};
/**
 * @param {!Object} el
 * @param {!Object} root
 * @return {undefined}
 */
mxGraphModel.prototype.updateEdgeParents = function(el, root) {
  root = root || this.getRoot(el);
  var elements = this.getChildCount(el);
  /** @type {number} */
  var i = 0;
  for (; i < elements; i++) {
    var c = this.getChildAt(el, i);
    this.updateEdgeParents(c, root);
  }
  c = this.getEdgeCount(el);
  /** @type {!Array} */
  elements = [];
  /** @type {number} */
  i = 0;
  for (; i < c; i++) {
    elements.push(this.getEdgeAt(el, i));
  }
  /** @type {number} */
  i = 0;
  for (; i < elements.length; i++) {
    el = elements[i];
    if (this.isAncestor(root, el)) {
      this.updateEdgeParent(el, root);
    }
  }
};
/**
 * @param {string} el
 * @param {?} element
 * @return {undefined}
 */
mxGraphModel.prototype.updateEdgeParent = function(el, element) {
  var node = this.getTerminal(el, true);
  var parent = this.getTerminal(el, false);
  for (; null != node && !this.isEdge(node) && null != node.geometry && node.geometry.relative;) {
    node = this.getParent(node);
  }
  for (; null != parent && this.ignoreRelativeEdgeParent && !this.isEdge(parent) && null != parent.geometry && parent.geometry.relative;) {
    parent = this.getParent(parent);
  }
  if (this.isAncestor(element, node) && this.isAncestor(element, parent) && (element = node == parent ? this.getParent(node) : this.getNearestCommonAncestor(node, parent), null != element && (this.getParent(element) != this.root || this.isAncestor(element, el)) && this.getParent(el) != element)) {
    node = this.getGeometry(el);
    if (null != node) {
      var offset = this.getOrigin(this.getParent(el));
      var position = this.getOrigin(element);
      /** @type {number} */
      parent = position.x - offset.x;
      /** @type {number} */
      offset = position.y - offset.y;
      node = node.clone();
      node.translate(-parent, -offset);
      this.setGeometry(el, node);
    }
    this.add(element, el, this.getChildCount(element));
  }
};
/**
 * @param {?} obj
 * @return {?}
 */
mxGraphModel.prototype.getOrigin = function(obj) {
  if (null != obj) {
    var ret = this.getOrigin(this.getParent(obj));
    if (!this.isEdge(obj)) {
      obj = this.getGeometry(obj);
      if (null != obj) {
        ret.x += obj.x;
        ret.y += obj.y;
      }
    }
  } else {
    ret = new mxPoint;
  }
  return ret;
};
/**
 * @param {number} current
 * @param {number} parent
 * @return {?}
 */
mxGraphModel.prototype.getNearestCommonAncestor = function(current, parent) {
  if (null != current && null != parent) {
    var a = mxCellPath.create(parent);
    if (null != a && 0 < a.length) {
      var dir = mxCellPath.create(current);
      if (a.length < dir.length) {
        /** @type {number} */
        current = parent;
        parent = dir;
        dir = a;
        /** @type {number} */
        a = parent;
      }
      for (; null != current;) {
        parent = this.getParent(current);
        if (0 == a.indexOf(dir + mxCellPath.PATH_SEPARATOR) && null != parent) {
          return current;
        }
        dir = mxCellPath.getParentPath(dir);
        /** @type {number} */
        current = parent;
      }
    }
  }
  return null;
};
/**
 * @param {(Object|string)} child
 * @return {?}
 */
mxGraphModel.prototype.remove = function(child) {
  if (child == this.root) {
    this.setRoot(null);
  } else {
    if (null != this.getParent(child)) {
      this.execute(new mxChildChange(this, null, child));
    }
  }
  return child;
};
/**
 * @param {!Object} index
 * @return {undefined}
 */
mxGraphModel.prototype.cellRemoved = function(index) {
  if (null != index && null != this.cells) {
    /** @type {number} */
    var previousWidgetPos = this.getChildCount(index) - 1;
    for (; 0 <= previousWidgetPos; previousWidgetPos--) {
      this.cellRemoved(this.getChildAt(index, previousWidgetPos));
    }
    if (null != this.cells && null != index.getId()) {
      delete this.cells[index.getId()];
    }
  }
};
/**
 * @param {undefined} i
 * @param {!Object} a
 * @param {!Array} c
 * @return {?}
 */
mxGraphModel.prototype.parentForCellChanged = function(i, a, c) {
  var b = this.getParent(i);
  if (null != a) {
    if (!(a == b && b.getIndex(i) == c)) {
      a.insert(i, c);
    }
  } else {
    if (null != b) {
      c = b.getIndex(i);
      b.remove(c);
    }
  }
  a = this.contains(a);
  c = this.contains(b);
  if (a && !c) {
    this.cellAdded(i);
  } else {
    if (c && !a) {
      this.cellRemoved(i);
    }
  }
  return b;
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxGraphModel.prototype.getChildCount = function(node) {
  return null != node ? node.getChildCount() : 0;
};
/**
 * @param {!Object} item
 * @param {number} index
 * @return {?}
 */
mxGraphModel.prototype.getChildAt = function(item, index) {
  return null != item ? item.getChildAt(index) : null;
};
/**
 * @param {!Object} o
 * @return {?}
 */
mxGraphModel.prototype.getChildren = function(o) {
  return null != o ? o.children : null;
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraphModel.prototype.getChildVertices = function(a) {
  return this.getChildCells(a, true, false);
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraphModel.prototype.getChildEdges = function(a) {
  return this.getChildCells(a, false, true);
};
/**
 * @param {!Array} i
 * @param {string} ctx
 * @param {string} config
 * @return {?}
 */
mxGraphModel.prototype.getChildCells = function(i, ctx, config) {
  ctx = null != ctx ? ctx : false;
  config = null != config ? config : false;
  var count = this.getChildCount(i);
  /** @type {!Array} */
  var clenseAttrs = [];
  /** @type {number} */
  var x = 0;
  for (; x < count; x++) {
    var text = this.getChildAt(i, x);
    if (!config && !ctx || config && this.isEdge(text) || ctx && this.isVertex(text)) {
      clenseAttrs.push(text);
    }
  }
  return clenseAttrs;
};
/**
 * @param {string} obj
 * @param {string} arg
 * @return {?}
 */
mxGraphModel.prototype.getTerminal = function(obj, arg) {
  return null != obj ? obj.getTerminal(arg) : null;
};
/**
 * @param {string} id
 * @param {string} value
 * @param {string} args
 * @return {?}
 */
mxGraphModel.prototype.setTerminal = function(id, value, args) {
  /** @type {boolean} */
  var move = value != this.getTerminal(id, args);
  this.execute(new mxTerminalChange(this, id, value, args));
  if (this.maintainEdgeParent && move) {
    this.updateEdgeParent(id, this.getRoot());
  }
  return value;
};
/**
 * @param {string} m
 * @param {string} b
 * @param {string} status
 * @return {undefined}
 */
mxGraphModel.prototype.setTerminals = function(m, b, status) {
  this.beginUpdate();
  try {
    this.setTerminal(m, b, true);
    this.setTerminal(m, status, false);
  } finally {
    this.endUpdate();
  }
};
/**
 * @param {(Object|string)} key
 * @param {!Object} source
 * @param {string} z
 * @return {?}
 */
mxGraphModel.prototype.terminalForCellChanged = function(key, source, z) {
  var result = this.getTerminal(key, z);
  if (null != source) {
    source.insertEdge(key, z);
  } else {
    if (null != result) {
      result.removeEdge(key, z);
    }
  }
  return result;
};
/**
 * @param {!Object} v
 * @return {?}
 */
mxGraphModel.prototype.getEdgeCount = function(v) {
  return null != v ? v.getEdgeCount() : 0;
};
/**
 * @param {!Object} x
 * @param {number} obj
 * @return {?}
 */
mxGraphModel.prototype.getEdgeAt = function(x, obj) {
  return null != x ? x.getEdgeAt(obj) : null;
};
/**
 * @param {!Object} value
 * @param {string} name
 * @param {string} n
 * @return {?}
 */
mxGraphModel.prototype.getDirectedEdgeCount = function(value, name, n) {
  /** @type {number} */
  var d = 0;
  var be = this.getEdgeCount(value);
  /** @type {number} */
  var b = 0;
  for (; b < be; b++) {
    var i = this.getEdgeAt(value, b);
    if (i != n && this.getTerminal(i, name) == value) {
      d++;
    }
  }
  return d;
};
/**
 * @param {!Object} id
 * @return {?}
 */
mxGraphModel.prototype.getConnections = function(id) {
  return this.getEdges(id, true, true, false);
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxGraphModel.prototype.getIncomingEdges = function(node) {
  return this.getEdges(node, true, false, false);
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxGraphModel.prototype.getOutgoingEdges = function(node) {
  return this.getEdges(node, false, true, false);
};
/**
 * @param {!Object} target
 * @param {?} id
 * @param {?} direction
 * @param {?} e
 * @return {?}
 */
mxGraphModel.prototype.getEdges = function(target, id, direction, e) {
  id = null != id ? id : true;
  direction = null != direction ? direction : true;
  e = null != e ? e : true;
  var zoom = this.getEdgeCount(target);
  /** @type {!Array} */
  var selected = [];
  /** @type {number} */
  var z = 0;
  for (; z < zoom; z++) {
    var key = this.getEdgeAt(target, z);
    var n = this.getTerminal(key, true);
    var node = this.getTerminal(key, false);
    if (e && n == node || n != node && (id && node == target || direction && n == target)) {
      selected.push(key);
    }
  }
  return selected;
};
/**
 * @param {!Object} b
 * @param {!Object} a
 * @param {string} options
 * @return {?}
 */
mxGraphModel.prototype.getEdgesBetween = function(b, a, options) {
  options = null != options ? options : false;
  var o = this.getEdgeCount(b);
  var d = this.getEdgeCount(a);
  /** @type {!Object} */
  var B = b;
  var t = o;
  if (d < o) {
    t = d;
    /** @type {!Object} */
    B = a;
  }
  /** @type {!Array} */
  o = [];
  /** @type {number} */
  d = 0;
  for (; d < t; d++) {
    var value = this.getEdgeAt(B, d);
    var name = this.getTerminal(value, true);
    var url = this.getTerminal(value, false);
    /** @type {boolean} */
    var tabless = url == b && name == a;
    if (name == b && url == a || !options && tabless) {
      o.push(value);
    }
  }
  return o;
};
/**
 * @param {!Object} text
 * @param {?} document
 * @param {?} parent
 * @param {?} e
 * @return {?}
 */
mxGraphModel.prototype.getOpposites = function(text, document, parent, e) {
  parent = null != parent ? parent : true;
  e = null != e ? e : true;
  /** @type {!Array} */
  var register = [];
  if (null != text) {
    /** @type {number} */
    var i = 0;
    for (; i < text.length; i++) {
      var node = this.getTerminal(text[i], true);
      var target = this.getTerminal(text[i], false);
      if (node == document && null != target && target != document && e) {
        register.push(target);
      } else {
        if (target == document && null != node && node != document && parent) {
          register.push(node);
        }
      }
    }
  }
  return register;
};
/**
 * @param {string} arr
 * @return {?}
 */
mxGraphModel.prototype.getTopmostCells = function(arr) {
  var b = new mxDictionary;
  /** @type {!Array} */
  var opt_insertArr = [];
  /** @type {number} */
  var i = 0;
  for (; i < arr.length; i++) {
    b.put(arr[i], true);
  }
  /** @type {number} */
  i = 0;
  for (; i < arr.length; i++) {
    var node = arr[i];
    /** @type {boolean} */
    var f = true;
    var parent = this.getParent(node);
    for (; null != parent;) {
      if (b.get(parent)) {
        /** @type {boolean} */
        f = false;
        break;
      }
      parent = this.getParent(parent);
    }
    if (f) {
      opt_insertArr.push(node);
    }
  }
  return opt_insertArr;
};
/**
 * @param {!Object} data
 * @return {?}
 */
mxGraphModel.prototype.isVertex = function(data) {
  return null != data ? data.isVertex() : false;
};
/**
 * @param {?} value
 * @return {?}
 */
mxGraphModel.prototype.isEdge = function(value) {
  return null != value ? value.isEdge() : false;
};
/**
 * @param {number} target
 * @return {?}
 */
mxGraphModel.prototype.isConnectable = function(target) {
  return null != target ? target.isConnectable() : false;
};
/**
 * @param {!Object} str
 * @return {?}
 */
mxGraphModel.prototype.getValue = function(str) {
  return null != str ? str.getValue() : null;
};
/**
 * @param {!Array} cell
 * @param {!Object} value
 * @return {?}
 */
mxGraphModel.prototype.setValue = function(cell, value) {
  this.execute(new mxValueChange(this, cell, value));
  return value;
};
/**
 * @param {?} exp
 * @param {?} val
 * @return {?}
 */
mxGraphModel.prototype.valueForCellChanged = function(exp, val) {
  return exp.valueChanged(val);
};
/**
 * @param {!Object} object
 * @return {?}
 */
mxGraphModel.prototype.getGeometry = function(object) {
  return null != object ? object.getGeometry() : null;
};
/**
 * @param {!Object} name
 * @param {!Object} id
 * @return {?}
 */
mxGraphModel.prototype.setGeometry = function(name, id) {
  if (id != this.getGeometry(name)) {
    this.execute(new mxGeometryChange(this, name, id));
  }
  return id;
};
/**
 * @param {!Object} feature
 * @param {!Object} path
 * @return {?}
 */
mxGraphModel.prototype.geometryForCellChanged = function(feature, path) {
  var geom = this.getGeometry(feature);
  feature.setGeometry(path);
  return geom;
};
/**
 * @param {!Object} object
 * @return {?}
 */
mxGraphModel.prototype.getStyle = function(object) {
  return null != object ? object.getStyle() : null;
};
/**
 * @param {!Object} obj
 * @param {!Object} value
 * @return {?}
 */
mxGraphModel.prototype.setStyle = function(obj, value) {
  if (value != this.getStyle(obj)) {
    this.execute(new mxStyleChange(this, obj, value));
  }
  return value;
};
/**
 * @param {!Object} cell
 * @param {undefined} style
 * @return {?}
 */
mxGraphModel.prototype.styleForCellChanged = function(cell, style) {
  var d = this.getStyle(cell);
  cell.setStyle(style);
  return d;
};
/**
 * @param {!Object} parent
 * @return {?}
 */
mxGraphModel.prototype.isCollapsed = function(parent) {
  return null != parent ? parent.isCollapsed() : false;
};
/**
 * @param {!Object} comp
 * @param {!Object} status
 * @return {?}
 */
mxGraphModel.prototype.setCollapsed = function(comp, status) {
  if (status != this.isCollapsed(comp)) {
    this.execute(new mxCollapseChange(this, comp, status));
  }
  return status;
};
/**
 * @param {!Object} button
 * @param {undefined} value
 * @return {?}
 */
mxGraphModel.prototype.collapsedStateForCellChanged = function(button, value) {
  var btn11 = this.isCollapsed(button);
  button.setCollapsed(value);
  return btn11;
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxGraphModel.prototype.isVisible = function(e) {
  return null != e ? e.isVisible() : false;
};
/**
 * @param {string} name
 * @param {!Object} value
 * @return {?}
 */
mxGraphModel.prototype.setVisible = function(name, value) {
  if (value != this.isVisible(name)) {
    this.execute(new mxVisibleChange(this, name, value));
  }
  return value;
};
/**
 * @param {!Object} el
 * @param {boolean} value
 * @return {?}
 */
mxGraphModel.prototype.visibleStateForCellChanged = function(el, value) {
  var visible = this.isVisible(el);
  el.setVisible(value);
  return visible;
};
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxGraphModel.prototype.execute = function(obj) {
  obj.execute();
  this.beginUpdate();
  this.currentEdit.add(obj);
  this.fireEvent(new mxEventObject(mxEvent.EXECUTE, "change", obj));
  this.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", obj));
  this.endUpdate();
};
/**
 * @return {undefined}
 */
mxGraphModel.prototype.beginUpdate = function() {
  this.updateLevel++;
  this.fireEvent(new mxEventObject(mxEvent.BEGIN_UPDATE));
  if (1 == this.updateLevel) {
    this.fireEvent(new mxEventObject(mxEvent.START_EDIT));
  }
};
/**
 * @return {undefined}
 */
mxGraphModel.prototype.endUpdate = function() {
  this.updateLevel--;
  if (0 == this.updateLevel) {
    this.fireEvent(new mxEventObject(mxEvent.END_EDIT));
  }
  if (!this.endingUpdate) {
    /** @type {boolean} */
    this.endingUpdate = 0 == this.updateLevel;
    this.fireEvent(new mxEventObject(mxEvent.END_UPDATE, "edit", this.currentEdit));
    try {
      if (this.endingUpdate && !this.currentEdit.isEmpty()) {
        this.fireEvent(new mxEventObject(mxEvent.BEFORE_UNDO, "edit", this.currentEdit));
        var edit = this.currentEdit;
        this.currentEdit = this.createUndoableEdit();
        edit.notify();
        this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", edit));
      }
    } finally {
      /** @type {boolean} */
      this.endingUpdate = false;
    }
  }
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraphModel.prototype.createUndoableEdit = function(a) {
  var edit = new mxUndoableEdit(this, null != a ? a : true);
  /**
   * @return {undefined}
   */
  edit.notify = function() {
    edit.source.fireEvent(new mxEventObject(mxEvent.CHANGE, "edit", edit, "changes", edit.changes));
    edit.source.fireEvent(new mxEventObject(mxEvent.NOTIFY, "edit", edit, "changes", edit.changes));
  };
  return edit;
};
/**
 * @param {?} refNode
 * @param {?} forward
 * @param {?} e
 * @return {undefined}
 */
mxGraphModel.prototype.mergeChildren = function(refNode, forward, e) {
  e = null != e ? e : true;
  this.beginUpdate();
  try {
    var parent = {};
    this.mergeChildrenImpl(refNode, forward, e, parent);
    var key;
    for (key in parent) {
      var value = parent[key];
      var node = this.getTerminal(value, true);
      if (null != node) {
        node = parent[mxCellPath.create(node)];
        this.setTerminal(value, node, true);
      }
      node = this.getTerminal(value, false);
      if (null != node) {
        node = parent[mxCellPath.create(node)];
        this.setTerminal(value, node, false);
      }
    }
  } finally {
    this.endUpdate();
  }
};
/**
 * @param {?} node
 * @param {?} path
 * @param {?} result
 * @param {?} style
 * @return {undefined}
 */
mxGraphModel.prototype.mergeChildrenImpl = function(node, path, result, style) {
  this.beginUpdate();
  try {
    var cell_amount = node.getChildCount();
    /** @type {number} */
    var i = 0;
    for (; i < cell_amount; i++) {
      var obj = node.getChildAt(i);
      if ("function" == typeof obj.getId) {
        var node = obj.getId();
        var value = null == node || this.isEdge(obj) && result ? null : this.getCell(node);
        if (null == value) {
          var tab = obj.clone();
          tab.setId(node);
          tab.setTerminal(obj.getTerminal(true), true);
          tab.setTerminal(obj.getTerminal(false), false);
          value = path.insert(tab);
          this.cellAdded(value);
        }
        style[mxCellPath.create(obj)] = value;
        this.mergeChildrenImpl(obj, value, result, style);
      }
    }
  } finally {
    this.endUpdate();
  }
};
/**
 * @param {!Object} options
 * @return {?}
 */
mxGraphModel.prototype.getParents = function(options) {
  /** @type {!Array} */
  var parents = [];
  if (null != options) {
    var dagService = new mxDictionary;
    /** @type {number} */
    var i = 0;
    for (; i < options.length; i++) {
      var node = this.getParent(options[i]);
      if (!(null == node || dagService.get(node))) {
        dagService.put(node, true);
        parents.push(node);
      }
    }
  }
  return parents;
};
/**
 * @param {!Object} s
 * @param {?} header
 * @param {boolean} w
 * @return {?}
 */
mxGraphModel.prototype.cloneCell = function(s, header, w) {
  return null != s ? this.cloneCells([s], header, null, w)[0] : null;
};
/**
 * @param {!Object} obj
 * @param {?} v
 * @param {number} data
 * @param {string} e
 * @return {?}
 */
mxGraphModel.prototype.cloneCells = function(obj, v, data, e) {
  v = null != v ? v : true;
  data = null != data ? data : {};
  e = null != e ? e : false;
  /** @type {!Array} */
  var d = [];
  /** @type {number} */
  var i = 0;
  for (; i < obj.length; i++) {
    if (null != obj[i]) {
      d.push(this.cloneCellImpl(obj[i], data, v, e));
    } else {
      d.push(null);
    }
  }
  /** @type {number} */
  i = 0;
  for (; i < d.length; i++) {
    if (null != d[i]) {
      this.restoreClone(d[i], obj[i], data);
    }
  }
  return d;
};
/**
 * @param {!Object} i
 * @param {number} s
 * @param {boolean} m
 * @param {string} n
 * @return {?}
 */
mxGraphModel.prototype.cloneCellImpl = function(i, s, m, n) {
  var j = mxObjectIdentity.get(i);
  var c = s[j];
  if (null == c && (c = this.cellCloned(i), s[j] = c, n && (c.id = i.id), m)) {
    m = this.getChildCount(i);
    /** @type {number} */
    j = 0;
    for (; j < m; j++) {
      var p = this.cloneCellImpl(this.getChildAt(i, j), s, true, n);
      c.insert(p);
    }
  }
  return c;
};
/**
 * @param {!Object} a
 * @return {?}
 */
mxGraphModel.prototype.cellCloned = function(a) {
  return a.clone();
};
/**
 * @param {undefined} i
 * @param {undefined} index
 * @param {number} data
 * @return {undefined}
 */
mxGraphModel.prototype.restoreClone = function(i, index, data) {
  var a = this.getTerminal(index, true);
  if (null != a) {
    a = data[mxObjectIdentity.get(a)];
    if (null != a) {
      a.insertEdge(i, true);
    }
  }
  a = this.getTerminal(index, false);
  if (null != a) {
    a = data[mxObjectIdentity.get(a)];
    if (null != a) {
      a.insertEdge(i, false);
    }
  }
  a = this.getChildCount(i);
  /** @type {number} */
  var x = 0;
  for (; x < a; x++) {
    this.restoreClone(this.getChildAt(i, x), this.getChildAt(index, x), data);
  }
};
/**
 * @param {!Object} val
 * @param {string} len
 * @return {undefined}
 */
function mxRootChange(val, len) {
  /** @type {!Object} */
  this.model = val;
  this.previous = this.root = len;
}
/**
 * @return {undefined}
 */
mxRootChange.prototype.execute = function() {
  this.root = this.previous;
  this.previous = this.model.rootChanged(this.previous);
};
/**
 * @param {!Object} game
 * @param {?} parent
 * @param {!Node} child
 * @param {number} index
 * @return {undefined}
 */
function mxChildChange(game, parent, child, index) {
  /** @type {!Object} */
  this.model = game;
  this.previous = this.parent = parent;
  /** @type {!Node} */
  this.child = child;
  this.previousIndex = this.index = index;
}
/**
 * @return {undefined}
 */
mxChildChange.prototype.execute = function() {
  if (null != this.child) {
    var old = this.model.getParent(this.child);
    var index = null != old ? old.getIndex(this.child) : 0;
    if (null == this.previous) {
      this.connect(this.child, false);
    }
    old = this.model.parentForCellChanged(this.child, this.previous, this.previousIndex);
    if (null != this.previous) {
      this.connect(this.child, true);
    }
    this.parent = this.previous;
    this.previous = old;
    this.index = this.previousIndex;
    this.previousIndex = index;
  }
};
/**
 * @param {!Object} parent
 * @param {?} e
 * @return {undefined}
 */
mxChildChange.prototype.connect = function(parent, e) {
  e = null != e ? e : true;
  var id = parent.getTerminal(true);
  var i = parent.getTerminal(false);
  if (null != id) {
    if (e) {
      this.model.terminalForCellChanged(parent, id, true);
    } else {
      this.model.terminalForCellChanged(parent, null, true);
    }
  }
  if (null != i) {
    if (e) {
      this.model.terminalForCellChanged(parent, i, false);
    } else {
      this.model.terminalForCellChanged(parent, null, false);
    }
  }
  parent.setTerminal(id, true);
  parent.setTerminal(i, false);
  id = this.model.getChildCount(parent);
  /** @type {number} */
  i = 0;
  for (; i < id; i++) {
    this.connect(this.model.getChildAt(parent, i), e);
  }
};
/**
 * @param {!Object} newModel
 * @param {?} sync
 * @param {?} er
 * @param {string} data
 * @return {undefined}
 */
function mxTerminalChange(newModel, sync, er, data) {
  /** @type {!Object} */
  this.model = newModel;
  this.cell = sync;
  this.previous = this.terminal = er;
  /** @type {string} */
  this.source = data;
}
/**
 * @return {undefined}
 */
mxTerminalChange.prototype.execute = function() {
  if (null != this.cell) {
    this.terminal = this.previous;
    this.previous = this.model.terminalForCellChanged(this.cell, this.previous, this.source);
  }
};
/**
 * @param {!Object} newModel
 * @param {?} _at_variable
 * @param {!Object} _at_value
 * @return {undefined}
 */
function mxValueChange(newModel, _at_variable, _at_value) {
  /** @type {!Object} */
  this.model = newModel;
  this.cell = _at_variable;
  this.previous = this.value = _at_value;
}
/**
 * @return {undefined}
 */
mxValueChange.prototype.execute = function() {
  if (null != this.cell) {
    this.value = this.previous;
    this.previous = this.model.valueForCellChanged(this.cell, this.previous);
  }
};
/**
 * @param {!Object} model
 * @param {?} cell
 * @param {?} className
 * @return {undefined}
 */
function mxStyleChange(model, cell, className) {
  /** @type {!Object} */
  this.model = model;
  this.cell = cell;
  this.previous = this.style = className;
}
/**
 * @return {undefined}
 */
mxStyleChange.prototype.execute = function() {
  if (null != this.cell) {
    this.style = this.previous;
    this.previous = this.model.styleForCellChanged(this.cell, this.previous);
  }
};
/**
 * @param {!Object} game
 * @param {?} context
 * @param {!Object} geometry
 * @return {undefined}
 */
function mxGeometryChange(game, context, geometry) {
  /** @type {!Object} */
  this.model = game;
  this.cell = context;
  this.previous = this.geometry = geometry;
}
/**
 * @return {undefined}
 */
mxGeometryChange.prototype.execute = function() {
  if (null != this.cell) {
    this.geometry = this.previous;
    this.previous = this.model.geometryForCellChanged(this.cell, this.previous);
  }
};
/**
 * @param {!Object} newModel
 * @param {?} rowHeight
 * @param {boolean} groupInitState
 * @return {undefined}
 */
function mxCollapseChange(newModel, rowHeight, groupInitState) {
  /** @type {!Object} */
  this.model = newModel;
  this.cell = rowHeight;
  this.previous = this.collapsed = groupInitState;
}
/**
 * @return {undefined}
 */
mxCollapseChange.prototype.execute = function() {
  if (null != this.cell) {
    this.collapsed = this.previous;
    this.previous = this.model.collapsedStateForCellChanged(this.cell, this.previous);
  }
};
/**
 * @param {!Object} model
 * @param {?} cell
 * @param {boolean} value
 * @return {undefined}
 */
function mxVisibleChange(model, cell, value) {
  /** @type {!Object} */
  this.model = model;
  this.cell = cell;
  this.previous = this.visible = value;
}
/**
 * @return {undefined}
 */
mxVisibleChange.prototype.execute = function() {
  if (null != this.cell) {
    this.visible = this.previous;
    this.previous = this.model.visibleStateForCellChanged(this.cell, this.previous);
  }
};
/**
 * @param {?} cell
 * @param {string} attribute
 * @param {!Object} value
 * @return {undefined}
 */
function mxCellAttributeChange(cell, attribute, value) {
  this.cell = cell;
  /** @type {string} */
  this.attribute = attribute;
  this.previous = this.value = value;
}
/**
 * @return {undefined}
 */
mxCellAttributeChange.prototype.execute = function() {
  if (null != this.cell) {
    var data = this.cell.getAttribute(this.attribute);
    if (null == this.previous) {
      this.cell.value.removeAttribute(this.attribute);
    } else {
      this.cell.setAttribute(this.attribute, this.previous);
    }
    this.previous = data;
  }
};
/**
 * @param {!Object} a
 * @param {!Object} lineWidth
 * @param {undefined} type
 * @return {undefined}
 */
function mxCell(a, lineWidth, type) {
  /** @type {!Object} */
  this.value = a;
  this.setGeometry(lineWidth);
  this.setStyle(type);
  if (null != this.onInit) {
    this.onInit();
  }
}
/** @type {null} */
mxCell.prototype.id = null;
/** @type {null} */
mxCell.prototype.value = null;
/** @type {null} */
mxCell.prototype.geometry = null;
/** @type {null} */
mxCell.prototype.style = null;
/** @type {boolean} */
mxCell.prototype.vertex = false;
/** @type {boolean} */
mxCell.prototype.edge = false;
/** @type {boolean} */
mxCell.prototype.connectable = true;
/** @type {boolean} */
mxCell.prototype.visible = true;
/** @type {boolean} */
mxCell.prototype.collapsed = false;
/** @type {null} */
mxCell.prototype.parent = null;
/** @type {null} */
mxCell.prototype.source = null;
/** @type {null} */
mxCell.prototype.target = null;
/** @type {null} */
mxCell.prototype.children = null;
/** @type {null} */
mxCell.prototype.edges = null;
/** @type {!Array<string>} */
mxCell.prototype.mxTransient = "id value parent source target children edges".split(" ");
/**
 * @return {?}
 */
mxCell.prototype.getId = function() {
  return this.id;
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxCell.prototype.setId = function(value) {
  /** @type {string} */
  this.id = value;
};
/**
 * @return {?}
 */
mxCell.prototype.getValue = function() {
  return this.value;
};
/**
 * @param {?} date
 * @return {undefined}
 */
mxCell.prototype.setValue = function(date) {
  this.value = date;
};
/**
 * @param {?} v
 * @return {?}
 */
mxCell.prototype.valueChanged = function(v) {
  var currentPrefs = this.getValue();
  this.setValue(v);
  return currentPrefs;
};
/**
 * @return {?}
 */
mxCell.prototype.getGeometry = function() {
  return this.geometry;
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxCell.prototype.setGeometry = function(value) {
  /** @type {!Object} */
  this.geometry = value;
};
/**
 * @return {?}
 */
mxCell.prototype.getStyle = function() {
  return this.style;
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxCell.prototype.setStyle = function(value) {
  /** @type {!Object} */
  this.style = value;
};
/**
 * @return {?}
 */
mxCell.prototype.isVertex = function() {
  return 0 != this.vertex;
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxCell.prototype.setVertex = function(value) {
  /** @type {string} */
  this.vertex = value;
};
/**
 * @return {?}
 */
mxCell.prototype.isEdge = function() {
  return 0 != this.edge;
};
/**
 * @param {string} edge
 * @return {undefined}
 */
mxCell.prototype.setEdge = function(edge) {
  /** @type {string} */
  this.edge = edge;
};
/**
 * @return {?}
 */
mxCell.prototype.isConnectable = function() {
  return 0 != this.connectable;
};
/**
 * @param {string} isIron
 * @return {undefined}
 */
mxCell.prototype.setConnectable = function(isIron) {
  /** @type {string} */
  this.connectable = isIron;
};
/**
 * @return {?}
 */
mxCell.prototype.isVisible = function() {
  return 0 != this.visible;
};
/**
 * @param {boolean} isVisible
 * @return {undefined}
 */
mxCell.prototype.setVisible = function(isVisible) {
  /** @type {boolean} */
  this.visible = isVisible;
};
/**
 * @return {?}
 */
mxCell.prototype.isCollapsed = function() {
  return 0 != this.collapsed;
};
/**
 * @param {boolean} collapsed
 * @return {undefined}
 */
mxCell.prototype.setCollapsed = function(collapsed) {
  /** @type {boolean} */
  this.collapsed = collapsed;
};
/**
 * @return {?}
 */
mxCell.prototype.getParent = function() {
  return this.parent;
};
/**
 * @param {!Object} parent
 * @return {undefined}
 */
mxCell.prototype.setParent = function(parent) {
  /** @type {!Object} */
  this.parent = parent;
};
/**
 * @param {string} arg
 * @return {?}
 */
mxCell.prototype.getTerminal = function(arg) {
  return arg ? this.source : this.target;
};
/**
 * @param {string} data
 * @param {string} id
 * @return {?}
 */
mxCell.prototype.setTerminal = function(data, id) {
  if (id) {
    /** @type {string} */
    this.source = data;
  } else {
    /** @type {string} */
    this.target = data;
  }
  return data;
};
/**
 * @return {?}
 */
mxCell.prototype.getChildCount = function() {
  return null == this.children ? 0 : this.children.length;
};
/**
 * @param {?} value
 * @return {?}
 */
mxCell.prototype.getIndex = function(value) {
  return mxUtils.indexOf(this.children, value);
};
/**
 * @param {!Object} index
 * @return {?}
 */
mxCell.prototype.getChildAt = function(index) {
  return null == this.children ? null : this.children[index];
};
/**
 * @param {!Object} node
 * @param {!Object} child
 * @return {?}
 */
mxCell.prototype.insert = function(node, child) {
  if (null != node) {
    if (null == child) {
      child = this.getChildCount();
      if (node.getParent() == this) {
        child--;
      }
    }
    node.removeFromParent();
    node.setParent(this);
    if (null == this.children) {
      /** @type {!Array} */
      this.children = [];
      this.children.push(node);
    } else {
      this.children.splice(child, 0, node);
    }
  }
  return node;
};
/**
 * @param {number} n
 * @return {?}
 */
mxCell.prototype.remove = function(n) {
  /** @type {null} */
  var child = null;
  if (null != this.children && 0 <= n) {
    child = this.getChildAt(n);
    if (null != child) {
      this.children.splice(n, 1);
      child.setParent(null);
    }
  }
  return child;
};
/**
 * @return {undefined}
 */
mxCell.prototype.removeFromParent = function() {
  if (null != this.parent) {
    var value = this.parent.getIndex(this);
    this.parent.remove(value);
  }
};
/**
 * @return {?}
 */
mxCell.prototype.getEdgeCount = function() {
  return null == this.edges ? 0 : this.edges.length;
};
/**
 * @param {!Array} value
 * @return {?}
 */
mxCell.prototype.getEdgeIndex = function(value) {
  return mxUtils.indexOf(this.edges, value);
};
/**
 * @param {!Object} name
 * @return {?}
 */
mxCell.prototype.getEdgeAt = function(name) {
  return null == this.edges ? null : this.edges[name];
};
/**
 * @param {!Object} value
 * @param {string} type
 * @return {?}
 */
mxCell.prototype.insertEdge = function(value, type) {
  if (null != value && (value.removeFromTerminal(type), value.setTerminal(this, type), null == this.edges || value.getTerminal(!type) != this || 0 > mxUtils.indexOf(this.edges, value))) {
    if (null == this.edges) {
      /** @type {!Array} */
      this.edges = [];
    }
    this.edges.push(value);
  }
  return value;
};
/**
 * @param {?} node
 * @param {string} id
 * @return {?}
 */
mxCell.prototype.removeEdge = function(node, id) {
  if (null != node) {
    if (node.getTerminal(!id) != this && null != this.edges) {
      var i = this.getEdgeIndex(node);
      if (0 <= i) {
        this.edges.splice(i, 1);
      }
    }
    node.setTerminal(null, id);
  }
  return node;
};
/**
 * @param {string} key
 * @return {undefined}
 */
mxCell.prototype.removeFromTerminal = function(key) {
  var result = this.getTerminal(key);
  if (null != result) {
    result.removeEdge(this, key);
  }
};
/**
 * @param {string} attribute
 * @return {?}
 */
mxCell.prototype.hasAttribute = function(attribute) {
  var image = this.getValue();
  return null != image && image.nodeType == mxConstants.NODETYPE_ELEMENT && image.hasAttribute ? image.hasAttribute(attribute) : null != image.getAttribute(attribute);
};
/**
 * @param {string} name
 * @param {string} setCompiled
 * @return {?}
 */
mxCell.prototype.getAttribute = function(name, setCompiled) {
  var shape = this.getValue();
  name = null != shape && shape.nodeType == mxConstants.NODETYPE_ELEMENT ? shape.getAttribute(name) : null;
  return null != name ? name : setCompiled;
};
/**
 * @param {string} name
 * @param {!Object} value
 * @return {undefined}
 */
mxCell.prototype.setAttribute = function(name, value) {
  var parent = this.getValue();
  if (null != parent && parent.nodeType == mxConstants.NODETYPE_ELEMENT) {
    parent.setAttribute(name, value);
  }
};
/**
 * @return {?}
 */
mxCell.prototype.clone = function() {
  var material = mxUtils.clone(this, this.mxTransient);
  material.setValue(this.cloneValue());
  return material;
};
/**
 * @param {!Object} val
 * @return {?}
 */
mxCell.prototype.cloneValue = function(val) {
  val = null != val ? val : this.getValue();
  if (null != val) {
    if ("function" == typeof val.clone) {
      val = val.clone();
    } else {
      if (!isNaN(val.nodeType)) {
        val = val.cloneNode(true);
      }
    }
  }
  return val;
};
/**
 * @param {?} a
 * @param {?} b
 * @param {?} c
 * @param {?} quality
 * @return {undefined}
 */
function mxGeometry(a, b, c, quality) {
  mxRectangle.call(this, a, b, c, quality);
}
mxGeometry.prototype = new mxRectangle;
/** @type {function(?, ?, ?, ?): undefined} */
mxGeometry.prototype.constructor = mxGeometry;
/** @type {boolean} */
mxGeometry.prototype.TRANSLATE_CONTROL_POINTS = true;
/** @type {null} */
mxGeometry.prototype.alternateBounds = null;
/** @type {null} */
mxGeometry.prototype.sourcePoint = null;
/** @type {null} */
mxGeometry.prototype.targetPoint = null;
/** @type {null} */
mxGeometry.prototype.points = null;
/** @type {null} */
mxGeometry.prototype.offset = null;
/** @type {boolean} */
mxGeometry.prototype.relative = false;
/**
 * @return {undefined}
 */
mxGeometry.prototype.swap = function() {
  if (null != this.alternateBounds) {
    var d = new mxRectangle(this.x, this.y, this.width, this.height);
    this.x = this.alternateBounds.x;
    this.y = this.alternateBounds.y;
    this.width = this.alternateBounds.width;
    this.height = this.alternateBounds.height;
    this.alternateBounds = d;
  }
};
/**
 * @param {boolean} num
 * @return {?}
 */
mxGeometry.prototype.getTerminalPoint = function(num) {
  return num ? this.sourcePoint : this.targetPoint;
};
/**
 * @param {string} point
 * @param {boolean} fill
 * @return {?}
 */
mxGeometry.prototype.setTerminalPoint = function(point, fill) {
  if (fill) {
    /** @type {string} */
    this.sourcePoint = point;
  } else {
    /** @type {string} */
    this.targetPoint = point;
  }
  return point;
};
/**
 * @param {number} value
 * @param {undefined} d
 * @return {undefined}
 */
mxGeometry.prototype.rotate = function(value, d) {
  var y = mxUtils.toRadians(value);
  /** @type {number} */
  value = Math.cos(y);
  /** @type {number} */
  y = Math.sin(y);
  if (!this.relative) {
    var e = new mxPoint(this.getCenterX(), this.getCenterY());
    e = mxUtils.getRotatedPoint(e, value, y, d);
    /** @type {number} */
    this.x = Math.round(e.x - this.width / 2);
    /** @type {number} */
    this.y = Math.round(e.y - this.height / 2);
  }
  if (null != this.sourcePoint) {
    e = mxUtils.getRotatedPoint(this.sourcePoint, value, y, d);
    /** @type {number} */
    this.sourcePoint.x = Math.round(e.x);
    /** @type {number} */
    this.sourcePoint.y = Math.round(e.y);
  }
  if (null != this.targetPoint) {
    e = mxUtils.getRotatedPoint(this.targetPoint, value, y, d);
    /** @type {number} */
    this.targetPoint.x = Math.round(e.x);
    /** @type {number} */
    this.targetPoint.y = Math.round(e.y);
  }
  if (null != this.points) {
    /** @type {number} */
    var i = 0;
    for (; i < this.points.length; i++) {
      if (null != this.points[i]) {
        e = mxUtils.getRotatedPoint(this.points[i], value, y, d);
        /** @type {number} */
        this.points[i].x = Math.round(e.x);
        /** @type {number} */
        this.points[i].y = Math.round(e.y);
      }
    }
  }
};
/**
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxGeometry.prototype.translate = function(x, y) {
  /** @type {number} */
  x = parseFloat(x);
  /** @type {number} */
  y = parseFloat(y);
  if (!this.relative) {
    /** @type {number} */
    this.x = parseFloat(this.x) + x;
    /** @type {number} */
    this.y = parseFloat(this.y) + y;
  }
  if (null != this.sourcePoint) {
    /** @type {number} */
    this.sourcePoint.x = parseFloat(this.sourcePoint.x) + x;
    /** @type {number} */
    this.sourcePoint.y = parseFloat(this.sourcePoint.y) + y;
  }
  if (null != this.targetPoint) {
    /** @type {number} */
    this.targetPoint.x = parseFloat(this.targetPoint.x) + x;
    /** @type {number} */
    this.targetPoint.y = parseFloat(this.targetPoint.y) + y;
  }
  if (this.TRANSLATE_CONTROL_POINTS && null != this.points) {
    /** @type {number} */
    var i = 0;
    for (; i < this.points.length; i++) {
      if (null != this.points[i]) {
        /** @type {number} */
        this.points[i].x = parseFloat(this.points[i].x) + x;
        /** @type {number} */
        this.points[i].y = parseFloat(this.points[i].y) + y;
      }
    }
  }
};
/**
 * @param {number} value
 * @param {number} scale
 * @param {number} source
 * @return {undefined}
 */
mxGeometry.prototype.scale = function(value, scale, source) {
  /** @type {number} */
  value = parseFloat(value);
  /** @type {number} */
  scale = parseFloat(scale);
  if (null != this.sourcePoint) {
    /** @type {number} */
    this.sourcePoint.x = parseFloat(this.sourcePoint.x) * value;
    /** @type {number} */
    this.sourcePoint.y = parseFloat(this.sourcePoint.y) * scale;
  }
  if (null != this.targetPoint) {
    /** @type {number} */
    this.targetPoint.x = parseFloat(this.targetPoint.x) * value;
    /** @type {number} */
    this.targetPoint.y = parseFloat(this.targetPoint.y) * scale;
  }
  if (null != this.points) {
    /** @type {number} */
    var i = 0;
    for (; i < this.points.length; i++) {
      if (null != this.points[i]) {
        /** @type {number} */
        this.points[i].x = parseFloat(this.points[i].x) * value;
        /** @type {number} */
        this.points[i].y = parseFloat(this.points[i].y) * scale;
      }
    }
  }
  if (!this.relative) {
    /** @type {number} */
    this.x = parseFloat(this.x) * value;
    /** @type {number} */
    this.y = parseFloat(this.y) * scale;
    if (source) {
      /** @type {number} */
      scale = value = Math.min(value, scale);
    }
    /** @type {number} */
    this.width = parseFloat(this.width) * value;
    /** @type {number} */
    this.height = parseFloat(this.height) * scale;
  }
};
/**
 * @param {!Object} d
 * @return {?}
 */
mxGeometry.prototype.equals = function(d) {
  return mxRectangle.prototype.equals.apply(this, arguments) && this.relative == d.relative && (null == this.sourcePoint && null == d.sourcePoint || null != this.sourcePoint && this.sourcePoint.equals(d.sourcePoint)) && (null == this.targetPoint && null == d.targetPoint || null != this.targetPoint && this.targetPoint.equals(d.targetPoint)) && (null == this.points && null == d.points || null != this.points && mxUtils.equalPoints(this.points, d.points)) && (null == this.alternateBounds && null == d.alternateBounds || 
  null != this.alternateBounds && this.alternateBounds.equals(d.alternateBounds)) && (null == this.offset && null == d.offset || null != this.offset && this.offset.equals(d.offset));
};
var mxCellPath = {
  PATH_SEPARATOR : ".",
  create : function(n) {
    /** @type {string} */
    var s = "";
    if (null != n) {
      var item = n.getParent();
      for (; null != item;) {
        /** @type {string} */
        s = item.getIndex(n) + mxCellPath.PATH_SEPARATOR + s;
        n = item;
        item = n.getParent();
      }
    }
    /** @type {number} */
    n = s.length;
    if (1 < n) {
      /** @type {string} */
      s = s.substring(0, n - 1);
    }
    return s;
  },
  getParentPath : function(fullPath) {
    if (null != fullPath) {
      var firstSlash = fullPath.lastIndexOf(mxCellPath.PATH_SEPARATOR);
      if (0 <= firstSlash) {
        return fullPath.substring(0, firstSlash);
      }
      if (0 < fullPath.length) {
        return "";
      }
    }
    return null;
  },
  resolve : function(p, n) {
    if (null != n) {
      n = n.split(mxCellPath.PATH_SEPARATOR);
      /** @type {number} */
      var i = 0;
      for (; i < n.length; i++) {
        p = p.getChildAt(parseInt(n[i]));
      }
    }
    return p;
  },
  compare : function(a, b) {
    /** @type {number} */
    var i = Math.min(a.length, b.length);
    /** @type {number} */
    var _ref = 0;
    /** @type {number} */
    var j = 0;
    for (; j < i; j++) {
      if (a[j] != b[j]) {
        if (0 == a[j].length || 0 == b[j].length) {
          /** @type {number} */
          _ref = a[j] == b[j] ? 0 : a[j] > b[j] ? 1 : -1;
        } else {
          /** @type {number} */
          i = parseInt(a[j]);
          /** @type {number} */
          j = parseInt(b[j]);
          /** @type {number} */
          _ref = i == j ? 0 : i > j ? 1 : -1;
        }
        break;
      }
    }
    if (0 == _ref) {
      i = a.length;
      j = b.length;
      if (i != j) {
        /** @type {number} */
        _ref = i > j ? 1 : -1;
      }
    }
    return _ref;
  }
};
var mxPerimeter = {
  RectanglePerimeter : function(point, x, p, altCss) {
    x = point.getCenterX();
    var height = point.getCenterY();
    /** @type {number} */
    var angle = Math.atan2(p.y - height, p.x - x);
    var self = new mxPoint(0, 0);
    /** @type {number} */
    var stemBase = Math.PI;
    /** @type {number} */
    var y = Math.PI / 2 - angle;
    /** @type {number} */
    var hb = Math.atan2(point.height, point.width);
    if (angle < -stemBase + hb || angle > stemBase - hb) {
      self.x = point.x;
      /** @type {number} */
      self.y = height - point.width * Math.tan(angle) / 2;
    } else {
      if (angle < -hb) {
        self.y = point.y;
        /** @type {number} */
        self.x = x - point.height * Math.tan(y) / 2;
      } else {
        if (angle < hb) {
          self.x = point.x + point.width;
          self.y = height + point.width * Math.tan(angle) / 2;
        } else {
          self.y = point.y + point.height;
          self.x = x + point.height * Math.tan(y) / 2;
        }
      }
    }
    if (altCss) {
      if (p.x >= point.x && p.x <= point.x + point.width) {
        self.x = p.x;
      } else {
        if (p.y >= point.y && p.y <= point.y + point.height) {
          self.y = p.y;
        }
      }
      if (p.x < point.x) {
        self.x = point.x;
      } else {
        if (p.x > point.x + point.width) {
          self.x = point.x + point.width;
        }
      }
      if (p.y < point.y) {
        self.y = point.y;
      } else {
        if (p.y > point.y + point.height) {
          self.y = point.y + point.height;
        }
      }
    }
    return self;
  },
  EllipsePerimeter : function(s, x, i, forceOptional) {
    var a = s.x;
    var t = s.y;
    /** @type {number} */
    var d = s.width / 2;
    /** @type {number} */
    var b = s.height / 2;
    var y = a + d;
    var c = t + b;
    x = i.x;
    i = i.y;
    /** @type {number} */
    var h = parseInt(x - y);
    /** @type {number} */
    var w = parseInt(i - c);
    if (0 == h && 0 != w) {
      return new mxPoint(y, c + b * w / Math.abs(w));
    }
    if (0 == h && 0 == w) {
      return new mxPoint(x, i);
    }
    if (forceOptional) {
      if (i >= t && i <= t + s.height) {
        return s = i - c, s = Math.sqrt(d * d * (1 - s * s / (b * b))) || 0, x <= a && (s = -s), new mxPoint(y + s, i);
      }
      if (x >= a && x <= a + s.width) {
        return s = x - y, s = Math.sqrt(b * b * (1 - s * s / (d * d))) || 0, i <= t && (s = -s), new mxPoint(x, c + s);
      }
    }
    /** @type {number} */
    a = w / h;
    /** @type {number} */
    c = c - a * y;
    /** @type {number} */
    t = d * d * a * a + b * b;
    /** @type {number} */
    s = -2 * y * t;
    /** @type {number} */
    b = Math.sqrt(s * s - 4 * t * (d * d * a * a * y * y + b * b * y * y - d * d * b * b));
    /** @type {number} */
    d = (-s + b) / (2 * t);
    /** @type {number} */
    y = (-s - b) / (2 * t);
    b = a * d + c;
    c = a * y + c;
    if (Math.sqrt(Math.pow(d - x, 2) + Math.pow(b - i, 2)) < Math.sqrt(Math.pow(y - x, 2) + Math.pow(c - i, 2))) {
      /** @type {number} */
      x = d;
      i = b;
    } else {
      /** @type {number} */
      x = y;
      i = c;
    }
    return new mxPoint(x, i);
  },
  RhombusPerimeter : function(size, x, index, _$suspendResize) {
    x = size.x;
    var h = size.y;
    var l = size.width;
    size = size.height;
    var n = x + l / 2;
    var count = h + size / 2;
    var i = index.x;
    index = index.y;
    if (n == i) {
      return count > index ? new mxPoint(n, h) : new mxPoint(n, h + size);
    }
    if (count == index) {
      return n > i ? new mxPoint(x, count) : new mxPoint(x + l, count);
    }
    var result = n;
    var before = count;
    if (_$suspendResize) {
      if (i >= x && i <= x + l) {
        result = i;
      } else {
        if (index >= h && index <= h + size) {
          before = index;
        }
      }
    }
    return i < n ? index < count ? mxUtils.intersection(i, index, result, before, n, h, x, count) : mxUtils.intersection(i, index, result, before, n, h + size, x, count) : index < count ? mxUtils.intersection(i, index, result, before, n, h, x + l, count) : mxUtils.intersection(i, index, result, before, n, h + size, x + l, count);
  },
  TrianglePerimeter : function(x, node, point, that) {
    node = null != node ? node.style[mxConstants.STYLE_DIRECTION] : null;
    /** @type {boolean} */
    var position = node == mxConstants.DIRECTION_NORTH || node == mxConstants.DIRECTION_SOUTH;
    var width = x.x;
    var y = x.y;
    var height = x.width;
    var r = x.height;
    x = width + height / 2;
    var top = y + r / 2;
    var bounds = new mxPoint(width, y);
    var target = new mxPoint(width + height, top);
    var pt = new mxPoint(width, y + r);
    if (node == mxConstants.DIRECTION_NORTH) {
      bounds = pt;
      target = new mxPoint(x, y);
      pt = new mxPoint(width + height, y + r);
    } else {
      if (node == mxConstants.DIRECTION_SOUTH) {
        target = new mxPoint(x, y + r);
        pt = new mxPoint(width + height, y);
      } else {
        if (node == mxConstants.DIRECTION_WEST) {
          bounds = new mxPoint(width + height, y);
          target = new mxPoint(width, top);
          pt = new mxPoint(width + height, y + r);
        }
      }
    }
    /** @type {number} */
    var a = point.x - x;
    /** @type {number} */
    var b = point.y - top;
    /** @type {number} */
    a = position ? Math.atan2(a, b) : Math.atan2(b, a);
    /** @type {number} */
    b = position ? Math.atan2(height, r) : Math.atan2(r, height);
    if (node == mxConstants.DIRECTION_NORTH || node == mxConstants.DIRECTION_WEST ? a > -b && a < b : a < -Math.PI + b || a > Math.PI - b) {
      point = that && (position && point.x >= bounds.x && point.x <= pt.x || !position && point.y >= bounds.y && point.y <= pt.y) ? position ? new mxPoint(point.x, bounds.y) : new mxPoint(bounds.x, point.y) : node == mxConstants.DIRECTION_NORTH ? new mxPoint(width + height / 2 + r * Math.tan(a) / 2, y + r) : node == mxConstants.DIRECTION_SOUTH ? new mxPoint(width + height / 2 - r * Math.tan(a) / 2, y) : node == mxConstants.DIRECTION_WEST ? new mxPoint(width + height, y + r / 2 + height * Math.tan(a) / 
      2) : new mxPoint(width, y + r / 2 - height * Math.tan(a) / 2);
    } else {
      if (that) {
        that = new mxPoint(x, top);
        if (point.y >= y && point.y <= y + r) {
          that.x = position ? x : node == mxConstants.DIRECTION_WEST ? width + height : width;
          that.y = point.y;
        } else {
          if (point.x >= width && point.x <= width + height) {
            that.x = point.x;
            that.y = position ? node == mxConstants.DIRECTION_NORTH ? y + r : y : top;
          }
        }
        x = that.x;
        top = that.y;
      }
      point = position && point.x <= width + height / 2 || !position && point.y <= y + r / 2 ? mxUtils.intersection(point.x, point.y, x, top, bounds.x, bounds.y, target.x, target.y) : mxUtils.intersection(point.x, point.y, x, top, target.x, target.y, pt.x, pt.y);
    }
    if (null == point) {
      point = new mxPoint(x, top);
    }
    return point;
  },
  HexagonPerimeter : function(value, cell, content, data) {
    var start = value.x;
    var x = value.y;
    var len = value.width;
    var y = value.height;
    var width = value.getCenterX();
    value = value.getCenterY();
    var i = content.x;
    var j = content.y;
    /** @type {number} */
    var index = -Math.atan2(j - value, i - width);
    /** @type {number} */
    var length = Math.PI;
    /** @type {number} */
    var max = Math.PI / 2;
    new mxPoint(width, value);
    cell = null != cell ? mxUtils.getValue(cell.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST) : mxConstants.DIRECTION_EAST;
    /** @type {boolean} */
    var t = cell == mxConstants.DIRECTION_NORTH || cell == mxConstants.DIRECTION_SOUTH;
    cell = new mxPoint;
    var item = new mxPoint;
    if (i < start && j < x || i < start && j > x + y || i > start + len && j < x || i > start + len && j > x + y) {
      /** @type {boolean} */
      data = false;
    }
    if (data) {
      if (t) {
        if (i == width) {
          if (j <= x) {
            return new mxPoint(width, x);
          }
          if (j >= x + y) {
            return new mxPoint(width, x + y);
          }
        } else {
          if (i < start) {
            if (j == x + y / 4) {
              return new mxPoint(start, x + y / 4);
            }
            if (j == x + 3 * y / 4) {
              return new mxPoint(start, x + 3 * y / 4);
            }
          } else {
            if (i > start + len) {
              if (j == x + y / 4) {
                return new mxPoint(start + len, x + y / 4);
              }
              if (j == x + 3 * y / 4) {
                return new mxPoint(start + len, x + 3 * y / 4);
              }
            } else {
              if (i == start) {
                if (j < value) {
                  return new mxPoint(start, x + y / 4);
                }
                if (j > value) {
                  return new mxPoint(start, x + 3 * y / 4);
                }
              } else {
                if (i == start + len) {
                  if (j < value) {
                    return new mxPoint(start + len, x + y / 4);
                  }
                  if (j > value) {
                    return new mxPoint(start + len, x + 3 * y / 4);
                  }
                }
              }
            }
          }
        }
        if (j == x) {
          return new mxPoint(width, x);
        }
        if (j == x + y) {
          return new mxPoint(width, x + y);
        }
        if (i < width) {
          if (j > x + y / 4 && j < x + 3 * y / 4) {
            cell = new mxPoint(start, x);
            item = new mxPoint(start, x + y);
          } else {
            if (j < x + y / 4) {
              cell = new mxPoint(start - Math.floor(.5 * len), x + Math.floor(.5 * y));
              item = new mxPoint(start + len, x - Math.floor(.25 * y));
            } else {
              if (j > x + 3 * y / 4) {
                cell = new mxPoint(start - Math.floor(.5 * len), x + Math.floor(.5 * y));
                item = new mxPoint(start + len, x + Math.floor(1.25 * y));
              }
            }
          }
        } else {
          if (i > width) {
            if (j > x + y / 4 && j < x + 3 * y / 4) {
              cell = new mxPoint(start + len, x);
              item = new mxPoint(start + len, x + y);
            } else {
              if (j < x + y / 4) {
                cell = new mxPoint(start, x - Math.floor(.25 * y));
                item = new mxPoint(start + Math.floor(1.5 * len), x + Math.floor(.5 * y));
              } else {
                if (j > x + 3 * y / 4) {
                  cell = new mxPoint(start + Math.floor(1.5 * len), x + Math.floor(.5 * y));
                  item = new mxPoint(start, x + Math.floor(1.25 * y));
                }
              }
            }
          }
        }
      } else {
        if (j == value) {
          if (i <= start) {
            return new mxPoint(start, x + y / 2);
          }
          if (i >= start + len) {
            return new mxPoint(start + len, x + y / 2);
          }
        } else {
          if (j < x) {
            if (i == start + len / 4) {
              return new mxPoint(start + len / 4, x);
            }
            if (i == start + 3 * len / 4) {
              return new mxPoint(start + 3 * len / 4, x);
            }
          } else {
            if (j > x + y) {
              if (i == start + len / 4) {
                return new mxPoint(start + len / 4, x + y);
              }
              if (i == start + 3 * len / 4) {
                return new mxPoint(start + 3 * len / 4, x + y);
              }
            } else {
              if (j == x) {
                if (i < width) {
                  return new mxPoint(start + len / 4, x);
                }
                if (i > width) {
                  return new mxPoint(start + 3 * len / 4, x);
                }
              } else {
                if (j == x + y) {
                  if (i < width) {
                    return new mxPoint(start + len / 4, x + y);
                  }
                  if (j > value) {
                    return new mxPoint(start + 3 * len / 4, x + y);
                  }
                }
              }
            }
          }
        }
        if (i == start) {
          return new mxPoint(start, value);
        }
        if (i == start + len) {
          return new mxPoint(start + len, value);
        }
        if (j < value) {
          if (i > start + len / 4 && i < start + 3 * len / 4) {
            cell = new mxPoint(start, x);
            item = new mxPoint(start + len, x);
          } else {
            if (i < start + len / 4) {
              cell = new mxPoint(start - Math.floor(.25 * len), x + y);
              item = new mxPoint(start + Math.floor(.5 * len), x - Math.floor(.5 * y));
            } else {
              if (i > start + 3 * len / 4) {
                cell = new mxPoint(start + Math.floor(.5 * len), x - Math.floor(.5 * y));
                item = new mxPoint(start + Math.floor(1.25 * len), x + y);
              }
            }
          }
        } else {
          if (j > value) {
            if (i > start + len / 4 && i < start + 3 * len / 4) {
              cell = new mxPoint(start, x + y);
              item = new mxPoint(start + len, x + y);
            } else {
              if (i < start + len / 4) {
                cell = new mxPoint(start - Math.floor(.25 * len), x);
                item = new mxPoint(start + Math.floor(.5 * len), x + Math.floor(1.5 * y));
              } else {
                if (i > start + 3 * len / 4) {
                  cell = new mxPoint(start + Math.floor(.5 * len), x + Math.floor(1.5 * y));
                  item = new mxPoint(start + Math.floor(1.25 * len), x);
                }
              }
            }
          }
        }
      }
      data = width;
      /** @type {number} */
      index = value;
      if (i >= start && i <= start + len) {
        data = i;
        index = j < value ? x + y : x;
      } else {
        if (j >= x && j <= x + y) {
          index = j;
          data = i < width ? start + len : start;
        }
      }
      content = mxUtils.intersection(data, index, content.x, content.y, cell.x, cell.y, item.x, item.y);
    } else {
      if (t) {
        /** @type {number} */
        i = Math.atan2(y / 4, len / 2);
        if (index == i) {
          return new mxPoint(start + len, x + Math.floor(.25 * y));
        }
        if (index == max) {
          return new mxPoint(start + Math.floor(.5 * len), x);
        }
        if (index == length - i) {
          return new mxPoint(start, x + Math.floor(.25 * y));
        }
        if (index == -i) {
          return new mxPoint(start + len, x + Math.floor(.75 * y));
        }
        if (index == -max) {
          return new mxPoint(start + Math.floor(.5 * len), x + y);
        }
        if (index == -length + i) {
          return new mxPoint(start, x + Math.floor(.75 * y));
        }
        if (index < i && index > -i) {
          cell = new mxPoint(start + len, x);
          item = new mxPoint(start + len, x + y);
        } else {
          if (index > i && index < max) {
            cell = new mxPoint(start, x - Math.floor(.25 * y));
            item = new mxPoint(start + Math.floor(1.5 * len), x + Math.floor(.5 * y));
          } else {
            if (index > max && index < length - i) {
              cell = new mxPoint(start - Math.floor(.5 * len), x + Math.floor(.5 * y));
              item = new mxPoint(start + len, x - Math.floor(.25 * y));
            } else {
              if (index > length - i && index <= length || index < -length + i && index >= -length) {
                cell = new mxPoint(start, x);
                item = new mxPoint(start, x + y);
              } else {
                if (index < -i && index > -max) {
                  cell = new mxPoint(start + Math.floor(1.5 * len), x + Math.floor(.5 * y));
                  item = new mxPoint(start, x + Math.floor(1.25 * y));
                } else {
                  if (index < -max && index > -length + i) {
                    cell = new mxPoint(start - Math.floor(.5 * len), x + Math.floor(.5 * y));
                    item = new mxPoint(start + len, x + Math.floor(1.25 * y));
                  }
                }
              }
            }
          }
        }
      } else {
        /** @type {number} */
        i = Math.atan2(y / 2, len / 4);
        if (index == i) {
          return new mxPoint(start + Math.floor(.75 * len), x);
        }
        if (index == length - i) {
          return new mxPoint(start + Math.floor(.25 * len), x);
        }
        if (index == length || index == -length) {
          return new mxPoint(start, x + Math.floor(.5 * y));
        }
        if (0 == index) {
          return new mxPoint(start + len, x + Math.floor(.5 * y));
        }
        if (index == -i) {
          return new mxPoint(start + Math.floor(.75 * len), x + y);
        }
        if (index == -length + i) {
          return new mxPoint(start + Math.floor(.25 * len), x + y);
        }
        if (0 < index && index < i) {
          cell = new mxPoint(start + Math.floor(.5 * len), x - Math.floor(.5 * y));
          item = new mxPoint(start + Math.floor(1.25 * len), x + y);
        } else {
          if (index > i && index < length - i) {
            cell = new mxPoint(start, x);
            item = new mxPoint(start + len, x);
          } else {
            if (index > length - i && index < length) {
              cell = new mxPoint(start - Math.floor(.25 * len), x + y);
              item = new mxPoint(start + Math.floor(.5 * len), x - Math.floor(.5 * y));
            } else {
              if (0 > index && index > -i) {
                cell = new mxPoint(start + Math.floor(.5 * len), x + Math.floor(1.5 * y));
                item = new mxPoint(start + Math.floor(1.25 * len), x);
              } else {
                if (index < -i && index > -length + i) {
                  cell = new mxPoint(start, x + y);
                  item = new mxPoint(start + len, x + y);
                } else {
                  if (index < -length + i && index > -length) {
                    cell = new mxPoint(start - Math.floor(.25 * len), x);
                    item = new mxPoint(start + Math.floor(.5 * len), x + Math.floor(1.5 * y));
                  }
                }
              }
            }
          }
        }
      }
      content = mxUtils.intersection(width, value, content.x, content.y, cell.x, cell.y, item.x, item.y);
    }
    return null == content ? new mxPoint(width, value) : content;
  }
};
/**
 * @param {!Object} graph
 * @param {number} type
 * @param {number} coords
 * @param {number} data
 * @param {number} story
 * @param {number} name
 * @param {string} value
 * @param {string} title
 * @param {?} annoations
 * @return {undefined}
 */
function mxPrintPreview(graph, type, coords, data, story, name, value, title, annoations) {
  /** @type {!Object} */
  this.graph = graph;
  this.scale = null != type ? type : 1 / graph.pageScale;
  this.border = null != data ? data : 0;
  this.pageFormat = mxRectangle.fromRectangle(null != coords ? coords : graph.pageFormat);
  this.title = null != title ? title : "Printer-friendly version";
  this.x0 = null != story ? story : 0;
  this.y0 = null != name ? name : 0;
  /** @type {string} */
  this.borderColor = value;
  this.pageSelector = null != annoations ? annoations : true;
}
/** @type {null} */
mxPrintPreview.prototype.graph = null;
/** @type {null} */
mxPrintPreview.prototype.pageFormat = null;
/** @type {null} */
mxPrintPreview.prototype.scale = null;
/** @type {number} */
mxPrintPreview.prototype.border = 0;
/** @type {number} */
mxPrintPreview.prototype.marginTop = 0;
/** @type {number} */
mxPrintPreview.prototype.marginBottom = 0;
/** @type {number} */
mxPrintPreview.prototype.x0 = 0;
/** @type {number} */
mxPrintPreview.prototype.y0 = 0;
/** @type {boolean} */
mxPrintPreview.prototype.autoOrigin = true;
/** @type {boolean} */
mxPrintPreview.prototype.printOverlays = false;
/** @type {boolean} */
mxPrintPreview.prototype.printControls = false;
/** @type {boolean} */
mxPrintPreview.prototype.printBackgroundImage = false;
/** @type {string} */
mxPrintPreview.prototype.backgroundColor = "#ffffff";
/** @type {null} */
mxPrintPreview.prototype.borderColor = null;
/** @type {null} */
mxPrintPreview.prototype.title = null;
/** @type {null} */
mxPrintPreview.prototype.pageSelector = null;
/** @type {null} */
mxPrintPreview.prototype.wnd = null;
/** @type {null} */
mxPrintPreview.prototype.targetWindow = null;
/** @type {number} */
mxPrintPreview.prototype.pageCount = 0;
/** @type {boolean} */
mxPrintPreview.prototype.clipping = true;
/**
 * @return {?}
 */
mxPrintPreview.prototype.getWindow = function() {
  return this.wnd;
};
/**
 * @return {?}
 */
mxPrintPreview.prototype.getDoctype = function() {
  /** @type {string} */
  var doctype = "";
  if (8 == document.documentMode) {
    /** @type {string} */
    doctype = '<meta http-equiv="X-UA-Compatible" content="IE=8">';
  } else {
    if (8 < document.documentMode) {
      /** @type {string} */
      doctype = '\x3c!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--\x3e';
    }
  }
  return doctype;
};
/**
 * @param {string} graph
 * @param {number} container
 * @param {number} count
 * @param {number} value
 * @param {?} buttons
 * @param {?} closeButton
 * @return {undefined}
 */
mxPrintPreview.prototype.appendGraph = function(graph, container, count, value, buttons, closeButton) {
  /** @type {string} */
  this.graph = graph;
  this.scale = null != container ? container : 1 / graph.pageScale;
  /** @type {number} */
  this.x0 = count;
  /** @type {number} */
  this.y0 = value;
  this.open(null, null, buttons, closeButton);
};
/**
 * @param {number} y
 * @param {!Object} parent
 * @param {?} buttons
 * @param {?} closeButton
 * @return {?}
 */
mxPrintPreview.prototype.open = function(y, parent, buttons, closeButton) {
  var e = this.graph.cellRenderer.initializeOverlay;
  /** @type {null} */
  var button = null;
  try {
    if (this.printOverlays) {
      /**
       * @param {!Object} context
       * @param {!Object} parentOptions
       * @return {undefined}
       */
      this.graph.cellRenderer.initializeOverlay = function(context, parentOptions) {
        parentOptions.init(context.view.getDrawPane());
      };
    }
    if (this.printControls) {
      /**
       * @param {!Object} state
       * @param {!Object} control
       * @param {boolean} handleEvents
       * @param {?} clickHandler
       * @return {undefined}
       */
      this.graph.cellRenderer.initControl = function(state, control, handleEvents, clickHandler) {
        control.dialect = state.view.graph.dialect;
        control.init(state.view.getDrawPane());
      };
    }
    this.wnd = null != parent ? parent : this.wnd;
    /** @type {boolean} */
    var is_document = false;
    if (null == this.wnd) {
      /** @type {boolean} */
      is_document = true;
      /** @type {(Window|null)} */
      this.wnd = window.open();
    }
    var doc = this.wnd.document;
    if (is_document) {
      var e = this.getDoctype();
      if (null != e && 0 < e.length) {
        doc.writeln(e);
      }
      if ("CSS1Compat" === document.compatMode) {
        doc.writeln("<!DOCTYPE html>");
      }
      doc.writeln("<html>");
      doc.writeln("<head>");
      this.writeHead(doc, y);
      doc.writeln("</head>");
      doc.writeln('<body class="mxPage">');
    }
    var box = this.graph.getGraphBounds().clone();
    var width = this.graph.getView().getScale();
    /** @type {number} */
    var zoom = width / this.scale;
    var point = this.graph.getView().getTranslate();
    if (!this.autoOrigin) {
      this.x0 -= point.x * this.scale;
      this.y0 -= point.y * this.scale;
      box.width += box.x;
      box.height += box.y;
      /** @type {number} */
      box.x = 0;
      /** @type {number} */
      this.border = box.y = 0;
    }
    /** @type {number} */
    var size = this.pageFormat.width - 2 * this.border;
    /** @type {number} */
    var texPerChild = this.pageFormat.height - 2 * this.border;
    this.pageFormat.height += this.marginTop + this.marginBottom;
    box.width /= zoom;
    box.height /= zoom;
    /** @type {number} */
    var height = Math.max(1, Math.ceil((box.width + this.x0) / size));
    /** @type {number} */
    var c = Math.max(1, Math.ceil((box.height + this.y0) / texPerChild));
    /** @type {number} */
    this.pageCount = height * c;
    var openScorm = mxUtils.bind(this, function() {
      if (this.pageSelector && (1 < c || 1 < height)) {
        var a = this.createPageSelector(c, height);
        doc.body.appendChild(a);
        if (mxClient.IS_IE && null == doc.documentMode || 5 == doc.documentMode || 8 == doc.documentMode || 7 == doc.documentMode) {
          /** @type {string} */
          a.style.position = "absolute";
          /**
           * @return {undefined}
           */
          var check = function() {
            /** @type {string} */
            a.style.top = (doc.body.scrollTop || doc.documentElement.scrollTop) + 10 + "px";
          };
          mxEvent.addListener(this.wnd, "scroll", function(canCreateDiscussions) {
            check();
          });
          mxEvent.addListener(this.wnd, "resize", function(canCreateDiscussions) {
            check();
          });
        }
      }
    });
    var parseInt = mxUtils.bind(this, function(e, OK) {
      if (null != this.borderColor) {
        e.style.borderColor = this.borderColor;
        /** @type {string} */
        e.style.borderStyle = "solid";
        /** @type {string} */
        e.style.borderWidth = "1px";
      }
      e.style.background = this.backgroundColor;
      if (buttons || OK) {
        /** @type {string} */
        e.style.pageBreakAfter = "always";
      }
      if (is_document && (mxClient.IS_IE || 11 <= document.documentMode || mxClient.IS_EDGE)) {
        doc.writeln(e.outerHTML);
        e.parentNode.removeChild(e);
      } else {
        if (mxClient.IS_IE || 11 <= document.documentMode || mxClient.IS_EDGE) {
          var div = doc.createElement("div");
          div.innerHTML = e.outerHTML;
          div = div.getElementsByTagName("div")[0];
          doc.body.appendChild(div);
          e.parentNode.removeChild(e);
        } else {
          e.parentNode.removeChild(e);
          doc.body.appendChild(e);
        }
      }
      if (buttons || OK) {
        this.addPageBreak(doc);
      }
    });
    var enmlHash = this.getCoverPages(this.pageFormat.width, this.pageFormat.height);
    if (null != enmlHash) {
      /** @type {number} */
      var i = 0;
      for (; i < enmlHash.length; i++) {
        parseInt(enmlHash[i], true);
      }
    }
    var number = this.getAppendices(this.pageFormat.width, this.pageFormat.height);
    /** @type {number} */
    i = 0;
    for (; i < c; i++) {
      /** @type {number} */
      var hex = i * texPerChild / this.scale - this.y0 / this.scale + (box.y - point.y * width) / width;
      /** @type {number} */
      y = 0;
      for (; y < height; y++) {
        if (null == this.wnd) {
          return null;
        }
        /** @type {number} */
        var msgB = y * size / this.scale - this.x0 / this.scale + (box.x - point.x * width) / width;
        /** @type {number} */
        var color = i * height + y + 1;
        var b = new mxRectangle(msgB, hex, size, texPerChild);
        button = this.renderPage(this.pageFormat.width, this.pageFormat.height, 0, 0, mxUtils.bind(this, function(virtualCube) {
          this.addGraphFragment(-msgB, -hex, this.scale, color, virtualCube, b);
          if (this.printBackgroundImage) {
            this.insertBackgroundImage(virtualCube, -msgB, -hex);
          }
        }), color);
        button.setAttribute("id", "mxPage-" + color);
        parseInt(button, null != number || i < c - 1 || y < height - 1);
      }
    }
    if (null != number) {
      /** @type {number} */
      i = 0;
      for (; i < number.length; i++) {
        parseInt(number[i], i < number.length - 1);
      }
    }
    if (is_document && !closeButton) {
      this.closeDocument();
      openScorm();
    }
    this.wnd.focus();
  } catch (E) {
    if (null != button && null != button.parentNode) {
      button.parentNode.removeChild(button);
    }
  } finally {
    this.graph.cellRenderer.initializeOverlay = e;
  }
  return this.wnd;
};
/**
 * @param {!Object} doc
 * @return {undefined}
 */
mxPrintPreview.prototype.addPageBreak = function(doc) {
  var separator = doc.createElement("hr");
  /** @type {string} */
  separator.className = "mxPageBreak";
  doc.body.appendChild(separator);
};
/**
 * @return {undefined}
 */
mxPrintPreview.prototype.closeDocument = function() {
  try {
    if (null != this.wnd && null != this.wnd.document) {
      var iframeDocument = this.wnd.document;
      this.writePostfix(iframeDocument);
      iframeDocument.writeln("</body>");
      iframeDocument.writeln("</html>");
      iframeDocument.close();
      mxEvent.release(iframeDocument.body);
    }
  } catch (b) {
  }
};
/**
 * @param {!Object} target
 * @param {?} s
 * @return {undefined}
 */
mxPrintPreview.prototype.writeHead = function(target, s) {
  if (null != this.title) {
    target.writeln("<title>" + this.title + "</title>");
  }
  mxClient.link("stylesheet", mxClient.basePath + "/css/common.css", target);
  target.writeln('<style type="text/css">');
  target.writeln("@media print {");
  target.writeln("  * { -webkit-print-color-adjust: exact; }");
  target.writeln("  table.mxPageSelector { display: none; }");
  target.writeln("  hr.mxPageBreak { display: none; }");
  target.writeln("}");
  target.writeln("@media screen {");
  target.writeln("  table.mxPageSelector { position: fixed; right: 10px; top: 10px;font-family: Arial; font-size:10pt; border: solid 1px darkgray;background: white; border-collapse:collapse; }");
  target.writeln("  table.mxPageSelector td { border: solid 1px gray; padding:4px; }");
  target.writeln("  body.mxPage { background: gray; }");
  target.writeln("}");
  if (null != s) {
    target.writeln(s);
  }
  target.writeln("</style>");
};
/**
 * @param {?} object
 * @return {undefined}
 */
mxPrintPreview.prototype.writePostfix = function(object) {
};
/**
 * @param {number} n
 * @param {number} p
 * @return {?}
 */
mxPrintPreview.prototype.createPageSelector = function(n, p) {
  var document = this.wnd.document;
  var element = document.createElement("table");
  /** @type {string} */
  element.className = "mxPageSelector";
  element.setAttribute("border", "0");
  var body = document.createElement("tbody");
  /** @type {number} */
  var start = 0;
  for (; start < n; start++) {
    var g = document.createElement("tr");
    /** @type {number} */
    var startAngle = 0;
    for (; startAngle < p; startAngle++) {
      /** @type {number} */
      var value = start * p + startAngle + 1;
      var m = document.createElement("td");
      var link = document.createElement("a");
      link.setAttribute("href", "#mxPage-" + value);
      if (!(!mxClient.IS_NS || mxClient.IS_SF || mxClient.IS_GC)) {
        link.setAttribute("onclick", "var page = document.getElementById('mxPage-" + value + "');page.scrollIntoView(true);event.preventDefault();");
      }
      mxUtils.write(link, value, document);
      m.appendChild(link);
      g.appendChild(m);
    }
    body.appendChild(g);
  }
  element.appendChild(body);
  return element;
};
/**
 * @param {number} position
 * @param {number} total
 * @param {number} name
 * @param {number} value
 * @param {?} render
 * @param {!Object} type
 * @return {?}
 */
mxPrintPreview.prototype.renderPage = function(position, total, name, value, render, type) {
  type = this.wnd.document;
  /** @type {!Element} */
  var d = document.createElement("div");
  /** @type {null} */
  var content = null;
  try {
    if (0 != name || 0 != value) {
      /** @type {string} */
      d.style.position = "relative";
      /** @type {string} */
      d.style.width = position + "px";
      /** @type {string} */
      d.style.height = total + "px";
      /** @type {string} */
      d.style.pageBreakInside = "avoid";
      /** @type {!Element} */
      var container = document.createElement("div");
      /** @type {string} */
      container.style.position = "relative";
      /** @type {string} */
      container.style.top = this.border + "px";
      /** @type {string} */
      container.style.left = this.border + "px";
      /** @type {string} */
      container.style.width = position - 2 * this.border + "px";
      /** @type {string} */
      container.style.height = total - 2 * this.border + "px";
      /** @type {string} */
      container.style.overflow = "hidden";
      /** @type {!Element} */
      var label = document.createElement("div");
      /** @type {string} */
      label.style.position = "relative";
      /** @type {string} */
      label.style.marginLeft = name + "px";
      /** @type {string} */
      label.style.marginTop = value + "px";
      if (8 == type.documentMode) {
        /** @type {string} */
        container.style.position = "absolute";
        /** @type {string} */
        label.style.position = "absolute";
      }
      if (10 == type.documentMode) {
        /** @type {string} */
        label.style.width = "100%";
        /** @type {string} */
        label.style.height = "100%";
      }
      container.appendChild(label);
      d.appendChild(container);
      document.body.appendChild(d);
      /** @type {!Element} */
      content = label;
    } else {
      /** @type {string} */
      d.style.width = position + "px";
      /** @type {string} */
      d.style.height = total + "px";
      /** @type {string} */
      d.style.overflow = "hidden";
      /** @type {string} */
      d.style.pageBreakInside = "avoid";
      if (8 == type.documentMode) {
        /** @type {string} */
        d.style.position = "relative";
      }
      /** @type {!Element} */
      container = document.createElement("div");
      /** @type {string} */
      container.style.width = position - 2 * this.border + "px";
      /** @type {string} */
      container.style.height = total - 2 * this.border + "px";
      /** @type {string} */
      container.style.overflow = "hidden";
      if (!mxClient.IS_IE || null != type.documentMode && 5 != type.documentMode && 8 != type.documentMode && 7 != type.documentMode) {
        /** @type {string} */
        container.style.top = this.border + "px";
        /** @type {string} */
        container.style.left = this.border + "px";
      } else {
        /** @type {string} */
        container.style.marginTop = this.border + "px";
        /** @type {string} */
        container.style.marginLeft = this.border + "px";
      }
      d.appendChild(container);
      document.body.appendChild(d);
      /** @type {!Element} */
      content = container;
    }
  } catch (path1) {
    throw d.parentNode.removeChild(d), path1;
  }
  render(content);
  return d;
};
/**
 * @return {?}
 */
mxPrintPreview.prototype.getRoot = function() {
  var result = this.graph.view.currentRoot;
  if (null == result) {
    result = this.graph.getModel().getRoot();
  }
  return result;
};
/**
 * @return {?}
 */
mxPrintPreview.prototype.useCssTransforms = function() {
  return !mxClient.NO_FO && !mxClient.IS_SF;
};
/**
 * @param {!Object} object
 * @return {?}
 */
mxPrintPreview.prototype.isCellVisible = function(object) {
  return true;
};
/**
 * @param {!Object} s
 * @param {string} h
 * @param {!Object} t
 * @param {!Object} value
 * @param {!Object} node
 * @param {!Object} a
 * @return {undefined}
 */
mxPrintPreview.prototype.addGraphFragment = function(s, h, t, value, node, a) {
  var self = this.graph.getView();
  value = this.graph.container;
  /** @type {!Object} */
  this.graph.container = node;
  var width = self.getCanvas();
  var tickZoom = self.getBackgroundPane();
  var updateSynchronously = self.getDrawPane();
  var hpaDasUrl = self.getOverlayPane();
  /** @type {!Object} */
  var p = t;
  if (this.graph.dialect == mxConstants.DIALECT_SVG) {
    if (self.createSvg(), this.useCssTransforms()) {
      var inner = self.getDrawPane().parentNode;
      inner.getAttribute("transform");
      inner.setAttribute("transformOrigin", "0 0");
      inner.setAttribute("transform", "scale(" + t + "," + t + ")translate(" + s + "," + h + ")");
      /** @type {number} */
      t = 1;
      /** @type {number} */
      h = s = 0;
    }
  } else {
    self.createHtml();
  }
  inner = self.isEventsEnabled();
  self.setEventsEnabled(false);
  var name = this.graph.isEnabled();
  this.graph.setEnabled(false);
  var translate = self.getTranslate();
  self.translate = new mxPoint(s, h);
  var redraw = this.graph.cellRenderer.redraw;
  var graph = self.states;
  s = self.scale;
  if (this.clipping) {
    var tmp = new mxRectangle((a.x + translate.x) * s, (a.y + translate.y) * s, a.width * s / p, a.height * s / p);
    var me = this;
    /**
     * @param {?} item
     * @param {boolean} force
     * @param {?} event
     * @return {undefined}
     */
    this.graph.cellRenderer.redraw = function(item, force, event) {
      if (null != item) {
        var value = graph.get(item.cell);
        if (null != value && (value = self.getBoundingBox(value, false), null != value && 0 < value.width && 0 < value.height && !mxUtils.intersects(tmp, value)) || !me.isCellVisible(item.cell)) {
          return;
        }
      }
      redraw.apply(this, arguments);
    };
  }
  /** @type {null} */
  s = null;
  try {
    /** @type {!Array} */
    var r = [this.getRoot()];
    s = new mxTemporaryCellStates(self, t, r, null, mxUtils.bind(this, function(b_val) {
      return this.getLinkForCellState(b_val);
    }));
  } finally {
    if (mxClient.IS_IE) {
      /** @type {string} */
      self.overlayPane.innerText = "";
      /** @type {string} */
      self.canvas.style.overflow = "hidden";
      /** @type {string} */
      self.canvas.style.position = "relative";
      /** @type {string} */
      self.canvas.style.top = this.marginTop + "px";
      /** @type {string} */
      self.canvas.style.width = a.width + "px";
      /** @type {string} */
      self.canvas.style.height = a.height + "px";
    } else {
      t = node.firstChild;
      for (; null != t;) {
        r = t.nextSibling;
        h = t.nodeName.toLowerCase();
        if ("svg" == h) {
          /** @type {string} */
          t.style.overflow = "hidden";
          /** @type {string} */
          t.style.position = "relative";
          /** @type {string} */
          t.style.top = this.marginTop + "px";
          t.setAttribute("width", a.width);
          t.setAttribute("height", a.height);
          /** @type {string} */
          t.style.width = "";
          /** @type {string} */
          t.style.height = "";
        } else {
          if ("default" != t.style.cursor && "div" != h) {
            t.parentNode.removeChild(t);
          }
        }
        t = r;
      }
    }
    if (this.printBackgroundImage) {
      node = node.getElementsByTagName("svg");
      if (0 < node.length) {
        /** @type {string} */
        node[0].style.position = "absolute";
      }
    }
    self.overlayPane.parentNode.removeChild(self.overlayPane);
    this.graph.setEnabled(name);
    /** @type {!Object} */
    this.graph.container = value;
    this.graph.cellRenderer.redraw = redraw;
    self.canvas = width;
    self.backgroundPane = tickZoom;
    self.drawPane = updateSynchronously;
    self.overlayPane = hpaDasUrl;
    self.translate = translate;
    s.destroy();
    self.setEventsEnabled(inner);
  }
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxPrintPreview.prototype.getLinkForCellState = function(state) {
  return this.graph.getLinkForCell(state.cell);
};
/**
 * @param {!Node} container
 * @param {number} offset
 * @param {number} top
 * @return {undefined}
 */
mxPrintPreview.prototype.insertBackgroundImage = function(container, offset, top) {
  var frame = this.graph.backgroundImage;
  if (null != frame) {
    /** @type {!Element} */
    var img = document.createElement("img");
    /** @type {string} */
    img.style.position = "absolute";
    /** @type {string} */
    img.style.marginLeft = Math.round((offset + frame.x) * this.scale) + "px";
    /** @type {string} */
    img.style.marginTop = Math.round((top + frame.y) * this.scale) + "px";
    img.setAttribute("width", Math.round(frame.width * this.scale));
    img.setAttribute("height", Math.round(frame.height * this.scale));
    img.src = frame.src;
    container.insertBefore(img, container.firstChild);
  }
};
/**
 * @return {?}
 */
mxPrintPreview.prototype.getCoverPages = function() {
  return null;
};
/**
 * @return {?}
 */
mxPrintPreview.prototype.getAppendices = function() {
  return null;
};
/**
 * @param {!Object} e
 * @return {undefined}
 */
mxPrintPreview.prototype.print = function(e) {
  e = this.open(e);
  if (null != e) {
    e.print();
  }
};
/**
 * @return {undefined}
 */
mxPrintPreview.prototype.close = function() {
  if (null != this.wnd) {
    this.wnd.close();
    /** @type {null} */
    this.wnd = null;
  }
};
/**
 * @return {undefined}
 */
function mxStylesheet() {
  this.styles = {};
  this.putDefaultVertexStyle(this.createDefaultVertexStyle());
  this.putDefaultEdgeStyle(this.createDefaultEdgeStyle());
}
/**
 * @return {?}
 */
mxStylesheet.prototype.createDefaultVertexStyle = function() {
  var style = {};
  style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
  style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;
  style[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;
  style[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
  /** @type {string} */
  style[mxConstants.STYLE_FILLCOLOR] = "#C3D9FF";
  /** @type {string} */
  style[mxConstants.STYLE_STROKECOLOR] = "#6482B9";
  /** @type {string} */
  style[mxConstants.STYLE_FONTCOLOR] = "#774400";
  return style;
};
/**
 * @return {?}
 */
mxStylesheet.prototype.createDefaultEdgeStyle = function() {
  var style = {};
  style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_CONNECTOR;
  style[mxConstants.STYLE_ENDARROW] = mxConstants.ARROW_CLASSIC;
  style[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;
  style[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
  /** @type {string} */
  style[mxConstants.STYLE_STROKECOLOR] = "#6482B9";
  /** @type {string} */
  style[mxConstants.STYLE_FONTCOLOR] = "#446299";
  return style;
};
/**
 * @param {!Object} childCompute
 * @return {undefined}
 */
mxStylesheet.prototype.putDefaultVertexStyle = function(childCompute) {
  this.putCellStyle("defaultVertex", childCompute);
};
/**
 * @param {!Object} childCompute
 * @return {undefined}
 */
mxStylesheet.prototype.putDefaultEdgeStyle = function(childCompute) {
  this.putCellStyle("defaultEdge", childCompute);
};
/**
 * @return {?}
 */
mxStylesheet.prototype.getDefaultVertexStyle = function() {
  return this.styles.defaultVertex;
};
/**
 * @return {?}
 */
mxStylesheet.prototype.getDefaultEdgeStyle = function() {
  return this.styles.defaultEdge;
};
/**
 * @param {string} styleName
 * @param {!Object} value
 * @return {undefined}
 */
mxStylesheet.prototype.putCellStyle = function(styleName, value) {
  /** @type {!Object} */
  this.styles[styleName] = value;
};
/**
 * @param {?} a
 * @param {string} result
 * @param {?} record
 * @return {?}
 */
mxStylesheet.prototype.getCellStyle = function(a, result, record) {
  record = null != record ? record : true;
  if (null != a && 0 < a.length) {
    var logArrays = a.split(";");
    result = null != result && ";" != a.charAt(0) ? mxUtils.clone(result) : {};
    /** @type {number} */
    a = 0;
    for (; a < logArrays.length; a++) {
      var value = logArrays[a];
      var lastSpace = value.indexOf("=");
      if (0 <= lastSpace) {
        var name = value.substring(0, lastSpace);
        value = value.substring(lastSpace + 1);
        if (value == mxConstants.NONE && record) {
          delete result[name];
        } else {
          if (mxUtils.isNumeric(value)) {
            /** @type {number} */
            result[name] = parseFloat(value);
          } else {
            result[name] = value;
          }
        }
      } else {
        if (value = this.styles[value], null != value) {
          for (name in value) {
            result[name] = value[name];
          }
        }
      }
    }
  }
  return result;
};
/**
 * @param {string} view
 * @param {?} cell
 * @param {!Object} style
 * @return {undefined}
 */
function mxCellState(view, cell, style) {
  /** @type {string} */
  this.view = view;
  this.cell = cell;
  this.style = null != style ? style : {};
  this.origin = new mxPoint;
  this.absoluteOffset = new mxPoint;
}
mxCellState.prototype = new mxRectangle;
/** @type {function(string, ?, !Object): undefined} */
mxCellState.prototype.constructor = mxCellState;
/** @type {null} */
mxCellState.prototype.view = null;
/** @type {null} */
mxCellState.prototype.cell = null;
/** @type {null} */
mxCellState.prototype.style = null;
/** @type {boolean} */
mxCellState.prototype.invalidStyle = false;
/** @type {boolean} */
mxCellState.prototype.invalid = true;
/** @type {null} */
mxCellState.prototype.origin = null;
/** @type {null} */
mxCellState.prototype.absolutePoints = null;
/** @type {null} */
mxCellState.prototype.absoluteOffset = null;
/** @type {null} */
mxCellState.prototype.visibleSourceState = null;
/** @type {null} */
mxCellState.prototype.visibleTargetState = null;
/** @type {number} */
mxCellState.prototype.terminalDistance = 0;
/** @type {number} */
mxCellState.prototype.length = 0;
/** @type {null} */
mxCellState.prototype.segments = null;
/** @type {null} */
mxCellState.prototype.shape = null;
/** @type {null} */
mxCellState.prototype.text = null;
/** @type {null} */
mxCellState.prototype.unscaledWidth = null;
/** @type {null} */
mxCellState.prototype.unscaledHeight = null;
/**
 * @param {string} s
 * @param {number} data
 * @return {?}
 */
mxCellState.prototype.getPerimeterBounds = function(s, data) {
  s = s || 0;
  data = null != data ? data : new mxRectangle(this.x, this.y, this.width, this.height);
  if (null != this.shape && null != this.shape.stencil && "fixed" == this.shape.stencil.aspect) {
    var rect = this.shape.stencil.computeAspect(this.style, data.x, data.y, data.width, data.height);
    data.x = rect.x;
    data.y = rect.y;
    /** @type {number} */
    data.width = this.shape.stencil.w0 * rect.width;
    /** @type {number} */
    data.height = this.shape.stencil.h0 * rect.height;
  }
  if (0 != s) {
    data.grow(s);
  }
  return data;
};
/**
 * @param {!Object} a
 * @param {boolean} b
 * @return {undefined}
 */
mxCellState.prototype.setAbsoluteTerminalPoint = function(a, b) {
  if (b) {
    if (null == this.absolutePoints) {
      /** @type {!Array} */
      this.absolutePoints = [];
    }
    if (0 == this.absolutePoints.length) {
      this.absolutePoints.push(a);
    } else {
      /** @type {!Object} */
      this.absolutePoints[0] = a;
    }
  } else {
    if (null == this.absolutePoints) {
      /** @type {!Array} */
      this.absolutePoints = [];
      this.absolutePoints.push(null);
      this.absolutePoints.push(a);
    } else {
      if (1 == this.absolutePoints.length) {
        this.absolutePoints.push(a);
      } else {
        /** @type {!Object} */
        this.absolutePoints[this.absolutePoints.length - 1] = a;
      }
    }
  }
};
/**
 * @param {string} line
 * @return {undefined}
 */
mxCellState.prototype.setCursor = function(line) {
  if (null != this.shape) {
    this.shape.setCursor(line);
  }
  if (null != this.text) {
    this.text.setCursor(line);
  }
};
/**
 * @param {!Object} data
 * @return {?}
 */
mxCellState.prototype.isFloatingTerminalPoint = function(data) {
  var count = this.getVisibleTerminalState(data);
  if (null == count) {
    return false;
  }
  data = this.view.graph.getConnectionConstraint(this, count, data);
  return null == data || null == data.point;
};
/**
 * @param {?} o
 * @return {?}
 */
mxCellState.prototype.getVisibleTerminal = function(o) {
  o = this.getVisibleTerminalState(o);
  return null != o ? o.cell : null;
};
/**
 * @param {boolean} overlay
 * @return {?}
 */
mxCellState.prototype.getVisibleTerminalState = function(overlay) {
  return overlay ? this.visibleSourceState : this.visibleTargetState;
};
/**
 * @param {!Object} value
 * @param {boolean} expectedTriggered
 * @return {undefined}
 */
mxCellState.prototype.setVisibleTerminalState = function(value, expectedTriggered) {
  if (expectedTriggered) {
    /** @type {!Object} */
    this.visibleSourceState = value;
  } else {
    /** @type {!Object} */
    this.visibleTargetState = value;
  }
};
/**
 * @return {?}
 */
mxCellState.prototype.getCellBounds = function() {
  return this.cellBounds;
};
/**
 * @return {?}
 */
mxCellState.prototype.getPaintBounds = function() {
  return this.paintBounds;
};
/**
 * @return {undefined}
 */
mxCellState.prototype.updateCachedBounds = function() {
  var t = this.view.translate;
  var scale = this.view.scale;
  this.cellBounds = new mxRectangle(this.x / scale - t.x, this.y / scale - t.y, this.width / scale, this.height / scale);
  this.paintBounds = mxRectangle.fromRectangle(this.cellBounds);
  if (null != this.shape && this.shape.isPaintBoundsInverted()) {
    this.paintBounds.rotate90();
  }
};
/**
 * @param {!Object} options
 * @return {undefined}
 */
mxCellState.prototype.setState = function(options) {
  this.view = options.view;
  this.cell = options.cell;
  this.style = options.style;
  this.absolutePoints = options.absolutePoints;
  this.origin = options.origin;
  this.absoluteOffset = options.absoluteOffset;
  this.boundingBox = options.boundingBox;
  this.terminalDistance = options.terminalDistance;
  this.segments = options.segments;
  this.length = options.length;
  this.x = options.x;
  this.y = options.y;
  this.width = options.width;
  this.height = options.height;
  this.unscaledWidth = options.unscaledWidth;
  this.unscaledHeight = options.unscaledHeight;
};
/**
 * @return {?}
 */
mxCellState.prototype.clone = function() {
  var c = new mxCellState(this.view, this.cell, this.style);
  if (null != this.absolutePoints) {
    /** @type {!Array} */
    c.absolutePoints = [];
    /** @type {number} */
    var i = 0;
    for (; i < this.absolutePoints.length; i++) {
      c.absolutePoints[i] = this.absolutePoints[i].clone();
    }
  }
  if (null != this.origin) {
    c.origin = this.origin.clone();
  }
  if (null != this.absoluteOffset) {
    c.absoluteOffset = this.absoluteOffset.clone();
  }
  if (null != this.boundingBox) {
    c.boundingBox = this.boundingBox.clone();
  }
  c.terminalDistance = this.terminalDistance;
  c.segments = this.segments;
  c.length = this.length;
  c.x = this.x;
  c.y = this.y;
  c.width = this.width;
  c.height = this.height;
  c.unscaledWidth = this.unscaledWidth;
  c.unscaledHeight = this.unscaledHeight;
  return c;
};
/**
 * @return {undefined}
 */
mxCellState.prototype.destroy = function() {
  this.view.graph.cellRenderer.destroy(this);
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxGraphSelectionModel(targetGraph) {
  /** @type {!Object} */
  this.graph = targetGraph;
  /** @type {!Array} */
  this.cells = [];
}
mxGraphSelectionModel.prototype = new mxEventSource;
/** @type {function(!Object): undefined} */
mxGraphSelectionModel.prototype.constructor = mxGraphSelectionModel;
/** @type {string} */
mxGraphSelectionModel.prototype.doneResource = "none" != mxClient.language ? "done" : "";
/** @type {string} */
mxGraphSelectionModel.prototype.updatingSelectionResource = "none" != mxClient.language ? "updatingSelection" : "";
/** @type {null} */
mxGraphSelectionModel.prototype.graph = null;
/** @type {boolean} */
mxGraphSelectionModel.prototype.singleSelection = false;
/**
 * @return {?}
 */
mxGraphSelectionModel.prototype.isSingleSelection = function() {
  return this.singleSelection;
};
/**
 * @param {boolean} val
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.setSingleSelection = function(val) {
  /** @type {boolean} */
  this.singleSelection = val;
};
/**
 * @param {?} value
 * @return {?}
 */
mxGraphSelectionModel.prototype.isSelected = function(value) {
  return null != value ? 0 <= mxUtils.indexOf(this.cells, value) : false;
};
/**
 * @return {?}
 */
mxGraphSelectionModel.prototype.isEmpty = function() {
  return 0 == this.cells.length;
};
/**
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.clear = function() {
  this.changeSelection(null, this.cells);
};
/**
 * @param {!Object} opt_value
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.setCell = function(opt_value) {
  if (null != opt_value) {
    this.setCells([opt_value]);
  }
};
/**
 * @param {!Object} cells
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.setCells = function(cells) {
  if (null != cells) {
    if (this.singleSelection) {
      /** @type {!Array} */
      cells = [this.getFirstSelectableCell(cells)];
    }
    /** @type {!Array} */
    var temp = [];
    /** @type {number} */
    var i = 0;
    for (; i < cells.length; i++) {
      if (this.graph.isCellSelectable(cells[i])) {
        temp.push(cells[i]);
      }
    }
    this.changeSelection(temp, this.cells);
  }
};
/**
 * @param {!Object} cells
 * @return {?}
 */
mxGraphSelectionModel.prototype.getFirstSelectableCell = function(cells) {
  if (null != cells) {
    /** @type {number} */
    var i = 0;
    for (; i < cells.length; i++) {
      if (this.graph.isCellSelectable(cells[i])) {
        return cells[i];
      }
    }
  }
  return null;
};
/**
 * @param {string} item
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.addCell = function(item) {
  if (null != item) {
    this.addCells([item]);
  }
};
/**
 * @param {!Object} cells
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.addCells = function(cells) {
  if (null != cells) {
    /** @type {null} */
    var e = null;
    if (this.singleSelection) {
      e = this.cells;
      /** @type {!Array} */
      cells = [this.getFirstSelectableCell(cells)];
    }
    /** @type {!Array} */
    var temp = [];
    /** @type {number} */
    var i = 0;
    for (; i < cells.length; i++) {
      if (!this.isSelected(cells[i]) && this.graph.isCellSelectable(cells[i])) {
        temp.push(cells[i]);
      }
    }
    this.changeSelection(temp, e);
  }
};
/**
 * @param {?} index
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.removeCell = function(index) {
  if (null != index) {
    this.removeCells([index]);
  }
};
/**
 * @param {!Object} id
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.removeCells = function(id) {
  if (null != id) {
    /** @type {!Array} */
    var e = [];
    /** @type {number} */
    var i = 0;
    for (; i < id.length; i++) {
      if (this.isSelected(id[i])) {
        e.push(id[i]);
      }
    }
    this.changeSelection(null, e);
  }
};
/**
 * @param {!Object} source
 * @param {!Object} event
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.changeSelection = function(source, event) {
  if (null != source && 0 < source.length && null != source[0] || null != event && 0 < event.length && null != event[0]) {
    source = new mxSelectionChange(this, source, event);
    source.execute();
    event = new mxUndoableEdit(this, false);
    event.add(source);
    this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", event));
  }
};
/**
 * @param {?} cell
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.cellAdded = function(cell) {
  if (!(null == cell || this.isSelected(cell))) {
    this.cells.push(cell);
  }
};
/**
 * @param {number} i
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.cellRemoved = function(i) {
  if (null != i) {
    i = mxUtils.indexOf(this.cells, i);
    if (0 <= i) {
      this.cells.splice(i, 1);
    }
  }
};
/**
 * @param {boolean} is_key
 * @param {string} indent
 * @param {string} type
 * @return {undefined}
 */
function mxSelectionChange(is_key, indent, type) {
  /** @type {boolean} */
  this.selectionModel = is_key;
  this.added = null != indent ? indent.slice() : null;
  this.removed = null != type ? type.slice() : null;
}
/**
 * @return {undefined}
 */
mxSelectionChange.prototype.execute = function() {
  var path = mxLog.enter("mxSelectionChange.execute");
  window.status = mxResources.get(this.selectionModel.updatingSelectionResource) || this.selectionModel.updatingSelectionResource;
  if (null != this.removed) {
    /** @type {number} */
    var i = 0;
    for (; i < this.removed.length; i++) {
      this.selectionModel.cellRemoved(this.removed[i]);
    }
  }
  if (null != this.added) {
    /** @type {number} */
    i = 0;
    for (; i < this.added.length; i++) {
      this.selectionModel.cellAdded(this.added[i]);
    }
  }
  i = this.added;
  this.added = this.removed;
  this.removed = i;
  window.status = mxResources.get(this.selectionModel.doneResource) || this.selectionModel.doneResource;
  mxLog.leave("mxSelectionChange.execute", path);
  this.selectionModel.fireEvent(new mxEventObject(mxEvent.CHANGE, "added", this.added, "removed", this.removed));
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxCellEditor(targetGraph) {
  /** @type {!Object} */
  this.graph = targetGraph;
  this.zoomHandler = mxUtils.bind(this, function() {
    if (this.graph.isEditing()) {
      this.resize();
    }
  });
  this.graph.view.addListener(mxEvent.SCALE, this.zoomHandler);
  this.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.zoomHandler);
  this.changeHandler = mxUtils.bind(this, function(p_dom_object_id) {
    if (null != this.editingCell) {
      p_dom_object_id = this.graph.getView().getState(this.editingCell);
      if (null == p_dom_object_id) {
        this.stopEditing(true);
      } else {
        this.updateTextAreaStyle(p_dom_object_id);
      }
    }
  });
  this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
}
/** @type {null} */
mxCellEditor.prototype.graph = null;
/** @type {null} */
mxCellEditor.prototype.textarea = null;
/** @type {null} */
mxCellEditor.prototype.editingCell = null;
/** @type {null} */
mxCellEditor.prototype.trigger = null;
/** @type {boolean} */
mxCellEditor.prototype.modified = false;
/** @type {boolean} */
mxCellEditor.prototype.autoSize = true;
/** @type {boolean} */
mxCellEditor.prototype.selectText = true;
/** @type {string} */
mxCellEditor.prototype.emptyLabelText = mxClient.IS_FF ? "<br>" : "";
/** @type {boolean} */
mxCellEditor.prototype.escapeCancelsEditing = true;
/** @type {string} */
mxCellEditor.prototype.textNode = "";
/** @type {number} */
mxCellEditor.prototype.zIndex = 1;
mxCellEditor.prototype.minResize = new mxRectangle(0, 20);
/** @type {number} */
mxCellEditor.prototype.wordWrapPadding = 0;
/** @type {boolean} */
mxCellEditor.prototype.blurEnabled = false;
/** @type {null} */
mxCellEditor.prototype.initialValue = null;
/** @type {null} */
mxCellEditor.prototype.align = null;
/**
 * @return {undefined}
 */
mxCellEditor.prototype.init = function() {
  /** @type {!Element} */
  this.textarea = document.createElement("div");
  /** @type {string} */
  this.textarea.className = "mxCellEditor mxPlainTextEditor";
  /** @type {boolean} */
  this.textarea.contentEditable = true;
  if (mxClient.IS_GC) {
    /** @type {string} */
    this.textarea.style.minHeight = "1em";
  }
  /** @type {string} */
  this.textarea.style.position = this.isLegacyEditor() ? "absolute" : "relative";
  this.installListeners(this.textarea);
};
/**
 * @param {!Object} state
 * @param {string} value
 * @return {undefined}
 */
mxCellEditor.prototype.applyValue = function(state, value) {
  this.graph.labelChanged(state.cell, value, this.trigger);
};
/**
 * @param {string} align
 * @return {undefined}
 */
mxCellEditor.prototype.setAlign = function(align) {
  if (null != this.textarea) {
    /** @type {string} */
    this.textarea.style.textAlign = align;
  }
  /** @type {string} */
  this.align = align;
  this.resize();
};
/**
 * @param {!Object} data
 * @param {!Object} target
 * @return {?}
 */
mxCellEditor.prototype.getInitialValue = function(data, target) {
  data = mxUtils.htmlEntities(this.graph.getEditingValue(data.cell, target), false);
  if (8 != document.documentMode && 9 != document.documentMode && 10 != document.documentMode) {
    data = mxUtils.replaceTrailingNewlines(data, "<div><br></div>");
  }
  return data.replace(/\n/g, "<br>");
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxCellEditor.prototype.getCurrentValue = function(value) {
  return mxUtils.extractTextWithWhitespace(this.textarea.childNodes);
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxCellEditor.prototype.isCancelEditingKeyEvent = function(evt) {
  return this.escapeCancelsEditing || mxEvent.isShiftDown(evt) || mxEvent.isControlDown(evt) || mxEvent.isMetaDown(evt);
};
/**
 * @param {!Object} link
 * @return {undefined}
 */
mxCellEditor.prototype.installListeners = function(link) {
  mxEvent.addListener(link, "dragstart", mxUtils.bind(this, function(e) {
    this.graph.stopEditing(false);
    mxEvent.consume(e);
  }));
  mxEvent.addListener(link, "blur", mxUtils.bind(this, function(mmCoreSplitViewBlock) {
    if (this.blurEnabled) {
      this.focusLost(mmCoreSplitViewBlock);
    }
  }));
  mxEvent.addListener(link, "keydown", mxUtils.bind(this, function(evt) {
    if (!mxEvent.isConsumed(evt)) {
      if (this.isStopEditingEvent(evt)) {
        this.graph.stopEditing(false);
        mxEvent.consume(evt);
      } else {
        if (27 == evt.keyCode) {
          this.graph.stopEditing(this.isCancelEditingKeyEvent(evt));
          mxEvent.consume(evt);
        }
      }
    }
  }));
  var type = mxUtils.bind(this, function(event) {
    if (null != this.editingCell && this.clearOnChange && link.innerHTML == this.getEmptyLabelText() && (!mxClient.IS_FF || 8 != event.keyCode && 46 != event.keyCode)) {
      /** @type {boolean} */
      this.clearOnChange = false;
      /** @type {string} */
      link.innerText = "";
    }
  });
  mxEvent.addListener(link, "keypress", type);
  mxEvent.addListener(link, "paste", type);
  type = mxUtils.bind(this, function(canCreateDiscussions) {
    if (null != this.editingCell) {
      if (0 == this.textarea.innerHTML.length || "<br>" == this.textarea.innerHTML) {
        this.textarea.innerHTML = this.getEmptyLabelText();
        /** @type {boolean} */
        this.clearOnChange = 0 < this.textarea.innerHTML.length;
      } else {
        /** @type {boolean} */
        this.clearOnChange = false;
      }
    }
  });
  mxEvent.addListener(link, mxClient.IS_IE11 || mxClient.IS_IE ? "keyup" : "input", type);
  mxEvent.addListener(link, "cut", type);
  mxEvent.addListener(link, "paste", type);
  /** @type {string} */
  type = mxClient.IS_IE11 || mxClient.IS_IE ? "keydown" : "input";
  var textEditing = mxUtils.bind(this, function(evt) {
    if (null != this.editingCell && this.autoSize && !mxEvent.isConsumed(evt)) {
      if (null != this.resizeThread) {
        window.clearTimeout(this.resizeThread);
      }
      this.resizeThread = window.setTimeout(mxUtils.bind(this, function() {
        /** @type {null} */
        this.resizeThread = null;
        this.resize();
      }), 0);
    }
  });
  mxEvent.addListener(link, type, textEditing);
  mxEvent.addListener(window, "resize", textEditing);
  if (9 <= document.documentMode) {
    mxEvent.addListener(link, "DOMNodeRemoved", textEditing);
    mxEvent.addListener(link, "DOMNodeInserted", textEditing);
  } else {
    mxEvent.addListener(link, "cut", textEditing);
    mxEvent.addListener(link, "paste", textEditing);
  }
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxCellEditor.prototype.isStopEditingEvent = function(evt) {
  return 113 == evt.keyCode || this.graph.isEnterStopsCellEditing() && 13 == evt.keyCode && !mxEvent.isControlDown(evt) && !mxEvent.isShiftDown(evt);
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxCellEditor.prototype.isEventSource = function(e) {
  return mxEvent.getSource(e) == this.textarea;
};
/**
 * @return {undefined}
 */
mxCellEditor.prototype.resize = function() {
  var state = this.graph.getView().getState(this.editingCell);
  if (null == state) {
    this.stopEditing(true);
  } else {
    if (null != this.textarea) {
      var bounds = this.graph.getModel().isEdge(state.cell);
      var scale = this.graph.getView().scale;
      /** @type {null} */
      var b = null;
      if (this.autoSize && "fill" != state.style[mxConstants.STYLE_OVERFLOW]) {
        var y = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);
        b = null != state.text && null == this.align ? state.text.margin : null;
        if (null == b) {
          b = mxUtils.getAlignmentAsPoint(this.align || mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER), mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE));
        }
        if (bounds) {
          if (this.bounds = new mxRectangle(state.absoluteOffset.x, state.absoluteOffset.y, 0, 0), null != y) {
            /** @type {number} */
            var width = (parseFloat(y) + 2) * scale;
            /** @type {number} */
            this.bounds.width = width;
            this.bounds.x += b.x * width;
          }
        } else {
          bounds = mxRectangle.fromRectangle(state);
          var dy = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
          var valign = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
          bounds = null != state.shape && dy == mxConstants.ALIGN_CENTER && valign == mxConstants.ALIGN_MIDDLE ? state.shape.getLabelBounds(bounds) : bounds;
          if (null != y) {
            /** @type {number} */
            bounds.width = parseFloat(y) * scale;
          }
          if (!state.view.graph.cellRenderer.legacySpacing || "width" != state.style[mxConstants.STYLE_OVERFLOW] && "block" != state.style[mxConstants.STYLE_OVERFLOW]) {
            /** @type {number} */
            dy = parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_SPACING, 2)) * scale;
            /** @type {number} */
            var newHeight = (parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_SPACING_TOP, 0)) + mxText.prototype.baseSpacingTop) * scale + dy;
            /** @type {number} */
            var h = (parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_SPACING_RIGHT, 0)) + mxText.prototype.baseSpacingRight) * scale + dy;
            /** @type {number} */
            var newPos = (parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_SPACING_BOTTOM, 0)) + mxText.prototype.baseSpacingBottom) * scale + dy;
            /** @type {number} */
            var w2 = (parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_SPACING_LEFT, 0)) + mxText.prototype.baseSpacingLeft) * scale + dy;
            dy = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
            valign = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
            bounds = new mxRectangle(bounds.x + w2, bounds.y + newHeight, bounds.width - (dy == mxConstants.ALIGN_CENTER && null == y ? w2 + h : 0), bounds.height - (valign == mxConstants.ALIGN_MIDDLE ? newHeight + newPos : 0));
            if (this.graph.isHtmlLabel(state.cell)) {
              bounds.x -= mxSvgCanvas2D.prototype.foreignObjectPadding / 2;
              bounds.y -= mxSvgCanvas2D.prototype.foreignObjectPadding / 2;
              bounds.width += mxSvgCanvas2D.prototype.foreignObjectPadding;
            }
          }
          this.bounds = new mxRectangle(bounds.x + state.absoluteOffset.x, bounds.y + state.absoluteOffset.y, bounds.width, bounds.height);
        }
        if (this.graph.isWrapping(state.cell) && (2 <= this.bounds.width || 2 <= this.bounds.height)) {
          if (this.textarea.style.wordWrap = mxConstants.WORD_WRAP, this.textarea.style.whiteSpace = "normal", this.textarea.innerHTML != this.getEmptyLabelText()) {
            if (width = Math.round(this.bounds.width / scale) + this.wordWrapPadding, "relative" != this.textarea.style.position) {
              /** @type {string} */
              this.textarea.style.width = width + "px";
              if (this.textarea.scrollWidth > width) {
                /** @type {string} */
                this.textarea.style.width = this.textarea.scrollWidth + "px";
              }
            } else {
              if ("block" == state.style[mxConstants.STYLE_OVERFLOW] || "width" == state.style[mxConstants.STYLE_OVERFLOW]) {
                if (-.5 == b.y || "width" == state.style[mxConstants.STYLE_OVERFLOW]) {
                  /** @type {string} */
                  this.textarea.style.maxHeight = this.bounds.height + "px";
                }
                /** @type {string} */
                this.textarea.style.width = width + "px";
              } else {
                /** @type {string} */
                this.textarea.style.maxWidth = width + "px";
              }
            }
          } else {
            /** @type {string} */
            this.textarea.style.maxWidth = width + "px";
          }
        } else {
          /** @type {string} */
          this.textarea.style.whiteSpace = "nowrap";
          /** @type {string} */
          this.textarea.style.width = "";
        }
        if (8 == document.documentMode) {
          /** @type {string} */
          this.textarea.style.zoom = "1";
          /** @type {string} */
          this.textarea.style.height = "auto";
        }
        if (8 == document.documentMode) {
          state = this.textarea.scrollWidth;
          y = this.textarea.scrollHeight;
          /** @type {string} */
          this.textarea.style.left = Math.max(0, Math.ceil((this.bounds.x - b.x * (this.bounds.width - (state + 1) * scale) + state * (scale - 1) * 0 + 2 * (b.x + .5)) / scale)) + "px";
          /** @type {string} */
          this.textarea.style.top = Math.max(0, Math.ceil((this.bounds.y - b.y * (this.bounds.height - (y + .5) * scale) + y * (scale - 1) * 0 + 1 * Math.abs(b.y + .5)) / scale)) + "px";
          /** @type {string} */
          this.textarea.style.width = Math.round(state * scale) + "px";
          /** @type {string} */
          this.textarea.style.height = Math.round(y * scale) + "px";
        } else {
          /** @type {string} */
          this.textarea.style.left = Math.max(0, Math.round(this.bounds.x - b.x * (this.bounds.width - 2)) + 1) + "px";
          /** @type {string} */
          this.textarea.style.top = Math.max(0, Math.round(this.bounds.y - b.y * (this.bounds.height - 4) + (-1 == b.y ? 3 : 0)) + 1) + "px";
        }
      } else {
        this.bounds = this.getEditorBounds(state);
        /** @type {string} */
        this.textarea.style.width = Math.round(this.bounds.width / scale) + "px";
        /** @type {string} */
        this.textarea.style.height = Math.round(this.bounds.height / scale) + "px";
        if (8 == document.documentMode) {
          /** @type {string} */
          this.textarea.style.left = Math.round(this.bounds.x) + "px";
          /** @type {string} */
          this.textarea.style.top = Math.round(this.bounds.y) + "px";
        } else {
          /** @type {string} */
          this.textarea.style.left = Math.max(0, Math.round(this.bounds.x + 1)) + "px";
          /** @type {string} */
          this.textarea.style.top = Math.max(0, Math.round(this.bounds.y + 1)) + "px";
        }
        if (this.graph.isWrapping(state.cell) && (2 <= this.bounds.width || 2 <= this.bounds.height) && this.textarea.innerHTML != this.getEmptyLabelText()) {
          this.textarea.style.wordWrap = mxConstants.WORD_WRAP;
          /** @type {string} */
          this.textarea.style.whiteSpace = "normal";
          if ("fill" != state.style[mxConstants.STYLE_OVERFLOW]) {
            /** @type {string} */
            this.textarea.style.width = Math.round(this.bounds.width / scale) + this.wordWrapPadding + "px";
          }
        } else {
          /** @type {string} */
          this.textarea.style.whiteSpace = "nowrap";
          if ("fill" != state.style[mxConstants.STYLE_OVERFLOW]) {
            /** @type {string} */
            this.textarea.style.width = "";
          }
        }
      }
      mxUtils.setPrefixedStyle(this.textarea.style, "transformOrigin", "0px 0px");
      mxUtils.setPrefixedStyle(this.textarea.style, "transform", "scale(" + scale + "," + scale + ")" + (null == b ? "" : " translate(" + 100 * b.x + "%," + 100 * b.y + "%)"));
    }
  }
};
/**
 * @return {undefined}
 */
mxCellEditor.prototype.focusLost = function() {
  this.stopEditing(!this.graph.isInvokesStopCellEditing());
};
/**
 * @param {!Object} i
 * @return {?}
 */
mxCellEditor.prototype.getBackgroundColor = function(i) {
  return null;
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxCellEditor.prototype.getBorderColor = function(node) {
  return null;
};
/**
 * @return {?}
 */
mxCellEditor.prototype.isLegacyEditor = function() {
  /** @type {boolean} */
  var a = false;
  if (mxClient.IS_SVG) {
    var e = this.graph.view.getDrawPane().ownerSVGElement;
    if (null != e) {
      e = mxUtils.getCurrentStyle(e);
      if (null != e) {
        /** @type {boolean} */
        a = "absolute" == e.position;
      }
    }
  }
  return !a;
};
/**
 * @param {!Object} s
 * @return {undefined}
 */
mxCellEditor.prototype.updateTextAreaStyle = function(s) {
  this.graph.getView();
  var value = mxUtils.getValue(s.style, mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE);
  var val = mxUtils.getValue(s.style, mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY);
  var mainTextColor = mxUtils.getValue(s.style, mxConstants.STYLE_FONTCOLOR, "black");
  var alignment = mxUtils.getValue(s.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_LEFT);
  /** @type {boolean} */
  var bold = (mxUtils.getValue(s.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD;
  /** @type {boolean} */
  var textItalic = (mxUtils.getValue(s.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC;
  /** @type {!Array} */
  var textDecorations = [];
  if ((mxUtils.getValue(s.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    textDecorations.push("underline");
  }
  if ((mxUtils.getValue(s.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
    textDecorations.push("line-through");
  }
  this.textarea.style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? Math.round(value * mxConstants.LINE_HEIGHT) + "px" : mxConstants.LINE_HEIGHT;
  this.textarea.style.backgroundColor = this.getBackgroundColor(s);
  /** @type {string} */
  this.textarea.style.textDecoration = textDecorations.join(" ");
  /** @type {string} */
  this.textarea.style.fontWeight = bold ? "bold" : "normal";
  /** @type {string} */
  this.textarea.style.fontStyle = textItalic ? "italic" : "";
  /** @type {string} */
  this.textarea.style.fontSize = Math.round(value) + "px";
  this.textarea.style.zIndex = this.zIndex;
  this.textarea.style.fontFamily = val;
  this.textarea.style.textAlign = alignment;
  /** @type {string} */
  this.textarea.style.outline = "none";
  this.textarea.style.color = mainTextColor;
  value = this.getBorderColor(s);
  /** @type {string} */
  this.textarea.style.border = null != value ? "1px solid " + value : "none";
  value = this.textDirection = mxUtils.getValue(s.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);
  if (value == mxConstants.TEXT_DIRECTION_AUTO) {
    if (!(null == s || null == s.text || s.text.dialect == mxConstants.DIALECT_STRICTHTML || mxUtils.isNode(s.text.value))) {
      value = s.text.getAutoDirection();
    }
  }
  if (value == mxConstants.TEXT_DIRECTION_LTR || value == mxConstants.TEXT_DIRECTION_RTL) {
    this.textarea.setAttribute("dir", value);
  } else {
    this.textarea.removeAttribute("dir");
  }
};
/**
 * @param {!Object} cell
 * @param {!Object} val
 * @return {undefined}
 */
mxCellEditor.prototype.startEditing = function(cell, val) {
  this.stopEditing(true);
  /** @type {null} */
  this.align = null;
  if (null == this.textarea) {
    this.init();
  }
  if (null != this.graph.tooltipHandler) {
    this.graph.tooltipHandler.hideTooltip();
  }
  var state = this.graph.getView().getState(cell);
  if (null != state) {
    this.updateTextAreaStyle(state);
    this.textarea.innerHTML = this.getInitialValue(state, val) || "";
    this.initialValue = this.textarea.innerHTML;
    if (0 == this.textarea.innerHTML.length || "<br>" == this.textarea.innerHTML) {
      this.textarea.innerHTML = this.getEmptyLabelText();
      /** @type {boolean} */
      this.clearOnChange = true;
    } else {
      /** @type {boolean} */
      this.clearOnChange = this.textarea.innerHTML == this.getEmptyLabelText();
    }
    this.graph.container.appendChild(this.textarea);
    /** @type {!Object} */
    this.editingCell = cell;
    /** @type {!Object} */
    this.trigger = val;
    /** @type {null} */
    this.textNode = null;
    if (null != state.text && this.isHideLabel(state)) {
      this.textNode = state.text.node;
      /** @type {string} */
      this.textNode.style.visibility = "hidden";
    }
    if (this.autoSize && (this.graph.model.isEdge(state.cell) || "fill" != state.style[mxConstants.STYLE_OVERFLOW])) {
      window.setTimeout(mxUtils.bind(this, function() {
        this.resize();
      }), 0);
    }
    this.resize();
    try {
      this.textarea.focus();
      if (this.isSelectText() && 0 < this.textarea.innerHTML.length && (this.textarea.innerHTML != this.getEmptyLabelText() || !this.clearOnChange)) {
        document.execCommand("selectAll", false, null);
      }
    } catch (d) {
    }
  }
};
/**
 * @return {?}
 */
mxCellEditor.prototype.isSelectText = function() {
  return this.selectText;
};
/**
 * @return {undefined}
 */
mxCellEditor.prototype.clearSelection = function() {
  /** @type {null} */
  var selection = null;
  if (window.getSelection) {
    /** @type {(Selection|null)} */
    selection = window.getSelection();
  } else {
    if (document.selection) {
      /** @type {!Selection} */
      selection = document.selection;
    }
  }
  if (null != selection) {
    if (selection.empty) {
      selection.empty();
    } else {
      if (selection.removeAllRanges) {
        selection.removeAllRanges();
      }
    }
  }
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxCellEditor.prototype.stopEditing = function(value) {
  if (null != this.editingCell) {
    if (null != this.textNode) {
      /** @type {string} */
      this.textNode.style.visibility = "visible";
      /** @type {null} */
      this.textNode = null;
    }
    value = value ? null : this.graph.view.getState(this.editingCell);
    var content = this.initialValue;
    /** @type {null} */
    this.bounds = this.trigger = this.editingCell = this.initialValue = null;
    this.textarea.blur();
    this.clearSelection();
    if (null != this.textarea.parentNode) {
      this.textarea.parentNode.removeChild(this.textarea);
    }
    if (this.clearOnChange && this.textarea.innerHTML == this.getEmptyLabelText()) {
      /** @type {string} */
      this.textarea.innerText = "";
      /** @type {boolean} */
      this.clearOnChange = false;
    }
    if (null != value && (this.textarea.innerHTML != content || null != this.align)) {
      this.prepareTextarea();
      content = this.getCurrentValue(value);
      this.graph.getModel().beginUpdate();
      try {
        if (null != content) {
          this.applyValue(value, content);
        }
        if (null != this.align) {
          this.graph.setCellStyles(mxConstants.STYLE_ALIGN, this.align, [value.cell]);
        }
      } finally {
        this.graph.getModel().endUpdate();
      }
    }
    mxEvent.release(this.textarea);
    /** @type {null} */
    this.align = this.textarea = null;
  }
};
/**
 * @return {undefined}
 */
mxCellEditor.prototype.prepareTextarea = function() {
  if (null != this.textarea.lastChild && "BR" == this.textarea.lastChild.nodeName) {
    this.textarea.removeChild(this.textarea.lastChild);
  }
};
/**
 * @param {?} basecolumn
 * @return {?}
 */
mxCellEditor.prototype.isHideLabel = function(basecolumn) {
  return true;
};
/**
 * @param {!Object} a
 * @return {?}
 */
mxCellEditor.prototype.getMinimumSize = function(a) {
  var scale = this.graph.getView().scale;
  return new mxRectangle(0, 0, null == a.text ? 30 : a.text.size * scale + 20, "left" == this.textarea.style.textAlign ? 120 : 40);
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxCellEditor.prototype.getEditorBounds = function(node) {
  var valign = this.graph.getModel().isEdge(node.cell);
  var result = this.graph.getView().scale;
  var val = this.getMinimumSize(node);
  var height = val.width;
  val = val.height;
  if (!valign && node.view.graph.cellRenderer.legacySpacing && "fill" == node.style[mxConstants.STYLE_OVERFLOW]) {
    result = node.shape.getLabelBounds(mxRectangle.fromRectangle(node));
  } else {
    /** @type {number} */
    var r = parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING, 2)) * result;
    /** @type {number} */
    var v = (parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_TOP, 0)) + mxText.prototype.baseSpacingTop) * result + r;
    /** @type {number} */
    var w = (parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_RIGHT, 0)) + mxText.prototype.baseSpacingRight) * result + r;
    /** @type {number} */
    var m = (parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_BOTTOM, 0)) + mxText.prototype.baseSpacingBottom) * result + r;
    /** @type {number} */
    r = (parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_LEFT, 0)) + mxText.prototype.baseSpacingLeft) * result + r;
    result = new mxRectangle(node.x, node.y, Math.max(height, node.width - r - w), Math.max(val, node.height - v - m));
    w = mxUtils.getValue(node.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
    m = mxUtils.getValue(node.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
    if (this.graph.isHtmlLabel(node.cell)) {
      result.width += mxSvgCanvas2D.prototype.foreignObjectPadding;
    }
    result = null != node.shape && w == mxConstants.ALIGN_CENTER && m == mxConstants.ALIGN_MIDDLE ? node.shape.getLabelBounds(result) : result;
    if (valign) {
      result.x = node.absoluteOffset.x;
      result.y = node.absoluteOffset.y;
      if (null != node.text && null != node.text.boundingBox) {
        if (0 < node.text.boundingBox.x) {
          result.x = node.text.boundingBox.x;
        }
        if (0 < node.text.boundingBox.y) {
          result.y = node.text.boundingBox.y;
        }
      }
    } else {
      if (null != node.text && null != node.text.boundingBox) {
        /** @type {number} */
        result.x = Math.min(result.x, node.text.boundingBox.x);
        /** @type {number} */
        result.y = Math.min(result.y, node.text.boundingBox.y);
      }
    }
    result.x += r;
    result.y += v;
    if (null != node.text && null != node.text.boundingBox) {
      if (valign) {
        /** @type {number} */
        result.width = Math.max(height, node.text.boundingBox.width);
        /** @type {number} */
        result.height = Math.max(val, node.text.boundingBox.height);
      } else {
        /** @type {number} */
        result.width = Math.max(result.width, node.text.boundingBox.width);
        /** @type {number} */
        result.height = Math.max(result.height, node.text.boundingBox.height);
      }
    }
    if (this.graph.getModel().isVertex(node.cell)) {
      valign = mxUtils.getValue(node.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
      if (valign == mxConstants.ALIGN_LEFT) {
        result.x -= node.width;
      } else {
        if (valign == mxConstants.ALIGN_RIGHT) {
          result.x += node.width;
        }
      }
      valign = mxUtils.getValue(node.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
      if (valign == mxConstants.ALIGN_TOP) {
        result.y -= node.height;
      } else {
        if (valign == mxConstants.ALIGN_BOTTOM) {
          result.y += node.height;
        }
      }
    }
  }
  return new mxRectangle(Math.round(result.x), Math.round(result.y), Math.round(result.width), Math.round(result.height));
};
/**
 * @param {?} a
 * @return {?}
 */
mxCellEditor.prototype.getEmptyLabelText = function(a) {
  return this.emptyLabelText;
};
/**
 * @return {?}
 */
mxCellEditor.prototype.getEditingCell = function() {
  return this.editingCell;
};
/**
 * @return {undefined}
 */
mxCellEditor.prototype.destroy = function() {
  if (null != this.textarea) {
    mxEvent.release(this.textarea);
    if (null != this.textarea.parentNode) {
      this.textarea.parentNode.removeChild(this.textarea);
    }
    /** @type {null} */
    this.textarea = null;
  }
  if (null != this.changeHandler) {
    this.graph.getModel().removeListener(this.changeHandler);
    /** @type {null} */
    this.changeHandler = null;
  }
  if (this.zoomHandler) {
    this.graph.view.removeListener(this.zoomHandler);
    /** @type {null} */
    this.zoomHandler = null;
  }
};
/**
 * @return {undefined}
 */
function mxCellRenderer() {
}
mxCellRenderer.defaultShapes = {};
/** @type {function(?, ?, ?): undefined} */
mxCellRenderer.prototype.defaultEdgeShape = mxConnector;
/** @type {function(!Object, string, !Object, number): undefined} */
mxCellRenderer.prototype.defaultVertexShape = mxRectangleShape;
/** @type {function(!Object, !Object, string, string, string, string, number, string, number, number, number, number, number, number, string, ?, string, string, string, number, ?): undefined} */
mxCellRenderer.prototype.defaultTextShape = mxText;
/** @type {boolean} */
mxCellRenderer.prototype.legacyControlPosition = true;
/** @type {boolean} */
mxCellRenderer.prototype.legacySpacing = true;
/** @type {boolean} */
mxCellRenderer.prototype.antiAlias = true;
/** @type {number} */
mxCellRenderer.prototype.minSvgStrokeWidth = 1;
/** @type {boolean} */
mxCellRenderer.prototype.forceControlClickHandler = false;
/**
 * @param {string} javascriptName
 * @param {!Function} jsonName
 * @return {undefined}
 */
mxCellRenderer.registerShape = function(javascriptName, jsonName) {
  /** @type {!Function} */
  mxCellRenderer.defaultShapes[javascriptName] = jsonName;
};
mxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);
mxCellRenderer.registerShape(mxConstants.SHAPE_ELLIPSE, mxEllipse);
mxCellRenderer.registerShape(mxConstants.SHAPE_RHOMBUS, mxRhombus);
mxCellRenderer.registerShape(mxConstants.SHAPE_CYLINDER, mxCylinder);
mxCellRenderer.registerShape(mxConstants.SHAPE_CONNECTOR, mxConnector);
mxCellRenderer.registerShape(mxConstants.SHAPE_ACTOR, mxActor);
mxCellRenderer.registerShape(mxConstants.SHAPE_TRIANGLE, mxTriangle);
mxCellRenderer.registerShape(mxConstants.SHAPE_HEXAGON, mxHexagon);
mxCellRenderer.registerShape(mxConstants.SHAPE_CLOUD, mxCloud);
mxCellRenderer.registerShape(mxConstants.SHAPE_LINE, mxLine);
mxCellRenderer.registerShape(mxConstants.SHAPE_ARROW, mxArrow);
mxCellRenderer.registerShape(mxConstants.SHAPE_ARROW_CONNECTOR, mxArrowConnector);
mxCellRenderer.registerShape(mxConstants.SHAPE_DOUBLE_ELLIPSE, mxDoubleEllipse);
mxCellRenderer.registerShape(mxConstants.SHAPE_SWIMLANE, mxSwimlane);
mxCellRenderer.registerShape(mxConstants.SHAPE_IMAGE, mxImageShape);
mxCellRenderer.registerShape(mxConstants.SHAPE_LABEL, mxLabel);
/**
 * @param {!Object} self
 * @return {undefined}
 */
mxCellRenderer.prototype.initializeShape = function(self) {
  self.shape.dialect = self.view.graph.dialect;
  this.configureShape(self);
  self.shape.init(self.view.getDrawPane());
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxCellRenderer.prototype.createShape = function(state) {
  /** @type {null} */
  var name = null;
  if (null != state.style) {
    name = state.style[mxConstants.STYLE_SHAPE];
    name = null == mxCellRenderer.defaultShapes[name] ? mxStencilRegistry.getStencil(name) : null;
    name = null != name ? new mxShape(name) : new (this.getShapeConstructor(state));
  }
  return name;
};
/**
 * @param {!Object} block
 * @return {undefined}
 */
mxCellRenderer.prototype.createIndicatorShape = function(block) {
  block.shape.indicatorShape = this.getShape(block.view.graph.getIndicatorShape(block));
};
/**
 * @param {?} pKey
 * @return {?}
 */
mxCellRenderer.prototype.getShape = function(pKey) {
  return null != pKey ? mxCellRenderer.defaultShapes[pKey] : null;
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxCellRenderer.prototype.getShapeConstructor = function(state) {
  var shape = this.getShape(state.style[mxConstants.STYLE_SHAPE]);
  if (null == shape) {
    shape = state.view.graph.getModel().isEdge(state.cell) ? this.defaultEdgeShape : this.defaultVertexShape;
  }
  return shape;
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxCellRenderer.prototype.configureShape = function(data) {
  data.shape.apply(data);
  data.shape.image = data.view.graph.getImage(data);
  data.shape.indicatorColor = data.view.graph.getIndicatorColor(data);
  data.shape.indicatorStrokeColor = data.style[mxConstants.STYLE_INDICATOR_STROKECOLOR];
  data.shape.indicatorGradientColor = data.view.graph.getIndicatorGradientColor(data);
  data.shape.indicatorDirection = data.style[mxConstants.STYLE_INDICATOR_DIRECTION];
  data.shape.indicatorImage = data.view.graph.getIndicatorImage(data);
  this.postConfigureShape(data);
};
/**
 * @param {!Object} a
 * @return {undefined}
 */
mxCellRenderer.prototype.postConfigureShape = function(a) {
  if (null != a.shape) {
    this.resolveColor(a, "indicatorGradientColor", mxConstants.STYLE_GRADIENTCOLOR);
    this.resolveColor(a, "indicatorColor", mxConstants.STYLE_FILLCOLOR);
    this.resolveColor(a, "gradient", mxConstants.STYLE_GRADIENTCOLOR);
    this.resolveColor(a, "stroke", mxConstants.STYLE_STROKECOLOR);
    this.resolveColor(a, "fill", mxConstants.STYLE_FILLCOLOR);
  }
};
/**
 * @param {!Object} a
 * @return {?}
 */
mxCellRenderer.prototype.checkPlaceholderStyles = function(a) {
  if (null != a.style) {
    /** @type {!Array} */
    var str = ["inherit", "swimlane", "indicated"];
    /** @type {!Array} */
    var battrs = [mxConstants.STYLE_FILLCOLOR, mxConstants.STYLE_STROKECOLOR, mxConstants.STYLE_GRADIENTCOLOR, mxConstants.STYLE_FONTCOLOR];
    /** @type {number} */
    var i = 0;
    for (; i < battrs.length; i++) {
      if (0 <= mxUtils.indexOf(str, a.style[battrs[i]])) {
        return true;
      }
    }
  }
  return false;
};
/**
 * @param {!Object} state
 * @param {string} name
 * @param {string} type
 * @return {undefined}
 */
mxCellRenderer.prototype.resolveColor = function(state, name, type) {
  var elem = type == mxConstants.STYLE_FONTCOLOR ? state.text : state.shape;
  if (null != elem) {
    var node = state.view.graph;
    var id = elem[name];
    /** @type {null} */
    var key = null;
    if ("inherit" == id) {
      key = node.model.getParent(state.cell);
    } else {
      if ("swimlane" == id) {
        /** @type {string} */
        elem[name] = type == mxConstants.STYLE_STROKECOLOR || type == mxConstants.STYLE_FONTCOLOR ? "#000000" : "#ffffff";
        key = null != node.model.getTerminal(state.cell, false) ? node.model.getTerminal(state.cell, false) : state.cell;
        key = node.getSwimlane(key);
        type = node.swimlaneIndicatorColorAttribute;
      } else {
        if ("indicated" == id && null != state.shape) {
          elem[name] = state.shape.indicatorColor;
        } else {
          if (type != mxConstants.STYLE_FILLCOLOR && id == mxConstants.STYLE_FILLCOLOR && null != state.shape) {
            elem[name] = state.style[mxConstants.STYLE_FILLCOLOR];
          } else {
            if (type != mxConstants.STYLE_STROKECOLOR && id == mxConstants.STYLE_STROKECOLOR && null != state.shape) {
              elem[name] = state.style[mxConstants.STYLE_STROKECOLOR];
            }
          }
        }
      }
    }
    if (null != key) {
      state = node.getView().getState(key);
      /** @type {null} */
      elem[name] = null;
      if (null != state) {
        node = type == mxConstants.STYLE_FONTCOLOR ? state.text : state.shape;
        elem[name] = null != node && "indicatorColor" != name ? node[name] : state.style[type];
      }
    }
  }
};
/**
 * @param {!Object} self
 * @return {?}
 */
mxCellRenderer.prototype.getLabelValue = function(self) {
  return self.view.graph.getLabel(self.cell);
};
/**
 * @param {!Object} state
 * @param {!Object} node
 * @return {undefined}
 */
mxCellRenderer.prototype.createLabel = function(state, node) {
  var graph = state.view.graph;
  graph.getModel().isEdge(state.cell);
  if (0 < state.style[mxConstants.STYLE_FONTSIZE] || null == state.style[mxConstants.STYLE_FONTSIZE]) {
    var ls = graph.isHtmlLabel(state.cell) || null != node && mxUtils.isNode(node);
    state.text = new this.defaultTextShape(node, new mxRectangle, state.style[mxConstants.STYLE_ALIGN] || mxConstants.ALIGN_CENTER, graph.getVerticalAlign(state), state.style[mxConstants.STYLE_FONTCOLOR], state.style[mxConstants.STYLE_FONTFAMILY], state.style[mxConstants.STYLE_FONTSIZE], state.style[mxConstants.STYLE_FONTSTYLE], state.style[mxConstants.STYLE_SPACING], state.style[mxConstants.STYLE_SPACING_TOP], state.style[mxConstants.STYLE_SPACING_RIGHT], state.style[mxConstants.STYLE_SPACING_BOTTOM], 
    state.style[mxConstants.STYLE_SPACING_LEFT], state.style[mxConstants.STYLE_HORIZONTAL], state.style[mxConstants.STYLE_LABEL_BACKGROUNDCOLOR], state.style[mxConstants.STYLE_LABEL_BORDERCOLOR], graph.isWrapping(state.cell) && graph.isHtmlLabel(state.cell), graph.isLabelClipped(state.cell), state.style[mxConstants.STYLE_OVERFLOW], state.style[mxConstants.STYLE_LABEL_PADDING], mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION));
    state.text.opacity = mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_OPACITY, 100);
    state.text.dialect = ls ? mxConstants.DIALECT_STRICTHTML : state.view.graph.dialect;
    state.text.style = state.style;
    /** @type {!Object} */
    state.text.state = state;
    this.initializeLabel(state, state.text);
    this.configureShape(state);
    /** @type {boolean} */
    var e = false;
    /**
     * @param {!Array} e
     * @return {?}
     */
    var error = function(e) {
      /** @type {!Object} */
      var value = state;
      if (mxClient.IS_TOUCH || e) {
        value = mxEvent.getClientX(e);
        e = mxEvent.getClientY(e);
        e = mxUtils.convertPoint(graph.container, value, e);
        value = graph.view.getState(graph.getCellAt(e.x, e.y));
      }
      return value;
    };
    mxEvent.addGestureListeners(state.text.node, mxUtils.bind(this, function(evt) {
      if (this.isLabelEvent(state, evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));
        /** @type {boolean} */
        e = graph.dialect != mxConstants.DIALECT_SVG && "IMG" == mxEvent.getSource(evt).nodeName;
      }
    }), mxUtils.bind(this, function(evt) {
      if (this.isLabelEvent(state, evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, error(evt)));
      }
    }), mxUtils.bind(this, function(evt) {
      if (this.isLabelEvent(state, evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, error(evt)));
        /** @type {boolean} */
        e = false;
      }
    }));
    if (graph.nativeDblClickEnabled) {
      mxEvent.addListener(state.text.node, "dblclick", mxUtils.bind(this, function(e) {
        if (this.isLabelEvent(state, e)) {
          graph.dblClick(e, state.cell);
          mxEvent.consume(e);
        }
      }));
    }
  }
};
/**
 * @param {!Object} data
 * @param {!Object} graph
 * @return {undefined}
 */
mxCellRenderer.prototype.initializeLabel = function(data, graph) {
  if (mxClient.IS_SVG && mxClient.NO_FO && graph.dialect != mxConstants.DIALECT_SVG) {
    graph.init(data.view.graph.container);
  } else {
    graph.init(data.view.getDrawPane());
  }
};
/**
 * @param {!Object} self
 * @return {undefined}
 */
mxCellRenderer.prototype.createCellOverlays = function(self) {
  var data = self.view.graph.getCellOverlays(self.cell);
  /** @type {null} */
  var o = null;
  if (null != data) {
    o = new mxDictionary;
    /** @type {number} */
    var i = 0;
    for (; i < data.length; i++) {
      var options = null != self.overlays ? self.overlays.remove(data[i]) : null;
      if (null == options) {
        options = new mxImageShape(new mxRectangle, data[i].image.src);
        options.dialect = self.view.graph.dialect;
        /** @type {boolean} */
        options.preserveImageAspect = false;
        options.overlay = data[i];
        this.initializeOverlay(self, options);
        this.installCellOverlayListeners(self, data[i], options);
        if (null != data[i].cursor) {
          options.node.style.cursor = data[i].cursor;
        }
        o.put(data[i], options);
      } else {
        o.put(data[i], options);
      }
    }
  }
  if (null != self.overlays) {
    self.overlays.visit(function(canCreateDiscussions, anAlertDialog) {
      anAlertDialog.destroy();
    });
  }
  self.overlays = o;
};
/**
 * @param {!Object} context
 * @param {!Object} parentOptions
 * @return {undefined}
 */
mxCellRenderer.prototype.initializeOverlay = function(context, parentOptions) {
  parentOptions.init(context.view.getOverlayPane());
};
/**
 * @param {!Object} state
 * @param {!Object} win
 * @param {!Object} method
 * @return {undefined}
 */
mxCellRenderer.prototype.installCellOverlayListeners = function(state, win, method) {
  var graph = state.view.graph;
  mxEvent.addListener(method.node, "click", function(edit) {
    if (graph.isEditing()) {
      graph.stopEditing(!graph.isInvokesStopCellEditing());
    }
    win.fireEvent(new mxEventObject(mxEvent.CLICK, "event", edit, "cell", state.cell));
  });
  mxEvent.addGestureListeners(method.node, function(e) {
    mxEvent.consume(e);
  }, function(evt) {
    graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, state));
  });
  if (mxClient.IS_TOUCH) {
    mxEvent.addListener(method.node, "touchend", function(edit) {
      win.fireEvent(new mxEventObject(mxEvent.CLICK, "event", edit, "cell", state.cell));
    });
  }
};
/**
 * @param {!Object} self
 * @return {undefined}
 */
mxCellRenderer.prototype.createControl = function(self) {
  var graph = self.view.graph;
  var table = graph.getFoldingImage(self);
  if (graph.foldingEnabled && null != table) {
    if (null == self.control) {
      var size = new mxRectangle(0, 0, table.width, table.height);
      self.control = new mxImageShape(size, table.src);
      /** @type {boolean} */
      self.control.preserveImageAspect = false;
      self.control.dialect = graph.dialect;
      this.initControl(self, self.control, true, this.createControlClickHandler(self));
    }
  } else {
    if (null != self.control) {
      self.control.destroy();
      /** @type {null} */
      self.control = null;
    }
  }
};
/**
 * @param {!Object} n
 * @return {?}
 */
mxCellRenderer.prototype.createControlClickHandler = function(n) {
  var graph = n.view.graph;
  return mxUtils.bind(this, function(evt) {
    if (this.forceControlClickHandler || graph.isEnabled()) {
      /** @type {boolean} */
      var realVal = !graph.isCellCollapsed(n.cell);
      graph.foldCells(realVal, false, [n.cell], null, evt);
      mxEvent.consume(evt);
    }
  });
};
/**
 * @param {!Object} state
 * @param {!Object} control
 * @param {boolean} handleEvents
 * @param {?} clickHandler
 * @return {?}
 */
mxCellRenderer.prototype.initControl = function(state, control, handleEvents, clickHandler) {
  var graph = state.view.graph;
  if (graph.isHtmlLabel(state.cell) && mxClient.NO_FO && graph.dialect == mxConstants.DIALECT_SVG) {
    control.dialect = mxConstants.DIALECT_PREFERHTML;
    control.init(graph.container);
    /** @type {number} */
    control.node.style.zIndex = 1;
  } else {
    control.init(state.view.getOverlayPane());
  }
  control = control.innerNode || control.node;
  if (!(null == clickHandler || mxClient.IS_IOS)) {
    if (graph.isEnabled()) {
      /** @type {string} */
      control.style.cursor = "pointer";
    }
    mxEvent.addListener(control, "click", clickHandler);
  }
  if (handleEvents) {
    /** @type {null} */
    var first = null;
    mxEvent.addGestureListeners(control, function(evt) {
      first = new mxPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt));
      graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));
      mxEvent.consume(evt);
    }, function(evt) {
      graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, state));
    }, function(evt) {
      graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, state));
      mxEvent.consume(evt);
    });
    if (null != clickHandler && mxClient.IS_IOS) {
      control.addEventListener("touchend", function(evt) {
        if (null != first) {
          var tol = graph.tolerance;
          if (Math.abs(first.x - mxEvent.getClientX(evt)) < tol && Math.abs(first.y - mxEvent.getClientY(evt)) < tol) {
            clickHandler.call(clickHandler, evt);
            mxEvent.consume(evt);
          }
        }
      }, true);
    }
  }
  return control;
};
/**
 * @param {!Object} rows
 * @param {!Object} e
 * @return {?}
 */
mxCellRenderer.prototype.isShapeEvent = function(rows, e) {
  return true;
};
/**
 * @param {!Object} rows
 * @param {?} e
 * @return {?}
 */
mxCellRenderer.prototype.isLabelEvent = function(rows, e) {
  return true;
};
/**
 * @param {!Object} state
 * @return {undefined}
 */
mxCellRenderer.prototype.installListeners = function(state) {
  var graph = state.view.graph;
  /**
   * @param {!Array} e
   * @return {?}
   */
  var process = function(e) {
    /** @type {!Object} */
    var value = state;
    if (graph.dialect != mxConstants.DIALECT_SVG && "IMG" == mxEvent.getSource(e).nodeName || mxClient.IS_TOUCH) {
      value = mxEvent.getClientX(e);
      e = mxEvent.getClientY(e);
      e = mxUtils.convertPoint(graph.container, value, e);
      value = graph.view.getState(graph.getCellAt(e.x, e.y));
    }
    return value;
  };
  mxEvent.addGestureListeners(state.shape.node, mxUtils.bind(this, function(evt) {
    if (this.isShapeEvent(state, evt)) {
      graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));
    }
  }), mxUtils.bind(this, function(evt) {
    if (this.isShapeEvent(state, evt)) {
      graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, process(evt)));
    }
  }), mxUtils.bind(this, function(evt) {
    if (this.isShapeEvent(state, evt)) {
      graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, process(evt)));
    }
  }));
  if (graph.nativeDblClickEnabled) {
    mxEvent.addListener(state.shape.node, "dblclick", mxUtils.bind(this, function(e) {
      if (this.isShapeEvent(state, e)) {
        graph.dblClick(e, state.cell);
        mxEvent.consume(e);
      }
    }));
  }
};
/**
 * @param {!Object} self
 * @param {string} err
 * @return {undefined}
 */
mxCellRenderer.prototype.redrawLabel = function(self, err) {
  var data = self.view.graph;
  var value = this.getLabelValue(self);
  var undefined = data.isWrapping(self.cell);
  var change = data.isLabelClipped(self.cell);
  var dialect = self.view.graph.isHtmlLabel(self.cell) || null != value && mxUtils.isNode(value) ? mxConstants.DIALECT_STRICTHTML : self.view.graph.dialect;
  var overflow = self.style[mxConstants.STYLE_OVERFLOW] || "visible";
  if (!(null == self.text || self.text.wrap == undefined && self.text.clipped == change && self.text.overflow == overflow && self.text.dialect == dialect)) {
    self.text.destroy();
    /** @type {null} */
    self.text = null;
  }
  if (null == self.text && null != value && (mxUtils.isNode(value) || 0 < value.length)) {
    this.createLabel(self, value);
  } else {
    if (!(null == self.text || null != value && 0 != value.length)) {
      self.text.destroy();
      /** @type {null} */
      self.text = null;
    }
  }
  if (null != self.text) {
    if (err) {
      if (null != self.text.lastValue && this.isTextShapeInvalid(self, self.text)) {
        /** @type {null} */
        self.text.lastValue = null;
      }
      self.text.resetStyles();
      self.text.apply(self);
      this.configureShape(self);
      self.text.valign = data.getVerticalAlign(self);
    }
    data = this.getLabelBounds(self);
    var zoom = this.getTextScale(self);
    this.resolveColor(self, "color", mxConstants.STYLE_FONTCOLOR);
    if (err || self.text.value != value || self.text.isWrapping != undefined || self.text.overflow != overflow || self.text.isClipping != change || self.text.scale != zoom || self.text.dialect != dialect || null == self.text.bounds || !self.text.bounds.equals(data)) {
      self.text.dialect = dialect;
      self.text.value = value;
      self.text.bounds = data;
      self.text.scale = zoom;
      self.text.wrap = undefined;
      self.text.clipped = change;
      self.text.overflow = overflow;
      err = self.text.node.style.visibility;
      this.redrawLabelShape(self.text);
      /** @type {string} */
      self.text.node.style.visibility = err;
    }
  }
};
/**
 * @param {!Object} s
 * @param {!Object} result
 * @return {?}
 */
mxCellRenderer.prototype.isTextShapeInvalid = function(s, result) {
  /**
   * @param {string} name
   * @param {string} key
   * @param {?} fn
   * @return {?}
   */
  function $(name, key, fn) {
    return "spacingTop" == key || "spacingRight" == key || "spacingBottom" == key || "spacingLeft" == key ? parseFloat(result[name]) - parseFloat(result.spacing) != (s.style[key] || fn) : result[name] != (s.style[key] || fn);
  }
  return $("fontStyle", mxConstants.STYLE_FONTSTYLE, mxConstants.DEFAULT_FONTSTYLE) || $("family", mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY) || $("size", mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE) || $("color", mxConstants.STYLE_FONTCOLOR, "black") || $("align", mxConstants.STYLE_ALIGN, "") || $("valign", mxConstants.STYLE_VERTICAL_ALIGN, "") || $("spacing", mxConstants.STYLE_SPACING, 2) || $("spacingTop", mxConstants.STYLE_SPACING_TOP, 0) || $("spacingRight", mxConstants.STYLE_SPACING_RIGHT, 
  0) || $("spacingBottom", mxConstants.STYLE_SPACING_BOTTOM, 0) || $("spacingLeft", mxConstants.STYLE_SPACING_LEFT, 0) || $("horizontal", mxConstants.STYLE_HORIZONTAL, true) || $("background", mxConstants.STYLE_LABEL_BACKGROUNDCOLOR) || $("border", mxConstants.STYLE_LABEL_BORDERCOLOR) || $("opacity", mxConstants.STYLE_TEXT_OPACITY, 100) || $("textDirection", mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);
};
/**
 * @param {!Object} year_selector_service
 * @return {undefined}
 */
mxCellRenderer.prototype.redrawLabelShape = function(year_selector_service) {
  year_selector_service.redraw();
};
/**
 * @param {!Object} turtle
 * @return {?}
 */
mxCellRenderer.prototype.getTextScale = function(turtle) {
  return turtle.view.scale;
};
/**
 * @param {!Object} s
 * @return {?}
 */
mxCellRenderer.prototype.getLabelBounds = function(s) {
  var w = s.view.graph;
  var scale = s.view.scale;
  var d = w.getModel().isEdge(s.cell);
  var p = new mxRectangle(s.absoluteOffset.x, s.absoluteOffset.y);
  if (d) {
    var d = s.text.getSpacing();
    p.x += d.x * scale;
    p.y += d.y * scale;
    w = w.getCellGeometry(s.cell);
    if (null != w) {
      /** @type {number} */
      p.width = Math.max(0, w.width * scale);
      /** @type {number} */
      p.height = Math.max(0, w.height * scale);
    }
  } else {
    if (s.text.isPaintBoundsInverted()) {
      w = p.x;
      p.x = p.y;
      p.y = w;
    }
    p.x += s.x;
    p.y += s.y;
    /** @type {number} */
    p.width = Math.max(1, s.width);
    /** @type {number} */
    p.height = Math.max(1, s.height);
  }
  if (s.text.isPaintBoundsInverted()) {
    /** @type {number} */
    w = (s.width - s.height) / 2;
    p.x += w;
    p.y -= w;
    w = p.width;
    p.width = p.height;
    p.height = w;
  }
  if (null != s.shape) {
    w = mxUtils.getValue(s.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
    d = mxUtils.getValue(s.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
    if (w == mxConstants.ALIGN_CENTER && d == mxConstants.ALIGN_MIDDLE) {
      p = s.shape.getLabelBounds(p);
    }
  }
  w = mxUtils.getValue(s.style, mxConstants.STYLE_LABEL_WIDTH, null);
  if (null != w) {
    /** @type {number} */
    p.width = parseFloat(w) * scale;
  }
  if (!d) {
    this.rotateLabelBounds(s, p);
  }
  return p;
};
/**
 * @param {!Object} s
 * @param {!Object} point
 * @return {undefined}
 */
mxCellRenderer.prototype.rotateLabelBounds = function(s, point) {
  point.y -= s.text.margin.y * point.height;
  point.x -= s.text.margin.x * point.width;
  if (!this.legacySpacing || "fill" != s.style[mxConstants.STYLE_OVERFLOW] && "width" != s.style[mxConstants.STYLE_OVERFLOW] && ("block" != s.style[mxConstants.STYLE_OVERFLOW] || "1" == s.style[mxConstants.STYLE_BLOCK_SPACING])) {
    var scale = s.view.scale;
    var r = s.text.getSpacing("1" == s.style[mxConstants.STYLE_BLOCK_SPACING]);
    point.x += r.x * scale;
    point.y += r.y * scale;
    r = mxUtils.getValue(s.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
    var valign = mxUtils.getValue(s.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
    var undefined = mxUtils.getValue(s.style, mxConstants.STYLE_LABEL_WIDTH, null);
    /** @type {number} */
    point.width = Math.max(0, point.width - (r == mxConstants.ALIGN_CENTER && null == undefined ? s.text.spacingLeft * scale + s.text.spacingRight * scale : 0));
    /** @type {number} */
    point.height = Math.max(0, point.height - (valign == mxConstants.ALIGN_MIDDLE ? s.text.spacingTop * scale + s.text.spacingBottom * scale : 0));
  }
  r = s.text.getTextRotation();
  if (0 != r && null != s && s.view.graph.model.isVertex(s.cell) && (scale = s.getCenterX(), s = s.getCenterY(), point.x != scale || point.y != s)) {
    /** @type {number} */
    r = r * (Math.PI / 180);
    s = mxUtils.getRotatedPoint(new mxPoint(point.x, point.y), Math.cos(r), Math.sin(r), new mxPoint(scale, s));
    point.x = s.x;
    point.y = s.y;
  }
};
/**
 * @param {!Object} self
 * @param {string} il
 * @return {undefined}
 */
mxCellRenderer.prototype.redrawCellOverlays = function(self, il) {
  this.createCellOverlays(self);
  if (null != self.overlays) {
    var extent = mxUtils.mod(mxUtils.getValue(self.style, mxConstants.STYLE_ROTATION, 0), 90);
    var r = mxUtils.toRadians(extent);
    /** @type {number} */
    var cos = Math.cos(r);
    /** @type {number} */
    var sin = Math.sin(r);
    self.overlays.visit(function(value, that) {
      value = that.overlay.getBounds(self);
      if (!self.view.graph.getModel().isEdge(self.cell) && null != self.shape && 0 != extent) {
        var width = value.getCenterX();
        var bottom = value.getCenterY();
        bottom = mxUtils.getRotatedPoint(new mxPoint(width, bottom), cos, sin, new mxPoint(self.getCenterX(), self.getCenterY()));
        width = bottom.x;
        bottom = bottom.y;
        /** @type {number} */
        value.x = Math.round(width - value.width / 2);
        /** @type {number} */
        value.y = Math.round(bottom - value.height / 2);
      }
      if (il || null == that.bounds || that.scale != self.view.scale || !that.bounds.equals(value)) {
        /** @type {!Object} */
        that.bounds = value;
        that.scale = self.view.scale;
        that.redraw();
      }
    });
  }
};
/**
 * @param {!Object} self
 * @param {string} il
 * @return {undefined}
 */
mxCellRenderer.prototype.redrawControl = function(self, il) {
  var value = self.view.graph.getFoldingImage(self);
  if (null != self.control && null != value) {
    value = this.getControlBounds(self, value.width, value.height);
    var val = this.legacyControlPosition ? mxUtils.getValue(self.style, mxConstants.STYLE_ROTATION, 0) : self.shape.getTextRotation();
    var scale = self.view.scale;
    if (il || self.control.scale != scale || !self.control.bounds.equals(value) || self.control.rotation != val) {
      self.control.rotation = val;
      self.control.bounds = value;
      self.control.scale = scale;
      self.control.redraw();
    }
  }
};
/**
 * @param {!Object} self
 * @param {number} length
 * @param {number} target
 * @return {?}
 */
mxCellRenderer.prototype.getControlBounds = function(self, length, target) {
  if (null != self.control) {
    var index = self.view.scale;
    var width = self.getCenterX();
    var x = self.getCenterY();
    if (!self.view.graph.getModel().isEdge(self.cell) && (width = self.x + length * index, x = self.y + target * index, null != self.shape)) {
      var value = self.shape.getShapeRotation();
      if (this.legacyControlPosition) {
        value = mxUtils.getValue(self.style, mxConstants.STYLE_ROTATION, 0);
      } else {
        if (self.shape.isPaintBoundsInverted()) {
          /** @type {number} */
          var offset = (self.width - self.height) / 2;
          width = width + offset;
          /** @type {number} */
          x = x - offset;
        }
      }
      if (0 != value) {
        offset = mxUtils.toRadians(value);
        /** @type {number} */
        value = Math.cos(offset);
        /** @type {number} */
        offset = Math.sin(offset);
        x = mxUtils.getRotatedPoint(new mxPoint(width, x), value, offset, new mxPoint(self.getCenterX(), self.getCenterY()));
        width = x.x;
        x = x.y;
      }
    }
    return self.view.graph.getModel().isEdge(self.cell), new mxRectangle(Math.round(width - length / 2 * index), Math.round(x - target / 2 * index), Math.round(length * index), Math.round(target * index));
  }
  return null;
};
/**
 * @param {!Object} graph
 * @param {string} node
 * @param {string} defs
 * @return {?}
 */
mxCellRenderer.prototype.insertStateAfter = function(graph, node, defs) {
  var cells = this.getShapesForState(graph);
  /** @type {number} */
  var i = 0;
  for (; i < cells.length; i++) {
    if (null != cells[i] && null != cells[i].node) {
      /** @type {boolean} */
      var list = cells[i].node.parentNode != graph.view.getDrawPane() && cells[i].node.parentNode != graph.view.getOverlayPane();
      var target = list ? defs : node;
      if (null != target && target.nextSibling != cells[i].node) {
        if (null == target.nextSibling) {
          target.parentNode.appendChild(cells[i].node);
        } else {
          target.parentNode.insertBefore(cells[i].node, target.nextSibling);
        }
      } else {
        if (null == target) {
          if (cells[i].node.parentNode == graph.view.graph.container) {
            target = graph.view.canvas;
            for (; null != target && target.parentNode != graph.view.graph.container;) {
              target = target.parentNode;
            }
            if (null != target && null != target.nextSibling) {
              if (target.nextSibling != cells[i].node) {
                cells[i].node.parentNode.insertBefore(cells[i].node, target.nextSibling);
              }
            } else {
              cells[i].node.parentNode.appendChild(cells[i].node);
            }
          } else {
            if (null != cells[i].node.parentNode && null != cells[i].node.parentNode.firstChild && cells[i].node.parentNode.firstChild != cells[i].node) {
              cells[i].node.parentNode.insertBefore(cells[i].node, cells[i].node.parentNode.firstChild);
            }
          }
        }
      }
      if (list) {
        defs = cells[i].node;
      } else {
        node = cells[i].node;
      }
    }
  }
  return [node, defs];
};
/**
 * @param {!Object} options
 * @return {?}
 */
mxCellRenderer.prototype.getShapesForState = function(options) {
  return [options.shape, options.text, options.control];
};
/**
 * @param {!Object} n
 * @param {string} r
 * @param {?} color
 * @return {undefined}
 */
mxCellRenderer.prototype.redraw = function(n, r, color) {
  r = this.redrawShape(n, r, color);
  if (!(null == n.shape || null != color && !color)) {
    this.redrawLabel(n, r);
    this.redrawCellOverlays(n, r);
    this.redrawControl(n, r);
  }
};
/**
 * @param {!Object} self
 * @param {string} v
 * @param {?} fill
 * @return {?}
 */
mxCellRenderer.prototype.redrawShape = function(self, v, fill) {
  var data = self.view.graph.model;
  /** @type {boolean} */
  var e = false;
  if (null != self.shape && null != self.shape.style && null != self.style && self.shape.style[mxConstants.STYLE_SHAPE] != self.style[mxConstants.STYLE_SHAPE]) {
    self.shape.destroy();
    /** @type {null} */
    self.shape = null;
  }
  if (null == self.shape && null != self.view.graph.container && self.cell != self.view.currentRoot && (data.isVertex(self.cell) || data.isEdge(self.cell))) {
    self.shape = this.createShape(self);
    if (null != self.shape) {
      self.shape.minSvgStrokeWidth = this.minSvgStrokeWidth;
      self.shape.antiAlias = this.antiAlias;
      this.createIndicatorShape(self);
      this.initializeShape(self);
      this.createCellOverlays(self);
      this.installListeners(self);
      self.view.graph.selectionCellsHandler.updateHandler(self);
    }
  } else {
    if (!(v || null == self.shape || mxUtils.equalEntries(self.shape.style, self.style) && !this.checkPlaceholderStyles(self))) {
      self.shape.resetStyles();
      this.configureShape(self);
      self.view.graph.selectionCellsHandler.updateHandler(self);
      /** @type {boolean} */
      v = true;
    }
  }
  if (null != self.shape && self.shape.indicatorShape != this.getShape(self.view.graph.getIndicatorShape(self))) {
    if (null != self.shape.indicator) {
      self.shape.indicator.destroy();
      /** @type {null} */
      self.shape.indicator = null;
    }
    this.createIndicatorShape(self);
    if (null != self.shape.indicatorShape) {
      self.shape.indicator = new self.shape.indicatorShape;
      self.shape.indicator.dialect = self.shape.dialect;
      self.shape.indicator.init(self.node);
      /** @type {boolean} */
      v = true;
    }
  }
  if (null != self.shape && (this.createControl(self), v || this.isShapeInvalid(self, self.shape))) {
    if (null != self.absolutePoints) {
      self.shape.points = self.absolutePoints.slice();
      /** @type {null} */
      self.shape.bounds = null;
    } else {
      /** @type {null} */
      self.shape.points = null;
      self.shape.bounds = new mxRectangle(self.x, self.y, self.width, self.height);
    }
    self.shape.scale = self.view.scale;
    if (null == fill || fill) {
      this.doRedrawShape(self);
    } else {
      self.shape.updateBoundingBox();
    }
    /** @type {boolean} */
    e = true;
  }
  return e;
};
/**
 * @param {!Object} view
 * @return {undefined}
 */
mxCellRenderer.prototype.doRedrawShape = function(view) {
  view.shape.redraw();
};
/**
 * @param {!Object} action
 * @param {!Object} obj
 * @return {?}
 */
mxCellRenderer.prototype.isShapeInvalid = function(action, obj) {
  return null == obj.bounds || obj.scale != action.view.scale || null == action.absolutePoints && !obj.bounds.equals(action) || null != action.absolutePoints && !mxUtils.equalPoints(obj.points, action.absolutePoints);
};
/**
 * @param {!Object} self
 * @return {undefined}
 */
mxCellRenderer.prototype.destroy = function(self) {
  if (null != self.shape) {
    if (null != self.text) {
      self.text.destroy();
      /** @type {null} */
      self.text = null;
    }
    if (null != self.overlays) {
      self.overlays.visit(function(b, anAlertDialog) {
        anAlertDialog.destroy();
      });
      /** @type {null} */
      self.overlays = null;
    }
    if (null != self.control) {
      self.control.destroy();
      /** @type {null} */
      self.control = null;
    }
    self.shape.destroy();
    /** @type {null} */
    self.shape = null;
  }
};
var mxEdgeStyle = {
  EntityRelation : function(s, a, data, d, self) {
    var node = s.view;
    var graph = node.graph;
    /** @type {number} */
    d = mxUtils.getValue(s.style, mxConstants.STYLE_SEGMENT, mxConstants.ENTITY_SEGMENT) * node.scale;
    var p = s.absolutePoints;
    var b = p[0];
    var shape = p[p.length - 1];
    /** @type {boolean} */
    p = false;
    if (null != a) {
      var e = graph.getCellGeometry(a.cell);
      if (e.relative) {
        /** @type {boolean} */
        p = .5 >= e.x;
      } else {
        if (null != data) {
          /** @type {boolean} */
          p = (null != shape ? shape.x : data.x + data.width) < (null != b ? b.x : a.x);
        }
      }
    }
    if (null != b) {
      a = new mxCellState;
      a.x = b.x;
      a.y = b.y;
    } else {
      if (null != a) {
        var i = mxUtils.getPortConstraints(a, s, true, mxConstants.DIRECTION_MASK_NONE);
        if (i != mxConstants.DIRECTION_MASK_NONE && i != mxConstants.DIRECTION_MASK_WEST + mxConstants.DIRECTION_MASK_EAST) {
          /** @type {boolean} */
          p = i == mxConstants.DIRECTION_MASK_WEST;
        }
      } else {
        return;
      }
    }
    /** @type {boolean} */
    e = true;
    if (null != data) {
      graph = graph.getCellGeometry(data.cell);
      if (graph.relative) {
        /** @type {boolean} */
        e = .5 >= graph.x;
      } else {
        if (null != a) {
          /** @type {boolean} */
          e = (null != b ? b.x : a.x + a.width) < (null != shape ? shape.x : data.x);
        }
      }
    }
    if (null != shape) {
      data = new mxCellState;
      data.x = shape.x;
      data.y = shape.y;
    } else {
      if (null != data) {
        i = mxUtils.getPortConstraints(data, s, false, mxConstants.DIRECTION_MASK_NONE);
        if (i != mxConstants.DIRECTION_MASK_NONE && i != mxConstants.DIRECTION_MASK_WEST + mxConstants.DIRECTION_MASK_EAST) {
          /** @type {boolean} */
          e = i == mxConstants.DIRECTION_MASK_WEST;
        }
      }
    }
    if (null != a && null != data) {
      s = p ? a.x : a.x + a.width;
      a = node.getRoutingCenterY(a);
      b = e ? data.x : data.x + data.width;
      data = node.getRoutingCenterY(data);
      node = new mxPoint(s + (p ? -d : d), a);
      graph = new mxPoint(b + (e ? -d : d), data);
      if (p == e) {
        /** @type {number} */
        d = p ? Math.min(s, b) - d : Math.max(s, b) + d;
        self.push(new mxPoint(d, a));
        self.push(new mxPoint(d, data));
      } else {
        if (node.x < graph.x == p) {
          d = a + (data - a) / 2;
          self.push(node);
          self.push(new mxPoint(node.x, d));
          self.push(new mxPoint(graph.x, d));
        } else {
          self.push(node);
        }
        self.push(graph);
      }
    }
  },
  Loop : function(s, r, o, n, state) {
    o = s.absolutePoints;
    var f = o[o.length - 1];
    if (null != o[0] && null != f) {
      if (null != n && 0 < n.length) {
        /** @type {number} */
        r = 0;
        for (; r < n.length; r++) {
          o = n[r];
          o = s.view.transformControlPoint(s, o);
          state.push(new mxPoint(o.x, o.y));
        }
      }
    } else {
      if (null != r) {
        f = s.view;
        var value = f.graph;
        o = null != n && 0 < n.length ? n[0] : null;
        if (null != o) {
          o = f.transformControlPoint(s, o);
          if (mxUtils.contains(r, o.x, o.y)) {
            /** @type {null} */
            o = null;
          }
        }
        /** @type {number} */
        var h = n = 0;
        /** @type {number} */
        var y = 0;
        /** @type {number} */
        var size = 0;
        /** @type {number} */
        value = mxUtils.getValue(s.style, mxConstants.STYLE_SEGMENT, value.gridSize) * f.scale;
        s = mxUtils.getValue(s.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_WEST);
        if (s == mxConstants.DIRECTION_NORTH || s == mxConstants.DIRECTION_SOUTH) {
          n = f.getRoutingCenterX(r);
          /** @type {number} */
          h = value;
        } else {
          y = f.getRoutingCenterY(r);
          /** @type {number} */
          size = value;
        }
        if (null == o || o.x < r.x || o.x > r.x + r.width) {
          if (null != o) {
            n = o.x;
            /** @type {number} */
            size = Math.max(Math.abs(y - o.y), size);
          } else {
            if (s == mxConstants.DIRECTION_NORTH) {
              /** @type {number} */
              y = r.y - 2 * h;
            } else {
              if (s == mxConstants.DIRECTION_SOUTH) {
                y = r.y + r.height + 2 * h;
              } else {
                n = s == mxConstants.DIRECTION_EAST ? r.x - 2 * size : r.x + r.width + 2 * size;
              }
            }
          }
        } else {
          if (null != o) {
            n = f.getRoutingCenterX(r);
            /** @type {number} */
            h = Math.max(Math.abs(n - o.x), size);
            y = o.y;
            /** @type {number} */
            size = 0;
          }
        }
        state.push(new mxPoint(n - h, y - size));
        state.push(new mxPoint(n + h, y + size));
      }
    }
  },
  ElbowConnector : function(state, a, b, m, options) {
    var t = null != m && 0 < m.length ? m[0] : null;
    /** @type {boolean} */
    var maxprop = false;
    /** @type {boolean} */
    var bigword = false;
    if (null != a && null != b) {
      if (null != t) {
        /** @type {number} */
        var val = Math.min(a.x, b.x);
        /** @type {number} */
        var max = Math.max(a.x + a.width, b.x + b.width);
        /** @type {number} */
        bigword = Math.min(a.y, b.y);
        /** @type {number} */
        var W = Math.max(a.y + a.height, b.y + b.height);
        t = state.view.transformControlPoint(state, t);
        /** @type {boolean} */
        maxprop = t.y < bigword || t.y > W;
        /** @type {boolean} */
        bigword = t.x < val || t.x > max;
      } else {
        /** @type {number} */
        val = Math.max(a.x, b.x);
        /** @type {number} */
        max = Math.min(a.x + a.width, b.x + b.width);
        /** @type {boolean} */
        maxprop = val == max;
        if (!maxprop) {
          /** @type {number} */
          bigword = Math.max(a.y, b.y);
          /** @type {number} */
          W = Math.min(a.y + a.height, b.y + b.height);
          /** @type {boolean} */
          bigword = bigword == W;
        }
      }
    }
    if (bigword || !maxprop && state.style[mxConstants.STYLE_ELBOW] != mxConstants.ELBOW_VERTICAL) {
      mxEdgeStyle.SideToSide(state, a, b, m, options);
    } else {
      mxEdgeStyle.TopToBottom(state, a, b, m, options);
    }
  },
  SideToSide : function(a, d, data, p, obj) {
    var b = a.view;
    p = null != p && 0 < p.length ? p[0] : null;
    var c = a.absolutePoints;
    var x = c[0];
    c = c[c.length - 1];
    if (null != p) {
      p = b.transformControlPoint(a, p);
    }
    if (null != x) {
      d = new mxCellState;
      d.x = x.x;
      d.y = x.y;
    }
    if (null != c) {
      data = new mxCellState;
      data.x = c.x;
      data.y = c.y;
    }
    if (null != d && null != data) {
      /** @type {number} */
      a = Math.max(d.x, data.x);
      /** @type {number} */
      x = Math.min(d.x + d.width, data.x + data.width);
      a = null != p ? p.x : Math.round(x + (a - x) / 2);
      x = b.getRoutingCenterY(d);
      b = b.getRoutingCenterY(data);
      if (null != p) {
        if (p.y >= d.y && p.y <= d.y + d.height) {
          x = p.y;
        }
        if (p.y >= data.y && p.y <= data.y + data.height) {
          b = p.y;
        }
      }
      if (!(mxUtils.contains(data, a, x) || mxUtils.contains(d, a, x))) {
        obj.push(new mxPoint(a, x));
      }
      if (!(mxUtils.contains(data, a, b) || mxUtils.contains(d, a, b))) {
        obj.push(new mxPoint(a, b));
      }
      if (1 == obj.length) {
        if (null != p) {
          if (!(mxUtils.contains(data, a, p.y) || mxUtils.contains(d, a, p.y))) {
            obj.push(new mxPoint(a, p.y));
          }
        } else {
          /** @type {number} */
          b = Math.max(d.y, data.y);
          obj.push(new mxPoint(a, b + (Math.min(d.y + d.height, data.y + data.height) - b) / 2));
        }
      }
    }
  },
  TopToBottom : function(b, a, e, p, parent) {
    var v = b.view;
    p = null != p && 0 < p.length ? p[0] : null;
    var t = b.absolutePoints;
    var obj = t[0];
    t = t[t.length - 1];
    if (null != p) {
      p = v.transformControlPoint(b, p);
    }
    if (null != obj) {
      a = new mxCellState;
      a.x = obj.x;
      a.y = obj.y;
    }
    if (null != t) {
      e = new mxCellState;
      e.x = t.x;
      e.y = t.y;
    }
    if (null != a && null != e) {
      /** @type {number} */
      obj = Math.max(a.y, e.y);
      /** @type {number} */
      t = Math.min(a.y + a.height, e.y + e.height);
      b = v.getRoutingCenterX(a);
      if (null != p && p.x >= a.x && p.x <= a.x + a.width) {
        b = p.x;
      }
      obj = null != p ? p.y : Math.round(t + (obj - t) / 2);
      if (!(mxUtils.contains(e, b, obj) || mxUtils.contains(a, b, obj))) {
        parent.push(new mxPoint(b, obj));
      }
      b = null != p && p.x >= e.x && p.x <= e.x + e.width ? p.x : v.getRoutingCenterX(e);
      if (!(mxUtils.contains(e, b, obj) || mxUtils.contains(a, b, obj))) {
        parent.push(new mxPoint(b, obj));
      }
      if (1 == parent.length) {
        if (null != p && 1 == parent.length) {
          if (!(mxUtils.contains(e, p.x, obj) || mxUtils.contains(a, p.x, obj))) {
            parent.push(new mxPoint(p.x, obj));
          }
        } else {
          /** @type {number} */
          v = Math.max(a.x, e.x);
          parent.push(new mxPoint(v + (Math.min(a.x + a.width, e.x + e.width) - v) / 2, obj));
        }
      }
    }
  },
  SegmentConnector : function(m, b, p, a, obj) {
    var data = mxEdgeStyle.scalePointArray(m.absolutePoints, m.view.scale);
    b = mxEdgeStyle.scaleCellState(b, m.view.scale);
    var node = mxEdgeStyle.scaleCellState(p, m.view.scale);
    /** @type {!Array} */
    p = [];
    var state = 0 < obj.length ? obj[0] : null;
    /** @type {boolean} */
    var current = true;
    var point = data[0];
    if (null == point && null != b) {
      point = new mxPoint(m.view.getRoutingCenterX(b), m.view.getRoutingCenterY(b));
    } else {
      if (null != point) {
        point = point.clone();
      }
    }
    /** @type {number} */
    var j = data.length - 1;
    if (null != a && 0 < a.length) {
      /** @type {!Array} */
      var d = [];
      /** @type {number} */
      var i = 0;
      for (; i < a.length; i++) {
        var r = m.view.transformControlPoint(m, a[i], true);
        if (null != r) {
          d.push(r);
        }
      }
      if (0 == d.length) {
        return;
      }
      if (null != point && null != d[0]) {
        if (1 > Math.abs(d[0].x - point.x)) {
          d[0].x = point.x;
        }
        if (1 > Math.abs(d[0].y - point.y)) {
          d[0].y = point.y;
        }
      }
      r = data[j];
      if (null != r && null != d[d.length - 1]) {
        if (1 > Math.abs(d[d.length - 1].x - r.x)) {
          d[d.length - 1].x = r.x;
        }
        if (1 > Math.abs(d[d.length - 1].y - r.y)) {
          d[d.length - 1].y = r.y;
        }
      }
      a = d[0];
      /** @type {!Object} */
      var p = b;
      var res = data[0];
      /** @type {number} */
      var c = a;
      if (null != res) {
        /** @type {null} */
        p = null;
      }
      /** @type {number} */
      i = 0;
      for (; 2 > i; i++) {
        /** @type {boolean} */
        var useJRD = null != res && res.x == c.x;
        /** @type {boolean} */
        var animationClosed = null != res && res.y == c.y;
        /** @type {boolean} */
        var animationPaused = null != p && c.y >= p.y && c.y <= p.y + p.height;
        /** @type {boolean} */
        var json = null != p && c.x >= p.x && c.x <= p.x + p.width;
        /** @type {boolean} */
        p = animationClosed || null == res && animationPaused;
        /** @type {boolean} */
        c = useJRD || null == res && json;
        if (0 != i || !(p && c || useJRD && animationClosed)) {
          if (null != res && !animationClosed && !useJRD && (animationPaused || json)) {
            /** @type {boolean} */
            current = animationPaused ? false : true;
            break;
          }
          if (c || p) {
            /** @type {boolean} */
            current = p;
            if (1 == i) {
              /** @type {boolean} */
              current = 0 == d.length % 2 ? p : c;
            }
            break;
          }
        }
        p = node;
        res = data[j];
        if (null != res) {
          /** @type {null} */
          p = null;
        }
        c = d[d.length - 1];
        if (useJRD && animationClosed) {
          /** @type {!Array<?>} */
          d = d.slice(1);
        }
      }
      if (current && (null != data[0] && data[0].y != a.y || null == data[0] && null != b && (a.y < b.y || a.y > b.y + b.height))) {
        p.push(new mxPoint(point.x, a.y));
      } else {
        if (!current && (null != data[0] && data[0].x != a.x || null == data[0] && null != b && (a.x < b.x || a.x > b.x + b.width))) {
          p.push(new mxPoint(a.x, point.y));
        }
      }
      if (current) {
        point.y = a.y;
      } else {
        point.x = a.x;
      }
      /** @type {number} */
      i = 0;
      for (; i < d.length; i++) {
        /** @type {boolean} */
        current = !current;
        a = d[i];
        if (current) {
          point.y = a.y;
        } else {
          point.x = a.x;
        }
        p.push(point.clone());
      }
    } else {
      a = point;
      /** @type {boolean} */
      current = true;
    }
    point = data[j];
    if (null == point && null != node) {
      point = new mxPoint(m.view.getRoutingCenterX(node), m.view.getRoutingCenterY(node));
    }
    if (null != point && null != a) {
      if (current && (null != data[j] && data[j].y != a.y || null == data[j] && null != node && (a.y < node.y || a.y > node.y + node.height))) {
        p.push(new mxPoint(point.x, a.y));
      } else {
        if (!current && (null != data[j] && data[j].x != a.x || null == data[j] && null != node && (a.x < node.x || a.x > node.x + node.width))) {
          p.push(new mxPoint(a.x, point.y));
        }
      }
    }
    if (null == data[0] && null != b) {
      for (; 0 < p.length && null != p[0] && mxUtils.contains(b, p[0].x, p[0].y);) {
        p.splice(0, 1);
      }
    }
    if (null == data[j] && null != node) {
      for (; 0 < p.length && null != p[p.length - 1] && mxUtils.contains(node, p[p.length - 1].x, p[p.length - 1].y);) {
        p.splice(p.length - 1, 1);
      }
    }
    /** @type {number} */
    i = 0;
    for (; i < p.length; i++) {
      if (data = p[i], data.x = Math.round(data.x * m.view.scale * 10) / 10, data.y = Math.round(data.y * m.view.scale * 10) / 10, null == state || 1 <= Math.abs(state.x - data.x) || Math.abs(state.y - data.y) >= Math.max(1, m.view.scale)) {
        obj.push(data);
        state = data;
      }
    }
    if (null != r && null != obj[obj.length - 1] && 1 >= Math.abs(r.x - obj[obj.length - 1].x) && 1 >= Math.abs(r.y - obj[obj.length - 1].y)) {
      obj.splice(obj.length - 1, 1);
      if (null != obj[obj.length - 1]) {
        if (1 > Math.abs(obj[obj.length - 1].x - r.x)) {
          obj[obj.length - 1].x = r.x;
        }
        if (1 > Math.abs(obj[obj.length - 1].y - r.y)) {
          obj[obj.length - 1].y = r.y;
        }
      }
    }
  },
  orthBuffer : 10,
  orthPointsFallback : true,
  dirVectors : [[-1, 0], [0, -1], [1, 0], [0, 1], [-1, 0], [0, -1], [1, 0]],
  wayPoints1 : [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
  routePatterns : [[[513, 2308, 2081, 2562], [513, 1090, 514, 2184, 2114, 2561], [513, 1090, 514, 2564, 2184, 2562], [513, 2308, 2561, 1090, 514, 2568, 2308]], [[514, 1057, 513, 2308, 2081, 2562], [514, 2184, 2114, 2561], [514, 2184, 2562, 1057, 513, 2564, 2184], [514, 1057, 513, 2568, 2308, 2561]], [[1090, 514, 1057, 513, 2308, 2081, 2562], [2114, 2561], [1090, 2562, 1057, 513, 2564, 2184], [1090, 514, 1057, 513, 2308, 2561, 2568]], [[2081, 2562], [1057, 513, 1090, 514, 2184, 2114, 2561], [1057, 
  513, 1090, 514, 2184, 2562, 2564], [1057, 2561, 1090, 514, 2568, 2308]]],
  inlineRoutePatterns : [[null, [2114, 2568], null, null], [null, [514, 2081, 2114, 2568], null, null], [null, [2114, 2561], null, null], [[2081, 2562], [1057, 2114, 2568], [2184, 2562], null]],
  vertexSeperations : [],
  limits : [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]],
  LEFT_MASK : 32,
  TOP_MASK : 64,
  RIGHT_MASK : 128,
  BOTTOM_MASK : 256,
  LEFT : 1,
  TOP : 2,
  RIGHT : 4,
  BOTTOM : 8,
  SIDE_MASK : 480,
  CENTER_MASK : 512,
  SOURCE_MASK : 1024,
  TARGET_MASK : 2048,
  VERTEX_MASK : 3072,
  getJettySize : function(cell, animate) {
    var value = mxUtils.getValue(cell.style, animate ? mxConstants.STYLE_SOURCE_JETTY_SIZE : mxConstants.STYLE_TARGET_JETTY_SIZE, mxUtils.getValue(cell.style, mxConstants.STYLE_JETTY_SIZE, mxEdgeStyle.orthBuffer));
    if ("auto" == value) {
      if (mxUtils.getValue(cell.style, animate ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE) {
        cell = mxUtils.getNumber(cell.style, animate ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE);
        /** @type {number} */
        value = Math.max(2, Math.ceil((cell + mxEdgeStyle.orthBuffer) / mxEdgeStyle.orthBuffer)) * mxEdgeStyle.orthBuffer;
      } else {
        /** @type {number} */
        value = 2 * mxEdgeStyle.orthBuffer;
      }
    }
    return value;
  },
  scalePointArray : function(bundle, len) {
    /** @type {!Array} */
    var trajectoryStep = [];
    if (null != bundle) {
      /** @type {number} */
      var i = 0;
      for (; i < bundle.length; i++) {
        if (null != bundle[i]) {
          var pt = new mxPoint(Math.round(bundle[i].x / len * 10) / 10, Math.round(bundle[i].y / len * 10) / 10);
          trajectoryStep[i] = pt;
        } else {
          /** @type {null} */
          trajectoryStep[i] = null;
        }
      }
    } else {
      /** @type {null} */
      trajectoryStep = null;
    }
    return trajectoryStep;
  },
  scaleCellState : function(point, resolution) {
    if (null != point) {
      var surface = point.clone();
      surface.setRect(Math.round(point.x / resolution * 10) / 10, Math.round(point.y / resolution * 10) / 10, Math.round(point.width / resolution * 10) / 10, Math.round(point.height / resolution * 10) / 10);
    } else {
      /** @type {null} */
      surface = null;
    }
    return surface;
  },
  OrthConnector : function(k, options, d, q, a) {
    var e = k.view.graph;
    var screenSmallerThanEditor = null == data ? false : e.getModel().isEdge(data.cell);
    var adjustHeight = null == f ? false : e.getModel().isEdge(f.cell);
    e = mxEdgeStyle.scalePointArray(k.absolutePoints, k.view.scale);
    var data = mxEdgeStyle.scaleCellState(options, k.view.scale);
    var f = mxEdgeStyle.scaleCellState(d, k.view.scale);
    var a = e[0];
    var b = e[e.length - 1];
    var pos = null != data ? data.x : a.x;
    var x = null != data ? data.y : a.y;
    var size = null != data ? data.width : 0;
    var s = null != data ? data.height : 0;
    var min = null != f ? f.x : b.x;
    var max = null != f ? f.y : b.y;
    var minWidth = null != f ? f.width : 0;
    var minHeight = null != f ? f.height : 0;
    e = mxEdgeStyle.getJettySize(k, true);
    var n = mxEdgeStyle.getJettySize(k, false);
    if (null != data && f == data) {
      /** @type {number} */
      e = n = Math.max(e, n);
    }
    var t = n + e;
    /** @type {boolean} */
    var i = false;
    if (null != a && null != b) {
      /** @type {number} */
      i = b.x - a.x;
      /** @type {number} */
      var j = b.y - a.y;
      /** @type {boolean} */
      i = i * i + j * j < t * t;
    }
    if (i || mxEdgeStyle.orthPointsFallback && null != q && 0 < q.length || screenSmallerThanEditor || adjustHeight) {
      mxEdgeStyle.SegmentConnector(k, options, d, q, a);
    } else {
      /** @type {!Array} */
      d = [mxConstants.DIRECTION_MASK_ALL, mxConstants.DIRECTION_MASK_ALL];
      if (null != data) {
        d[0] = mxUtils.getPortConstraints(data, k, true, mxConstants.DIRECTION_MASK_ALL);
        options = mxUtils.getValue(data.style, mxConstants.STYLE_ROTATION, 0);
        if (0 != options) {
          options = mxUtils.getBoundingBox(new mxRectangle(pos, x, size, s), options);
          pos = options.x;
          x = options.y;
          size = options.width;
          s = options.height;
        }
      }
      if (null != f) {
        d[1] = mxUtils.getPortConstraints(f, k, false, mxConstants.DIRECTION_MASK_ALL);
        options = mxUtils.getValue(f.style, mxConstants.STYLE_ROTATION, 0);
        if (0 != options) {
          options = mxUtils.getBoundingBox(new mxRectangle(min, max, minWidth, minHeight), options);
          min = options.x;
          max = options.y;
          minWidth = options.width;
          minHeight = options.height;
        }
      }
      /** @type {!Array} */
      options = [0, 0];
      /** @type {!Array} */
      pos = [[pos, x, size, s], [min, max, minWidth, minHeight]];
      /** @type {!Array} */
      n = [e, n];
      /** @type {number} */
      i = 0;
      for (; 2 > i; i++) {
        /** @type {number} */
        mxEdgeStyle.limits[i][1] = pos[i][0] - n[i];
        /** @type {number} */
        mxEdgeStyle.limits[i][2] = pos[i][1] - n[i];
        mxEdgeStyle.limits[i][4] = pos[i][0] + pos[i][2] + n[i];
        mxEdgeStyle.limits[i][8] = pos[i][1] + pos[i][3] + n[i];
      }
      n = pos[0][1] + pos[0][3] / 2;
      x = pos[1][1] + pos[1][3] / 2;
      /** @type {number} */
      i = pos[0][0] + pos[0][2] / 2 - (pos[1][0] + pos[1][2] / 2);
      /** @type {number} */
      j = n - x;
      /** @type {number} */
      n = 0;
      if (0 > i) {
        /** @type {number} */
        n = 0 > j ? 2 : 1;
      } else {
        if (0 >= j) {
          /** @type {number} */
          n = 3;
          if (0 == i) {
            /** @type {number} */
            n = 2;
          }
        }
      }
      /** @type {null} */
      x = null;
      if (null != data) {
        x = a;
      }
      /** @type {!Array} */
      data = [[.5, .5], [.5, .5]];
      /** @type {number} */
      i = 0;
      for (; 2 > i; i++) {
        if (null != x) {
          /** @type {number} */
          data[i][0] = (x.x - pos[i][0]) / pos[i][2];
          if (1 >= Math.abs(x.x - pos[i][0])) {
            options[i] = mxConstants.DIRECTION_MASK_WEST;
          } else {
            if (1 >= Math.abs(x.x - pos[i][0] - pos[i][2])) {
              options[i] = mxConstants.DIRECTION_MASK_EAST;
            }
          }
          /** @type {number} */
          data[i][1] = (x.y - pos[i][1]) / pos[i][3];
          if (1 >= Math.abs(x.y - pos[i][1])) {
            options[i] = mxConstants.DIRECTION_MASK_NORTH;
          } else {
            if (1 >= Math.abs(x.y - pos[i][1] - pos[i][3])) {
              options[i] = mxConstants.DIRECTION_MASK_SOUTH;
            }
          }
        }
        /** @type {null} */
        x = null;
        if (null != f) {
          x = b;
        }
      }
      /** @type {number} */
      i = pos[0][1] - (pos[1][1] + pos[1][3]);
      /** @type {number} */
      b = pos[0][0] - (pos[1][0] + pos[1][2]);
      /** @type {number} */
      x = pos[1][1] - (pos[0][1] + pos[0][3]);
      /** @type {number} */
      size = pos[1][0] - (pos[0][0] + pos[0][2]);
      /** @type {number} */
      mxEdgeStyle.vertexSeperations[1] = Math.max(b - t, 0);
      /** @type {number} */
      mxEdgeStyle.vertexSeperations[2] = Math.max(i - t, 0);
      /** @type {number} */
      mxEdgeStyle.vertexSeperations[4] = Math.max(x - t, 0);
      /** @type {number} */
      mxEdgeStyle.vertexSeperations[3] = Math.max(size - t, 0);
      /** @type {!Array} */
      t = [];
      /** @type {!Array} */
      f = [];
      /** @type {!Array} */
      a = [];
      f[0] = b >= size ? mxConstants.DIRECTION_MASK_WEST : mxConstants.DIRECTION_MASK_EAST;
      a[0] = i >= x ? mxConstants.DIRECTION_MASK_NORTH : mxConstants.DIRECTION_MASK_SOUTH;
      f[1] = mxUtils.reversePortConstraints(f[0]);
      a[1] = mxUtils.reversePortConstraints(a[0]);
      /** @type {number} */
      b = b >= size ? b : size;
      /** @type {number} */
      x = i >= x ? i : x;
      /** @type {!Array} */
      size = [[0, 0], [0, 0]];
      /** @type {boolean} */
      s = false;
      /** @type {number} */
      i = 0;
      for (; 2 > i; i++) {
        if (0 == options[i]) {
          if (0 == (f[i] & d[i])) {
            f[i] = mxUtils.reversePortConstraints(f[i]);
          }
          if (0 == (a[i] & d[i])) {
            a[i] = mxUtils.reversePortConstraints(a[i]);
          }
          size[i][0] = a[i];
          size[i][1] = f[i];
        }
      }
      if (0 < x && 0 < b) {
        if (0 < (f[0] & d[0]) && 0 < (a[1] & d[1])) {
          size[0][0] = f[0];
          size[0][1] = a[0];
          size[1][0] = a[1];
          size[1][1] = f[1];
          /** @type {boolean} */
          s = true;
        } else {
          if (0 < (a[0] & d[0]) && 0 < (f[1] & d[1])) {
            size[0][0] = a[0];
            size[0][1] = f[0];
            size[1][0] = f[1];
            size[1][1] = a[1];
            /** @type {boolean} */
            s = true;
          }
        }
      }
      if (0 < x && !s) {
        size[0][0] = a[0];
        size[0][1] = f[0];
        size[1][0] = a[1];
        size[1][1] = f[1];
        /** @type {boolean} */
        s = true;
      }
      if (0 < b && !s) {
        size[0][0] = f[0];
        size[0][1] = a[0];
        size[1][0] = f[1];
        size[1][1] = a[1];
      }
      /** @type {number} */
      i = 0;
      for (; 2 > i; i++) {
        if (0 == options[i] && (0 == (size[i][0] & d[i]) && (size[i][0] = size[i][1]), t[i] = size[i][0] & d[i], t[i] |= (size[i][1] & d[i]) << 8, t[i] |= (size[1 - i][i] & d[i]) << 16, t[i] |= (size[1 - i][1 - i] & d[i]) << 24, 0 == (t[i] & 15) && (t[i] <<= 8), 0 == (t[i] & 3840) && (t[i] = t[i] & 15 | t[i] >> 8), 0 == (t[i] & 983040) && (t[i] = t[i] & 65535 | (t[i] & 251658240) >> 8), options[i] = t[i] & 15, d[i] == mxConstants.DIRECTION_MASK_WEST || d[i] == mxConstants.DIRECTION_MASK_NORTH || 
        d[i] == mxConstants.DIRECTION_MASK_EAST || d[i] == mxConstants.DIRECTION_MASK_SOUTH)) {
          options[i] = d[i];
        }
      }
      d = options[0] == mxConstants.DIRECTION_MASK_EAST ? 3 : options[0];
      t = options[1] == mxConstants.DIRECTION_MASK_EAST ? 3 : options[1];
      /** @type {number} */
      d = d - n;
      /** @type {number} */
      t = t - n;
      if (1 > d) {
        d = d + 4;
      }
      if (1 > t) {
        t = t + 4;
      }
      d = mxEdgeStyle.routePatterns[d - 1][t - 1];
      mxEdgeStyle.wayPoints1[0][0] = pos[0][0];
      mxEdgeStyle.wayPoints1[0][1] = pos[0][1];
      switch(options[0]) {
        case mxConstants.DIRECTION_MASK_WEST:
          mxEdgeStyle.wayPoints1[0][0] -= e;
          mxEdgeStyle.wayPoints1[0][1] += data[0][1] * pos[0][3];
          break;
        case mxConstants.DIRECTION_MASK_SOUTH:
          mxEdgeStyle.wayPoints1[0][0] += data[0][0] * pos[0][2];
          mxEdgeStyle.wayPoints1[0][1] += pos[0][3] + e;
          break;
        case mxConstants.DIRECTION_MASK_EAST:
          mxEdgeStyle.wayPoints1[0][0] += pos[0][2] + e;
          mxEdgeStyle.wayPoints1[0][1] += data[0][1] * pos[0][3];
          break;
        case mxConstants.DIRECTION_MASK_NORTH:
          mxEdgeStyle.wayPoints1[0][0] += data[0][0] * pos[0][2];
          mxEdgeStyle.wayPoints1[0][1] -= e;
      }
      /** @type {number} */
      e = 0;
      /** @type {number} */
      f = t = 0 < (options[0] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) ? 0 : 1;
      /** @type {number} */
      i = 0;
      for (; i < d.length; i++) {
        /** @type {number} */
        a = d[i] & 15;
        /** @type {number} */
        s = a == mxConstants.DIRECTION_MASK_EAST ? 3 : a;
        /** @type {number} */
        s = s + n;
        if (4 < s) {
          /** @type {number} */
          s = s - 4;
        }
        b = mxEdgeStyle.dirVectors[s - 1];
        /** @type {number} */
        a = 0 < s % 2 ? 0 : 1;
        if (a != t) {
          e++;
          mxEdgeStyle.wayPoints1[e][0] = mxEdgeStyle.wayPoints1[e - 1][0];
          mxEdgeStyle.wayPoints1[e][1] = mxEdgeStyle.wayPoints1[e - 1][1];
        }
        /** @type {boolean} */
        min = 0 < (d[i] & mxEdgeStyle.TARGET_MASK);
        /** @type {boolean} */
        max = 0 < (d[i] & mxEdgeStyle.SOURCE_MASK);
        /** @type {number} */
        x = (d[i] & mxEdgeStyle.SIDE_MASK) >> 5;
        /** @type {number} */
        x = x << n;
        if (15 < x) {
          /** @type {number} */
          x = x >> 4;
        }
        /** @type {boolean} */
        size = 0 < (d[i] & mxEdgeStyle.CENTER_MASK);
        if ((max || min) && 9 > x) {
          /** @type {number} */
          s = max ? 0 : 1;
          x = size && 0 == a ? pos[s][0] + data[s][0] * pos[s][2] : size ? pos[s][1] + data[s][1] * pos[s][3] : mxEdgeStyle.limits[s][x];
          if (0 == a) {
            /** @type {number} */
            x = (x - mxEdgeStyle.wayPoints1[e][0]) * b[0];
            if (0 < x) {
              mxEdgeStyle.wayPoints1[e][0] += b[0] * x;
            }
          } else {
            /** @type {number} */
            x = (x - mxEdgeStyle.wayPoints1[e][1]) * b[1];
            if (0 < x) {
              mxEdgeStyle.wayPoints1[e][1] += b[1] * x;
            }
          }
        } else {
          if (size) {
            mxEdgeStyle.wayPoints1[e][0] += b[0] * Math.abs(mxEdgeStyle.vertexSeperations[s] / 2);
            mxEdgeStyle.wayPoints1[e][1] += b[1] * Math.abs(mxEdgeStyle.vertexSeperations[s] / 2);
          }
        }
        if (0 < e && mxEdgeStyle.wayPoints1[e][a] == mxEdgeStyle.wayPoints1[e - 1][a]) {
          e--;
        } else {
          /** @type {number} */
          t = a;
        }
      }
      /** @type {number} */
      i = 0;
      for (; i <= e && (i != e || ((0 < (options[1] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) ? 0 : 1) == f ? 0 : 1) == (e + 1) % 2); i++) {
        a.push(new mxPoint(Math.round(mxEdgeStyle.wayPoints1[i][0] * k.view.scale * 10) / 10, Math.round(mxEdgeStyle.wayPoints1[i][1] * k.view.scale * 10) / 10));
      }
      /** @type {number} */
      k = 1;
      for (; k < a.length;) {
        if (null == a[k - 1] || null == a[k] || a[k - 1].x != a[k].x || a[k - 1].y != a[k].y) {
          k++;
        } else {
          a.splice(k, 1);
        }
      }
    }
  },
  getRoutePattern : function(index, length, latSidePrev, lonSidePrev) {
    var newEnd = index[0] == mxConstants.DIRECTION_MASK_EAST ? 3 : index[0];
    index = index[1] == mxConstants.DIRECTION_MASK_EAST ? 3 : index[1];
    /** @type {number} */
    newEnd = newEnd - length;
    /** @type {number} */
    index = index - length;
    if (1 > newEnd) {
      newEnd = newEnd + 4;
    }
    if (1 > index) {
      index = index + 4;
    }
    length = routePatterns[newEnd - 1][index - 1];
    if (!(0 != latSidePrev && 0 != lonSidePrev || null == inlineRoutePatterns[newEnd - 1][index - 1])) {
      length = inlineRoutePatterns[newEnd - 1][index - 1];
    }
    return length;
  }
};
var mxStyleRegistry = {
  values : [],
  putValue : function(index, value) {
    /** @type {!Object} */
    mxStyleRegistry.values[index] = value;
  },
  getValue : function(s) {
    return mxStyleRegistry.values[s];
  },
  getName : function(value) {
    var name;
    for (name in mxStyleRegistry.values) {
      if (mxStyleRegistry.values[name] == value) {
        return name;
      }
    }
    return null;
  }
};
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ELBOW, mxEdgeStyle.ElbowConnector);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ENTITY_RELATION, mxEdgeStyle.EntityRelation);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_LOOP, mxEdgeStyle.Loop);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_SIDETOSIDE, mxEdgeStyle.SideToSide);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_TOPTOBOTTOM, mxEdgeStyle.TopToBottom);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ORTHOGONAL, mxEdgeStyle.OrthConnector);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_SEGMENT, mxEdgeStyle.SegmentConnector);
mxStyleRegistry.putValue(mxConstants.PERIMETER_ELLIPSE, mxPerimeter.EllipsePerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_RECTANGLE, mxPerimeter.RectanglePerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_RHOMBUS, mxPerimeter.RhombusPerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_TRIANGLE, mxPerimeter.TrianglePerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_HEXAGON, mxPerimeter.HexagonPerimeter);
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxGraphView(targetGraph) {
  /** @type {!Object} */
  this.graph = targetGraph;
  this.translate = new mxPoint;
  this.graphBounds = new mxRectangle;
  this.states = new mxDictionary;
}
mxGraphView.prototype = new mxEventSource;
/** @type {function(!Object): undefined} */
mxGraphView.prototype.constructor = mxGraphView;
mxGraphView.prototype.EMPTY_POINT = new mxPoint;
/** @type {string} */
mxGraphView.prototype.doneResource = "none" != mxClient.language ? "done" : "";
/** @type {string} */
mxGraphView.prototype.updatingDocumentResource = "none" != mxClient.language ? "updatingDocument" : "";
/** @type {boolean} */
mxGraphView.prototype.allowEval = false;
/** @type {boolean} */
mxGraphView.prototype.captureDocumentGesture = true;
/** @type {boolean} */
mxGraphView.prototype.rendering = true;
/** @type {null} */
mxGraphView.prototype.graph = null;
/** @type {null} */
mxGraphView.prototype.currentRoot = null;
/** @type {null} */
mxGraphView.prototype.graphBounds = null;
/** @type {number} */
mxGraphView.prototype.scale = 1;
/** @type {null} */
mxGraphView.prototype.translate = null;
/** @type {null} */
mxGraphView.prototype.states = null;
/** @type {boolean} */
mxGraphView.prototype.updateStyle = false;
/** @type {null} */
mxGraphView.prototype.lastNode = null;
/** @type {null} */
mxGraphView.prototype.lastHtmlNode = null;
/** @type {null} */
mxGraphView.prototype.lastForegroundNode = null;
/** @type {null} */
mxGraphView.prototype.lastForegroundHtmlNode = null;
/**
 * @return {?}
 */
mxGraphView.prototype.getGraphBounds = function() {
  return this.graphBounds;
};
/**
 * @param {!AudioNode} a
 * @return {undefined}
 */
mxGraphView.prototype.setGraphBounds = function(a) {
  /** @type {!AudioNode} */
  this.graphBounds = a;
};
/**
 * @param {!Object} b
 * @return {?}
 */
mxGraphView.prototype.getBounds = function(b) {
  /** @type {null} */
  var group = null;
  if (null != b && 0 < b.length) {
    var V = this.graph.getModel();
    /** @type {number} */
    var i = 0;
    for (; i < b.length; i++) {
      if (V.isVertex(b[i]) || V.isEdge(b[i])) {
        var rect = this.getState(b[i]);
        if (null != rect) {
          if (null == group) {
            group = mxRectangle.fromRectangle(rect);
          } else {
            group.add(rect);
          }
        }
      }
    }
  }
  return group;
};
/**
 * @param {!Object} data
 * @return {?}
 */
mxGraphView.prototype.setCurrentRoot = function(data) {
  if (this.currentRoot != data) {
    var j = new mxCurrentRootChange(this, data);
    j.execute();
    var vLinks = new mxUndoableEdit(this, true);
    vLinks.add(j);
    this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", vLinks));
    this.graph.sizeDidChange();
  }
  return data;
};
/**
 * @param {string} data
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxGraphView.prototype.scaleAndTranslate = function(data, x, y) {
  var backupScale = this.scale;
  var ct = new mxPoint(this.translate.x, this.translate.y);
  if (this.scale != data || this.translate.x != x || this.translate.y != y) {
    /** @type {string} */
    this.scale = data;
    /** @type {number} */
    this.translate.x = x;
    /** @type {number} */
    this.translate.y = y;
    if (this.isEventsEnabled()) {
      this.viewStateChanged();
    }
  }
  this.fireEvent(new mxEventObject(mxEvent.SCALE_AND_TRANSLATE, "scale", data, "previousScale", backupScale, "translate", this.translate, "previousTranslate", ct));
};
/**
 * @return {?}
 */
mxGraphView.prototype.getScale = function() {
  return this.scale;
};
/**
 * @param {number} val
 * @return {undefined}
 */
mxGraphView.prototype.setScale = function(val) {
  var backupScale = this.scale;
  if (this.scale != val) {
    /** @type {number} */
    this.scale = val;
    if (this.isEventsEnabled()) {
      this.viewStateChanged();
    }
  }
  this.fireEvent(new mxEventObject(mxEvent.SCALE, "scale", val, "previousScale", backupScale));
};
/**
 * @return {?}
 */
mxGraphView.prototype.getTranslate = function() {
  return this.translate;
};
/**
 * @param {number} x
 * @param {number} value
 * @return {undefined}
 */
mxGraphView.prototype.setTranslate = function(x, value) {
  var ct = new mxPoint(this.translate.x, this.translate.y);
  if (this.translate.x != x || this.translate.y != value) {
    /** @type {number} */
    this.translate.x = x;
    /** @type {number} */
    this.translate.y = value;
    if (this.isEventsEnabled()) {
      this.viewStateChanged();
    }
  }
  this.fireEvent(new mxEventObject(mxEvent.TRANSLATE, "translate", this.translate, "previousTranslate", ct));
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.viewStateChanged = function() {
  this.revalidate();
  this.graph.sizeDidChange();
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.refresh = function() {
  if (null != this.currentRoot) {
    this.clear();
  }
  this.revalidate();
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.revalidate = function() {
  this.invalidate();
  this.validate();
};
/**
 * @param {string} index
 * @param {string} height
 * @param {number} position
 * @return {undefined}
 */
mxGraphView.prototype.clear = function(index, height, position) {
  var self = this.graph.getModel();
  index = index || self.getRoot();
  height = null != height ? height : false;
  position = null != position ? position : true;
  this.removeState(index);
  if (position && (height || index != this.currentRoot)) {
    position = self.getChildCount(index);
    /** @type {number} */
    var i = 0;
    for (; i < position; i++) {
      this.clear(self.getChildAt(index, i), height);
    }
  } else {
    this.invalidate(index);
  }
};
/**
 * @param {!Object} x
 * @param {?} y
 * @param {?} data
 * @return {undefined}
 */
mxGraphView.prototype.invalidate = function(x, y, data) {
  var self = this.graph.getModel();
  x = x || self.getRoot();
  y = null != y ? y : true;
  data = null != data ? data : true;
  var i = this.getState(x);
  if (null != i) {
    /** @type {boolean} */
    i.invalid = true;
  }
  if (!x.invalidating) {
    /** @type {boolean} */
    x.invalidating = true;
    if (y) {
      var len = self.getChildCount(x);
      /** @type {number} */
      i = 0;
      for (; i < len; i++) {
        var idx = self.getChildAt(x, i);
        this.invalidate(idx, y, data);
      }
    }
    if (data) {
      len = self.getEdgeCount(x);
      /** @type {number} */
      i = 0;
      for (; i < len; i++) {
        this.invalidate(self.getEdgeAt(x, i), y, data);
      }
    }
    delete x.invalidating;
  }
};
/**
 * @param {string} returnTuples
 * @return {undefined}
 */
mxGraphView.prototype.validate = function(returnTuples) {
  var path = mxLog.enter("mxGraphView.validate");
  window.status = mxResources.get(this.updatingDocumentResource) || this.updatingDocumentResource;
  this.resetValidationState();
  /** @type {null} */
  var display = null;
  if (!(null == this.canvas || null != this.textDiv || 8 != document.documentMode || mxClient.IS_EM)) {
    /** @type {!Element} */
    this.placeholder = document.createElement("div");
    /** @type {string} */
    this.placeholder.style.position = "absolute";
    /** @type {string} */
    this.placeholder.style.width = this.canvas.clientWidth + "px";
    /** @type {string} */
    this.placeholder.style.height = this.canvas.clientHeight + "px";
    this.canvas.parentNode.appendChild(this.placeholder);
    display = this.drawPane.style.display;
    /** @type {string} */
    this.canvas.style.display = "none";
    /** @type {!Element} */
    this.textDiv = document.createElement("div");
    /** @type {string} */
    this.textDiv.style.position = "absolute";
    /** @type {string} */
    this.textDiv.style.whiteSpace = "nowrap";
    /** @type {string} */
    this.textDiv.style.visibility = "hidden";
    /** @type {string} */
    this.textDiv.style.display = "inline-block";
    /** @type {string} */
    this.textDiv.style.zoom = "1";
    document.body.appendChild(this.textDiv);
  }
  returnTuples = this.getBoundingBox(this.validateCellState(this.validateCell(returnTuples || (null != this.currentRoot ? this.currentRoot : this.graph.getModel().getRoot()))));
  this.setGraphBounds(null != returnTuples ? returnTuples : this.getEmptyBounds());
  this.validateBackground();
  if (null != display) {
    this.canvas.style.display = display;
    this.textDiv.parentNode.removeChild(this.textDiv);
    if (null != this.placeholder) {
      this.placeholder.parentNode.removeChild(this.placeholder);
    }
    /** @type {null} */
    this.textDiv = null;
  }
  this.resetValidationState();
  window.status = mxResources.get(this.doneResource) || this.doneResource;
  mxLog.leave("mxGraphView.validate", path);
};
/**
 * @return {?}
 */
mxGraphView.prototype.getEmptyBounds = function() {
  return new mxRectangle(this.translate.x * this.scale, this.translate.y * this.scale);
};
/**
 * @param {!Object} o
 * @param {?} parent
 * @return {?}
 */
mxGraphView.prototype.getBoundingBox = function(o, parent) {
  parent = null != parent ? parent : true;
  /** @type {null} */
  var box = null;
  if (null != o && (null != o.shape && null != o.shape.boundingBox && (box = o.shape.boundingBox.clone()), null != o.text && null != o.text.boundingBox && (null != box ? box.add(o.text.boundingBox) : box = o.text.boundingBox.clone()), parent)) {
    parent = this.graph.getModel();
    var cell_amount = parent.getChildCount(o.cell);
    /** @type {number} */
    var i = 0;
    for (; i < cell_amount; i++) {
      var b = this.getBoundingBox(this.getState(parent.getChildAt(o.cell, i)));
      if (null != b) {
        if (null == box) {
          box = b;
        } else {
          box.add(b);
        }
      }
    }
  }
  return box;
};
/**
 * @param {string} bounds
 * @return {?}
 */
mxGraphView.prototype.createBackgroundPageShape = function(bounds) {
  return new mxRectangleShape(bounds, "white", "black");
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.validateBackground = function() {
  this.validateBackgroundImage();
  this.validateBackgroundPage();
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.validateBackgroundImage = function() {
  var bg = this.graph.getBackgroundImage();
  if (null != bg) {
    if (null == this.backgroundImage || this.backgroundImage.image != bg.src) {
      if (null != this.backgroundImage) {
        this.backgroundImage.destroy();
      }
      var bounds = new mxRectangle(0, 0, 1, 1);
      this.backgroundImage = new mxImageShape(bounds, bg.src);
      this.backgroundImage.dialect = this.graph.dialect;
      this.backgroundImage.init(this.backgroundPane);
      this.backgroundImage.redraw();
      if (!(8 != document.documentMode || mxClient.IS_EM)) {
        mxEvent.addGestureListeners(this.backgroundImage.node, mxUtils.bind(this, function(evt) {
          this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
        }), mxUtils.bind(this, function(evt) {
          this.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
        }), mxUtils.bind(this, function(evt) {
          this.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
        }));
      }
    }
    this.redrawBackgroundImage(this.backgroundImage, bg);
  } else {
    if (null != this.backgroundImage) {
      this.backgroundImage.destroy();
      /** @type {null} */
      this.backgroundImage = null;
    }
  }
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.validateBackgroundPage = function() {
  if (this.graph.pageVisible) {
    var bounds = this.getBackgroundPageBounds();
    if (null == this.backgroundPageShape) {
      this.backgroundPageShape = this.createBackgroundPageShape(bounds);
      this.backgroundPageShape.scale = this.scale;
      /** @type {boolean} */
      this.backgroundPageShape.isShadow = true;
      this.backgroundPageShape.dialect = this.graph.dialect;
      this.backgroundPageShape.init(this.backgroundPane);
      this.backgroundPageShape.redraw();
      if (this.graph.nativeDblClickEnabled) {
        mxEvent.addListener(this.backgroundPageShape.node, "dblclick", mxUtils.bind(this, function(evt) {
          this.graph.dblClick(evt);
        }));
      }
      mxEvent.addGestureListeners(this.backgroundPageShape.node, mxUtils.bind(this, function(evt) {
        this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
      }), mxUtils.bind(this, function(evt) {
        if (null != this.graph.tooltipHandler && this.graph.tooltipHandler.isHideOnHover()) {
          this.graph.tooltipHandler.hide();
        }
        if (this.graph.isMouseDown && !mxEvent.isConsumed(evt)) {
          this.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
        }
      }), mxUtils.bind(this, function(evt) {
        this.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
      }));
    } else {
      this.backgroundPageShape.scale = this.scale;
      this.backgroundPageShape.bounds = bounds;
      this.backgroundPageShape.redraw();
    }
  } else {
    if (null != this.backgroundPageShape) {
      this.backgroundPageShape.destroy();
      /** @type {null} */
      this.backgroundPageShape = null;
    }
  }
};
/**
 * @return {?}
 */
mxGraphView.prototype.getBackgroundPageBounds = function() {
  var fmt = this.graph.pageFormat;
  /** @type {number} */
  var ps = this.scale * this.graph.pageScale;
  return new mxRectangle(this.scale * this.translate.x, this.scale * this.translate.y, fmt.width * ps, fmt.height * ps);
};
/**
 * @param {!Object} controller
 * @param {!Object} element
 * @return {undefined}
 */
mxGraphView.prototype.redrawBackgroundImage = function(controller, element) {
  controller.scale = this.scale;
  /** @type {number} */
  controller.bounds.x = this.scale * (this.translate.x + element.x);
  /** @type {number} */
  controller.bounds.y = this.scale * (this.translate.y + element.y);
  /** @type {number} */
  controller.bounds.width = this.scale * element.width;
  /** @type {number} */
  controller.bounds.height = this.scale * element.height;
  controller.redraw();
};
/**
 * @param {(Object|string)} cell
 * @param {?} value
 * @return {?}
 */
mxGraphView.prototype.validateCell = function(cell, value) {
  if (null != cell) {
    if (value = (null != value ? value : true) && this.graph.isCellVisible(cell), null == this.getState(cell, value) || value) {
      var self = this.graph.getModel();
      var childCount = self.getChildCount(cell);
      /** @type {number} */
      var i = 0;
      for (; i < childCount; i++) {
        this.validateCell(self.getChildAt(cell, i), value && (!this.isCellCollapsed(cell) || cell == this.currentRoot));
      }
    } else {
      this.removeState(cell);
    }
  }
  return cell;
};
/**
 * @param {string} i
 * @param {number} min
 * @return {?}
 */
mxGraphView.prototype.validateCellState = function(i, min) {
  min = null != min ? min : true;
  /** @type {null} */
  var data = null;
  if (null != i && (data = this.getState(i), null != data)) {
    var menu = this.graph.getModel();
    if (data.invalid) {
      /** @type {boolean} */
      data.invalid = false;
      if (null == data.style || data.invalidStyle) {
        data.style = this.graph.getCellStyle(data.cell);
        /** @type {boolean} */
        data.invalidStyle = false;
      }
      if (i != this.currentRoot) {
        this.validateCellState(menu.getParent(i), false);
      }
      data.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(i, true), false), true);
      data.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(i, false), false), false);
      this.updateCellState(data);
      if (!(i == this.currentRoot || data.invalid)) {
        this.graph.cellRenderer.redraw(data, false, this.isRendering());
        data.updateCachedBounds();
      }
    }
    if (min && !data.invalid) {
      if (null != data.shape) {
        this.stateValidated(data);
      }
      min = menu.getChildCount(i);
      /** @type {number} */
      var y = 0;
      for (; y < min; y++) {
        this.validateCellState(menu.getChildAt(i, y));
      }
    }
  }
  return data;
};
/**
 * @param {!Object} node
 * @return {undefined}
 */
mxGraphView.prototype.updateCellState = function(node) {
  /** @type {number} */
  node.absoluteOffset.x = 0;
  /** @type {number} */
  node.absoluteOffset.y = 0;
  /** @type {number} */
  node.origin.x = 0;
  /** @type {number} */
  node.origin.y = 0;
  /** @type {number} */
  node.length = 0;
  if (node.cell != this.currentRoot) {
    var exports = this.graph.getModel();
    var t = this.getState(exports.getParent(node.cell));
    if (null != t && t.cell != this.currentRoot) {
      node.origin.x += t.origin.x;
      node.origin.y += t.origin.y;
    }
    var point = this.graph.getChildOffsetForCell(node.cell);
    if (null != point) {
      node.origin.x += point.x;
      node.origin.y += point.y;
    }
    var b = this.graph.getCellGeometry(node.cell);
    if (null != b) {
      if (!exports.isEdge(node.cell)) {
        point = null != b.offset ? b.offset : this.EMPTY_POINT;
        if (b.relative && null != t) {
          if (exports.isEdge(t.cell)) {
            point = this.getPoint(t, b);
            if (null != point) {
              node.origin.x += point.x / this.scale - t.origin.x - this.translate.x;
              node.origin.y += point.y / this.scale - t.origin.y - this.translate.y;
            }
          } else {
            node.origin.x += b.x * t.unscaledWidth + point.x;
            node.origin.y += b.y * t.unscaledHeight + point.y;
          }
        } else {
          /** @type {number} */
          node.absoluteOffset.x = this.scale * point.x;
          /** @type {number} */
          node.absoluteOffset.y = this.scale * point.y;
          node.origin.x += b.x;
          node.origin.y += b.y;
        }
      }
      /** @type {number} */
      node.x = this.scale * (this.translate.x + node.origin.x);
      /** @type {number} */
      node.y = this.scale * (this.translate.y + node.origin.y);
      /** @type {number} */
      node.width = this.scale * b.width;
      node.unscaledWidth = b.width;
      /** @type {number} */
      node.height = this.scale * b.height;
      node.unscaledHeight = b.height;
      if (exports.isVertex(node.cell)) {
        this.updateVertexState(node, b);
      }
      if (exports.isEdge(node.cell)) {
        this.updateEdgeState(node, b);
      }
    }
  }
  node.updateCachedBounds();
};
/**
 * @param {!Object} el
 * @return {?}
 */
mxGraphView.prototype.isCellCollapsed = function(el) {
  return this.graph.isCellCollapsed(el);
};
/**
 * @param {!Object} self
 * @param {!Object} value
 * @return {undefined}
 */
mxGraphView.prototype.updateVertexState = function(self, value) {
  var data = this.graph.getModel();
  var s = this.getState(data.getParent(self.cell));
  if (value.relative && null != s && !data.isEdge(s.cell) && (data = mxUtils.toRadians(s.style[mxConstants.STYLE_ROTATION] || "0"), 0 != data)) {
    /** @type {number} */
    value = Math.cos(data);
    /** @type {number} */
    data = Math.sin(data);
    var pt = new mxPoint(self.getCenterX(), self.getCenterY());
    s = new mxPoint(s.getCenterX(), s.getCenterY());
    s = mxUtils.getRotatedPoint(pt, value, data, s);
    /** @type {number} */
    self.x = s.x - self.width / 2;
    /** @type {number} */
    self.y = s.y - self.height / 2;
  }
  this.updateVertexLabelOffset(self);
};
/**
 * @param {!Object} e
 * @param {!Object} key
 * @return {undefined}
 */
mxGraphView.prototype.updateEdgeState = function(e, key) {
  var c = e.getVisibleTerminalState(true);
  var d = e.getVisibleTerminalState(false);
  if (null != this.graph.model.getTerminal(e.cell, true) && null == c || null == c && null == key.getTerminalPoint(true) || null != this.graph.model.getTerminal(e.cell, false) && null == d || null == d && null == key.getTerminalPoint(false)) {
    this.clear(e.cell, true);
  } else {
    this.updateFixedTerminalPoints(e, c, d);
    this.updatePoints(e, key.points, c, d);
    this.updateFloatingTerminalPoints(e, c, d);
    key = e.absolutePoints;
    if (e.cell != this.currentRoot && (null == key || 2 > key.length || null == key[0] || null == key[key.length - 1])) {
      this.clear(e.cell, true);
    } else {
      this.updateEdgeBounds(e);
      this.updateEdgeLabelOffset(e);
    }
  }
};
/**
 * @param {!Object} options
 * @return {undefined}
 */
mxGraphView.prototype.updateVertexLabelOffset = function(options) {
  var align = mxUtils.getValue(options.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
  if (align == mxConstants.ALIGN_LEFT) {
    align = mxUtils.getValue(options.style, mxConstants.STYLE_LABEL_WIDTH, null);
    align = null != align ? align * this.scale : options.width;
    options.absoluteOffset.x -= align;
  } else {
    if (align == mxConstants.ALIGN_RIGHT) {
      options.absoluteOffset.x += options.width;
    } else {
      if (align == mxConstants.ALIGN_CENTER && (align = mxUtils.getValue(options.style, mxConstants.STYLE_LABEL_WIDTH, null), null != align)) {
        var align = mxUtils.getValue(options.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER);
        /** @type {number} */
        var delta = 0;
        if (align == mxConstants.ALIGN_CENTER) {
          /** @type {number} */
          delta = .5;
        } else {
          if (align == mxConstants.ALIGN_RIGHT) {
            /** @type {number} */
            delta = 1;
          }
        }
        if (0 != delta) {
          options.absoluteOffset.x -= (align * this.scale - options.width) * delta;
        }
      }
    }
  }
  align = mxUtils.getValue(options.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
  if (align == mxConstants.ALIGN_TOP) {
    options.absoluteOffset.y -= options.height;
  } else {
    if (align == mxConstants.ALIGN_BOTTOM) {
      options.absoluteOffset.y += options.height;
    }
  }
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.resetValidationState = function() {
  /** @type {null} */
  this.lastForegroundHtmlNode = this.lastForegroundNode = this.lastHtmlNode = this.lastNode = null;
};
/**
 * @param {!Object} tmp
 * @return {undefined}
 */
mxGraphView.prototype.stateValidated = function(tmp) {
  var b = this.graph.getModel().isEdge(tmp.cell) && this.graph.keepEdgesInForeground || this.graph.getModel().isVertex(tmp.cell) && this.graph.keepEdgesInBackground;
  tmp = this.graph.cellRenderer.insertStateAfter(tmp, b ? this.lastForegroundNode || this.lastNode : this.lastNode, b ? this.lastForegroundHtmlNode || this.lastHtmlNode : this.lastHtmlNode);
  if (b) {
    this.lastForegroundHtmlNode = tmp[1];
    this.lastForegroundNode = tmp[0];
  } else {
    this.lastHtmlNode = tmp[1];
    this.lastNode = tmp[0];
  }
};
/**
 * @param {!Object} el
 * @param {(Object|string)} value
 * @param {(Object|string)} label
 * @return {undefined}
 */
mxGraphView.prototype.updateFixedTerminalPoints = function(el, value, label) {
  this.updateFixedTerminalPoint(el, value, true, this.graph.getConnectionConstraint(el, value, true));
  this.updateFixedTerminalPoint(el, label, false, this.graph.getConnectionConstraint(el, label, false));
};
/**
 * @param {!Object} a
 * @param {?} val
 * @param {boolean} x
 * @param {?} key
 * @return {undefined}
 */
mxGraphView.prototype.updateFixedTerminalPoint = function(a, val, x, key) {
  a.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(a, val, x, key), x);
};
/**
 * @param {!Object} data
 * @param {!Object} name
 * @param {boolean} url
 * @param {!Object} t
 * @return {?}
 */
mxGraphView.prototype.getFixedTerminalPoint = function(data, name, url, t) {
  /** @type {null} */
  var s = null;
  if (null != t) {
    s = this.graph.getConnectionPoint(name, t, false);
  }
  if (null == s && null == name) {
    name = this.scale;
    t = this.translate;
    var position = data.origin;
    s = this.graph.getCellGeometry(data.cell).getTerminalPoint(url);
    if (null != s) {
      s = new mxPoint(name * (t.x + s.x + position.x), name * (t.y + s.y + position.y));
    }
  }
  return s;
};
/**
 * @param {!Object} rect
 * @return {?}
 */
mxGraphView.prototype.updateBoundsFromStencil = function(rect) {
  /** @type {null} */
  var blackrects = null;
  if (null != rect && null != rect.shape && null != rect.shape.stencil && "fixed" == rect.shape.stencil.aspect) {
    blackrects = mxRectangle.fromRectangle(rect);
    var startPosition = rect.shape.stencil.computeAspect(rect.style, rect.x, rect.y, rect.width, rect.height);
    rect.setRect(startPosition.x, startPosition.y, rect.shape.stencil.w0 * startPosition.width, rect.shape.stencil.h0 * startPosition.height);
  }
  return blackrects;
};
/**
 * @param {!Object} o
 * @param {!Object} value
 * @param {?} c
 * @param {!Object} s
 * @return {undefined}
 */
mxGraphView.prototype.updatePoints = function(o, value, c, s) {
  if (null != o) {
    /** @type {!Array} */
    var result = [];
    result.push(o.absolutePoints[0]);
    var i = this.getEdgeStyle(o, value, c, s);
    if (null != i) {
      c = this.getTerminalPort(o, c, true);
      s = this.getTerminalPort(o, s, false);
      var b = this.updateBoundsFromStencil(c);
      var p = this.updateBoundsFromStencil(s);
      i(o, c, s, value, result);
      if (null != b) {
        c.setRect(b.x, b.y, b.width, b.height);
      }
      if (null != p) {
        s.setRect(p.x, p.y, p.width, p.height);
      }
    } else {
      if (null != value) {
        /** @type {number} */
        i = 0;
        for (; i < value.length; i++) {
          if (null != value[i]) {
            c = mxUtils.clone(value[i]);
            result.push(this.transformControlPoint(o, c));
          }
        }
      }
    }
    value = o.absolutePoints;
    result.push(value[value.length - 1]);
    /** @type {!Array} */
    o.absolutePoints = result;
  }
};
/**
 * @param {!Object} a
 * @param {!Object} b
 * @param {number} o
 * @return {?}
 */
mxGraphView.prototype.transformControlPoint = function(a, b, o) {
  return null != a && null != b ? (a = a.origin, o = o ? 1 : this.scale, new mxPoint(o * (b.x + this.translate.x + a.x), o * (b.y + this.translate.y + a.y))) : null;
};
/**
 * @param {!Object} s
 * @param {string} t
 * @param {!Object} i
 * @param {!Object} value
 * @return {?}
 */
mxGraphView.prototype.isLoopStyleEnabled = function(s, t, i, value) {
  var center = this.graph.getConnectionConstraint(s, i, true);
  var r = this.graph.getConnectionConstraint(s, value, false);
  return !(null == t || 2 > t.length) || mxUtils.getValue(s.style, mxConstants.STYLE_ORTHOGONAL_LOOP, false) && (null != center && null != center.point || null != r && null != r.point) ? false : null != i && i == value;
};
/**
 * @param {!Object} s
 * @param {string} n
 * @param {!Object} e
 * @param {!Object} d
 * @return {?}
 */
mxGraphView.prototype.getEdgeStyle = function(s, n, e, d) {
  s = this.isLoopStyleEnabled(s, n, e, d) ? mxUtils.getValue(s.style, mxConstants.STYLE_LOOP, this.graph.defaultLoopStyle) : mxUtils.getValue(s.style, mxConstants.STYLE_NOEDGESTYLE, false) ? null : s.style[mxConstants.STYLE_EDGE];
  if ("string" == typeof s) {
    n = mxStyleRegistry.getValue(s);
    if (null == n && this.isAllowEval()) {
      n = mxUtils.eval(s);
    }
    /** @type {string} */
    s = n;
  }
  return "function" == typeof s ? s : null;
};
/**
 * @param {!Object} props
 * @param {number} input
 * @param {number} x
 * @return {undefined}
 */
mxGraphView.prototype.updateFloatingTerminalPoints = function(props, input, x) {
  var values = props.absolutePoints;
  var notes_mac = values[0];
  if (null == values[values.length - 1] && null != x) {
    this.updateFloatingTerminalPoint(props, x, input, false);
  }
  if (null == notes_mac && null != input) {
    this.updateFloatingTerminalPoint(props, input, x, true);
  }
};
/**
 * @param {!Object} a
 * @param {number} v
 * @param {number} n
 * @param {boolean} t
 * @return {undefined}
 */
mxGraphView.prototype.updateFloatingTerminalPoint = function(a, v, n, t) {
  a.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(a, v, n, t), t);
};
/**
 * @param {!Object} result
 * @param {!Object} state
 * @param {number} r
 * @param {boolean} s
 * @return {?}
 */
mxGraphView.prototype.getFloatingTerminalPoint = function(result, state, r, s) {
  state = this.getTerminalPort(result, state, s);
  var pt = this.getNextPoint(result, r, s);
  var resultCmp = this.graph.isOrthogonal(result);
  r = mxUtils.toRadians(Number(state.style[mxConstants.STYLE_ROTATION] || "0"));
  var ct = new mxPoint(state.getCenterX(), state.getCenterY());
  if (0 != r) {
    /** @type {number} */
    var value = Math.cos(-r);
    /** @type {number} */
    var sin = Math.sin(-r);
    pt = mxUtils.getRotatedPoint(pt, value, sin, ct);
  }
  /** @type {number} */
  value = parseFloat(result.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);
  /** @type {number} */
  value = value + parseFloat(result.style[s ? mxConstants.STYLE_SOURCE_PERIMETER_SPACING : mxConstants.STYLE_TARGET_PERIMETER_SPACING] || 0);
  result = this.getPerimeterPoint(state, pt, 0 == r && resultCmp, value);
  if (0 != r) {
    /** @type {number} */
    value = Math.cos(r);
    /** @type {number} */
    sin = Math.sin(r);
    result = mxUtils.getRotatedPoint(result, value, sin, ct);
  }
  return result;
};
/**
 * @param {!Object} s
 * @param {!Object} pos
 * @param {boolean} cnt
 * @return {?}
 */
mxGraphView.prototype.getTerminalPort = function(s, pos, cnt) {
  s = mxUtils.getValue(s.style, cnt ? mxConstants.STYLE_SOURCE_PORT : mxConstants.STYLE_TARGET_PORT);
  if (null != s) {
    s = this.getState(this.graph.getModel().getCell(s));
    if (null != s) {
      /** @type {!Object} */
      pos = s;
    }
  }
  return pos;
};
/**
 * @param {!Object} s
 * @param {!Object} point
 * @param {boolean} axis
 * @param {number} self
 * @return {?}
 */
mxGraphView.prototype.getPerimeterPoint = function(s, point, axis, self) {
  /** @type {null} */
  var pos = null;
  if (null != s) {
    var offset = this.getPerimeterFunction(s);
    if (null != offset && null != point && (self = this.getPerimeterBounds(s, self), 0 < self.width || 0 < self.height)) {
      pos = new mxPoint(point.x, point.y);
      /** @type {boolean} */
      var r = point = false;
      if (this.graph.model.isVertex(s.cell)) {
        /** @type {boolean} */
        point = 1 == mxUtils.getValue(s.style, mxConstants.STYLE_FLIPH, 0);
        /** @type {boolean} */
        r = 1 == mxUtils.getValue(s.style, mxConstants.STYLE_FLIPV, 0);
        if (null != s.shape && null != s.shape.stencil) {
          /** @type {boolean} */
          point = 1 == mxUtils.getValue(s.style, "stencilFlipH", 0) || point;
          /** @type {boolean} */
          r = 1 == mxUtils.getValue(s.style, "stencilFlipV", 0) || r;
        }
        if (point) {
          /** @type {number} */
          pos.x = 2 * self.getCenterX() - pos.x;
        }
        if (r) {
          /** @type {number} */
          pos.y = 2 * self.getCenterY() - pos.y;
        }
      }
      pos = offset(self, s, pos, axis);
      if (null != pos) {
        if (point) {
          /** @type {number} */
          pos.x = 2 * self.getCenterX() - pos.x;
        }
        if (r) {
          /** @type {number} */
          pos.y = 2 * self.getCenterY() - pos.y;
        }
      }
    }
    if (null == pos) {
      pos = this.getPoint(s);
    }
  }
  return pos;
};
/**
 * @param {!Object} a
 * @return {?}
 */
mxGraphView.prototype.getRoutingCenterX = function(a) {
  /** @type {number} */
  var p = null != a.style ? parseFloat(a.style[mxConstants.STYLE_ROUTING_CENTER_X]) || 0 : 0;
  return a.getCenterX() + p * a.width;
};
/**
 * @param {!Object} s
 * @return {?}
 */
mxGraphView.prototype.getRoutingCenterY = function(s) {
  /** @type {number} */
  var w = null != s.style ? parseFloat(s.style[mxConstants.STYLE_ROUTING_CENTER_Y]) || 0 : 0;
  return s.getCenterY() + w * s.height;
};
/**
 * @param {!Object} h
 * @param {number} x
 * @return {?}
 */
mxGraphView.prototype.getPerimeterBounds = function(h, x) {
  x = null != x ? x : 0;
  if (null != h) {
    x = x + parseFloat(h.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);
  }
  return h.getPerimeterBounds(x * this.scale);
};
/**
 * @param {!Object} n
 * @return {?}
 */
mxGraphView.prototype.getPerimeterFunction = function(n) {
  n = n.style[mxConstants.STYLE_PERIMETER];
  if ("string" == typeof n) {
    var x = mxStyleRegistry.getValue(n);
    if (null == x && this.isAllowEval()) {
      x = mxUtils.eval(n);
    }
    n = x;
  }
  return "function" == typeof n ? n : null;
};
/**
 * @param {!Object} t
 * @param {number} point
 * @param {boolean} offset
 * @return {?}
 */
mxGraphView.prototype.getNextPoint = function(t, point, offset) {
  t = t.absolutePoints;
  /** @type {null} */
  var start = null;
  if (null != t && 2 <= t.length) {
    start = t.length;
    start = t[offset ? Math.min(1, start - 1) : Math.max(0, start - 2)];
  }
  if (null == start && null != point) {
    start = new mxPoint(point.getCenterX(), point.getCenterY());
  }
  return start;
};
/**
 * @param {string} s
 * @param {string} i
 * @return {?}
 */
mxGraphView.prototype.getVisibleTerminal = function(s, i) {
  var self = this.graph.getModel();
  i = s = self.getTerminal(s, i);
  for (; null != s && s != this.currentRoot;) {
    if (!this.graph.isCellVisible(i) || this.isCellCollapsed(s)) {
      /** @type {string} */
      i = s;
    }
    s = self.getParent(s);
  }
  if (!(null == i || self.contains(i) && self.getParent(i) != self.getRoot() && i != this.currentRoot)) {
    /** @type {null} */
    i = null;
  }
  return i;
};
/**
 * @param {!Object} t
 * @return {undefined}
 */
mxGraphView.prototype.updateEdgeBounds = function(t) {
  var list = t.absolutePoints;
  var start = list[0];
  var end = list[list.length - 1];
  if (start.x != end.x || start.y != end.y) {
    /** @type {number} */
    var f = end.x - start.x;
    /** @type {number} */
    var e = end.y - start.y;
    /** @type {number} */
    t.terminalDistance = Math.sqrt(f * f + e * e);
  } else {
    /** @type {number} */
    t.terminalDistance = 0;
  }
  /** @type {number} */
  end = 0;
  /** @type {!Array} */
  var result = [];
  e = start;
  if (null != e) {
    start = e.x;
    var h = e.y;
    var last = start;
    var height = h;
    /** @type {number} */
    var i = 1;
    for (; i < list.length; i++) {
      var t = list[i];
      if (null != t) {
        /** @type {number} */
        f = e.x - t.x;
        /** @type {number} */
        e = e.y - t.y;
        /** @type {number} */
        f = Math.sqrt(f * f + e * e);
        result.push(f);
        /** @type {number} */
        end = end + f;
        e = t;
        /** @type {number} */
        start = Math.min(e.x, start);
        /** @type {number} */
        h = Math.min(e.y, h);
        /** @type {number} */
        last = Math.max(e.x, last);
        /** @type {number} */
        height = Math.max(e.y, height);
      }
    }
    /** @type {number} */
    t.length = end;
    /** @type {!Array} */
    t.segments = result;
    t.x = start;
    t.y = h;
    /** @type {number} */
    t.width = Math.max(1, last - start);
    /** @type {number} */
    t.height = Math.max(1, height - h);
  }
};
/**
 * @param {number} s
 * @param {number} r
 * @return {?}
 */
mxGraphView.prototype.getPoint = function(s, r) {
  var x = s.getCenterX();
  var y = s.getCenterY();
  if (null == s.segments || null != r && !r.relative) {
    if (null != r) {
      r = r.offset;
      if (null != r) {
        x = x + r.x;
        y = y + r.y;
      }
    }
  } else {
    var width = s.absolutePoints.length;
    /** @type {number} */
    var t = Math.round(((null != r ? r.x / 2 : 0) + .5) * s.length);
    var h = s.segments[0];
    /** @type {number} */
    var top = 0;
    /** @type {number} */
    var i = 1;
    for (; t >= Math.round(top + h) && i < width - 1;) {
      top = top + h;
      h = s.segments[i++];
    }
    /** @type {number} */
    width = 0 == h ? 0 : (t - top) / h;
    t = s.absolutePoints[i - 1];
    s = s.absolutePoints[i];
    if (null != t && null != s) {
      /** @type {number} */
      i = x = y = 0;
      if (null != r) {
        y = r.y;
        r = r.offset;
        if (null != r) {
          x = r.x;
          i = r.y;
        }
      }
      /** @type {number} */
      r = s.x - t.x;
      /** @type {number} */
      s = s.y - t.y;
      x = t.x + r * width + ((0 == h ? 0 : s / h) * y + x) * this.scale;
      /** @type {number} */
      y = t.y + s * width - ((0 == h ? 0 : r / h) * y - i) * this.scale;
    }
  }
  return new mxPoint(x, y);
};
/**
 * @param {number} b
 * @param {number} x
 * @param {number} y
 * @return {?}
 */
mxGraphView.prototype.getRelativePoint = function(b, x, y) {
  var c = this.graph.getModel().getGeometry(b.cell);
  if (null != c) {
    var value = b.absolutePoints.length;
    if (c.relative && 1 < value) {
      c = b.length;
      var t = b.segments;
      var s = b.absolutePoints[0];
      var q = b.absolutePoints[1];
      var l = mxUtils.ptSegDistSq(s.x, s.y, q.x, q.y, x, y);
      /** @type {number} */
      var a = 0;
      /** @type {number} */
      var d = 0;
      /** @type {number} */
      var subCheck = 0;
      /** @type {number} */
      var i = 2;
      for (; i < value; i++) {
        s = q;
        q = b.absolutePoints[i];
        s = mxUtils.ptSegDistSq(s.x, s.y, q.x, q.y, x, y);
        subCheck = subCheck + t[i - 2];
        if (s <= l) {
          l = s;
          /** @type {number} */
          d = i - 1;
          a = subCheck;
        }
      }
      value = t[d];
      s = b.absolutePoints[d];
      q = b.absolutePoints[d + 1];
      l = q.x;
      t = q.y;
      /** @type {number} */
      b = s.x - l;
      /** @type {number} */
      d = s.y - t;
      /** @type {number} */
      l = b - (x - l);
      /** @type {number} */
      t = d - (y - t);
      /** @type {number} */
      t = l * b + t * d;
      /** @type {number} */
      b = Math.sqrt(0 >= t ? 0 : t * t / (b * b + d * d));
      if (b > value) {
        b = value;
      }
      /** @type {number} */
      value = Math.sqrt(mxUtils.ptSegDistSq(s.x, s.y, q.x, q.y, x, y));
      if (-1 == mxUtils.relativeCcw(s.x, s.y, q.x, q.y, x, y)) {
        /** @type {number} */
        value = -value;
      }
      return new mxPoint((c / 2 - a - b) / c * -2, value / this.scale);
    }
  }
  return new mxPoint;
};
/**
 * @param {!Object} s
 * @return {undefined}
 */
mxGraphView.prototype.updateEdgeLabelOffset = function(s) {
  var a = s.absolutePoints;
  s.absoluteOffset.x = s.getCenterX();
  s.absoluteOffset.y = s.getCenterY();
  if (null != a && 0 < a.length && null != s.segments) {
    var value = this.graph.getCellGeometry(s.cell);
    if (value.relative) {
      var p = this.getPoint(s, value);
      if (null != p) {
        s.absoluteOffset = p;
      }
    } else {
      p = a[0];
      var b = a[a.length - 1];
      if (null != p && null != b) {
        /** @type {number} */
        a = b.x - p.x;
        /** @type {number} */
        var height = b.y - p.y;
        /** @type {number} */
        var y = b = 0;
        value = value.offset;
        if (null != value) {
          b = value.x;
          y = value.y;
        }
        value = p.y + height / 2 + y * this.scale;
        s.absoluteOffset.x = p.x + a / 2 + b * this.scale;
        s.absoluteOffset.y = value;
      }
    }
  }
};
/**
 * @param {!Object} name
 * @param {boolean} obj
 * @return {?}
 */
mxGraphView.prototype.getState = function(name, obj) {
  obj = obj || false;
  /** @type {null} */
  var value = null;
  if (null != name) {
    value = this.states.get(name);
    if (obj && (null == value || this.updateStyle) && this.graph.isCellVisible(name)) {
      if (null == value) {
        value = this.createState(name);
        this.states.put(name, value);
      } else {
        value.style = this.graph.getCellStyle(name);
      }
    }
  }
  return value;
};
/**
 * @return {?}
 */
mxGraphView.prototype.isRendering = function() {
  return this.rendering;
};
/**
 * @param {string} renderingType
 * @return {undefined}
 */
mxGraphView.prototype.setRendering = function(renderingType) {
  /** @type {string} */
  this.rendering = renderingType;
};
/**
 * @return {?}
 */
mxGraphView.prototype.isAllowEval = function() {
  return this.allowEval;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraphView.prototype.setAllowEval = function(a) {
  /** @type {boolean} */
  this.allowEval = a;
};
/**
 * @return {?}
 */
mxGraphView.prototype.getStates = function() {
  return this.states;
};
/**
 * @param {!Object} states
 * @return {undefined}
 */
mxGraphView.prototype.setStates = function(states) {
  /** @type {!Object} */
  this.states = states;
};
/**
 * @param {string} idArr
 * @return {?}
 */
mxGraphView.prototype.getCellStates = function(idArr) {
  if (null == idArr) {
    return this.states;
  }
  /** @type {!Array} */
  var stdout = [];
  /** @type {number} */
  var i = 0;
  for (; i < idArr.length; i++) {
    var Locale = this.getState(idArr[i]);
    if (null != Locale) {
      stdout.push(Locale);
    }
  }
  return stdout;
};
/**
 * @param {?} index
 * @return {?}
 */
mxGraphView.prototype.removeState = function(index) {
  /** @type {null} */
  var form = null;
  if (null != index) {
    form = this.states.remove(index);
    if (null != form) {
      this.graph.cellRenderer.destroy(form);
      /** @type {boolean} */
      form.invalid = true;
      form.destroy();
    }
  }
  return form;
};
/**
 * @param {!Object} edge
 * @return {?}
 */
mxGraphView.prototype.createState = function(edge) {
  return new mxCellState(this, edge, this.graph.getCellStyle(edge));
};
/**
 * @return {?}
 */
mxGraphView.prototype.getCanvas = function() {
  return this.canvas;
};
/**
 * @return {?}
 */
mxGraphView.prototype.getBackgroundPane = function() {
  return this.backgroundPane;
};
/**
 * @return {?}
 */
mxGraphView.prototype.getDrawPane = function() {
  return this.drawPane;
};
/**
 * @return {?}
 */
mxGraphView.prototype.getOverlayPane = function() {
  return this.overlayPane;
};
/**
 * @return {?}
 */
mxGraphView.prototype.getDecoratorPane = function() {
  return this.decoratorPane;
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxGraphView.prototype.isContainerEvent = function(node) {
  node = mxEvent.getSource(node);
  return node == this.graph.container || node.parentNode == this.backgroundPane || null != node.parentNode && node.parentNode.parentNode == this.backgroundPane || node == this.canvas.parentNode || node == this.canvas || node == this.backgroundPane || node == this.drawPane || node == this.overlayPane || node == this.decoratorPane;
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxGraphView.prototype.isScrollEvent = function(e) {
  var offset = mxUtils.getOffset(this.graph.container);
  e = new mxPoint(e.clientX - offset.x, e.clientY - offset.y);
  offset = this.graph.container.offsetWidth;
  var top = this.graph.container.clientWidth;
  if (offset > top && e.x > top + 2 && e.x <= offset) {
    return true;
  }
  offset = this.graph.container.offsetHeight;
  top = this.graph.container.clientHeight;
  return offset > top && e.y > top + 2 && e.y <= offset ? true : false;
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.init = function() {
  this.installListeners();
  if (this.graph.dialect == mxConstants.DIALECT_SVG) {
    this.createSvg();
  } else {
    this.createHtml();
  }
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.installListeners = function() {
  var graph = this.graph;
  var node = graph.container;
  if (null != node) {
    if (mxClient.IS_TOUCH) {
      mxEvent.addListener(node, "gesturestart", mxUtils.bind(this, function(e) {
        graph.fireGestureEvent(e);
        mxEvent.consume(e);
      }));
      mxEvent.addListener(node, "gesturechange", mxUtils.bind(this, function(e) {
        graph.fireGestureEvent(e);
        mxEvent.consume(e);
      }));
      mxEvent.addListener(node, "gestureend", mxUtils.bind(this, function(e) {
        graph.fireGestureEvent(e);
        mxEvent.consume(e);
      }));
    }
    mxEvent.addGestureListeners(node, mxUtils.bind(this, function(evt) {
      if (!(!this.isContainerEvent(evt) || (mxClient.IS_IE || mxClient.IS_IE11 || mxClient.IS_GC || mxClient.IS_OP || mxClient.IS_SF) && this.isScrollEvent(evt))) {
        graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
      }
    }), mxUtils.bind(this, function(evt) {
      if (this.isContainerEvent(evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
      }
    }), mxUtils.bind(this, function(evt) {
      if (this.isContainerEvent(evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
      }
    }));
    mxEvent.addListener(node, "dblclick", mxUtils.bind(this, function(e) {
      if (this.isContainerEvent(e)) {
        graph.dblClick(e);
      }
    }));
    graph.addMouseListener({
      mouseDown : function(item, event) {
        graph.popupMenuHandler.hideMenu();
      },
      mouseMove : function() {
      },
      mouseUp : function() {
      }
    });
    this.moveHandler = mxUtils.bind(this, function(e) {
      if (null != graph.tooltipHandler && graph.tooltipHandler.isHideOnHover()) {
        graph.tooltipHandler.hide();
      }
      if (this.captureDocumentGesture && graph.isMouseDown && null != graph.container && !this.isContainerEvent(e) && "none" != graph.container.style.display && "hidden" != graph.container.style.visibility && !mxEvent.isConsumed(e)) {
        var parent = graph.fireMouseEvent;
        var eventType = mxEvent.MOUSE_MOVE;
        /** @type {null} */
        var point = null;
        if (mxClient.IS_TOUCH) {
          point = mxEvent.getClientX(e);
          var x = mxEvent.getClientY(e);
          point = mxUtils.convertPoint(node, point, x);
          point = graph.view.getState(graph.getCellAt(point.x, point.y));
        }
        parent.call(graph, eventType, new mxMouseEvent(e, point));
      }
    });
    this.endHandler = mxUtils.bind(this, function(evt) {
      if (this.captureDocumentGesture && graph.isMouseDown && null != graph.container && !this.isContainerEvent(evt) && "none" != graph.container.style.display && "hidden" != graph.container.style.visibility) {
        graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
      }
    });
    mxEvent.addGestureListeners(document, null, this.moveHandler, this.endHandler);
  }
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.createHtml = function() {
  var target = this.graph.container;
  if (null != target) {
    this.canvas = this.createHtmlPane("100%", "100%");
    /** @type {string} */
    this.canvas.style.overflow = "hidden";
    this.backgroundPane = this.createHtmlPane("1px", "1px");
    this.drawPane = this.createHtmlPane("1px", "1px");
    this.overlayPane = this.createHtmlPane("1px", "1px");
    this.decoratorPane = this.createHtmlPane("1px", "1px");
    this.canvas.appendChild(this.backgroundPane);
    this.canvas.appendChild(this.drawPane);
    this.canvas.appendChild(this.overlayPane);
    this.canvas.appendChild(this.decoratorPane);
    target.appendChild(this.canvas);
    this.updateContainerStyle(target);
  }
};
/**
 * @param {number} width
 * @param {number} y0
 * @return {undefined}
 */
mxGraphView.prototype.updateHtmlCanvasSize = function(width, y0) {
  if (null != this.graph.container) {
    var scrollPosition = this.graph.container.offsetHeight;
    /** @type {string} */
    this.canvas.style.width = this.graph.container.offsetWidth < width ? width + "px" : "100%";
    /** @type {string} */
    this.canvas.style.height = scrollPosition < y0 ? y0 + "px" : "100%";
  }
};
/**
 * @param {string} a
 * @param {string} b
 * @return {?}
 */
mxGraphView.prototype.createHtmlPane = function(a, b) {
  /** @type {!Element} */
  var vline = document.createElement("DIV");
  if (null != a && null != b) {
    /** @type {string} */
    vline.style.position = "absolute";
    /** @type {string} */
    vline.style.left = "0px";
    /** @type {string} */
    vline.style.top = "0px";
    /** @type {string} */
    vline.style.width = a;
    /** @type {string} */
    vline.style.height = b;
  } else {
    /** @type {string} */
    vline.style.position = "relative";
  }
  return vline;
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.createSvg = function() {
  var style = this.graph.container;
  /** @type {!Element} */
  this.canvas = document.createElementNS(mxConstants.NS_SVG, "g");
  /** @type {!Element} */
  this.backgroundPane = document.createElementNS(mxConstants.NS_SVG, "g");
  this.canvas.appendChild(this.backgroundPane);
  /** @type {!Element} */
  this.drawPane = document.createElementNS(mxConstants.NS_SVG, "g");
  this.canvas.appendChild(this.drawPane);
  /** @type {!Element} */
  this.overlayPane = document.createElementNS(mxConstants.NS_SVG, "g");
  this.canvas.appendChild(this.overlayPane);
  /** @type {!Element} */
  this.decoratorPane = document.createElementNS(mxConstants.NS_SVG, "g");
  this.canvas.appendChild(this.decoratorPane);
  /** @type {!Element} */
  var node = document.createElementNS(mxConstants.NS_SVG, "svg");
  /** @type {string} */
  node.style.left = "0px";
  /** @type {string} */
  node.style.top = "0px";
  /** @type {string} */
  node.style.width = "100%";
  /** @type {string} */
  node.style.height = "100%";
  /** @type {string} */
  node.style.display = "block";
  node.appendChild(this.canvas);
  if (mxClient.IS_IE || mxClient.IS_IE11) {
    /** @type {string} */
    node.style.overflow = "hidden";
  }
  if (null != style) {
    style.appendChild(node);
    this.updateContainerStyle(style);
  }
};
/**
 * @param {!Element} e
 * @return {undefined}
 */
mxGraphView.prototype.updateContainerStyle = function(e) {
  var edgeLabel = mxUtils.getCurrentStyle(e);
  if (null != edgeLabel && "static" == edgeLabel.position) {
    /** @type {string} */
    e.style.position = "relative";
  }
  if (mxClient.IS_POINTER) {
    /** @type {string} */
    e.style.touchAction = "none";
  }
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.destroy = function() {
  var elem = null != this.canvas ? this.canvas.ownerSVGElement : null;
  if (null == elem) {
    elem = this.canvas;
  }
  if (null != elem && null != elem.parentNode) {
    this.clear(this.currentRoot, true);
    mxEvent.removeGestureListeners(document, null, this.moveHandler, this.endHandler);
    mxEvent.release(this.graph.container);
    elem.parentNode.removeChild(elem);
    /** @type {null} */
    this.decoratorPane = this.overlayPane = this.drawPane = this.backgroundPane = this.canvas = this.endHandler = this.moveHandler = null;
  }
};
/**
 * @param {string} id
 * @param {string} root
 * @return {undefined}
 */
function mxCurrentRootChange(id, root) {
  /** @type {string} */
  this.view = id;
  this.previous = this.root = root;
  /** @type {boolean} */
  this.isUp = null == root;
  if (!this.isUp) {
    id = this.view.currentRoot;
    var parentDiv = this.view.graph.getModel();
    for (; null != id;) {
      if (id == root) {
        /** @type {boolean} */
        this.isUp = true;
        break;
      }
      id = parentDiv.getParent(id);
    }
  }
}
/**
 * @return {undefined}
 */
mxCurrentRootChange.prototype.execute = function() {
  var value = this.view.currentRoot;
  this.view.currentRoot = this.previous;
  this.previous = value;
  value = this.view.graph.getTranslateForRoot(this.view.currentRoot);
  if (null != value) {
    this.view.translate = new mxPoint(-value.x, -value.y);
  }
  if (this.isUp) {
    this.view.clear(this.view.currentRoot, true);
    this.view.validate();
  } else {
    this.view.refresh();
  }
  this.view.fireEvent(new mxEventObject(this.isUp ? mxEvent.UP : mxEvent.DOWN, "root", this.view.currentRoot, "previous", this.previous));
  /** @type {boolean} */
  this.isUp = !this.isUp;
};
/**
 * @param {!Element} id
 * @param {string} model
 * @param {!AudioNode} elbow
 * @param {string} position
 * @param {string} fromNewID
 * @return {undefined}
 */
function mxGraph(id, model, elbow, position, fromNewID) {
  /** @type {null} */
  this.mouseListeners = null;
  /** @type {!AudioNode} */
  this.renderHint = elbow;
  this.dialect = mxClient.IS_SVG ? mxConstants.DIALECT_SVG : elbow == mxConstants.RENDERING_HINT_FASTEST ? mxConstants.DIALECT_STRICTHTML : elbow == mxConstants.RENDERING_HINT_FASTER ? mxConstants.DIALECT_PREFERHTML : mxConstants.DIALECT_MIXEDHTML;
  this.model = null != model ? model : new mxGraphModel;
  /** @type {!Array} */
  this.multiplicities = [];
  /** @type {!Array} */
  this.imageBundles = [];
  this.cellRenderer = this.createCellRenderer();
  this.setSelectionModel(this.createSelectionModel());
  this.setStylesheet(null != position ? position : this.createStylesheet());
  this.view = this.createGraphView();
  this.view.rendering = null != fromNewID ? fromNewID : this.view.rendering;
  this.graphModelChangeListener = mxUtils.bind(this, function(canCreateDiscussions, link) {
    this.graphModelChanged(link.getProperty("edit").changes);
  });
  this.model.addListener(mxEvent.CHANGE, this.graphModelChangeListener);
  this.createHandlers();
  if (null != id) {
    this.init(id);
  }
  if (this.view.rendering) {
    this.view.revalidate();
  }
}
if (mxLoadResources) {
  mxResources.add(mxClient.basePath + "/resources/graph");
} else {
  mxClient.defaultBundles.push(mxClient.basePath + "/resources/graph");
}
mxGraph.prototype = new mxEventSource;
/** @type {function(!Element, string, !AudioNode, string, string): undefined} */
mxGraph.prototype.constructor = mxGraph;
/** @type {null} */
mxGraph.prototype.mouseListeners = null;
/** @type {boolean} */
mxGraph.prototype.isMouseDown = false;
/** @type {null} */
mxGraph.prototype.model = null;
/** @type {null} */
mxGraph.prototype.view = null;
/** @type {null} */
mxGraph.prototype.stylesheet = null;
/** @type {null} */
mxGraph.prototype.selectionModel = null;
/** @type {null} */
mxGraph.prototype.cellEditor = null;
/** @type {null} */
mxGraph.prototype.cellRenderer = null;
/** @type {null} */
mxGraph.prototype.multiplicities = null;
/** @type {null} */
mxGraph.prototype.renderHint = null;
/** @type {null} */
mxGraph.prototype.dialect = null;
/** @type {number} */
mxGraph.prototype.gridSize = 10;
/** @type {boolean} */
mxGraph.prototype.gridEnabled = true;
/** @type {boolean} */
mxGraph.prototype.portsEnabled = true;
/** @type {boolean} */
mxGraph.prototype.nativeDblClickEnabled = true;
/** @type {boolean} */
mxGraph.prototype.doubleTapEnabled = true;
/** @type {number} */
mxGraph.prototype.doubleTapTimeout = 500;
/** @type {number} */
mxGraph.prototype.doubleTapTolerance = 25;
/** @type {number} */
mxGraph.prototype.lastTouchY = 0;
/** @type {number} */
mxGraph.prototype.lastTouchY = 0;
/** @type {number} */
mxGraph.prototype.lastTouchTime = 0;
/** @type {boolean} */
mxGraph.prototype.tapAndHoldEnabled = true;
/** @type {number} */
mxGraph.prototype.tapAndHoldDelay = 500;
/** @type {boolean} */
mxGraph.prototype.tapAndHoldInProgress = false;
/** @type {boolean} */
mxGraph.prototype.tapAndHoldValid = false;
/** @type {number} */
mxGraph.prototype.initialTouchX = 0;
/** @type {number} */
mxGraph.prototype.initialTouchY = 0;
/** @type {number} */
mxGraph.prototype.tolerance = 4;
/** @type {number} */
mxGraph.prototype.defaultOverlap = .5;
/** @type {null} */
mxGraph.prototype.defaultParent = null;
/** @type {null} */
mxGraph.prototype.alternateEdgeStyle = null;
/** @type {null} */
mxGraph.prototype.backgroundImage = null;
/** @type {boolean} */
mxGraph.prototype.pageVisible = false;
/** @type {boolean} */
mxGraph.prototype.pageBreaksVisible = false;
/** @type {string} */
mxGraph.prototype.pageBreakColor = "gray";
/** @type {boolean} */
mxGraph.prototype.pageBreakDashed = true;
/** @type {number} */
mxGraph.prototype.minPageBreakDist = 20;
/** @type {boolean} */
mxGraph.prototype.preferPageSize = false;
mxGraph.prototype.pageFormat = mxConstants.PAGE_FORMAT_A4_PORTRAIT;
/** @type {number} */
mxGraph.prototype.pageScale = 1.5;
/** @type {boolean} */
mxGraph.prototype.enabled = true;
/** @type {boolean} */
mxGraph.prototype.escapeEnabled = true;
/** @type {boolean} */
mxGraph.prototype.invokesStopCellEditing = true;
/** @type {boolean} */
mxGraph.prototype.enterStopsCellEditing = false;
/** @type {boolean} */
mxGraph.prototype.useScrollbarsForPanning = true;
/** @type {boolean} */
mxGraph.prototype.exportEnabled = true;
/** @type {boolean} */
mxGraph.prototype.importEnabled = true;
/** @type {boolean} */
mxGraph.prototype.cellsLocked = false;
/** @type {boolean} */
mxGraph.prototype.cellsCloneable = true;
/** @type {boolean} */
mxGraph.prototype.foldingEnabled = true;
/** @type {boolean} */
mxGraph.prototype.cellsEditable = true;
/** @type {boolean} */
mxGraph.prototype.cellsDeletable = true;
/** @type {boolean} */
mxGraph.prototype.cellsMovable = true;
/** @type {boolean} */
mxGraph.prototype.edgeLabelsMovable = true;
/** @type {boolean} */
mxGraph.prototype.vertexLabelsMovable = false;
/** @type {boolean} */
mxGraph.prototype.dropEnabled = false;
/** @type {boolean} */
mxGraph.prototype.splitEnabled = true;
/** @type {boolean} */
mxGraph.prototype.cellsResizable = true;
/** @type {boolean} */
mxGraph.prototype.cellsBendable = true;
/** @type {boolean} */
mxGraph.prototype.cellsSelectable = true;
/** @type {boolean} */
mxGraph.prototype.cellsDisconnectable = true;
/** @type {boolean} */
mxGraph.prototype.autoSizeCells = false;
/** @type {boolean} */
mxGraph.prototype.autoSizeCellsOnAdd = false;
/** @type {boolean} */
mxGraph.prototype.autoScroll = true;
/** @type {boolean} */
mxGraph.prototype.ignoreScrollbars = false;
/** @type {boolean} */
mxGraph.prototype.translateToScrollPosition = false;
/** @type {boolean} */
mxGraph.prototype.timerAutoScroll = false;
/** @type {boolean} */
mxGraph.prototype.allowAutoPanning = false;
/** @type {boolean} */
mxGraph.prototype.autoExtend = true;
/** @type {null} */
mxGraph.prototype.maximumGraphBounds = null;
/** @type {null} */
mxGraph.prototype.minimumGraphSize = null;
/** @type {null} */
mxGraph.prototype.minimumContainerSize = null;
/** @type {null} */
mxGraph.prototype.maximumContainerSize = null;
/** @type {boolean} */
mxGraph.prototype.resizeContainer = false;
/** @type {number} */
mxGraph.prototype.border = 0;
/** @type {boolean} */
mxGraph.prototype.keepEdgesInForeground = false;
/** @type {boolean} */
mxGraph.prototype.keepEdgesInBackground = false;
/** @type {boolean} */
mxGraph.prototype.allowNegativeCoordinates = true;
/** @type {boolean} */
mxGraph.prototype.constrainChildren = true;
/** @type {boolean} */
mxGraph.prototype.constrainRelativeChildren = false;
/** @type {boolean} */
mxGraph.prototype.extendParents = true;
/** @type {boolean} */
mxGraph.prototype.extendParentsOnAdd = true;
/** @type {boolean} */
mxGraph.prototype.extendParentsOnMove = false;
/** @type {boolean} */
mxGraph.prototype.recursiveResize = false;
/** @type {boolean} */
mxGraph.prototype.collapseToPreferredSize = true;
/** @type {number} */
mxGraph.prototype.zoomFactor = 1.2;
/** @type {boolean} */
mxGraph.prototype.keepSelectionVisibleOnZoom = false;
/** @type {boolean} */
mxGraph.prototype.centerZoom = true;
/** @type {boolean} */
mxGraph.prototype.resetViewOnRootChange = true;
/** @type {boolean} */
mxGraph.prototype.resetEdgesOnResize = false;
/** @type {boolean} */
mxGraph.prototype.resetEdgesOnMove = false;
/** @type {boolean} */
mxGraph.prototype.resetEdgesOnConnect = true;
/** @type {boolean} */
mxGraph.prototype.allowLoops = false;
/** @type {function(!Object, number, !Object, number, !Array): undefined} */
mxGraph.prototype.defaultLoopStyle = mxEdgeStyle.Loop;
/** @type {boolean} */
mxGraph.prototype.multigraph = true;
/** @type {boolean} */
mxGraph.prototype.connectableEdges = false;
/** @type {boolean} */
mxGraph.prototype.allowDanglingEdges = true;
/** @type {boolean} */
mxGraph.prototype.cloneInvalidEdges = false;
/** @type {boolean} */
mxGraph.prototype.disconnectOnMove = true;
/** @type {boolean} */
mxGraph.prototype.labelsVisible = true;
/** @type {boolean} */
mxGraph.prototype.htmlLabels = false;
/** @type {boolean} */
mxGraph.prototype.swimlaneSelectionEnabled = true;
/** @type {boolean} */
mxGraph.prototype.swimlaneNesting = true;
/** @type {string} */
mxGraph.prototype.swimlaneIndicatorColorAttribute = mxConstants.STYLE_FILLCOLOR;
/** @type {null} */
mxGraph.prototype.imageBundles = null;
/** @type {number} */
mxGraph.prototype.minFitScale = .1;
/** @type {number} */
mxGraph.prototype.maxFitScale = 8;
/** @type {number} */
mxGraph.prototype.panDx = 0;
/** @type {number} */
mxGraph.prototype.panDy = 0;
mxGraph.prototype.collapsedImage = new mxImage(mxClient.imageBasePath + "/collapsed.gif", 9, 9);
mxGraph.prototype.expandedImage = new mxImage(mxClient.imageBasePath + "/expanded.gif", 9, 9);
mxGraph.prototype.warningImage = new mxImage(mxClient.imageBasePath + "/warning" + (mxClient.IS_MAC ? ".png" : ".gif"), 16, 16);
/** @type {string} */
mxGraph.prototype.alreadyConnectedResource = "none" != mxClient.language ? "alreadyConnected" : "";
/** @type {string} */
mxGraph.prototype.containsValidationErrorsResource = "none" != mxClient.language ? "containsValidationErrors" : "";
/** @type {string} */
mxGraph.prototype.collapseExpandResource = "none" != mxClient.language ? "collapse-expand" : "";
/**
 * @param {!Element} node
 * @return {undefined}
 */
mxGraph.prototype.init = function(node) {
  /** @type {!Element} */
  this.container = node;
  this.cellEditor = this.createCellEditor();
  this.view.init();
  this.sizeDidChange();
  mxEvent.addListener(node, "mouseleave", mxUtils.bind(this, function(event) {
    if (null != this.tooltipHandler && null != this.tooltipHandler.div && this.tooltipHandler.div != event.relatedTarget) {
      this.tooltipHandler.hide();
    }
  }));
  if (mxClient.IS_IE) {
    mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
      this.destroy();
    }));
    mxEvent.addListener(node, "selectstart", mxUtils.bind(this, function(evt) {
      return this.isEditing() || !this.isMouseDown && !mxEvent.isShiftDown(evt);
    }));
  }
};
/**
 * @return {undefined}
 */
mxGraph.prototype.createHandlers = function() {
  this.tooltipHandler = this.createTooltipHandler();
  this.tooltipHandler.setEnabled(false);
  this.selectionCellsHandler = this.createSelectionCellsHandler();
  this.connectionHandler = this.createConnectionHandler();
  this.connectionHandler.setEnabled(false);
  this.graphHandler = this.createGraphHandler();
  this.panningHandler = this.createPanningHandler();
  /** @type {boolean} */
  this.panningHandler.panningEnabled = false;
  this.popupMenuHandler = this.createPopupMenuHandler();
};
/**
 * @return {?}
 */
mxGraph.prototype.createTooltipHandler = function() {
  return new mxTooltipHandler(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createSelectionCellsHandler = function() {
  return new mxSelectionCellsHandler(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createConnectionHandler = function() {
  return new mxConnectionHandler(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createGraphHandler = function() {
  return new mxGraphHandler(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createPanningHandler = function() {
  return new mxPanningHandler(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createPopupMenuHandler = function() {
  return new mxPopupMenuHandler(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createSelectionModel = function() {
  return new mxGraphSelectionModel(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createStylesheet = function() {
  return new mxStylesheet;
};
/**
 * @return {?}
 */
mxGraph.prototype.createGraphView = function() {
  return new mxGraphView(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createCellRenderer = function() {
  return new mxCellRenderer;
};
/**
 * @return {?}
 */
mxGraph.prototype.createCellEditor = function() {
  return new mxCellEditor(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.getModel = function() {
  return this.model;
};
/**
 * @return {?}
 */
mxGraph.prototype.getView = function() {
  return this.view;
};
/**
 * @return {?}
 */
mxGraph.prototype.getStylesheet = function() {
  return this.stylesheet;
};
/**
 * @param {!AudioNode} stylesheet
 * @return {undefined}
 */
mxGraph.prototype.setStylesheet = function(stylesheet) {
  /** @type {!AudioNode} */
  this.stylesheet = stylesheet;
};
/**
 * @return {?}
 */
mxGraph.prototype.getSelectionModel = function() {
  return this.selectionModel;
};
/**
 * @param {boolean} model
 * @return {undefined}
 */
mxGraph.prototype.setSelectionModel = function(model) {
  /** @type {boolean} */
  this.selectionModel = model;
};
/**
 * @param {!NodeList} set
 * @param {string} filter
 * @return {?}
 */
mxGraph.prototype.getSelectionCellsForChanges = function(set, filter) {
  var row = new mxDictionary;
  /** @type {!Array} */
  var team_array = [];
  var equal = mxUtils.bind(this, function(cell) {
    if (!row.get(cell) && this.model.contains(cell)) {
      if (this.model.isEdge(cell) || this.model.isVertex(cell)) {
        row.put(cell, true);
        team_array.push(cell);
      } else {
        var childCount = this.model.getChildCount(cell);
        /** @type {number} */
        var i = 0;
        for (; i < childCount; i++) {
          equal(this.model.getChildAt(cell, i));
        }
      }
    }
  });
  /** @type {number} */
  var i = 0;
  for (; i < set.length; i++) {
    var change = set[i];
    if (change.constructor != mxRootChange && (null == filter || !filter(change))) {
      /** @type {null} */
      var _ref = null;
      if (change instanceof mxChildChange) {
        _ref = change.child;
      } else {
        if (null != change.cell && change.cell instanceof mxCell) {
          _ref = change.cell;
        }
      }
      if (null != _ref) {
        equal(_ref);
      }
    }
  }
  return team_array;
};
/**
 * @param {!NodeList} changes
 * @return {undefined}
 */
mxGraph.prototype.graphModelChanged = function(changes) {
  /** @type {number} */
  var i = 0;
  for (; i < changes.length; i++) {
    this.processChange(changes[i]);
  }
  this.updateSelection();
  this.view.validate();
  this.sizeDidChange();
};
/**
 * @return {undefined}
 */
mxGraph.prototype.updateSelection = function() {
  var cells = this.getSelectionCells();
  /** @type {!Array} */
  var c = [];
  /** @type {number} */
  var i = 0;
  for (; i < cells.length; i++) {
    if (this.model.contains(cells[i]) && this.isCellVisible(cells[i])) {
      var key = this.model.getParent(cells[i]);
      for (; null != key && key != this.view.currentRoot;) {
        if (this.isCellCollapsed(key) || !this.isCellVisible(key)) {
          c.push(cells[i]);
          break;
        }
        key = this.model.getParent(key);
      }
    } else {
      c.push(cells[i]);
    }
  }
  this.removeSelectionCells(c);
};
/**
 * @param {!Object} change
 * @return {undefined}
 */
mxGraph.prototype.processChange = function(change) {
  if (change instanceof mxRootChange) {
    this.clearSelection();
    this.setDefaultParent(null);
    this.removeStateForCell(change.previous);
    if (this.resetViewOnRootChange) {
      /** @type {number} */
      this.view.scale = 1;
      /** @type {number} */
      this.view.translate.x = 0;
      /** @type {number} */
      this.view.translate.y = 0;
    }
    this.fireEvent(new mxEventObject(mxEvent.ROOT));
  } else {
    if (change instanceof mxChildChange) {
      var path = this.model.getParent(change.child);
      this.view.invalidate(change.child, true, true);
      if (!this.model.contains(path) || this.isCellCollapsed(path)) {
        this.view.invalidate(change.child, true, true);
        this.removeStateForCell(change.child);
        if (this.view.currentRoot == change.child) {
          this.home();
        }
      }
      if (path != change.previous) {
        if (null != path) {
          this.view.invalidate(path, false, false);
        }
        if (null != change.previous) {
          this.view.invalidate(change.previous, false, false);
        }
      }
    } else {
      if (change instanceof mxTerminalChange || change instanceof mxGeometryChange) {
        if (change instanceof mxTerminalChange || null == change.previous && null != change.geometry || null != change.previous && !change.previous.equals(change.geometry)) {
          this.view.invalidate(change.cell);
        }
      } else {
        if (change instanceof mxValueChange) {
          this.view.invalidate(change.cell, false, false);
        } else {
          if (change instanceof mxStyleChange) {
            this.view.invalidate(change.cell, true, true);
            change = this.view.getState(change.cell);
            if (null != change) {
              /** @type {boolean} */
              change.invalidStyle = true;
            }
          } else {
            if (null != change.cell && change.cell instanceof mxCell) {
              this.removeStateForCell(change.cell);
            }
          }
        }
      }
    }
  }
};
/**
 * @param {undefined} index
 * @return {undefined}
 */
mxGraph.prototype.removeStateForCell = function(index) {
  var b = this.model.getChildCount(index);
  /** @type {number} */
  var y = 0;
  for (; y < b; y++) {
    this.removeStateForCell(this.model.getChildAt(index, y));
  }
  this.view.invalidate(index, false, true);
  this.view.removeState(index);
};
/**
 * @param {!Object} index
 * @param {!Object} instance
 * @return {?}
 */
mxGraph.prototype.addCellOverlay = function(index, instance) {
  if (null == index.overlays) {
    /** @type {!Array} */
    index.overlays = [];
  }
  index.overlays.push(instance);
  var sub = this.view.getState(index);
  if (null != sub) {
    this.cellRenderer.redraw(sub);
  }
  this.fireEvent(new mxEventObject(mxEvent.ADD_OVERLAY, "cell", index, "overlay", instance));
  return instance;
};
/**
 * @param {!Object} viewer
 * @return {?}
 */
mxGraph.prototype.getCellOverlays = function(viewer) {
  return viewer.overlays;
};
/**
 * @param {!Object} state
 * @param {!Object} value
 * @return {?}
 */
mxGraph.prototype.removeCellOverlay = function(state, value) {
  if (null == value) {
    this.removeCellOverlays(state);
  } else {
    var item = mxUtils.indexOf(state.overlays, value);
    if (0 <= item) {
      state.overlays.splice(item, 1);
      if (0 == state.overlays.length) {
        /** @type {null} */
        state.overlays = null;
      }
      item = this.view.getState(state);
      if (null != item) {
        this.cellRenderer.redraw(item);
      }
      this.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY, "cell", state, "overlay", value));
    } else {
      /** @type {null} */
      value = null;
    }
  }
  return value;
};
/**
 * @param {!Object} options
 * @return {?}
 */
mxGraph.prototype.removeCellOverlays = function(options) {
  var tokens = options.overlays;
  if (null != tokens) {
    /** @type {null} */
    options.overlays = null;
    var target = this.view.getState(options);
    if (null != target) {
      this.cellRenderer.redraw(target);
    }
    /** @type {number} */
    target = 0;
    for (; target < tokens.length; target++) {
      this.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY, "cell", options, "overlay", tokens[target]));
    }
  }
  return tokens;
};
/**
 * @param {!Object} parent
 * @return {undefined}
 */
mxGraph.prototype.clearCellOverlays = function(parent) {
  parent = null != parent ? parent : this.model.getRoot();
  this.removeCellOverlays(parent);
  var newParentTag = this.model.getChildCount(parent);
  /** @type {number} */
  var i = 0;
  for (; i < newParentTag; i++) {
    var d = this.model.getChildAt(parent, i);
    this.clearCellOverlays(d);
  }
};
/**
 * @param {!Object} f
 * @param {!Object} o
 * @param {string} r
 * @param {?} agumentsArr
 * @return {?}
 */
mxGraph.prototype.setCellWarning = function(f, o, r, agumentsArr) {
  if (null != o && 0 < o.length) {
    return r = null != r ? r : this.warningImage, o = new mxCellOverlay(r, "<font color=red>" + o + "</font>"), agumentsArr && o.addListener(mxEvent.CLICK, mxUtils.bind(this, function(canCreateDiscussions, isSlidingUp) {
      if (this.isEnabled()) {
        this.setSelectionCell(f);
      }
    })), this.addCellOverlay(f, o);
  }
  this.removeCellOverlays(f);
  return null;
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxGraph.prototype.startEditing = function(value) {
  this.startEditingAtCell(null, value);
};
/**
 * @param {string} node
 * @param {string} value
 * @return {undefined}
 */
mxGraph.prototype.startEditingAtCell = function(node, value) {
  if (!(null != value && mxEvent.isMultiTouchEvent(value))) {
    if (null == node) {
      node = this.getSelectionCell();
      if (!(null == node || this.isCellEditable(node))) {
        /** @type {null} */
        node = null;
      }
    }
    if (null != node) {
      this.fireEvent(new mxEventObject(mxEvent.START_EDITING, "cell", node, "event", value));
      this.cellEditor.startEditing(node, value);
      this.fireEvent(new mxEventObject(mxEvent.EDITING_STARTED, "cell", node, "event", value));
    }
  }
};
/**
 * @param {!Object} tile
 * @param {!Object} cell
 * @return {?}
 */
mxGraph.prototype.getEditingValue = function(tile, cell) {
  return this.convertValueToString(tile);
};
/**
 * @param {string} a
 * @return {undefined}
 */
mxGraph.prototype.stopEditing = function(a) {
  this.cellEditor.stopEditing(a);
  this.fireEvent(new mxEventObject(mxEvent.EDITING_STOPPED, "cancel", a));
};
/**
 * @param {string} cell
 * @param {string} newValue
 * @param {number} evt
 * @return {?}
 */
mxGraph.prototype.labelChanged = function(cell, newValue, evt) {
  this.model.beginUpdate();
  try {
    var tuple = cell.value;
    this.cellLabelChanged(cell, newValue, this.isAutoSizeCell(cell));
    this.fireEvent(new mxEventObject(mxEvent.LABEL_CHANGED, "cell", cell, "value", newValue, "old", tuple, "event", evt));
  } finally {
    this.model.endUpdate();
  }
  return cell;
};
/**
 * @param {?} cell
 * @param {!Object} value
 * @param {?} autoSize
 * @return {undefined}
 */
mxGraph.prototype.cellLabelChanged = function(cell, value, autoSize) {
  this.model.beginUpdate();
  try {
    this.model.setValue(cell, value);
    if (autoSize) {
      this.cellSizeUpdated(cell, false);
    }
  } finally {
    this.model.endUpdate();
  }
};
/**
 * @param {!Object} string
 * @return {undefined}
 */
mxGraph.prototype.escape = function(string) {
  this.fireEvent(new mxEventObject(mxEvent.ESCAPE, "event", string));
};
/**
 * @param {!Object} me
 * @return {undefined}
 */
mxGraph.prototype.click = function(me) {
  var evt = me.getEvent();
  var element = me.getCell();
  var e = new mxEventObject(mxEvent.CLICK, "event", evt, "cell", element);
  if (me.isConsumed()) {
    e.consume();
  }
  this.fireEvent(e);
  if (this.isEnabled() && !mxEvent.isConsumed(evt) && !e.isConsumed()) {
    if (null != element) {
      if (this.isTransparentClickEvent(evt)) {
        /** @type {boolean} */
        var hasDataToSync = false;
        me = this.getCellAt(me.graphX, me.graphY, null, null, null, mxUtils.bind(this, function(event) {
          var hasAttempts = this.isCellSelected(event.cell);
          hasDataToSync = hasDataToSync || hasAttempts;
          return !hasDataToSync || hasAttempts || event.cell != element && this.model.isAncestor(event.cell, element);
        }));
        if (null != me) {
          /** @type {!Object} */
          element = me;
        }
      }
    } else {
      if (this.isSwimlaneSelectionEnabled() && (element = this.getSwimlaneAt(me.getGraphX(), me.getGraphY()), !(null == element || this.isToggleEvent(evt) && mxEvent.isAltDown(evt)))) {
        e = element;
        /** @type {!Array} */
        me = [];
        for (; null != e;) {
          e = this.model.getParent(e);
          var feedID = this.view.getState(e);
          if (this.isSwimlane(e) && null != feedID) {
            me.push(e);
          }
        }
        if (0 < me.length) {
          /** @type {!Array} */
          me = me.reverse();
          me.splice(0, 0, element);
          me.push(element);
          /** @type {number} */
          e = 0;
          for (; e < me.length - 1; e++) {
            if (this.isCellSelected(me[e])) {
              element = me[this.isToggleEvent(evt) ? e : e + 1];
            }
          }
        }
      }
    }
    if (null != element) {
      this.selectCellForEvent(element, evt);
    } else {
      if (!this.isToggleEvent(evt)) {
        this.clearSelection();
      }
    }
  }
};
/**
 * @param {!Object} key
 * @return {?}
 */
mxGraph.prototype.isSiblingSelected = function(key) {
  var self = this.model;
  var cell = self.getParent(key);
  var childCount = self.getChildCount(cell);
  /** @type {number} */
  var i = 0;
  for (; i < childCount; i++) {
    var value = self.getChildAt(cell, i);
    if (key != value && this.isCellSelected(value)) {
      return true;
    }
  }
  return false;
};
/**
 * @param {string} e
 * @param {string} obj
 * @return {undefined}
 */
mxGraph.prototype.dblClick = function(e, obj) {
  var event = new mxEventObject(mxEvent.DOUBLE_CLICK, "event", e, "cell", obj);
  this.fireEvent(event);
  if (!(!this.isEnabled() || mxEvent.isConsumed(e) || event.isConsumed() || null == obj || !this.isCellEditable(obj) || this.isEditing(obj))) {
    this.startEditingAtCell(obj, e);
    mxEvent.consume(e);
  }
};
/**
 * @param {!Object} me
 * @return {undefined}
 */
mxGraph.prototype.tapAndHold = function(me) {
  var e = me.getEvent();
  var event = new mxEventObject(mxEvent.TAP_AND_HOLD, "event", e, "cell", me.getCell());
  this.fireEvent(event);
  if (event.isConsumed()) {
    /** @type {boolean} */
    this.panningHandler.panningTrigger = false;
  }
  if (this.isEnabled() && !mxEvent.isConsumed(e) && !event.isConsumed() && this.connectionHandler.isEnabled()) {
    e = this.view.getState(this.connectionHandler.marker.getCell(me));
    if (null != e) {
      this.connectionHandler.marker.currentColor = this.connectionHandler.marker.validColor;
      this.connectionHandler.marker.markedState = e;
      this.connectionHandler.marker.mark();
      this.connectionHandler.first = new mxPoint(me.getGraphX(), me.getGraphY());
      this.connectionHandler.edgeState = this.connectionHandler.createEdgeState(me);
      this.connectionHandler.previous = e;
      this.connectionHandler.fireEvent(new mxEventObject(mxEvent.START, "state", this.connectionHandler.previous));
    }
  }
};
/**
 * @param {number} left
 * @param {number} top
 * @param {boolean} text
 * @param {number} y
 * @return {undefined}
 */
mxGraph.prototype.scrollPointToVisible = function(left, top, text, y) {
  if (this.timerAutoScroll || !this.ignoreScrollbars && !mxUtils.hasScrollbars(this.container)) {
    if (this.allowAutoPanning && !this.panningHandler.isActive()) {
      if (null == this.panningManager) {
        this.panningManager = this.createPanningManager();
      }
      this.panningManager.panTo(left + this.panDx, top + this.panDy);
    }
  } else {
    var element = this.container;
    y = null != y ? y : 20;
    if (left >= element.scrollLeft && top >= element.scrollTop && left <= element.scrollLeft + element.clientWidth && top <= element.scrollTop + element.clientHeight) {
      /** @type {number} */
      var bottom = element.scrollLeft + element.clientWidth - left;
      if (bottom < y) {
        if (left = element.scrollLeft, element.scrollLeft += y - bottom, text && left == element.scrollLeft) {
          if (this.dialect == mxConstants.DIALECT_SVG) {
            left = this.view.getDrawPane().ownerSVGElement;
            /** @type {number} */
            var height = this.container.scrollWidth + y - bottom;
            /** @type {string} */
            left.style.width = height + "px";
          } else {
            /** @type {number} */
            height = Math.max(element.clientWidth, element.scrollWidth) + y - bottom;
            left = this.view.getCanvas();
            /** @type {string} */
            left.style.width = height + "px";
          }
          element.scrollLeft += y - bottom;
        }
      } else {
        /** @type {number} */
        bottom = left - element.scrollLeft;
        if (bottom < y) {
          element.scrollLeft -= y - bottom;
        }
      }
      /** @type {number} */
      bottom = element.scrollTop + element.clientHeight - top;
      if (bottom < y) {
        left = element.scrollTop;
        element.scrollTop += y - bottom;
        if (left == element.scrollTop && text) {
          if (this.dialect == mxConstants.DIALECT_SVG) {
            left = this.view.getDrawPane().ownerSVGElement;
            /** @type {number} */
            top = this.container.scrollHeight + y - bottom;
            /** @type {string} */
            left.style.height = top + "px";
          } else {
            /** @type {number} */
            top = Math.max(element.clientHeight, element.scrollHeight) + y - bottom;
            left = this.view.getCanvas();
            /** @type {string} */
            left.style.height = top + "px";
          }
          element.scrollTop += y - bottom;
        }
      } else {
        /** @type {number} */
        bottom = top - element.scrollTop;
        if (bottom < y) {
          element.scrollTop -= y - bottom;
        }
      }
    }
  }
};
/**
 * @return {?}
 */
mxGraph.prototype.createPanningManager = function() {
  return new mxPanningManager(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.getBorderSizes = function() {
  var s = mxUtils.getCurrentStyle(this.container);
  return new mxRectangle(mxUtils.parseCssNumber(s.paddingLeft) + ("none" != s.borderLeftStyle ? mxUtils.parseCssNumber(s.borderLeftWidth) : 0), mxUtils.parseCssNumber(s.paddingTop) + ("none" != s.borderTopStyle ? mxUtils.parseCssNumber(s.borderTopWidth) : 0), mxUtils.parseCssNumber(s.paddingRight) + ("none" != s.borderRightStyle ? mxUtils.parseCssNumber(s.borderRightWidth) : 0), mxUtils.parseCssNumber(s.paddingBottom) + ("none" != s.borderBottomStyle ? mxUtils.parseCssNumber(s.borderBottomWidth) : 
  0));
};
/**
 * @param {!Object} bounds
 * @param {number} width
 * @param {number} height
 * @return {?}
 */
mxGraph.prototype.getPreferredPageSize = function(bounds, width, height) {
  bounds = this.view.translate;
  var box = this.pageFormat;
  var multiplier = this.pageScale;
  box = new mxRectangle(0, 0, Math.ceil(box.width * multiplier), Math.ceil(box.height * multiplier));
  return new mxRectangle(0, 0, (this.pageBreaksVisible ? Math.ceil(width / box.width) : 1) * box.width + 2 + bounds.x, (this.pageBreaksVisible ? Math.ceil(height / box.height) : 1) * box.height + 2 + bounds.y);
};
/**
 * @param {number} options
 * @param {string} callback
 * @param {number} name
 * @param {?} timeout
 * @param {?} value
 * @param {?} v
 * @param {?} bounds
 * @return {?}
 */
mxGraph.prototype.fit = function(options, callback, name, timeout, value, v, bounds) {
  if (null != this.container) {
    options = null != options ? options : this.getBorder();
    callback = null != callback ? callback : false;
    name = null != name ? name : 0;
    timeout = null != timeout ? timeout : true;
    value = null != value ? value : false;
    v = null != v ? v : false;
    var scale = this.getBorderSizes();
    /** @type {number} */
    var w = this.container.offsetWidth - scale.x - scale.width - 1;
    var h = null != bounds ? bounds : this.container.offsetHeight - scale.y - scale.height - 1;
    bounds = this.view.getGraphBounds();
    if (0 < bounds.width && 0 < bounds.height) {
      if (callback && null != bounds.x && null != bounds.y) {
        bounds = bounds.clone();
        bounds.width += bounds.x;
        bounds.height += bounds.y;
        /** @type {number} */
        bounds.x = 0;
        /** @type {number} */
        bounds.y = 0;
      }
      scale = this.view.scale;
      /** @type {number} */
      var width = bounds.width / scale;
      /** @type {number} */
      var height = bounds.height / scale;
      if (null != this.backgroundImage && null != this.backgroundImage.width && null != this.backgroundImage.height) {
        /** @type {number} */
        width = Math.max(width, this.backgroundImage.width - bounds.x / scale);
        /** @type {number} */
        height = Math.max(height, this.backgroundImage.height - bounds.y / scale);
      }
      var lw = (callback ? options : 2 * options) + name + 1;
      /** @type {number} */
      w = w - lw;
      /** @type {number} */
      h = h - lw;
      /** @type {number} */
      value = value ? h / height : v ? w / width : Math.min(w / width, h / height);
      if (null != this.minFitScale) {
        /** @type {number} */
        value = Math.max(value, this.minFitScale);
      }
      if (null != this.maxFitScale) {
        /** @type {number} */
        value = Math.min(value, this.maxFitScale);
      }
      if (timeout) {
        if (callback) {
          if (this.view.scale != value) {
            this.view.setScale(value);
          }
        } else {
          if (mxUtils.hasScrollbars(this.container)) {
            this.view.setScale(value);
            options = this.getGraphBounds();
            if (null != options.x) {
              this.container.scrollLeft = options.x;
            }
            if (null != options.y) {
              this.container.scrollTop = options.y;
            }
          } else {
            this.view.scaleAndTranslate(value, null != bounds.x ? Math.floor(this.view.translate.x - bounds.x / scale + options / value + name / 2) : options, null != bounds.y ? Math.floor(this.view.translate.y - bounds.y / scale + options / value + name / 2) : options);
          }
        }
      } else {
        return value;
      }
    }
  }
  return this.view.scale;
};
/**
 * @return {undefined}
 */
mxGraph.prototype.sizeDidChange = function() {
  var bounds = this.getGraphBounds();
  if (null != this.container) {
    var left = this.getBorder();
    var scale = Math.max(0, bounds.x) + bounds.width + 2 * left;
    left = Math.max(0, bounds.y) + bounds.height + 2 * left;
    if (null != this.minimumContainerSize) {
      /** @type {number} */
      scale = Math.max(scale, this.minimumContainerSize.width);
      /** @type {number} */
      left = Math.max(left, this.minimumContainerSize.height);
    }
    if (this.resizeContainer) {
      this.doResizeContainer(scale, left);
    }
    if (this.preferPageSize || !mxClient.IS_IE && this.pageVisible) {
      var layer = this.getPreferredPageSize(bounds, Math.max(1, scale), Math.max(1, left));
      if (null != layer) {
        /** @type {number} */
        scale = layer.width * this.view.scale;
        /** @type {number} */
        left = layer.height * this.view.scale;
      }
    }
    if (null != this.minimumGraphSize) {
      /** @type {number} */
      scale = Math.max(scale, this.minimumGraphSize.width * this.view.scale);
      /** @type {number} */
      left = Math.max(left, this.minimumGraphSize.height * this.view.scale);
    }
    /** @type {number} */
    scale = Math.ceil(scale);
    /** @type {number} */
    left = Math.ceil(left);
    if (this.dialect == mxConstants.DIALECT_SVG) {
      layer = this.view.getDrawPane().ownerSVGElement;
      if (null != layer) {
        /** @type {string} */
        layer.style.minWidth = Math.max(1, scale) + "px";
        /** @type {string} */
        layer.style.minHeight = Math.max(1, left) + "px";
        /** @type {string} */
        layer.style.width = "100%";
        /** @type {string} */
        layer.style.height = "100%";
      }
    } else {
      /** @type {string} */
      this.view.canvas.style.minWidth = Math.max(1, scale) + "px";
      /** @type {string} */
      this.view.canvas.style.minHeight = Math.max(1, left) + "px";
    }
    this.updatePageBreaks(this.pageBreaksVisible, scale, left);
  }
  this.fireEvent(new mxEventObject(mxEvent.SIZE, "bounds", bounds));
};
/**
 * @param {number} n
 * @param {number} left
 * @return {undefined}
 */
mxGraph.prototype.doResizeContainer = function(n, left) {
  if (null != this.maximumContainerSize) {
    /** @type {number} */
    n = Math.min(this.maximumContainerSize.width, n);
    /** @type {number} */
    left = Math.min(this.maximumContainerSize.height, left);
  }
  /** @type {string} */
  this.container.style.width = Math.ceil(n) + "px";
  /** @type {string} */
  this.container.style.height = Math.ceil(left) + "px";
};
/**
 * @param {boolean} v
 * @param {!Audio} scale
 * @param {!Object} t
 * @return {undefined}
 */
mxGraph.prototype.updatePageBreaks = function(v, scale, t) {
  scale = this.view.scale;
  t = this.view.translate;
  var event = this.pageFormat;
  /** @type {number} */
  var ps = scale * this.pageScale;
  var self = new mxRectangle(0, 0, event.width * ps, event.height * ps);
  event = mxRectangle.fromRectangle(this.getGraphBounds());
  /** @type {number} */
  event.width = Math.max(1, event.width);
  /** @type {number} */
  event.height = Math.max(1, event.height);
  /** @type {number} */
  self.x = Math.floor((event.x - t.x * scale) / self.width) * self.width + t.x * scale;
  /** @type {number} */
  self.y = Math.floor((event.y - t.y * scale) / self.height) * self.height + t.y * scale;
  /** @type {number} */
  event.width = Math.ceil((event.width + (event.x - self.x)) / self.width) * self.width;
  /** @type {number} */
  event.height = Math.ceil((event.height + (event.y - self.y)) / self.height) * self.height;
  /** @type {number} */
  var y = (v = v && Math.min(self.width, self.height) > this.minPageBreakDist) ? Math.ceil(event.height / self.height) + 1 : 0;
  /** @type {number} */
  var x = v ? Math.ceil(event.width / self.width) + 1 : 0;
  /** @type {number} */
  var rad = (x - 1) * self.width;
  /** @type {number} */
  var canvasTop = (y - 1) * self.height;
  if (null == this.horizontalPageBreaks && 0 < y) {
    /** @type {!Array} */
    this.horizontalPageBreaks = [];
  }
  if (null == this.verticalPageBreaks && 0 < x) {
    /** @type {!Array} */
    this.verticalPageBreaks = [];
  }
  v = mxUtils.bind(this, function(data) {
    if (null != data) {
      /** @type {number} */
      var index = data == this.horizontalPageBreaks ? y : x;
      /** @type {number} */
      var i = 0;
      for (; i <= index; i++) {
        /** @type {!Array} */
        var pageBreak = data == this.horizontalPageBreaks ? [new mxPoint(Math.round(self.x), Math.round(self.y + i * self.height)), new mxPoint(Math.round(self.x + rad), Math.round(self.y + i * self.height))] : [new mxPoint(Math.round(self.x + i * self.width), Math.round(self.y)), new mxPoint(Math.round(self.x + i * self.width), Math.round(self.y + canvasTop))];
        if (null != data[i]) {
          /** @type {!Array} */
          data[i].points = pageBreak;
          data[i].redraw();
        } else {
          pageBreak = new mxPolyline(pageBreak, this.pageBreakColor);
          pageBreak.dialect = this.dialect;
          /** @type {boolean} */
          pageBreak.pointerEvents = false;
          pageBreak.isDashed = this.pageBreakDashed;
          pageBreak.init(this.view.backgroundPane);
          pageBreak.redraw();
          data[i] = pageBreak;
        }
      }
      /** @type {number} */
      i = index;
      for (; i < data.length; i++) {
        data[i].destroy();
      }
      data.splice(index, data.length - index);
    }
  });
  v(this.horizontalPageBreaks);
  v(this.verticalPageBreaks);
};
/**
 * @param {?} x
 * @param {!Object} y
 * @return {?}
 */
mxGraph.prototype.getCurrentCellStyle = function(x, y) {
  y = y ? null : this.view.getState(x);
  return null != y ? y.style : this.getCellStyle(x);
};
/**
 * @param {!Object} cell
 * @param {?} record
 * @return {?}
 */
mxGraph.prototype.getCellStyle = function(cell, record) {
  record = null != record ? record : true;
  var row = this.model.getStyle(cell);
  var result = this.model.isEdge(cell) ? this.stylesheet.getDefaultEdgeStyle() : this.stylesheet.getDefaultVertexStyle();
  if (null != row) {
    result = this.stylesheet.getCellStyle(row, result, record);
  } else {
    if (null != result) {
      result = mxUtils.clone(result);
    }
  }
  if (null == result) {
    result = {};
  } else {
    if (record) {
      result = this.postProcessCellStyle(cell, result);
    }
  }
  return result;
};
/**
 * @param {?} a
 * @param {?} f
 * @return {?}
 */
mxGraph.prototype.postProcessCellStyle = function(a, f) {
  if (null != f) {
    var i = f[mxConstants.STYLE_IMAGE];
    a = this.getImageFromBundles(i);
    if (null != a) {
      f[mxConstants.STYLE_IMAGE] = a;
    } else {
      a = i;
    }
    if (null != a && "data:image/" == a.substring(0, 11)) {
      if ("data:image/svg+xml,<" == a.substring(0, 20)) {
        a = a.substring(0, 19) + encodeURIComponent(a.substring(19));
      } else {
        if ("data:image/svg+xml,%3C" != a.substring(0, 22)) {
          i = a.indexOf(",");
          if (0 < i && ";base64," != a.substring(i - 7, i + 1)) {
            a = a.substring(0, i) + ";base64," + a.substring(i + 1);
          }
        }
      }
      f[mxConstants.STYLE_IMAGE] = a;
    }
  }
  return f;
};
/**
 * @param {undefined} position
 * @param {number} matches
 * @return {undefined}
 */
mxGraph.prototype.setCellStyle = function(position, matches) {
  matches = matches || this.getSelectionCells();
  if (null != matches) {
    this.model.beginUpdate();
    try {
      /** @type {number} */
      var i = 0;
      for (; i < matches.length; i++) {
        this.model.setStyle(matches[i], position);
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {!Array} tweenType
 * @param {?} node
 * @param {?} callback
 * @return {?}
 */
mxGraph.prototype.toggleCellStyle = function(tweenType, node, callback) {
  callback = callback || this.getSelectionCell();
  return this.toggleCellStyles(tweenType, node, [callback]);
};
/**
 * @param {!Array} name
 * @param {?} data
 * @param {!Object} props
 * @return {?}
 */
mxGraph.prototype.toggleCellStyles = function(name, data, props) {
  data = null != data ? data : false;
  props = props || this.getEditableCells(this.getSelectionCells());
  /** @type {null} */
  var value = null;
  if (null != props && 0 < props.length) {
    value = this.getCurrentCellStyle(props[0]);
    /** @type {number} */
    value = mxUtils.getValue(value, name, data) ? 0 : 1;
    this.setCellStyles(name, value, props);
  }
  return value;
};
/**
 * @param {!Array} opacity
 * @param {string} position
 * @param {!Array} value
 * @return {undefined}
 */
mxGraph.prototype.setCellStyles = function(opacity, position, value) {
  value = value || this.getEditableCells(this.getSelectionCells());
  mxUtils.setCellStyles(this.model, value, opacity, position);
};
/**
 * @param {undefined} m
 * @param {string} format
 * @param {undefined} value
 * @return {undefined}
 */
mxGraph.prototype.toggleCellStyleFlags = function(m, format, value) {
  this.setCellStyleFlags(m, format, null, value);
};
/**
 * @param {string} i
 * @param {string} name
 * @param {!Object} offset
 * @param {string} value
 * @return {undefined}
 */
mxGraph.prototype.setCellStyleFlags = function(i, name, offset, value) {
  value = value || this.getEditableCells(this.getSelectionCells());
  if (null != value && 0 < value.length) {
    if (null == offset) {
      offset = this.getCurrentCellStyle(value[0]);
      /** @type {boolean} */
      offset = (parseInt(offset[i] || 0) & name) != name;
    }
    mxUtils.setCellStyleFlags(this.model, value, i, name, offset);
  }
};
/**
 * @param {!Object} cell
 * @return {?}
 */
mxGraph.prototype.getOriginForCell = function(cell) {
  cell = this.model.getParent(cell);
  var pt = new mxPoint;
  for (; null != cell;) {
    var o = this.getCellGeometry(cell);
    if (!(null == o || o.relative)) {
      pt.x += o.x;
      pt.y += o.y;
    }
    cell = this.model.getParent(cell);
  }
  return pt;
};
/**
 * @param {number} align
 * @param {string} style
 * @param {number} top
 * @return {?}
 */
mxGraph.prototype.alignCells = function(align, style, top) {
  if (null == style) {
    style = this.getMovableCells(this.getSelectionCells());
  }
  if (null != style && 1 < style.length) {
    if (null == top) {
      /** @type {number} */
      var i = 0;
      for (; i < style.length; i++) {
        var coords = this.getOriginForCell(style[i]);
        var options = this.getCellGeometry(style[i]);
        if (!this.model.isEdge(style[i]) && null != options && !options.relative) {
          if (null == top) {
            if (align == mxConstants.ALIGN_CENTER) {
              top = coords.x + options.x + options.width / 2;
              break;
            } else {
              if (align == mxConstants.ALIGN_RIGHT) {
                top = coords.x + options.x + options.width;
              } else {
                if (align == mxConstants.ALIGN_TOP) {
                  top = coords.y + options.y;
                } else {
                  if (align == mxConstants.ALIGN_MIDDLE) {
                    top = coords.y + options.y + options.height / 2;
                    break;
                  } else {
                    top = align == mxConstants.ALIGN_BOTTOM ? coords.y + options.y + options.height : coords.x + options.x;
                  }
                }
              }
            }
          } else {
            /** @type {number} */
            top = align == mxConstants.ALIGN_RIGHT ? Math.max(top, coords.x + options.x + options.width) : align == mxConstants.ALIGN_TOP ? Math.min(top, coords.y + options.y) : align == mxConstants.ALIGN_BOTTOM ? Math.max(top, coords.y + options.y + options.height) : Math.min(top, coords.x + options.x);
          }
        }
      }
    }
    if (null != top) {
      style = mxUtils.sortCells(style);
      this.model.beginUpdate();
      try {
        /** @type {number} */
        i = 0;
        for (; i < style.length; i++) {
          coords = this.getOriginForCell(style[i]);
          options = this.getCellGeometry(style[i]);
          if (!(this.model.isEdge(style[i]) || null == options || options.relative)) {
            options = options.clone();
            if (align == mxConstants.ALIGN_CENTER) {
              /** @type {number} */
              options.x = top - coords.x - options.width / 2;
            } else {
              if (align == mxConstants.ALIGN_RIGHT) {
                /** @type {number} */
                options.x = top - coords.x - options.width;
              } else {
                if (align == mxConstants.ALIGN_TOP) {
                  /** @type {number} */
                  options.y = top - coords.y;
                } else {
                  if (align == mxConstants.ALIGN_MIDDLE) {
                    /** @type {number} */
                    options.y = top - coords.y - options.height / 2;
                  } else {
                    if (align == mxConstants.ALIGN_BOTTOM) {
                      /** @type {number} */
                      options.y = top - coords.y - options.height;
                    } else {
                      /** @type {number} */
                      options.x = top - coords.x;
                    }
                  }
                }
              }
            }
            this.resizeCell(style[i], options);
          }
        }
        this.fireEvent(new mxEventObject(mxEvent.ALIGN_CELLS, "align", align, "cells", style));
      } finally {
        this.model.endUpdate();
      }
    }
  }
  return style;
};
/**
 * @param {!Object} property
 * @return {?}
 */
mxGraph.prototype.flipEdge = function(property) {
  if (null != property && null != this.alternateEdgeStyle) {
    this.model.beginUpdate();
    try {
      var instanceFillValue = this.model.getStyle(property);
      if (null == instanceFillValue || 0 == instanceFillValue.length) {
        this.model.setStyle(property, this.alternateEdgeStyle);
      } else {
        this.model.setStyle(property, null);
      }
      this.resetEdge(property);
      this.fireEvent(new mxEventObject(mxEvent.FLIP_EDGE, "edge", property));
    } finally {
      this.model.endUpdate();
    }
  }
  return property;
};
/**
 * @param {?} bone_in
 * @return {undefined}
 */
mxGraph.prototype.addImageBundle = function(bone_in) {
  this.imageBundles.push(bone_in);
};
/**
 * @param {?} charVal
 * @return {undefined}
 */
mxGraph.prototype.removeImageBundle = function(charVal) {
  /** @type {!Array} */
  var sortedSelection = [];
  /** @type {number} */
  var i = 0;
  for (; i < this.imageBundles.length; i++) {
    if (this.imageBundles[i] != charVal) {
      sortedSelection.push(this.imageBundles[i]);
    }
  }
  /** @type {!Array} */
  this.imageBundles = sortedSelection;
};
/**
 * @param {!Object} key
 * @return {?}
 */
mxGraph.prototype.getImageFromBundles = function(key) {
  if (null != key) {
    /** @type {number} */
    var i = 0;
    for (; i < this.imageBundles.length; i++) {
      var encodedKeyOrRange = this.imageBundles[i].getImage(key);
      if (null != encodedKeyOrRange) {
        return encodedKeyOrRange;
      }
    }
  }
  return null;
};
/**
 * @param {string} room
 * @param {string} max
 * @param {string} chars
 * @return {?}
 */
mxGraph.prototype.orderCells = function(room, max, chars) {
  if (null == max) {
    max = mxUtils.sortCells(this.getEditableCells(this.getSelectionCells()), true);
  }
  this.model.beginUpdate();
  try {
    this.cellsOrdered(max, room, chars);
    this.fireEvent(new mxEventObject(mxEvent.ORDER_CELLS, "back", room, "cells", max, "increment", chars));
  } finally {
    this.model.endUpdate();
  }
  return max;
};
/**
 * @param {string} list
 * @param {string} str
 * @param {string} keep_new_lines
 * @return {undefined}
 */
mxGraph.prototype.cellsOrdered = function(list, str, keep_new_lines) {
  if (null != list) {
    this.model.beginUpdate();
    try {
      /** @type {number} */
      var i = 0;
      for (; i < list.length; i++) {
        var parent = this.model.getParent(list[i]);
        if (str) {
          if (keep_new_lines) {
            this.model.add(parent, list[i], Math.max(0, parent.getIndex(list[i]) - 1));
          } else {
            this.model.add(parent, list[i], i);
          }
        } else {
          if (keep_new_lines) {
            this.model.add(parent, list[i], Math.min(this.model.getChildCount(parent) - 1, parent.getIndex(list[i]) + 1));
          } else {
            this.model.add(parent, list[i], this.model.getChildCount(parent) - 1);
          }
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_ORDERED, "back", str, "cells", list, "increment", keep_new_lines));
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {string} cell
 * @param {number} value
 * @param {string} cells
 * @return {?}
 */
mxGraph.prototype.groupCells = function(cell, value, cells) {
  if (null == cells) {
    cells = mxUtils.sortCells(this.getSelectionCells(), true);
  }
  cells = this.getCellsForGroup(cells);
  if (null == cell) {
    cell = this.createGroupCell(cells);
  }
  var result = this.getBoundsForGroup(cell, cells, value);
  if (1 < cells.length && null != result) {
    var parent = this.model.getParent(cell);
    if (null == parent) {
      parent = this.model.getParent(cells[0]);
    }
    this.model.beginUpdate();
    try {
      if (null == this.getCellGeometry(cell)) {
        this.model.setGeometry(cell, new mxGeometry);
      }
      var row = this.model.getChildCount(parent);
      this.cellsAdded([cell], parent, row, null, null, false, false, false);
      row = this.model.getChildCount(cell);
      this.cellsAdded(cells, cell, row, null, null, false, false, false);
      this.cellsMoved(cells, -result.x, -result.y, false, false, false);
      this.cellsResized([cell], [result], false);
      this.fireEvent(new mxEventObject(mxEvent.GROUP_CELLS, "group", cell, "border", value, "cells", cells));
    } finally {
      this.model.endUpdate();
    }
  }
  return cell;
};
/**
 * @param {string} children
 * @return {?}
 */
mxGraph.prototype.getCellsForGroup = function(children) {
  /** @type {!Array} */
  var childleftbehind = [];
  if (null != children && 0 < children.length) {
    var c = this.model.getParent(children[0]);
    childleftbehind.push(children[0]);
    /** @type {number} */
    var i = 1;
    for (; i < children.length; i++) {
      if (this.model.getParent(children[i]) == c) {
        childleftbehind.push(children[i]);
      }
    }
  }
  return childleftbehind;
};
/**
 * @param {?} options
 * @param {!Object} node
 * @param {number} size
 * @return {?}
 */
mxGraph.prototype.getBoundsForGroup = function(options, node, size) {
  node = this.getBoundingBoxFromGeometry(node, true);
  if (null != node) {
    if (this.isSwimlane(options)) {
      options = this.getStartSize(options);
      node.x -= options.width;
      node.y -= options.height;
      node.width += options.width;
      node.height += options.height;
    }
    if (null != size) {
      node.x -= size;
      node.y -= size;
      node.width += 2 * size;
      node.height += 2 * size;
    }
  }
  return node;
};
/**
 * @param {string} group
 * @return {?}
 */
mxGraph.prototype.createGroupCell = function(group) {
  group = new mxCell("");
  group.setVertex(true);
  group.setConnectable(false);
  return group;
};
/**
 * @param {!Object} matches
 * @return {?}
 */
mxGraph.prototype.ungroupCells = function(matches) {
  /** @type {!Array} */
  var chain = [];
  if (null == matches) {
    matches = this.getCellsForUngroup();
  }
  if (null != matches && 0 < matches.length) {
    this.model.beginUpdate();
    try {
      /** @type {number} */
      var j = 0;
      for (; j < matches.length; j++) {
        var children = this.model.getChildren(matches[j]);
        if (null != children && 0 < children.length) {
          children = children.slice();
          var parent = this.model.getParent(matches[j]);
          var parentContext = this.model.getChildCount(parent);
          this.cellsAdded(children, parent, parentContext, null, null, true);
          /** @type {!Array<?>} */
          chain = chain.concat(children);
          /** @type {number} */
          var i = 0;
          for (; i < children.length; i++) {
            if (this.model.isVertex(children[i])) {
              var anchorBounds = this.view.getState(children[i]);
              var path = this.getCellGeometry(children[i]);
              if (null != anchorBounds && null != path && path.relative) {
                path = path.clone();
                path.x = anchorBounds.origin.x;
                path.y = anchorBounds.origin.y;
                /** @type {boolean} */
                path.relative = false;
                this.model.setGeometry(children[i], path);
              }
            }
          }
        }
      }
      this.removeCellsAfterUngroup(matches);
      this.fireEvent(new mxEventObject(mxEvent.UNGROUP_CELLS, "cells", matches));
    } finally {
      this.model.endUpdate();
    }
  }
  return chain;
};
/**
 * @return {?}
 */
mxGraph.prototype.getCellsForUngroup = function() {
  var cells = this.getEditableCells(this.getSelectionCells());
  /** @type {!Array} */
  var cellsUpdated = [];
  /** @type {number} */
  var i = 0;
  for (; i < cells.length; i++) {
    if (this.model.isVertex(cells[i]) && 0 < this.model.getChildCount(cells[i])) {
      cellsUpdated.push(cells[i]);
    }
  }
  return cellsUpdated;
};
/**
 * @param {boolean} data
 * @return {undefined}
 */
mxGraph.prototype.removeCellsAfterUngroup = function(data) {
  this.cellsRemoved(this.addAllEdges(data));
};
/**
 * @param {string} a
 * @return {?}
 */
mxGraph.prototype.removeCellsFromParent = function(a) {
  if (null == a) {
    a = this.getSelectionCells();
  }
  this.model.beginUpdate();
  try {
    var parent = this.getDefaultParent();
    var parentContext = this.model.getChildCount(parent);
    this.cellsAdded(a, parent, parentContext, null, null, true);
    this.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS_FROM_PARENT, "cells", a));
  } finally {
    this.model.endUpdate();
  }
  return a;
};
/**
 * @param {!Object} list
 * @param {number} pos
 * @param {string} data
 * @param {number} width
 * @param {number} space
 * @param {number} offset
 * @param {number} v
 * @return {?}
 */
mxGraph.prototype.updateGroupBounds = function(list, pos, data, width, space, offset, v) {
  if (null == list) {
    list = this.getSelectionCells();
  }
  pos = null != pos ? pos : 0;
  data = null != data ? data : false;
  width = null != width ? width : 0;
  space = null != space ? space : 0;
  offset = null != offset ? offset : 0;
  v = null != v ? v : 0;
  this.model.beginUpdate();
  try {
    /** @type {number} */
    var i = list.length - 1;
    for (; 0 <= i; i--) {
      var line = this.getCellGeometry(list[i]);
      if (null != line) {
        var string = this.getChildCells(list[i]);
        if (null != string && 0 < string.length) {
          var that = this.getBoundingBoxFromGeometry(string, true);
          if (null != that && 0 < that.width && 0 < that.height) {
            var item = this.isSwimlane(list[i]) ? this.getActualStartSize(list[i], true) : new mxRectangle;
            line = line.clone();
            if (data) {
              /** @type {number} */
              line.x = Math.round(line.x + that.x - pos - item.x - v);
              /** @type {number} */
              line.y = Math.round(line.y + that.y - pos - item.y - width);
            }
            /** @type {number} */
            line.width = Math.round(that.width + 2 * pos + item.x + v + space + item.width);
            /** @type {number} */
            line.height = Math.round(that.height + 2 * pos + item.y + width + offset + item.height);
            this.model.setGeometry(list[i], line);
            this.moveCells(string, pos + item.x - that.x + v, pos + item.y - that.y + width);
          }
        }
      }
    }
  } finally {
    this.model.endUpdate();
  }
  return list;
};
/**
 * @param {!Object} o
 * @return {?}
 */
mxGraph.prototype.getBoundingBox = function(o) {
  /** @type {null} */
  var box = null;
  if (null != o && 0 < o.length) {
    /** @type {number} */
    var i = 0;
    for (; i < o.length; i++) {
      if (this.model.isVertex(o[i]) || this.model.isEdge(o[i])) {
        var selected = this.view.getBoundingBox(this.view.getState(o[i]), true);
        if (null != selected) {
          if (null == box) {
            box = mxRectangle.fromRectangle(selected);
          } else {
            box.add(selected);
          }
        }
      }
    }
  }
  return box;
};
/**
 * @param {!Object} type
 * @param {?} array
 * @param {undefined} n
 * @param {boolean} cell
 * @return {?}
 */
mxGraph.prototype.cloneCell = function(type, array, n, cell) {
  return this.cloneCells([type], array, n, cell)[0];
};
/**
 * @param {!Object} nodes
 * @param {?} e
 * @param {number} h
 * @param {boolean} a
 * @return {?}
 */
mxGraph.prototype.cloneCells = function(nodes, e, h, a) {
  e = null != e ? e : true;
  /** @type {null} */
  var list = null;
  if (null != nodes) {
    var self = new mxDictionary;
    /** @type {!Array} */
    list = [];
    /** @type {number} */
    var i = 0;
    for (; i < nodes.length; i++) {
      self.put(nodes[i], true);
      list.push(nodes[i]);
    }
    if (0 < list.length) {
      var scale = this.view.scale;
      var t = this.view.translate;
      list = this.model.cloneCells(nodes, true, h);
      /** @type {number} */
      i = 0;
      for (; i < nodes.length; i++) {
        if (!e && this.model.isEdge(list[i]) && null != this.getEdgeValidationError(list[i], this.model.getTerminal(list[i], true), this.model.getTerminal(list[i], false))) {
          /** @type {null} */
          list[i] = null;
        } else {
          var p = this.model.getGeometry(list[i]);
          if (null != p) {
            var pos = this.view.getState(nodes[i]);
            var s = this.view.getState(this.model.getParent(nodes[i]));
            if (null != pos && null != s) {
              if (h = a ? 0 : s.origin.x, s = a ? 0 : s.origin.y, this.model.isEdge(list[i])) {
                if (pos = pos.absolutePoints, null != pos) {
                  var d = this.model.getTerminal(nodes[i], true);
                  for (; null != d && !self.get(d);) {
                    d = this.model.getParent(d);
                  }
                  if (null == d && null != pos[0]) {
                    p.setTerminalPoint(new mxPoint(pos[0].x / scale - t.x, pos[0].y / scale - t.y), true);
                  }
                  d = this.model.getTerminal(nodes[i], false);
                  for (; null != d && !self.get(d);) {
                    d = this.model.getParent(d);
                  }
                  /** @type {number} */
                  var j = pos.length - 1;
                  if (null == d && null != pos[j]) {
                    p.setTerminalPoint(new mxPoint(pos[j].x / scale - t.x, pos[j].y / scale - t.y), false);
                  }
                  p = p.points;
                  if (null != p) {
                    /** @type {number} */
                    pos = 0;
                    for (; pos < p.length; pos++) {
                      p[pos].x += h;
                      p[pos].y += s;
                    }
                  }
                }
              } else {
                p.translate(h, s);
              }
            }
          }
        }
      }
    } else {
      /** @type {!Array} */
      list = [];
    }
  }
  return list;
};
/**
 * @param {undefined} index
 * @param {string} i
 * @param {!Object} end
 * @param {number} str
 * @param {?} e
 * @param {boolean} id
 * @param {?} vertex
 * @param {!Function} start
 * @param {string} step
 * @return {?}
 */
mxGraph.prototype.insertVertex = function(index, i, end, str, e, id, vertex, start, step) {
  i = this.createVertex(index, i, end, str, e, id, vertex, start, step);
  return this.addCell(i, index);
};
/**
 * @param {string} result
 * @param {string} id
 * @param {!Object} label
 * @param {?} x
 * @param {boolean} y
 * @param {boolean} color
 * @param {boolean} name
 * @param {!Function} options
 * @param {string} value
 * @return {?}
 */
mxGraph.prototype.createVertex = function(result, id, label, x, y, color, name, options, value) {
  result = new mxGeometry(x, y, color, name);
  result.relative = null != value ? value : false;
  label = new mxCell(label, result, options);
  label.setId(id);
  label.setVertex(true);
  label.setConnectable(true);
  return label;
};
/**
 * @param {(Object|string)} target
 * @param {string} value
 * @param {string} id
 * @param {string} data
 * @param {string} key
 * @param {?} type
 * @return {?}
 */
mxGraph.prototype.insertEdge = function(target, value, id, data, key, type) {
  value = this.createEdge(target, value, id, data, key, type);
  return this.addEdge(value, target, data, key);
};
/**
 * @param {!Object} cell
 * @param {string} value
 * @param {string} id
 * @param {!Object} type
 * @param {string} style
 * @param {?} properties
 * @return {?}
 */
mxGraph.prototype.createEdge = function(cell, value, id, type, style, properties) {
  cell = new mxCell(id, new mxGeometry, properties);
  cell.setId(value);
  cell.setEdge(true);
  /** @type {boolean} */
  cell.geometry.relative = true;
  return cell;
};
/**
 * @param {string} from
 * @param {(Object|string)} to
 * @param {string} e
 * @param {string} options
 * @param {?} value
 * @return {?}
 */
mxGraph.prototype.addEdge = function(from, to, e, options, value) {
  return this.addCell(from, to, value, e, options);
};
/**
 * @param {string} data
 * @param {?} index
 * @param {?} row
 * @param {!Object} pos
 * @param {!Object} text
 * @return {?}
 */
mxGraph.prototype.addCell = function(data, index, row, pos, text) {
  return this.addCells([data], index, row, pos, text)[0];
};
/**
 * @param {string} cells
 * @param {number} node
 * @param {number} row
 * @param {boolean} event
 * @param {boolean} type
 * @param {string} skipFormulaReparse
 * @return {?}
 */
mxGraph.prototype.addCells = function(cells, node, row, event, type, skipFormulaReparse) {
  if (null == node) {
    node = this.getDefaultParent();
  }
  if (null == row) {
    row = this.model.getChildCount(node);
  }
  this.model.beginUpdate();
  try {
    this.cellsAdded(cells, node, row, event, type, null != skipFormulaReparse ? skipFormulaReparse : false, true);
    this.fireEvent(new mxEventObject(mxEvent.ADD_CELLS, "cells", cells, "parent", node, "index", row, "source", event, "target", type));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
/**
 * @param {string} list
 * @param {number} name
 * @param {number} source
 * @param {number} obj
 * @param {boolean} data
 * @param {string} r
 * @param {string} success
 * @param {string} status
 * @return {undefined}
 */
mxGraph.prototype.cellsAdded = function(list, name, source, obj, data, r, success, status) {
  if (null != list && null != name && null != source) {
    this.model.beginUpdate();
    try {
      var i = r ? this.view.getState(name) : null;
      var Cpoints = null != i ? i.origin : null;
      var label = new mxPoint(0, 0);
      /** @type {number} */
      i = 0;
      for (; i < list.length; i++) {
        if (null == list[i]) {
          source--;
        } else {
          var type = this.model.getParent(list[i]);
          if (null != Cpoints && list[i] != name && name != type) {
            var html = this.view.getState(type);
            var point = null != html ? html.origin : label;
            var to = this.model.getGeometry(list[i]);
            if (null != to) {
              /** @type {number} */
              var m = point.x - Cpoints.x;
              /** @type {number} */
              var value = point.y - Cpoints.y;
              to = to.clone();
              to.translate(m, value);
              if (!(to.relative || !this.model.isVertex(list[i]) || this.isAllowNegativeCoordinates())) {
                /** @type {number} */
                to.x = Math.max(0, to.x);
                /** @type {number} */
                to.y = Math.max(0, to.y);
              }
              this.model.setGeometry(list[i], to);
            }
          }
          if (name == type && source + i > this.model.getChildCount(name)) {
            source--;
          }
          this.model.add(name, list[i], source + i);
          if (this.autoSizeCellsOnAdd) {
            this.autoSizeCell(list[i], true);
          }
          if ((null == status || status) && this.isExtendParentsOnAdd(list[i]) && this.isExtendParent(list[i])) {
            this.extendParent(list[i]);
          }
          if (null == success || success) {
            this.constrainChild(list[i]);
          }
          if (null != obj) {
            this.cellConnected(list[i], obj, true);
          }
          if (null != data) {
            this.cellConnected(list[i], data, false);
          }
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_ADDED, "cells", list, "parent", name, "index", source, "source", obj, "target", data, "absolute", r));
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {undefined} cell
 * @param {number} v
 * @return {undefined}
 */
mxGraph.prototype.autoSizeCell = function(cell, v) {
  if (null != v ? v : 1) {
    v = this.model.getChildCount(cell);
    /** @type {number} */
    var i = 0;
    for (; i < v; i++) {
      this.autoSizeCell(this.model.getChildAt(cell, i));
    }
  }
  if (this.getModel().isVertex(cell) && this.isAutoSizeCell(cell)) {
    this.updateCellSize(cell);
  }
};
/**
 * @param {string} arr
 * @param {!Object} name
 * @return {?}
 */
mxGraph.prototype.removeCells = function(arr, name) {
  name = null != name ? name : true;
  if (null == arr) {
    arr = this.getDeletableCells(this.getSelectionCells());
  }
  if (name) {
    arr = this.getDeletableCells(this.addAllEdges(arr));
  } else {
    arr = arr.slice();
    var nodes = this.getDeletableCells(this.getAllEdges(arr));
    var result = new mxDictionary;
    /** @type {number} */
    var i = 0;
    for (; i < arr.length; i++) {
      result.put(arr[i], true);
    }
    /** @type {number} */
    i = 0;
    for (; i < nodes.length; i++) {
      if (!(null != this.view.getState(nodes[i]) || result.get(nodes[i]))) {
        result.put(nodes[i], true);
        arr.push(nodes[i]);
      }
    }
  }
  this.model.beginUpdate();
  try {
    this.cellsRemoved(arr);
    this.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS, "cells", arr, "includeEdges", name));
  } finally {
    this.model.endUpdate();
  }
  return arr;
};
/**
 * @param {!Object} array
 * @return {undefined}
 */
mxGraph.prototype.cellsRemoved = function(array) {
  if (null != array && 0 < array.length) {
    var scale = this.view.scale;
    var t = this.view.translate;
    this.model.beginUpdate();
    try {
      var exports = new mxDictionary;
      /** @type {number} */
      var i = 0;
      for (; i < array.length; i++) {
        exports.put(array[i], true);
      }
      /** @type {number} */
      i = 0;
      for (; i < array.length; i++) {
        var a = this.getAllEdges([array[i]]);
        var g = mxUtils.bind(this, function(id, options) {
          var y = this.model.getGeometry(id);
          if (null != y) {
            var x = this.model.getTerminal(id, options);
            /** @type {boolean} */
            var e = false;
            var name = x;
            for (; null != name;) {
              if (array[i] == name) {
                /** @type {boolean} */
                e = true;
                break;
              }
              name = this.model.getParent(name);
            }
            if (e) {
              y = y.clone();
              e = this.view.getState(id);
              if (null != e && null != e.absolutePoints) {
                x = e.absolutePoints;
                /** @type {number} */
                name = options ? 0 : x.length - 1;
                y.setTerminalPoint(new mxPoint(x[name].x / scale - t.x - e.origin.x, x[name].y / scale - t.y - e.origin.y), options);
              } else {
                x = this.view.getState(x);
                if (null != x) {
                  y.setTerminalPoint(new mxPoint(x.getCenterX() / scale - t.x, x.getCenterY() / scale - t.y), options);
                }
              }
              this.model.setGeometry(id, y);
              this.model.setTerminal(id, null, options);
            }
          }
        });
        /** @type {number} */
        var j = 0;
        for (; j < a.length; j++) {
          if (!exports.get(a[j])) {
            exports.put(a[j], true);
            g(a[j], true);
            g(a[j], false);
          }
        }
        this.model.remove(array[i]);
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_REMOVED, "cells", array));
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {string} x
 * @param {string} cells
 * @param {number} cell
 * @param {number} l
 * @param {boolean} i
 * @param {number} map
 * @param {?} nodes
 * @param {number} parent
 * @return {?}
 */
mxGraph.prototype.splitEdge = function(x, cells, cell, l, i, map, nodes, parent) {
  l = l || 0;
  i = i || 0;
  parent = null != parent ? parent : this.model.getParent(x);
  map = this.model.getTerminal(x, true);
  this.model.beginUpdate();
  try {
    if (null == cell) {
      cell = this.cloneCell(x);
      var style = this.view.getState(x);
      var geo = this.getCellGeometry(cell);
      if (null != geo && null != geo.points && null != style) {
        var p = this.view.translate;
        var scale = this.view.scale;
        var m = mxUtils.findNearestSegment(style, (l + p.x) * scale, (i + p.y) * scale);
        geo.points = geo.points.slice(0, m);
        geo = this.getCellGeometry(x);
        if (null != geo && null != geo.points) {
          geo = geo.clone();
          geo.points = geo.points.slice(m);
          this.model.setGeometry(x, geo);
        }
      }
    }
    this.cellsMoved(cells, l, i, false, false);
    this.cellsAdded(cells, parent, this.model.getChildCount(parent), null, null, true);
    this.cellsAdded([cell], parent, this.model.getChildCount(parent), map, cells[0], false);
    this.cellConnected(x, cells[0], true);
    this.fireEvent(new mxEventObject(mxEvent.SPLIT_EDGE, "edge", x, "cells", cells, "newEdge", cell, "dx", l, "dy", i));
  } finally {
    this.model.endUpdate();
  }
  return cell;
};
/**
 * @param {string} date
 * @param {string} f
 * @param {string} _clusterMode
 * @return {?}
 */
mxGraph.prototype.toggleCells = function(date, f, _clusterMode) {
  if (null == f) {
    f = this.getSelectionCells();
  }
  if (_clusterMode) {
    f = this.addAllEdges(f);
  }
  this.model.beginUpdate();
  try {
    this.cellsToggled(f, date);
    this.fireEvent(new mxEventObject(mxEvent.TOGGLE_CELLS, "show", date, "cells", f, "includeEdges", _clusterMode));
  } finally {
    this.model.endUpdate();
  }
  return f;
};
/**
 * @param {string} filters
 * @param {!Object} type
 * @return {undefined}
 */
mxGraph.prototype.cellsToggled = function(filters, type) {
  if (null != filters && 0 < filters.length) {
    this.model.beginUpdate();
    try {
      /** @type {number} */
      var i = 0;
      for (; i < filters.length; i++) {
        this.model.setVisible(filters[i], type);
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {string} value
 * @param {string} position
 * @param {string} text
 * @param {!Object} container
 * @param {!Object} p
 * @return {?}
 */
mxGraph.prototype.foldCells = function(value, position, text, container, p) {
  position = null != position ? position : false;
  if (null == text) {
    text = this.getFoldableCells(this.getSelectionCells(), value);
  }
  this.stopEditing(false);
  this.model.beginUpdate();
  try {
    this.cellsFolded(text, value, position, container);
    this.fireEvent(new mxEventObject(mxEvent.FOLD_CELLS, "collapse", value, "recurse", position, "cells", text));
  } finally {
    this.model.endUpdate();
  }
  return text;
};
/**
 * @param {string} children
 * @param {string} collapsed
 * @param {string} rect
 * @param {!Object} node
 * @return {undefined}
 */
mxGraph.prototype.cellsFolded = function(children, collapsed, rect, node) {
  if (null != children && 0 < children.length) {
    this.model.beginUpdate();
    try {
      /** @type {number} */
      var i = 0;
      for (; i < children.length; i++) {
        if ((!node || this.isCellFoldable(children[i], collapsed)) && collapsed != this.isCellCollapsed(children[i])) {
          this.model.setCollapsed(children[i], collapsed);
          this.swapBounds(children[i], collapsed);
          if (this.isExtendParent(children[i])) {
            this.extendParent(children[i]);
          }
          if (rect) {
            var detailNodes = this.model.getChildren(children[i]);
            this.cellsFolded(detailNodes, collapsed, rect);
          }
          this.constrainChild(children[i]);
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_FOLDED, "cells", children, "collapse", collapsed, "recurse", rect));
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {?} p
 * @param {?} value
 * @return {undefined}
 */
mxGraph.prototype.swapBounds = function(p, value) {
  if (null != p) {
    var y = this.model.getGeometry(p);
    if (null != y) {
      y = y.clone();
      this.updateAlternateBounds(p, y, value);
      y.swap();
      this.model.setGeometry(p, y);
    }
  }
};
/**
 * @param {number} i
 * @param {number} point
 * @param {number} d
 * @return {undefined}
 */
mxGraph.prototype.updateAlternateBounds = function(i, point, d) {
  if (null != i && null != point) {
    d = this.getCurrentCellStyle(i);
    if (null == point.alternateBounds) {
      /** @type {number} */
      var s = point;
      if (this.collapseToPreferredSize) {
        i = this.getPreferredSizeForCell(i);
        if (null != i) {
          /** @type {number} */
          s = i;
          i = mxUtils.getValue(d, mxConstants.STYLE_STARTSIZE);
          if (0 < i) {
            /** @type {number} */
            s.height = Math.max(s.height, i);
          }
        }
      }
      point.alternateBounds = new mxRectangle(0, 0, s.width, s.height);
    }
    if (null != point.alternateBounds) {
      point.alternateBounds.x = point.x;
      point.alternateBounds.y = point.y;
      var j = mxUtils.toRadians(d[mxConstants.STYLE_ROTATION] || 0);
      if (0 != j) {
        /** @type {number} */
        d = point.alternateBounds.getCenterX() - point.getCenterX();
        /** @type {number} */
        s = point.alternateBounds.getCenterY() - point.getCenterY();
        /** @type {number} */
        i = Math.cos(j);
        /** @type {number} */
        j = Math.sin(j);
        point.alternateBounds.x += i * d - j * s - d;
        point.alternateBounds.y += j * d + i * s - s;
      }
    }
  }
};
/**
 * @param {string} rows
 * @return {?}
 */
mxGraph.prototype.addAllEdges = function(rows) {
  var res = rows.slice();
  return mxUtils.removeDuplicates(res.concat(this.getAllEdges(rows)));
};
/**
 * @param {!Object} array
 * @return {?}
 */
mxGraph.prototype.getAllEdges = function(array) {
  /** @type {!Array} */
  var results = [];
  if (null != array) {
    /** @type {number} */
    var i = 0;
    for (; i < array.length; i++) {
      var pixels = this.model.getEdgeCount(array[i]);
      /** @type {number} */
      var e = 0;
      for (; e < pixels; e++) {
        results.push(this.model.getEdgeAt(array[i], e));
      }
      pixels = this.model.getChildren(array[i]);
      /** @type {!Array<?>} */
      results = results.concat(this.getAllEdges(pixels));
    }
  }
  return results;
};
/**
 * @param {number} e
 * @param {string} args
 * @return {?}
 */
mxGraph.prototype.updateCellSize = function(e, args) {
  args = null != args ? args : false;
  this.model.beginUpdate();
  try {
    this.cellSizeUpdated(e, args);
    this.fireEvent(new mxEventObject(mxEvent.UPDATE_CELL_SIZE, "cell", e, "ignoreChildren", args));
  } finally {
    this.model.endUpdate();
  }
  return e;
};
/**
 * @param {?} element
 * @param {string} x
 * @return {undefined}
 */
mxGraph.prototype.cellSizeUpdated = function(element, x) {
  if (null != element) {
    this.model.beginUpdate();
    try {
      var data = this.getCellStyle(element);
      var o = this.model.getGeometry(element);
      if (null != o) {
        /** @type {null} */
        var about = null;
        var x = mxUtils.getValue(data, mxConstants.STYLE_FIXED_WIDTH, false);
        if (x) {
          /** @type {number} */
          about = o.width - 2 * parseFloat(mxUtils.getValue(data, mxConstants.STYLE_SPACING, 2)) - parseFloat(mxUtils.getValue(data, mxConstants.STYLE_SPACING_LEFT, 0)) - parseFloat(mxUtils.getValue(data, mxConstants.STYLE_SPACING_RIGHT, 0));
        }
        var s = this.getPreferredSizeForCell(element, about);
        if (null != s) {
          var y = this.isCellCollapsed(element);
          o = o.clone();
          if (this.isSwimlane(element)) {
            var value = this.model.getStyle(element);
            if (null == value) {
              /** @type {string} */
              value = "";
            }
            if (mxUtils.getValue(data, mxConstants.STYLE_HORIZONTAL, true)) {
              value = mxUtils.setStyle(value, mxConstants.STYLE_STARTSIZE, s.height + 8);
              if (y) {
                o.height = s.height + 8;
              }
              if (!x) {
                o.width = s.width;
              }
            } else {
              value = mxUtils.setStyle(value, mxConstants.STYLE_STARTSIZE, s.width + 8);
              if (y && !x) {
                o.width = s.width + 8;
              }
              o.height = s.height;
            }
            this.model.setStyle(element, value);
          } else {
            var state = this.view.createState(element);
            var align = state.style[mxConstants.STYLE_ALIGN] || mxConstants.ALIGN_CENTER;
            var valign = this.getVerticalAlign(state);
            if ("fixed" == state.style[mxConstants.STYLE_ASPECT]) {
              /** @type {number} */
              s.height = Math.round(o.height * s.width * 100 / o.width) / 100;
            }
            if (valign == mxConstants.ALIGN_BOTTOM) {
              o.y += o.height - s.height;
            } else {
              if (valign == mxConstants.ALIGN_MIDDLE) {
                o.y += Math.round((o.height - s.height) / 2);
              }
            }
            o.height = s.height;
            if (!x) {
              if (align == mxConstants.ALIGN_RIGHT) {
                o.x += o.width - s.width;
              } else {
                if (align == mxConstants.ALIGN_CENTER) {
                  o.x += Math.round((o.width - s.width) / 2);
                }
              }
              o.width = s.width;
            }
          }
          if (!x && !y) {
            var locPSRect = this.view.getBounds(this.model.getChildren(element));
            if (null != locPSRect) {
              var t = this.view.translate;
              var scale = this.view.scale;
              /** @type {number} */
              var w = (locPSRect.x + locPSRect.width) / scale - o.x - t.x;
              /** @type {number} */
              o.height = Math.max(o.height, (locPSRect.y + locPSRect.height) / scale - o.y - t.y);
              if (!x) {
                /** @type {number} */
                o.width = Math.max(o.width, w);
              }
            }
          }
          this.cellsResized([element], [o], false);
        }
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {number} i
 * @param {string} to
 * @return {?}
 */
mxGraph.prototype.getPreferredSizeForCell = function(i, to) {
  /** @type {null} */
  var offset = null;
  if (null != i) {
    var result = this.view.createState(i);
    var style = result.style;
    if (!this.model.isEdge(i)) {
      var cos = style[mxConstants.STYLE_FONTSIZE] || mxConstants.DEFAULT_FONTSIZE;
      /** @type {number} */
      i = offset = 0;
      if (!(null == this.getImage(result) && null == style[mxConstants.STYLE_IMAGE] || style[mxConstants.STYLE_SHAPE] != mxConstants.SHAPE_LABEL)) {
        if (style[mxConstants.STYLE_VERTICAL_ALIGN] == mxConstants.ALIGN_MIDDLE) {
          /** @type {number} */
          offset = offset + parseFloat(mxUtils.getValue(style, mxConstants.STYLE_IMAGE_WIDTH, mxLabel.prototype.imageSize));
        }
        if (style[mxConstants.STYLE_ALIGN] != mxConstants.ALIGN_CENTER) {
          /** @type {number} */
          i = i + parseFloat(mxUtils.getValue(style, mxConstants.STYLE_IMAGE_HEIGHT, mxLabel.prototype.imageSize));
        }
      }
      /** @type {number} */
      offset = offset + 2 * parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING, 2));
      /** @type {number} */
      offset = offset + parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_LEFT, 2));
      /** @type {number} */
      offset = offset + parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_RIGHT, 2));
      /** @type {number} */
      i = i + 2 * parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING, 2));
      /** @type {number} */
      i = i + parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_TOP, 2));
      /** @type {number} */
      i = i + parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_BOTTOM, 2));
      var value = this.getFoldingImage(result);
      if (null != value) {
        offset = offset + (value.width + 8);
      }
      value = this.cellRenderer.getLabelValue(result);
      if (null != value && 0 < value.length) {
        if (this.isHtmlLabel(result.cell)) {
          if (null != to) {
            to = to + mxSvgCanvas2D.prototype.foreignObjectPadding;
          }
        } else {
          value = mxUtils.htmlEntities(value, false);
        }
        value = value.replace(/\n/g, "<br>");
        result = mxUtils.getSizeForString(value, cos, style[mxConstants.STYLE_FONTFAMILY], to, style[mxConstants.STYLE_FONTSTYLE]);
        to = result.width + offset;
        result = result.height + i;
        if (!mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true)) {
          style = result;
          /** @type {string} */
          result = to;
          to = style;
        }
        if (this.gridEnabled) {
          to = this.snap(to + this.gridSize / 2);
          result = this.snap(result + this.gridSize / 2);
        }
        offset = new mxRectangle(0, 0, to, result);
      } else {
        /** @type {number} */
        style = 4 * this.gridSize;
        offset = new mxRectangle(0, 0, style, style);
      }
    }
  }
  return offset;
};
/**
 * @param {!Object} index
 * @param {?} height
 * @param {!Function} width
 * @return {?}
 */
mxGraph.prototype.resizeCell = function(index, height, width) {
  return this.resizeCells([index], [height], width)[0];
};
/**
 * @param {string} height
 * @param {number} width
 * @param {string} name
 * @return {?}
 */
mxGraph.prototype.resizeCells = function(height, width, name) {
  name = null != name ? name : this.isRecursiveResize();
  this.model.beginUpdate();
  try {
    var f = this.cellsResized(height, width, name);
    this.fireEvent(new mxEventObject(mxEvent.RESIZE_CELLS, "cells", height, "bounds", width, "previous", f));
  } finally {
    this.model.endUpdate();
  }
  return height;
};
/**
 * @param {string} a
 * @param {number} b
 * @param {string} c
 * @return {?}
 */
mxGraph.prototype.cellsResized = function(a, b, c) {
  c = null != c ? c : false;
  /** @type {!Array} */
  var join = [];
  if (null != a && null != b && a.length == b.length) {
    this.model.beginUpdate();
    try {
      /** @type {number} */
      var i = 0;
      for (; i < a.length; i++) {
        join.push(this.cellResized(a[i], b[i], false, c));
        if (this.isExtendParent(a[i])) {
          this.extendParent(a[i]);
        }
        this.constrainChild(a[i]);
      }
      if (this.resetEdgesOnResize) {
        this.resetEdges(a);
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_RESIZED, "cells", a, "bounds", b, "previous", join));
    } finally {
      this.model.endUpdate();
    }
  }
  return join;
};
/**
 * @param {!Object} element
 * @param {!Object} a
 * @param {number} d
 * @param {string} prefix
 * @return {?}
 */
mxGraph.prototype.cellResized = function(element, a, d, prefix) {
  var params = this.model.getGeometry(element);
  if (null != params && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height)) {
    var c = params.clone();
    if (!d && c.relative) {
      d = c.offset;
      if (null != d) {
        d.x += a.x - c.x;
        d.y += a.y - c.y;
      }
    } else {
      c.x = a.x;
      c.y = a.y;
    }
    c.width = a.width;
    c.height = a.height;
    if (!(c.relative || !this.model.isVertex(element) || this.isAllowNegativeCoordinates())) {
      /** @type {number} */
      c.x = Math.max(0, c.x);
      /** @type {number} */
      c.y = Math.max(0, c.y);
    }
    this.model.beginUpdate();
    try {
      if (prefix) {
        this.resizeChildCells(element, c);
      }
      this.model.setGeometry(element, c);
      this.constrainChildCells(element);
    } finally {
      this.model.endUpdate();
    }
  }
  return params;
};
/**
 * @param {!Object} cell
 * @param {number} b
 * @return {undefined}
 */
mxGraph.prototype.resizeChildCells = function(cell, b) {
  var a = this.model.getGeometry(cell);
  /** @type {number} */
  var verticalrailid = 0 != a.width ? b.width / a.width : 1;
  /** @type {number} */
  b = 0 != a.height ? b.height / a.height : 1;
  a = this.model.getChildCount(cell);
  /** @type {number} */
  var i = 0;
  for (; i < a; i++) {
    this.scaleCell(this.model.getChildAt(cell, i), verticalrailid, b, true);
  }
};
/**
 * @param {!Object} cell
 * @return {undefined}
 */
mxGraph.prototype.constrainChildCells = function(cell) {
  var childCount = this.model.getChildCount(cell);
  /** @type {number} */
  var i = 0;
  for (; i < childCount; i++) {
    this.constrainChild(this.model.getChildAt(cell, i));
  }
};
/**
 * @param {undefined} element
 * @param {number} s
 * @param {number} p
 * @param {string} a
 * @return {undefined}
 */
mxGraph.prototype.scaleCell = function(element, s, p, a) {
  var v = this.model.getGeometry(element);
  if (null != v) {
    var style = this.getCurrentCellStyle(element);
    v = v.clone();
    var dx = v.x;
    var y = v.y;
    var size = v.width;
    var height = v.height;
    v.scale(s, p, "fixed" == style[mxConstants.STYLE_ASPECT]);
    if ("1" == style[mxConstants.STYLE_RESIZE_WIDTH]) {
      /** @type {number} */
      v.width = size * s;
    } else {
      if ("0" == style[mxConstants.STYLE_RESIZE_WIDTH]) {
        v.width = size;
      }
    }
    if ("1" == style[mxConstants.STYLE_RESIZE_HEIGHT]) {
      /** @type {number} */
      v.height = height * p;
    } else {
      if ("0" == style[mxConstants.STYLE_RESIZE_HEIGHT]) {
        v.height = height;
      }
    }
    if (!this.isCellMovable(element)) {
      v.x = dx;
      v.y = y;
    }
    if (!this.isCellResizable(element)) {
      v.width = size;
      v.height = height;
    }
    if (this.model.isVertex(element)) {
      this.cellResized(element, v, true, a);
    } else {
      this.model.setGeometry(element, v);
    }
  }
};
/**
 * @param {!Object} d
 * @return {undefined}
 */
mxGraph.prototype.extendParent = function(d) {
  if (null != d) {
    var b = this.model.getParent(d);
    var a = this.getCellGeometry(b);
    if (!(null == b || null == a || this.isCellCollapsed(b))) {
      d = this.getCellGeometry(d);
      if (null != d && !d.relative && (a.width < d.x + d.width || a.height < d.y + d.height)) {
        a = a.clone();
        /** @type {number} */
        a.width = Math.max(a.width, d.x + d.width);
        /** @type {number} */
        a.height = Math.max(a.height, d.y + d.height);
        this.cellsResized([b], [a], false);
      }
    }
  }
};
/**
 * @param {!Array} cells
 * @param {number} type
 * @param {number} s
 * @param {undefined} parent
 * @param {undefined} start
 * @param {undefined} data
 * @return {?}
 */
mxGraph.prototype.importCells = function(cells, type, s, parent, start, data) {
  return this.moveCells(cells, type, s, true, parent, start, data);
};
/**
 * @param {string} cells
 * @param {number} data
 * @param {number} e
 * @param {number} o
 * @param {number} parent
 * @param {string} target
 * @param {number} headers
 * @return {?}
 */
mxGraph.prototype.moveCells = function(cells, data, e, o, parent, target, headers) {
  data = null != data ? data : 0;
  e = null != e ? e : 0;
  o = null != o ? o : false;
  if (null != cells && (0 != data || 0 != e || o || null != parent)) {
    var existingSels = cells = this.model.getTopmostCells(cells);
    this.model.beginUpdate();
    try {
      var c = new mxDictionary;
      /** @type {number} */
      var i = 0;
      for (; i < cells.length; i++) {
        c.put(cells[i], true);
      }
      var isUndefined = mxUtils.bind(this, function(d) {
        for (; null != d;) {
          if (c.get(d)) {
            return true;
          }
          d = this.model.getParent(d);
        }
        return false;
      });
      /** @type {!Array} */
      var _ = [];
      /** @type {number} */
      i = 0;
      for (; i < cells.length; i++) {
        var geo = this.getCellGeometry(cells[i]);
        var cell = this.model.getParent(cells[i]);
        if (!(null != geo && geo.relative && this.model.isEdge(cell) && (isUndefined(this.model.getTerminal(cell, true)) || isUndefined(this.model.getTerminal(cell, false))))) {
          _.push(cells[i]);
        }
      }
      /** @type {!Array} */
      cells = _;
      if (o) {
        cells = this.cloneCells(cells, this.isCloneInvalidEdges(), headers);
        if (null == parent) {
          parent = this.getDefaultParent();
        }
      }
      var 1 = this.isAllowNegativeCoordinates();
      if (null != parent) {
        this.setAllowNegativeCoordinates(true);
      }
      this.cellsMoved(cells, data, e, !o && this.isDisconnectOnMove() && this.isAllowDanglingEdges(), null == parent, this.isExtendParentsOnMove() && null == parent);
      this.setAllowNegativeCoordinates(1);
      if (null != parent) {
        var parentContext = this.model.getChildCount(parent);
        this.cellsAdded(cells, parent, parentContext, null, null, true);
        if (o) {
          /** @type {number} */
          i = 0;
          for (; i < cells.length; i++) {
            geo = this.getCellGeometry(cells[i]);
            cell = this.model.getParent(existingSels[i]);
            if (null != geo && geo.relative && this.model.isEdge(cell) && this.model.contains(cell)) {
              this.model.add(cell, cells[i]);
            }
          }
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.MOVE_CELLS, "cells", cells, "dx", data, "dy", e, "clone", o, "target", parent, "event", target));
    } finally {
      this.model.endUpdate();
    }
  }
  return cells;
};
/**
 * @param {string} obj
 * @param {string} arg0
 * @param {number} arg1
 * @param {number} args
 * @param {boolean} replace
 * @param {string} data
 * @return {undefined}
 */
mxGraph.prototype.cellsMoved = function(obj, arg0, arg1, args, replace, data) {
  if (null != obj && (0 != arg0 || 0 != arg1)) {
    data = null != data ? data : false;
    this.model.beginUpdate();
    try {
      if (args) {
        this.disconnectGraph(obj);
      }
      /** @type {number} */
      var i = 0;
      for (; i < obj.length; i++) {
        this.translateCell(obj[i], arg0, arg1);
        if (data && this.isExtendParent(obj[i])) {
          this.extendParent(obj[i]);
        } else {
          if (replace) {
            this.constrainChild(obj[i]);
          }
        }
      }
      if (this.resetEdgesOnMove) {
        this.resetEdges(obj);
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_MOVED, "cells", obj, "dx", arg0, "dy", arg1, "disconnect", args));
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {undefined} cell
 * @param {number} width
 * @param {number} x
 * @return {undefined}
 */
mxGraph.prototype.translateCell = function(cell, width, x) {
  var data = this.model.getGeometry(cell);
  if (null != data) {
    /** @type {number} */
    width = parseFloat(width);
    /** @type {number} */
    x = parseFloat(x);
    data = data.clone();
    data.translate(width, x);
    if (!(data.relative || !this.model.isVertex(cell) || this.isAllowNegativeCoordinates())) {
      /** @type {number} */
      data.x = Math.max(0, parseFloat(data.x));
      /** @type {number} */
      data.y = Math.max(0, parseFloat(data.y));
    }
    if (data.relative && !this.model.isEdge(cell)) {
      var value = this.model.getParent(cell);
      /** @type {number} */
      var y = 0;
      if (this.model.isVertex(value)) {
        value = this.getCurrentCellStyle(value);
        y = mxUtils.getValue(value, mxConstants.STYLE_ROTATION, 0);
      }
      if (0 != y) {
        y = mxUtils.toRadians(-y);
        /** @type {number} */
        value = Math.cos(y);
        /** @type {number} */
        y = Math.sin(y);
        x = mxUtils.getRotatedPoint(new mxPoint(width, x), value, y, new mxPoint(0, 0));
        width = x.x;
        x = x.y;
      }
      if (null == data.offset) {
        data.offset = new mxPoint(Math.round(width), Math.round(x));
      } else {
        /** @type {number} */
        data.offset.x = Math.round(parseFloat(data.offset.x + width));
        /** @type {number} */
        data.offset.y = Math.round(parseFloat(data.offset.y + x));
      }
    }
    this.model.setGeometry(cell, data);
  }
};
/**
 * @param {string} id
 * @return {?}
 */
mxGraph.prototype.getCellContainmentArea = function(id) {
  if (null != id && !this.model.isEdge(id)) {
    var i = this.model.getParent(id);
    if (null != i && i != this.getDefaultParent()) {
      var size = this.model.getGeometry(i);
      if (null != size) {
        /** @type {number} */
        var el = id = 0;
        var width = size.width;
        size = size.height;
        if (this.isSwimlane(i)) {
          var r = this.getStartSize(i);
          var node = this.getCurrentCellStyle(i);
          i = mxUtils.getValue(node, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
          /** @type {boolean} */
          var isQuad = 1 == mxUtils.getValue(node, mxConstants.STYLE_FLIPH, 0);
          /** @type {boolean} */
          node = 1 == mxUtils.getValue(node, mxConstants.STYLE_FLIPV, 0);
          if (i == mxConstants.DIRECTION_SOUTH || i == mxConstants.DIRECTION_NORTH) {
            var n = r.width;
            r.width = r.height;
            r.height = n;
          }
          if (i == mxConstants.DIRECTION_EAST && !node || i == mxConstants.DIRECTION_NORTH && !isQuad || i == mxConstants.DIRECTION_WEST && node || i == mxConstants.DIRECTION_SOUTH && isQuad) {
            id = r.width;
            el = r.height;
          }
          /** @type {number} */
          width = width - r.width;
          /** @type {number} */
          size = size - r.height;
        }
        return new mxRectangle(id, el, width, size);
      }
    }
  }
  return null;
};
/**
 * @return {?}
 */
mxGraph.prototype.getMaximumGraphBounds = function() {
  return this.maximumGraphBounds;
};
/**
 * @param {!Object} path
 * @param {!Object} options
 * @return {undefined}
 */
mxGraph.prototype.constrainChild = function(path, options) {
  if (null != path && (options = this.getCellGeometry(path), null != options && (this.isConstrainRelativeChildren() || !options.relative))) {
    var a = this.model.getParent(path);
    this.getCellGeometry(a);
    var b = this.getMaximumGraphBounds();
    if (null != b) {
      a = this.getBoundingBoxFromGeometry([a], false);
      if (null != a) {
        b = mxRectangle.fromRectangle(b);
        b.x -= a.x;
        b.y -= a.y;
      }
    }
    if (this.isConstrainChild(path) && (a = this.getCellContainmentArea(path), null != a)) {
      var s = this.getOverlap(path);
      if (0 < s) {
        a = mxRectangle.fromRectangle(a);
        a.x -= a.width * s;
        a.y -= a.height * s;
        a.width += 2 * a.width * s;
        a.height += 2 * a.height * s;
      }
      if (null == b) {
        b = a;
      } else {
        b = mxRectangle.fromRectangle(b);
        b.intersect(a);
      }
    }
    if (null != b) {
      /** @type {!Array} */
      a = [path];
      if (!this.isCellCollapsed(path)) {
        s = this.model.getDescendants(path);
        /** @type {number} */
        var h = 0;
        for (; h < s.length; h++) {
          if (this.isCellVisible(s[h])) {
            a.push(s[h]);
          }
        }
      }
      a = this.getBoundingBoxFromGeometry(a, false);
      if (null != a) {
        options = options.clone();
        /** @type {number} */
        s = 0;
        if (options.width > b.width) {
          /** @type {number} */
          s = options.width - b.width;
          options.width -= s;
        }
        if (a.x + a.width > b.x + b.width) {
          /** @type {number} */
          s = s - (a.x + a.width - b.x - b.width - s);
        }
        /** @type {number} */
        h = 0;
        if (options.height > b.height) {
          /** @type {number} */
          h = options.height - b.height;
          options.height -= h;
        }
        if (a.y + a.height > b.y + b.height) {
          /** @type {number} */
          h = h - (a.y + a.height - b.y - b.height - h);
        }
        if (a.x < b.x) {
          /** @type {number} */
          s = s - (a.x - b.x);
        }
        if (a.y < b.y) {
          /** @type {number} */
          h = h - (a.y - b.y);
        }
        if (0 != s || 0 != h) {
          if (options.relative) {
            if (null == options.offset) {
              options.offset = new mxPoint;
            }
            options.offset.x += s;
            options.offset.y += h;
          } else {
            options.x += s;
            options.y += h;
          }
        }
        this.model.setGeometry(path, options);
      }
    }
  }
};
/**
 * @param {string} args
 * @return {undefined}
 */
mxGraph.prototype.resetEdges = function(args) {
  if (null != args) {
    var b = new mxDictionary;
    /** @type {number} */
    var i = 0;
    for (; i < args.length; i++) {
      b.put(args[i], true);
    }
    this.model.beginUpdate();
    try {
      /** @type {number} */
      i = 0;
      for (; i < args.length; i++) {
        var rels = this.model.getEdges(args[i]);
        if (null != rels) {
          /** @type {number} */
          var i = 0;
          for (; i < rels.length; i++) {
            var f = this.view.getState(rels[i]);
            var g = null != f ? f.getVisibleTerminal(true) : this.view.getVisibleTerminal(rels[i], true);
            var k = null != f ? f.getVisibleTerminal(false) : this.view.getVisibleTerminal(rels[i], false);
            if (!(b.get(g) && b.get(k))) {
              this.resetEdge(rels[i]);
            }
          }
        }
        this.resetEdges(this.model.getChildren(args[i]));
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {!Object} p
 * @return {?}
 */
mxGraph.prototype.resetEdge = function(p) {
  var y = this.model.getGeometry(p);
  if (null != y && null != y.points && 0 < y.points.length) {
    y = y.clone();
    /** @type {!Array} */
    y.points = [];
    this.model.setGeometry(p, y);
  }
  return p;
};
/**
 * @param {!Object} node
 * @param {!Object} state
 * @param {!Object} me
 * @return {?}
 */
mxGraph.prototype.getOutlineConstraint = function(node, state, me) {
  if (null != state.shape) {
    me = this.view.getPerimeterBounds(state);
    var align = state.style[mxConstants.STYLE_DIRECTION];
    if (align == mxConstants.DIRECTION_NORTH || align == mxConstants.DIRECTION_SOUTH) {
      me.x += me.width / 2 - me.height / 2;
      me.y += me.height / 2 - me.width / 2;
      var value = me.width;
      me.width = me.height;
      me.height = value;
    }
    var z = mxUtils.toRadians(state.shape.getShapeRotation());
    if (0 != z) {
      /** @type {number} */
      value = Math.cos(-z);
      /** @type {number} */
      z = Math.sin(-z);
      var ct = new mxPoint(me.getCenterX(), me.getCenterY());
      node = mxUtils.getRotatedPoint(node, value, z, ct);
    }
    /** @type {number} */
    ct = z = 1;
    /** @type {number} */
    var anchorHeight = 0;
    /** @type {number} */
    var height = 0;
    if (this.getModel().isVertex(state.cell)) {
      var field = state.style[mxConstants.STYLE_FLIPH];
      var frequency = state.style[mxConstants.STYLE_FLIPV];
      if (null != state.shape && null != state.shape.stencil) {
        field = 1 == mxUtils.getValue(state.style, "stencilFlipH", 0) || field;
        frequency = 1 == mxUtils.getValue(state.style, "stencilFlipV", 0) || frequency;
      }
      if (align == mxConstants.DIRECTION_NORTH || align == mxConstants.DIRECTION_SOUTH) {
        value = field;
        field = frequency;
        frequency = value;
      }
      if (field) {
        /** @type {number} */
        z = -1;
        /** @type {number} */
        anchorHeight = -me.width;
      }
      if (frequency) {
        /** @type {number} */
        ct = -1;
        /** @type {number} */
        height = -me.height;
      }
    }
    node = new mxPoint((node.x - me.x) * z - anchorHeight + me.x, (node.y - me.y) * ct - height + me.y);
    return new mxConnectionConstraint(new mxPoint(0 == me.width ? 0 : Math.round(1E3 * (node.x - me.x) / me.width) / 1E3, 0 == me.height ? 0 : Math.round(1E3 * (node.y - me.y) / me.height) / 1E3), false);
  }
  return null;
};
/**
 * @param {!Object} source
 * @param {number} b
 * @return {?}
 */
mxGraph.prototype.getAllConnectionConstraints = function(source, b) {
  return null != source && null != source.shape && null != source.shape.stencil ? source.shape.stencil.constraints : null;
};
/**
 * @param {!Object} s
 * @param {!Object} index
 * @param {boolean} v
 * @return {?}
 */
mxGraph.prototype.getConnectionConstraint = function(s, index, v) {
  /** @type {null} */
  index = null;
  var fltScore = s.style[v ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X];
  if (null != fltScore) {
    var size = s.style[v ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y];
    if (null != size) {
      index = new mxPoint(parseFloat(fltScore), parseFloat(size));
    }
  }
  /** @type {boolean} */
  fltScore = false;
  /** @type {number} */
  var ret = size = 0;
  if (null != index) {
    fltScore = mxUtils.getValue(s.style, v ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, true);
    /** @type {number} */
    size = parseFloat(s.style[v ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX]);
    /** @type {number} */
    ret = parseFloat(s.style[v ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY]);
    /** @type {number} */
    size = isFinite(size) ? size : 0;
    /** @type {number} */
    ret = isFinite(ret) ? ret : 0;
  }
  return new mxConnectionConstraint(index, fltScore, null, size, ret);
};
/**
 * @param {string} edge
 * @param {string} t
 * @param {string} c
 * @param {!Object} d
 * @return {undefined}
 */
mxGraph.prototype.setConnectionConstraint = function(edge, t, c, d) {
  if (null != d) {
    this.model.beginUpdate();
    try {
      if (null == d || null == d.point) {
        this.setCellStyles(c ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X, null, [edge]);
        this.setCellStyles(c ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y, null, [edge]);
        this.setCellStyles(c ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX, null, [edge]);
        this.setCellStyles(c ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY, null, [edge]);
        this.setCellStyles(c ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, null, [edge]);
      } else {
        if (null != d.point) {
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X, d.point.x, [edge]);
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y, d.point.y, [edge]);
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX, d.dx, [edge]);
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY, d.dy, [edge]);
          if (d.perimeter) {
            this.setCellStyles(c ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, null, [edge]);
          } else {
            this.setCellStyles(c ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, "0", [edge]);
          }
        }
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {!Object} e
 * @param {!Object} c
 * @param {?} data
 * @return {?}
 */
mxGraph.prototype.getConnectionPoint = function(e, c, data) {
  data = null != data ? data : true;
  /** @type {null} */
  var value = null;
  if (null != e && null != c.point) {
    var s = this.view.getPerimeterBounds(e);
    var ct = new mxPoint(s.getCenterX(), s.getCenterY());
    var k = e.style[mxConstants.STYLE_DIRECTION];
    /** @type {number} */
    var start = 0;
    if (null != k && 1 == mxUtils.getValue(e.style, mxConstants.STYLE_ANCHOR_POINT_DIRECTION, 1)) {
      if (k == mxConstants.DIRECTION_NORTH) {
        /** @type {number} */
        start = start + 270;
      } else {
        if (k == mxConstants.DIRECTION_WEST) {
          /** @type {number} */
          start = start + 180;
        } else {
          if (k == mxConstants.DIRECTION_SOUTH) {
            /** @type {number} */
            start = start + 90;
          }
        }
      }
      if (!(k != mxConstants.DIRECTION_NORTH && k != mxConstants.DIRECTION_SOUTH)) {
        s.rotate90();
      }
    }
    value = this.view.scale;
    value = new mxPoint(s.x + c.point.x * s.width + c.dx * value, s.y + c.point.y * s.height + c.dy * value);
    var end = e.style[mxConstants.STYLE_ROTATION] || 0;
    if (c.perimeter) {
      if (0 != start) {
        /** @type {number} */
        k = s = 0;
        if (90 == start) {
          /** @type {number} */
          k = 1;
        } else {
          if (180 == start) {
            /** @type {number} */
            s = -1;
          } else {
            if (270 == start) {
              /** @type {number} */
              k = -1;
            }
          }
        }
        value = mxUtils.getRotatedPoint(value, s, k, ct);
      }
      value = this.view.getPerimeterPoint(e, value, false);
    } else {
      if (end = end + start, this.getModel().isVertex(e.cell)) {
        /** @type {boolean} */
        start = 1 == e.style[mxConstants.STYLE_FLIPH];
        /** @type {boolean} */
        c = 1 == e.style[mxConstants.STYLE_FLIPV];
        if (null != e.shape && null != e.shape.stencil) {
          /** @type {boolean} */
          start = 1 == mxUtils.getValue(e.style, "stencilFlipH", 0) || start;
          /** @type {boolean} */
          c = 1 == mxUtils.getValue(e.style, "stencilFlipV", 0) || c;
        }
        if (k == mxConstants.DIRECTION_NORTH || k == mxConstants.DIRECTION_SOUTH) {
          /** @type {boolean} */
          e = start;
          /** @type {!Object} */
          start = c;
          /** @type {!Object} */
          c = e;
        }
        if (start) {
          /** @type {number} */
          value.x = 2 * s.getCenterX() - value.x;
        }
        if (c) {
          /** @type {number} */
          value.y = 2 * s.getCenterY() - value.y;
        }
      }
    }
    if (0 != end && null != value) {
      e = mxUtils.toRadians(end);
      /** @type {number} */
      s = Math.cos(e);
      /** @type {number} */
      k = Math.sin(e);
      value = mxUtils.getRotatedPoint(value, s, k, ct);
    }
  }
  if (data && null != value) {
    /** @type {number} */
    value.x = Math.round(value.x);
    /** @type {number} */
    value.y = Math.round(value.y);
  }
  return value;
};
/**
 * @param {string} val
 * @param {string} init
 * @param {string} start
 * @param {string} data
 * @return {?}
 */
mxGraph.prototype.connectCell = function(val, init, start, data) {
  this.model.beginUpdate();
  try {
    var blockIndex = this.model.getTerminal(val, start);
    this.cellConnected(val, init, start, data);
    this.fireEvent(new mxEventObject(mxEvent.CONNECT_CELL, "edge", val, "terminal", init, "source", start, "previous", blockIndex));
  } finally {
    this.model.endUpdate();
  }
  return val;
};
/**
 * @param {string} d
 * @param {string} node
 * @param {string} name
 * @param {string} value
 * @return {undefined}
 */
mxGraph.prototype.cellConnected = function(d, node, name, value) {
  if (null != d) {
    this.model.beginUpdate();
    try {
      var feature = this.model.getTerminal(d, name);
      this.setConnectionConstraint(d, node, name, value);
      if (this.isPortsEnabled()) {
        /** @type {null} */
        value = null;
        if (this.isPort(node)) {
          value = node.getId();
          node = this.getTerminalForPort(node, name);
        }
        this.setCellStyles(name ? mxConstants.STYLE_SOURCE_PORT : mxConstants.STYLE_TARGET_PORT, value, [d]);
      }
      this.model.setTerminal(d, node, name);
      if (this.resetEdgesOnConnect) {
        this.resetEdge(d);
      }
      this.fireEvent(new mxEventObject(mxEvent.CELL_CONNECTED, "edge", d, "terminal", node, "source", name, "previous", feature));
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {string} nodes
 * @return {undefined}
 */
mxGraph.prototype.disconnectGraph = function(nodes) {
  if (null != nodes) {
    this.model.beginUpdate();
    try {
      var scale = this.view.scale;
      var t = this.view.translate;
      var Dom = new mxDictionary;
      /** @type {number} */
      var i = 0;
      for (; i < nodes.length; i++) {
        Dom.put(nodes[i], true);
      }
      /** @type {number} */
      i = 0;
      for (; i < nodes.length; i++) {
        if (this.model.isEdge(nodes[i])) {
          var y = this.model.getGeometry(nodes[i]);
          if (null != y) {
            var r_chunk = this.view.getState(nodes[i]);
            var m = this.view.getState(this.model.getParent(nodes[i]));
            if (null != r_chunk && null != m) {
              y = y.clone();
              /** @type {number} */
              var sz = -m.origin.x;
              /** @type {number} */
              var th = -m.origin.y;
              var vertices = r_chunk.absolutePoints;
              var d = this.model.getTerminal(nodes[i], true);
              if (null != d && this.isCellDisconnectable(nodes[i], d, true)) {
                for (; null != d && !Dom.get(d);) {
                  d = this.model.getParent(d);
                }
                if (null == d) {
                  y.setTerminalPoint(new mxPoint(vertices[0].x / scale - t.x + sz, vertices[0].y / scale - t.y + th), true);
                  this.model.setTerminal(nodes[i], null, true);
                }
              }
              var name = this.model.getTerminal(nodes[i], false);
              if (null != name && this.isCellDisconnectable(nodes[i], name, false)) {
                for (; null != name && !Dom.get(name);) {
                  name = this.model.getParent(name);
                }
                if (null == name) {
                  /** @type {number} */
                  var minVertexIndex = vertices.length - 1;
                  y.setTerminalPoint(new mxPoint(vertices[minVertexIndex].x / scale - t.x + sz, vertices[minVertexIndex].y / scale - t.y + th), false);
                  this.model.setTerminal(nodes[i], null, false);
                }
              }
              this.model.setGeometry(nodes[i], y);
            }
          }
        }
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @return {?}
 */
mxGraph.prototype.getCurrentRoot = function() {
  return this.view.currentRoot;
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.getTranslateForRoot = function(a) {
  return null;
};
/**
 * @param {string} x
 * @return {?}
 */
mxGraph.prototype.isPort = function(x) {
  return false;
};
/**
 * @param {!Object} selector
 * @param {string} options
 * @return {?}
 */
mxGraph.prototype.getTerminalForPort = function(selector, options) {
  return this.model.getParent(selector);
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.getChildOffsetForCell = function(a) {
  return null;
};
/**
 * @param {!Object} event
 * @return {undefined}
 */
mxGraph.prototype.enterGroup = function(event) {
  event = event || this.getSelectionCell();
  if (null != event && this.isValidRoot(event)) {
    this.view.setCurrentRoot(event);
    this.clearSelection();
  }
};
/**
 * @return {undefined}
 */
mxGraph.prototype.exitGroup = function() {
  var undefined = this.model.getRoot();
  var type = this.getCurrentRoot();
  if (null != type) {
    var key = this.model.getParent(type);
    for (; key != undefined && !this.isValidRoot(key) && this.model.getParent(key) != undefined;) {
      key = this.model.getParent(key);
    }
    if (key == undefined || this.model.getParent(key) == undefined) {
      this.view.setCurrentRoot(null);
    } else {
      this.view.setCurrentRoot(key);
    }
    if (null != this.view.getState(type)) {
      this.setSelectionCell(type);
    }
  }
};
/**
 * @return {undefined}
 */
mxGraph.prototype.home = function() {
  var index = this.getCurrentRoot();
  if (null != index) {
    this.view.setCurrentRoot(null);
    if (null != this.view.getState(index)) {
      this.setSelectionCell(index);
    }
  }
};
/**
 * @param {!Object} jsonObj
 * @return {?}
 */
mxGraph.prototype.isValidRoot = function(jsonObj) {
  return null != jsonObj;
};
/**
 * @return {?}
 */
mxGraph.prototype.getGraphBounds = function() {
  return this.view.getGraphBounds();
};
/**
 * @param {undefined} cell
 * @param {?} col
 * @param {number} rowSpan
 * @return {?}
 */
mxGraph.prototype.getCellBounds = function(cell, col, rowSpan) {
  /** @type {!Array} */
  var current = [cell];
  if (col) {
    /** @type {!Array<?>} */
    current = current.concat(this.model.getEdges(cell));
  }
  current = this.view.getBounds(current);
  if (rowSpan) {
    rowSpan = this.model.getChildCount(cell);
    /** @type {number} */
    var i = 0;
    for (; i < rowSpan; i++) {
      var p = this.getCellBounds(this.model.getChildAt(cell, i), col, true);
      if (null != current) {
        current.add(p);
      } else {
        current = p;
      }
    }
  }
  return current;
};
/**
 * @param {!Object} node
 * @param {string} min
 * @return {?}
 */
mxGraph.prototype.getBoundingBoxFromGeometry = function(node, min) {
  min = null != min ? min : false;
  /** @type {null} */
  var $p = null;
  if (null != node) {
    /** @type {number} */
    var i = 0;
    for (; i < node.length; i++) {
      if (min || this.model.isVertex(node[i])) {
        var data = this.getCellGeometry(node[i]);
        if (null != data) {
          /** @type {null} */
          var p = null;
          if (this.model.isEdge(node[i])) {
            /**
             * @param {!Object} step
             * @return {undefined}
             */
            p = function(step) {
              if (null != step) {
                if (null == c) {
                  c = new mxRectangle(step.x, step.y, 0, 0);
                } else {
                  c.add(new mxRectangle(step.x, step.y, 0, 0));
                }
              }
            };
            if (null == this.model.getTerminal(node[i], true)) {
              p(data.getTerminalPoint(true));
            }
            if (null == this.model.getTerminal(node[i], false)) {
              p(data.getTerminalPoint(false));
            }
            data = data.points;
            if (null != data && 0 < data.length) {
              var c = new mxRectangle(data[0].x, data[0].y, 0, 0);
              /** @type {number} */
              var value = 1;
              for (; value < data.length; value++) {
                p(data[value]);
              }
            }
            p = c;
          } else {
            value = this.model.getParent(node[i]);
            if (data.relative) {
              if (this.model.isVertex(value) && value != this.view.currentRoot) {
                c = this.getBoundingBoxFromGeometry([value], false);
                if (null != c) {
                  p = new mxRectangle(data.x * c.width, data.y * c.height, data.width, data.height);
                  if (0 <= mxUtils.indexOf(node, value)) {
                    p.x += c.x;
                    p.y += c.y;
                  }
                }
              }
            } else {
              p = mxRectangle.fromRectangle(data);
              if (this.model.isVertex(value) && 0 <= mxUtils.indexOf(node, value)) {
                c = this.getBoundingBoxFromGeometry([value], false);
                if (null != c) {
                  p.x += c.x;
                  p.y += c.y;
                }
              }
            }
            if (null != p && null != data.offset) {
              p.x += data.offset.x;
              p.y += data.offset.y;
            }
            data = this.getCurrentCellStyle(node[i]);
            if (null != p) {
              data = mxUtils.getValue(data, mxConstants.STYLE_ROTATION, 0);
              if (0 != data) {
                p = mxUtils.getBoundingBox(p, data);
              }
            }
          }
          if (null != p) {
            if (null == $p) {
              $p = mxRectangle.fromRectangle(p);
            } else {
              $p.add(p);
            }
          }
        }
      }
    }
  }
  return $p;
};
/**
 * @param {string} a
 * @return {undefined}
 */
mxGraph.prototype.refresh = function(a) {
  this.view.clear(a, null == a);
  this.view.validate();
  this.sizeDidChange();
  this.fireEvent(new mxEventObject(mxEvent.REFRESH));
};
/**
 * @param {number} value
 * @return {?}
 */
mxGraph.prototype.snap = function(value) {
  if (this.gridEnabled) {
    /** @type {number} */
    value = Math.round(value / this.gridSize) * this.gridSize;
  }
  return value;
};
/**
 * @param {!Object} pos
 * @param {number} offset
 * @param {number} zoom
 * @param {number} a
 * @param {boolean} be
 * @return {?}
 */
mxGraph.prototype.snapDelta = function(pos, offset, zoom, a, be) {
  var t = this.view.translate;
  var scale = this.view.scale;
  if (!zoom && this.gridEnabled) {
    /** @type {number} */
    zoom = this.gridSize * scale * .5;
    if (!a) {
      /** @type {number} */
      a = offset.x - (this.snap(offset.x / scale - t.x) + t.x) * scale;
      /** @type {number} */
      pos.x = Math.abs(pos.x - a) < zoom ? 0 : this.snap(pos.x / scale) * scale - a;
    }
    if (!be) {
      /** @type {number} */
      offset = offset.y - (this.snap(offset.y / scale - t.y) + t.y) * scale;
      /** @type {number} */
      pos.y = Math.abs(pos.y - offset) < zoom ? 0 : this.snap(pos.y / scale) * scale - offset;
    }
  } else {
    /** @type {number} */
    zoom = .5 * scale;
    if (!a) {
      /** @type {number} */
      a = offset.x - (Math.round(offset.x / scale - t.x) + t.x) * scale;
      /** @type {number} */
      pos.x = Math.abs(pos.x - a) < zoom ? 0 : Math.round(pos.x / scale) * scale - a;
    }
    if (!be) {
      /** @type {number} */
      offset = offset.y - (Math.round(offset.y / scale - t.y) + t.y) * scale;
      /** @type {number} */
      pos.y = Math.abs(pos.y - offset) < zoom ? 0 : Math.round(pos.y / scale) * scale - offset;
    }
  }
  return pos;
};
/**
 * @param {number} dx
 * @param {number} dy
 * @return {undefined}
 */
mxGraph.prototype.panGraph = function(dx, dy) {
  if (this.useScrollbarsForPanning && mxUtils.hasScrollbars(this.container)) {
    /** @type {number} */
    this.container.scrollLeft = -dx;
    /** @type {number} */
    this.container.scrollTop = -dy;
  } else {
    var e = this.view.getCanvas();
    if (this.dialect == mxConstants.DIALECT_SVG) {
      if (0 == dx && 0 == dy) {
        if (mxClient.IS_IE ? e.setAttribute("transform", "translate(" + dx + "," + dy + ")") : e.removeAttribute("transform"), null != this.shiftPreview1) {
          var table = this.shiftPreview1.firstChild;
          for (; null != table;) {
            var row = table.nextSibling;
            this.container.appendChild(table);
            table = row;
          }
          if (null != this.shiftPreview1.parentNode) {
            this.shiftPreview1.parentNode.removeChild(this.shiftPreview1);
          }
          /** @type {null} */
          this.shiftPreview1 = null;
          this.container.appendChild(e.parentNode);
          table = this.shiftPreview2.firstChild;
          for (; null != table;) {
            row = table.nextSibling;
            this.container.appendChild(table);
            table = row;
          }
          if (null != this.shiftPreview2.parentNode) {
            this.shiftPreview2.parentNode.removeChild(this.shiftPreview2);
          }
          /** @type {null} */
          this.shiftPreview2 = null;
        }
      } else {
        e.setAttribute("transform", "translate(" + dx + "," + dy + ")");
        if (null == this.shiftPreview1) {
          /** @type {!Element} */
          this.shiftPreview1 = document.createElement("div");
          /** @type {string} */
          this.shiftPreview1.style.position = "absolute";
          /** @type {string} */
          this.shiftPreview1.style.overflow = "visible";
          /** @type {!Element} */
          this.shiftPreview2 = document.createElement("div");
          /** @type {string} */
          this.shiftPreview2.style.position = "absolute";
          /** @type {string} */
          this.shiftPreview2.style.overflow = "visible";
          /** @type {!Element} */
          var tableHolder = this.shiftPreview1;
          table = this.container.firstChild;
          for (; null != table;) {
            row = table.nextSibling;
            if (table != e.parentNode) {
              tableHolder.appendChild(table);
            } else {
              /** @type {!Element} */
              tableHolder = this.shiftPreview2;
            }
            table = row;
          }
          if (null != this.shiftPreview1.firstChild) {
            this.container.insertBefore(this.shiftPreview1, e.parentNode);
          }
          if (null != this.shiftPreview2.firstChild) {
            this.container.appendChild(this.shiftPreview2);
          }
        }
        /** @type {string} */
        this.shiftPreview1.style.left = dx + "px";
        /** @type {string} */
        this.shiftPreview1.style.top = dy + "px";
        /** @type {string} */
        this.shiftPreview2.style.left = dx + "px";
        /** @type {string} */
        this.shiftPreview2.style.top = dy + "px";
      }
    } else {
      /** @type {string} */
      e.style.left = dx + "px";
      /** @type {string} */
      e.style.top = dy + "px";
    }
    /** @type {number} */
    this.panDx = dx;
    /** @type {number} */
    this.panDy = dy;
    this.fireEvent(new mxEventObject(mxEvent.PAN));
  }
};
/**
 * @return {undefined}
 */
mxGraph.prototype.zoomIn = function() {
  this.zoom(this.zoomFactor);
};
/**
 * @return {undefined}
 */
mxGraph.prototype.zoomOut = function() {
  this.zoom(1 / this.zoomFactor);
};
/**
 * @return {undefined}
 */
mxGraph.prototype.zoomActual = function() {
  if (1 == this.view.scale) {
    this.view.setTranslate(0, 0);
  } else {
    /** @type {number} */
    this.view.translate.x = 0;
    /** @type {number} */
    this.view.translate.y = 0;
    this.view.setScale(1);
  }
};
/**
 * @param {number} zoom
 * @param {undefined} x
 * @return {undefined}
 */
mxGraph.prototype.zoomTo = function(zoom, x) {
  this.zoom(zoom / this.view.scale, x);
};
/**
 * @param {!Object} x
 * @param {number} y
 * @param {number} s
 * @param {number} e
 * @return {undefined}
 */
mxGraph.prototype.center = function(x, y, s, e) {
  x = null != x ? x : true;
  y = null != y ? y : true;
  s = null != s ? s : .5;
  e = null != e ? e : .5;
  var layoutFunc = mxUtils.hasScrollbars(this.container);
  /** @type {number} */
  var height = 2 * this.getBorder();
  /** @type {number} */
  var width = this.container.clientWidth - height;
  /** @type {number} */
  height = this.container.clientHeight - height;
  var o = this.getGraphBounds();
  var options = this.view.translate;
  var scale = this.view.scale;
  /** @type {number} */
  var w = x ? width - o.width : 0;
  /** @type {number} */
  var h = y ? height - o.height : 0;
  if (layoutFunc) {
    o.x -= options.x;
    o.y -= options.y;
    x = this.container.scrollWidth;
    y = this.container.scrollHeight;
    if (x > width) {
      /** @type {number} */
      w = 0;
    }
    if (y > height) {
      /** @type {number} */
      h = 0;
    }
    this.view.setTranslate(Math.floor(w / 2 - o.x), Math.floor(h / 2 - o.y));
    /** @type {number} */
    this.container.scrollLeft = (x - width) / 2;
    /** @type {number} */
    this.container.scrollTop = (y - height) / 2;
  } else {
    this.view.setTranslate(x ? Math.floor(options.x - o.x / scale + w * s / scale) : options.x, y ? Math.floor(options.y - o.y / scale + h * e / scale) : options.y);
  }
};
/**
 * @param {number} y
 * @param {number} e
 * @param {number} size
 * @return {undefined}
 */
mxGraph.prototype.zoom = function(y, e, size) {
  e = null != e ? e : this.centerZoom;
  /** @type {number} */
  var x = Math.round(this.view.scale * y * 100) / 100;
  if (null != size) {
    /** @type {number} */
    x = Math.round(x * size) / size;
  }
  size = this.view.getState(this.getSelectionCell());
  /** @type {number} */
  y = x / this.view.scale;
  if (this.keepSelectionVisibleOnZoom && null != size) {
    y = new mxRectangle(size.x * y, size.y * y, size.width * y, size.height * y);
    /** @type {number} */
    this.view.scale = x;
    if (!this.scrollRectToVisible(y)) {
      this.view.revalidate();
      this.view.setScale(x);
    }
  } else {
    if (size = mxUtils.hasScrollbars(this.container), e && !size) {
      size = this.container.offsetWidth;
      var h = this.container.offsetHeight;
      if (1 < y) {
        /** @type {number} */
        y = (y - 1) / (2 * x);
        /** @type {number} */
        size = size * -y;
        /** @type {number} */
        h = h * -y;
      } else {
        /** @type {number} */
        y = (1 / y - 1) / (2 * this.view.scale);
        /** @type {number} */
        size = size * y;
        /** @type {number} */
        h = h * y;
      }
      this.view.scaleAndTranslate(x, this.view.translate.x + size, this.view.translate.y + h);
    } else {
      var dx = this.view.translate.x;
      var dy = this.view.translate.y;
      var tx = this.container.scrollLeft;
      var w = this.container.scrollTop;
      this.view.setScale(x);
      if (size) {
        /** @type {number} */
        h = size = 0;
        if (e) {
          /** @type {number} */
          size = this.container.offsetWidth * (y - 1) / 2;
          /** @type {number} */
          h = this.container.offsetHeight * (y - 1) / 2;
        }
        /** @type {number} */
        this.container.scrollLeft = (this.view.translate.x - dx) * this.view.scale + Math.round(tx * y + size);
        /** @type {number} */
        this.container.scrollTop = (this.view.translate.y - dy) * this.view.scale + Math.round(w * y + h);
      }
    }
  }
};
/**
 * @param {!Object} options
 * @return {undefined}
 */
mxGraph.prototype.zoomToRect = function(options) {
  /** @type {number} */
  var y = this.container.clientWidth / options.width / (this.container.clientHeight / options.height);
  /** @type {number} */
  options.x = Math.max(0, options.x);
  /** @type {number} */
  options.y = Math.max(0, options.y);
  /** @type {number} */
  var w = Math.min(this.container.scrollWidth, options.x + options.width);
  /** @type {number} */
  var top = Math.min(this.container.scrollHeight, options.y + options.height);
  /** @type {number} */
  options.width = w - options.x;
  /** @type {number} */
  options.height = top - options.y;
  if (1 > y) {
    /** @type {number} */
    y = options.height / y;
    /** @type {number} */
    w = (y - options.height) / 2;
    /** @type {number} */
    options.height = y;
    options.y -= Math.min(options.y, w);
    /** @type {number} */
    top = Math.min(this.container.scrollHeight, options.y + options.height);
    /** @type {number} */
    options.height = top - options.y;
  } else {
    /** @type {number} */
    y = y * options.width;
    /** @type {number} */
    w = (y - options.width) / 2;
    /** @type {number} */
    options.width = y;
    options.x -= Math.min(options.x, w);
    /** @type {number} */
    w = Math.min(this.container.scrollWidth, options.x + options.width);
    /** @type {number} */
    options.width = w - options.x;
  }
  /** @type {number} */
  y = this.container.clientWidth / options.width;
  /** @type {number} */
  w = this.view.scale * y;
  if (mxUtils.hasScrollbars(this.container)) {
    this.view.setScale(w);
    /** @type {number} */
    this.container.scrollLeft = Math.round(options.x * y);
    /** @type {number} */
    this.container.scrollTop = Math.round(options.y * y);
  } else {
    this.view.scaleAndTranslate(w, this.view.translate.x - options.x / this.view.scale, this.view.translate.y - options.y / this.view.scale);
  }
};
/**
 * @param {!Object} element
 * @param {number} value
 * @return {undefined}
 */
mxGraph.prototype.scrollCellToVisible = function(element, value) {
  /** @type {number} */
  var s = -this.view.translate.x;
  /** @type {number} */
  var y = -this.view.translate.y;
  element = this.view.getState(element);
  if (null != element) {
    s = new mxRectangle(s + element.x, y + element.y, element.width, element.height);
    if (value && null != this.container) {
      value = this.container.clientWidth;
      y = this.container.clientHeight;
      /** @type {number} */
      s.x = s.getCenterX() - value / 2;
      /** @type {number} */
      s.width = value;
      /** @type {number} */
      s.y = s.getCenterY() - y / 2;
      s.height = y;
    }
    value = new mxPoint(this.view.translate.x, this.view.translate.y);
    if (this.scrollRectToVisible(s)) {
      s = new mxPoint(this.view.translate.x, this.view.translate.y);
      this.view.translate.x = value.x;
      this.view.translate.y = value.y;
      this.view.setTranslate(s.x, s.y);
    }
  }
};
/**
 * @param {number} pos
 * @return {?}
 */
mxGraph.prototype.scrollRectToVisible = function(pos) {
  /** @type {boolean} */
  var b = false;
  if (null != pos) {
    var w = this.container.offsetWidth;
    var y = this.container.offsetHeight;
    /** @type {number} */
    var value = Math.min(w, pos.width);
    /** @type {number} */
    var h = Math.min(y, pos.height);
    if (mxUtils.hasScrollbars(this.container)) {
      w = this.container;
      pos.x += this.view.translate.x;
      pos.y += this.view.translate.y;
      /** @type {number} */
      var x = w.scrollLeft - pos.x;
      /** @type {number} */
      y = Math.max(x - w.scrollLeft, 0);
      if (0 < x) {
        w.scrollLeft -= x + 2;
      } else {
        /** @type {number} */
        x = pos.x + value - w.scrollLeft - w.clientWidth;
        if (0 < x) {
          w.scrollLeft += x + 2;
        }
      }
      /** @type {number} */
      value = w.scrollTop - pos.y;
      /** @type {number} */
      x = Math.max(0, value - w.scrollTop);
      if (0 < value) {
        w.scrollTop -= value + 2;
      } else {
        /** @type {number} */
        value = pos.y + h - w.scrollTop - w.clientHeight;
        if (0 < value) {
          w.scrollTop += value + 2;
        }
      }
      if (!(this.useScrollbarsForPanning || 0 == y && 0 == x)) {
        this.view.setTranslate(y, x);
      }
    } else {
      /** @type {number} */
      x = -this.view.translate.x;
      /** @type {number} */
      var height = -this.view.translate.y;
      var factor = this.view.scale;
      if (pos.x + value > x + w) {
        this.view.translate.x -= (pos.x + value - w - x) / factor;
        /** @type {boolean} */
        b = true;
      }
      if (pos.y + h > height + y) {
        this.view.translate.y -= (pos.y + h - y - height) / factor;
        /** @type {boolean} */
        b = true;
      }
      if (pos.x < x) {
        this.view.translate.x += (x - pos.x) / factor;
        /** @type {boolean} */
        b = true;
      }
      if (pos.y < height) {
        this.view.translate.y += (height - pos.y) / factor;
        /** @type {boolean} */
        b = true;
      }
      if (b) {
        this.view.refresh();
        if (null != this.selectionCellsHandler) {
          this.selectionCellsHandler.refresh();
        }
      }
    }
  }
  return b;
};
/**
 * @param {!Object} element
 * @return {?}
 */
mxGraph.prototype.getCellGeometry = function(element) {
  return this.model.getGeometry(element);
};
/**
 * @param {!Object} el
 * @return {?}
 */
mxGraph.prototype.isCellVisible = function(el) {
  return this.model.isVisible(el);
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxGraph.prototype.isCellCollapsed = function(node) {
  return this.model.isCollapsed(node);
};
/**
 * @param {number} obj
 * @return {?}
 */
mxGraph.prototype.isCellConnectable = function(obj) {
  return this.model.isConnectable(obj);
};
/**
 * @param {!Object} i
 * @return {?}
 */
mxGraph.prototype.isOrthogonal = function(i) {
  var b = i.style[mxConstants.STYLE_ORTHOGONAL];
  if (null != b) {
    return b;
  }
  i = this.view.getEdgeStyle(i);
  return i == mxEdgeStyle.SegmentConnector || i == mxEdgeStyle.ElbowConnector || i == mxEdgeStyle.SideToSide || i == mxEdgeStyle.TopToBottom || i == mxEdgeStyle.EntityRelation || i == mxEdgeStyle.OrthConnector;
};
/**
 * @param {?} position
 * @return {?}
 */
mxGraph.prototype.isLoop = function(position) {
  var lastIndex = position.getVisibleTerminalState(true);
  position = position.getVisibleTerminalState(false);
  return null != lastIndex && lastIndex == position;
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxGraph.prototype.isCloneEvent = function(evt) {
  return mxEvent.isControlDown(evt);
};
/**
 * @param {?} p
 * @return {?}
 */
mxGraph.prototype.isTransparentClickEvent = function(p) {
  return false;
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxGraph.prototype.isToggleEvent = function(e) {
  return mxClient.IS_MAC ? mxEvent.isMetaDown(e) : mxEvent.isControlDown(e);
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxGraph.prototype.isGridEnabledEvent = function(evt) {
  return null != evt && !mxEvent.isAltDown(evt);
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxGraph.prototype.isConstrainedEvent = function(e) {
  return mxEvent.isShiftDown(e);
};
/**
 * @param {number} blurElems
 * @return {?}
 */
mxGraph.prototype.isIgnoreTerminalEvent = function(blurElems) {
  return false;
};
/**
 * @param {?} result
 * @return {undefined}
 */
mxGraph.prototype.validationAlert = function(result) {
  mxUtils.alert(result);
};
/**
 * @param {string} result
 * @param {!Object} code
 * @param {!Object} desc
 * @return {?}
 */
mxGraph.prototype.isEdgeValid = function(result, code, desc) {
  return null == this.getEdgeValidationError(result, code, desc);
};
/**
 * @param {string} value
 * @param {!Object} target
 * @param {!Object} item
 * @return {?}
 */
mxGraph.prototype.getEdgeValidationError = function(value, target, item) {
  if (null != value && !this.isAllowDanglingEdges() && (null == target || null == item)) {
    return "";
  }
  if (null != value && null == this.model.getTerminal(value, true) && null == this.model.getTerminal(value, false)) {
    return null;
  }
  if (!this.allowLoops && target == item && null != target || !this.isValidConnection(target, item)) {
    return "";
  }
  if (null != target && null != item) {
    /** @type {string} */
    var message = "";
    if (!this.multigraph) {
      var obj = this.model.getEdgesBetween(target, item, true);
      if (1 < obj.length || 1 == obj.length && obj[0] != value) {
        /** @type {string} */
        message = message + ((mxResources.get(this.alreadyConnectedResource) || this.alreadyConnectedResource) + "\n");
      }
    }
    obj = this.model.getDirectedEdgeCount(target, true, value);
    var left = this.model.getDirectedEdgeCount(item, false, value);
    if (null != this.multiplicities) {
      /** @type {number} */
      var i = 0;
      for (; i < this.multiplicities.length; i++) {
        var index = this.multiplicities[i].check(this, value, target, item, obj, left);
        if (null != index) {
          /** @type {string} */
          message = message + index;
        }
      }
    }
    index = this.validateEdge(value, target, item);
    if (null != index) {
      /** @type {string} */
      message = message + index;
    }
    return 0 < message.length ? message : null;
  }
  return this.allowDanglingEdges ? null : "";
};
/**
 * @param {string} data
 * @param {!Object} label
 * @param {!Object} id
 * @return {?}
 */
mxGraph.prototype.validateEdge = function(data, label, id) {
  return null;
};
/**
 * @param {(Object|string)} i
 * @param {number} j
 * @return {?}
 */
mxGraph.prototype.validateGraph = function(i, j) {
  i = null != i ? i : this.model.getRoot();
  j = null != j ? j : {};
  /** @type {boolean} */
  var key = true;
  var s = this.model.getChildCount(i);
  /** @type {number} */
  var r = 0;
  for (; r < s; r++) {
    var f = this.model.getChildAt(i, r);
    /** @type {number} */
    var h = j;
    if (this.isValidRoot(f)) {
      h = {};
    }
    h = this.validateGraph(f, h);
    if (null != h) {
      this.setCellWarning(f, h.replace(/\n/g, "<br>"));
    } else {
      this.setCellWarning(f, null);
    }
    /** @type {boolean} */
    key = key && null == h;
  }
  /** @type {string} */
  s = "";
  if (this.isCellCollapsed(i) && !key) {
    /** @type {string} */
    s = s + ((mxResources.get(this.containsValidationErrorsResource) || this.containsValidationErrorsResource) + "\n");
  }
  s = this.model.isEdge(i) ? s + (this.getEdgeValidationError(i, this.model.getTerminal(i, true), this.model.getTerminal(i, false)) || "") : s + (this.getCellValidationError(i) || "");
  j = this.validateCell(i, j);
  if (null != j) {
    s = s + j;
  }
  if (null == this.model.getParent(i)) {
    this.view.validate();
  }
  return 0 < s.length || !key ? s : null;
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxGraph.prototype.getCellValidationError = function(node) {
  var row = this.model.getDirectedEdgeCount(node, true);
  var newWidth = this.model.getDirectedEdgeCount(node, false);
  node = this.model.getValue(node);
  /** @type {string} */
  var ret = "";
  if (null != this.multiplicities) {
    /** @type {number} */
    var target = 0;
    for (; target < this.multiplicities.length; target++) {
      var self = this.multiplicities[target];
      if (self.source && mxUtils.isNode(node, self.type, self.attr, self.value) && (row > self.max || row < self.min)) {
        /** @type {string} */
        ret = ret + (self.countError + "\n");
      } else {
        if (!self.source && mxUtils.isNode(node, self.type, self.attr, self.value) && (newWidth > self.max || newWidth < self.min)) {
          /** @type {string} */
          ret = ret + (self.countError + "\n");
        }
      }
    }
  }
  return 0 < ret.length ? ret : null;
};
/**
 * @param {(Object|string)} row
 * @param {number} col
 * @return {?}
 */
mxGraph.prototype.validateCell = function(row, col) {
  return null;
};
/**
 * @return {?}
 */
mxGraph.prototype.getBackgroundImage = function() {
  return this.backgroundImage;
};
/**
 * @param {string} img
 * @return {undefined}
 */
mxGraph.prototype.setBackgroundImage = function(img) {
  /** @type {string} */
  this.backgroundImage = img;
};
/**
 * @param {!Object} data
 * @return {?}
 */
mxGraph.prototype.getFoldingImage = function(data) {
  if (null != data && this.foldingEnabled && !this.getModel().isEdge(data.cell)) {
    var b = this.isCellCollapsed(data.cell);
    if (this.isCellFoldable(data.cell, !b)) {
      return b ? this.collapsedImage : this.expandedImage;
    }
  }
  return null;
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxGraph.prototype.convertValueToString = function(value) {
  value = this.model.getValue(value);
  if (null != value) {
    if (mxUtils.isNode(value)) {
      return value.nodeName;
    }
    if ("function" == typeof value.toString) {
      return value.toString();
    }
  }
  return "";
};
/**
 * @param {?} name
 * @return {?}
 */
mxGraph.prototype.getLabel = function(name) {
  /** @type {string} */
  var language = "";
  if (this.labelsVisible && null != name) {
    var str = this.getCurrentCellStyle(name);
    if (!mxUtils.getValue(str, mxConstants.STYLE_NOLABEL, false)) {
      language = this.convertValueToString(name);
    }
  }
  return language;
};
/**
 * @param {!Object} cell
 * @return {?}
 */
mxGraph.prototype.isHtmlLabel = function(cell) {
  return this.isHtmlLabels();
};
/**
 * @return {?}
 */
mxGraph.prototype.isHtmlLabels = function() {
  return this.htmlLabels;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setHtmlLabels = function(a) {
  /** @type {boolean} */
  this.htmlLabels = a;
};
/**
 * @param {?} mercatorX
 * @return {?}
 */
mxGraph.prototype.isWrapping = function(mercatorX) {
  return "wrap" == this.getCurrentCellStyle(mercatorX)[mxConstants.STYLE_WHITE_SPACE];
};
/**
 * @param {?} mercatorX
 * @return {?}
 */
mxGraph.prototype.isLabelClipped = function(mercatorX) {
  return "hidden" == this.getCurrentCellStyle(mercatorX)[mxConstants.STYLE_OVERFLOW];
};
/**
 * @param {!Object} data
 * @param {string} node
 * @param {string} view
 * @param {?} type
 * @return {?}
 */
mxGraph.prototype.getTooltip = function(data, node, view, type) {
  /** @type {null} */
  var value = null;
  if (null != data) {
    if (!(null == data.control || node != data.control.node && node.parentNode != data.control.node)) {
      value = this.collapseExpandResource;
      value = mxUtils.htmlEntities(mxResources.get(value) || value).replace(/\\n/g, "<br>");
    }
    if (null == value && null != data.overlays) {
      data.overlays.visit(function(canCreateDiscussions, self) {
        if (!(null != value || node != self.node && node.parentNode != self.node)) {
          value = self.overlay.toString();
        }
      });
    }
    if (null == value) {
      view = this.selectionCellsHandler.getHandler(data.cell);
      if (null != view && "function" == typeof view.getTooltipForNode) {
        value = view.getTooltipForNode(node);
      }
    }
    if (null == value) {
      value = this.getTooltipForCell(data.cell);
    }
  }
  return value;
};
/**
 * @param {!Object} P
 * @return {?}
 */
mxGraph.prototype.getTooltipForCell = function(P) {
  return null != P && null != P.getTooltip ? P.getTooltip() : this.convertValueToString(P);
};
/**
 * @param {?} cell
 * @return {?}
 */
mxGraph.prototype.getLinkForCell = function(cell) {
  return null;
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.getLinkTargetForCell = function(a) {
  return null;
};
/**
 * @param {!Object} header
 * @return {?}
 */
mxGraph.prototype.getCursorForMouseEvent = function(header) {
  return this.getCursorForCell(header.getCell());
};
/**
 * @param {?} cell
 * @return {?}
 */
mxGraph.prototype.getCursorForCell = function(cell) {
  return null;
};
/**
 * @param {?} data
 * @param {number} size
 * @return {?}
 */
mxGraph.prototype.getStartSize = function(data, size) {
  var tmp = new mxRectangle;
  data = this.getCurrentCellStyle(data, size);
  /** @type {number} */
  size = parseInt(mxUtils.getValue(data, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
  if (mxUtils.getValue(data, mxConstants.STYLE_HORIZONTAL, true)) {
    /** @type {number} */
    tmp.height = size;
  } else {
    /** @type {number} */
    tmp.width = size;
  }
  return tmp;
};
/**
 * @param {number} str
 * @return {?}
 */
mxGraph.prototype.getSwimlaneDirection = function(str) {
  var number = mxUtils.getValue(str, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
  /** @type {boolean} */
  var maxvalue = 1 == mxUtils.getValue(str, mxConstants.STYLE_FLIPH, 0);
  /** @type {boolean} */
  var skipErrors = 1 == mxUtils.getValue(str, mxConstants.STYLE_FLIPV, 0);
  /** @type {number} */
  str = mxUtils.getValue(str, mxConstants.STYLE_HORIZONTAL, true) ? 0 : 3;
  if (number == mxConstants.DIRECTION_NORTH) {
    str--;
  } else {
    if (number == mxConstants.DIRECTION_WEST) {
      /** @type {number} */
      str = str + 2;
    } else {
      if (number == mxConstants.DIRECTION_SOUTH) {
        /** @type {number} */
        str = str + 1;
      }
    }
  }
  number = mxUtils.mod(str, 2);
  if (maxvalue && 1 == number) {
    /** @type {number} */
    str = str + 2;
  }
  if (skipErrors && 0 == number) {
    /** @type {number} */
    str = str + 2;
  }
  return [mxConstants.DIRECTION_NORTH, mxConstants.DIRECTION_EAST, mxConstants.DIRECTION_SOUTH, mxConstants.DIRECTION_WEST][mxUtils.mod(str, 4)];
};
/**
 * @param {number} size
 * @param {number} value
 * @return {?}
 */
mxGraph.prototype.getActualStartSize = function(size, value) {
  var tmp = new mxRectangle;
  if (this.isSwimlane(size, value)) {
    value = this.getCurrentCellStyle(size, value);
    /** @type {number} */
    size = parseInt(mxUtils.getValue(value, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
    value = this.getSwimlaneDirection(value);
    if (value == mxConstants.DIRECTION_NORTH) {
      /** @type {number} */
      tmp.y = size;
    } else {
      if (value == mxConstants.DIRECTION_WEST) {
        /** @type {number} */
        tmp.x = size;
      } else {
        if (value == mxConstants.DIRECTION_SOUTH) {
          /** @type {number} */
          tmp.height = size;
        } else {
          /** @type {number} */
          tmp.width = size;
        }
      }
    }
  }
  return tmp;
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxGraph.prototype.getImage = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_IMAGE] : null;
};
/**
 * @param {!Object} key
 * @return {?}
 */
mxGraph.prototype.isTransparentState = function(key) {
  /** @type {boolean} */
  var align = false;
  if (null != key) {
    align = mxUtils.getValue(key.style, mxConstants.STYLE_STROKECOLOR, mxConstants.NONE);
    var valign = mxUtils.getValue(key.style, mxConstants.STYLE_FILLCOLOR, mxConstants.NONE);
    /** @type {boolean} */
    align = align == mxConstants.NONE && valign == mxConstants.NONE && null == this.getImage(key);
  }
  return align;
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxGraph.prototype.getVerticalAlign = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_VERTICAL_ALIGN] || mxConstants.ALIGN_MIDDLE : null;
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxGraph.prototype.getIndicatorColor = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_INDICATOR_COLOR] : null;
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxGraph.prototype.getIndicatorGradientColor = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_INDICATOR_GRADIENTCOLOR] : null;
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxGraph.prototype.getIndicatorShape = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_INDICATOR_SHAPE] : null;
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxGraph.prototype.getIndicatorImage = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_INDICATOR_IMAGE] : null;
};
/**
 * @return {?}
 */
mxGraph.prototype.getBorder = function() {
  return this.border;
};
/**
 * @param {?} border
 * @return {undefined}
 */
mxGraph.prototype.setBorder = function(border) {
  this.border = border;
};
/**
 * @param {?} n
 * @param {?} V
 * @return {?}
 */
mxGraph.prototype.isSwimlane = function(n, V) {
  return null == n || this.model.getParent(n) == this.model.getRoot() || this.model.isEdge(n) ? false : this.getCurrentCellStyle(n, V)[mxConstants.STYLE_SHAPE] == mxConstants.SHAPE_SWIMLANE;
};
/**
 * @return {?}
 */
mxGraph.prototype.isResizeContainer = function() {
  return this.resizeContainer;
};
/**
 * @param {boolean} resizeContainer
 * @return {undefined}
 */
mxGraph.prototype.setResizeContainer = function(resizeContainer) {
  /** @type {boolean} */
  this.resizeContainer = resizeContainer;
};
/**
 * @return {?}
 */
mxGraph.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {boolean} state
 * @return {undefined}
 */
mxGraph.prototype.setEnabled = function(state) {
  /** @type {boolean} */
  this.enabled = state;
  this.fireEvent(new mxEventObject("enabledChanged", "enabled", state));
};
/**
 * @return {?}
 */
mxGraph.prototype.isEscapeEnabled = function() {
  return this.escapeEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setEscapeEnabled = function(a) {
  /** @type {boolean} */
  this.escapeEnabled = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isInvokesStopCellEditing = function() {
  return this.invokesStopCellEditing;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setInvokesStopCellEditing = function(a) {
  /** @type {boolean} */
  this.invokesStopCellEditing = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isEnterStopsCellEditing = function() {
  return this.enterStopsCellEditing;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setEnterStopsCellEditing = function(a) {
  /** @type {boolean} */
  this.enterStopsCellEditing = a;
};
/**
 * @param {string} element
 * @return {?}
 */
mxGraph.prototype.isCellLocked = function(element) {
  var chunk = this.model.getGeometry(element);
  return this.isCellsLocked() || null != chunk && this.model.isVertex(element) && chunk.relative;
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsLocked = function() {
  return this.cellsLocked;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsLocked = function(a) {
  /** @type {boolean} */
  this.cellsLocked = a;
};
/**
 * @param {!Object} type
 * @return {?}
 */
mxGraph.prototype.getCloneableCells = function(type) {
  return this.model.filterCells(type, mxUtils.bind(this, function(style_in) {
    return this.isCellCloneable(style_in);
  }));
};
/**
 * @param {?} style
 * @return {?}
 */
mxGraph.prototype.isCellCloneable = function(style) {
  style = this.getCurrentCellStyle(style);
  return this.isCellsCloneable() && 0 != style[mxConstants.STYLE_CLONEABLE];
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsCloneable = function() {
  return this.cellsCloneable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsCloneable = function(a) {
  /** @type {boolean} */
  this.cellsCloneable = a;
};
/**
 * @param {!Object} shouldCapture
 * @return {?}
 */
mxGraph.prototype.getExportableCells = function(shouldCapture) {
  return this.model.filterCells(shouldCapture, mxUtils.bind(this, function(cX1) {
    return this.canExportCell(cX1);
  }));
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.canExportCell = function(a) {
  return this.exportEnabled;
};
/**
 * @param {!Object} shouldCapture
 * @return {?}
 */
mxGraph.prototype.getImportableCells = function(shouldCapture) {
  return this.model.filterCells(shouldCapture, mxUtils.bind(this, function(cX1) {
    return this.canImportCell(cX1);
  }));
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.canImportCell = function(a) {
  return this.importEnabled;
};
/**
 * @param {?} cell
 * @return {?}
 */
mxGraph.prototype.isCellSelectable = function(cell) {
  return this.isCellsSelectable();
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsSelectable = function() {
  return this.cellsSelectable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsSelectable = function(a) {
  /** @type {boolean} */
  this.cellsSelectable = a;
};
/**
 * @param {!Object} shouldCapture
 * @return {?}
 */
mxGraph.prototype.getDeletableCells = function(shouldCapture) {
  return this.model.filterCells(shouldCapture, mxUtils.bind(this, function(style_in) {
    return this.isCellDeletable(style_in);
  }));
};
/**
 * @param {?} style
 * @return {?}
 */
mxGraph.prototype.isCellDeletable = function(style) {
  style = this.getCurrentCellStyle(style);
  return this.isCellsDeletable() && 0 != style[mxConstants.STYLE_DELETABLE];
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsDeletable = function() {
  return this.cellsDeletable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsDeletable = function(a) {
  /** @type {boolean} */
  this.cellsDeletable = a;
};
/**
 * @param {undefined} cell
 * @return {?}
 */
mxGraph.prototype.isLabelMovable = function(cell) {
  return !this.isCellLocked(cell) && (this.model.isEdge(cell) && this.edgeLabelsMovable || this.model.isVertex(cell) && this.vertexLabelsMovable);
};
/**
 * @param {!Object} shouldCapture
 * @return {?}
 */
mxGraph.prototype.getRotatableCells = function(shouldCapture) {
  return this.model.filterCells(shouldCapture, mxUtils.bind(this, function(cX1) {
    return this.isCellRotatable(cX1);
  }));
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.isCellRotatable = function(a) {
  return 0 != this.getCurrentCellStyle(a)[mxConstants.STYLE_ROTATABLE];
};
/**
 * @param {!Object} shouldCapture
 * @return {?}
 */
mxGraph.prototype.getMovableCells = function(shouldCapture) {
  return this.model.filterCells(shouldCapture, mxUtils.bind(this, function(cX1) {
    return this.isCellMovable(cX1);
  }));
};
/**
 * @param {boolean} a
 * @return {?}
 */
mxGraph.prototype.isCellMovable = function(a) {
  var style = this.getCurrentCellStyle(a);
  return this.isCellsMovable() && !this.isCellLocked(a) && 0 != style[mxConstants.STYLE_MOVABLE];
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsMovable = function() {
  return this.cellsMovable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsMovable = function(a) {
  /** @type {boolean} */
  this.cellsMovable = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isGridEnabled = function() {
  return this.gridEnabled;
};
/**
 * @param {number} a
 * @return {undefined}
 */
mxGraph.prototype.setGridEnabled = function(a) {
  /** @type {number} */
  this.gridEnabled = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isPortsEnabled = function() {
  return this.portsEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setPortsEnabled = function(a) {
  /** @type {boolean} */
  this.portsEnabled = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.getGridSize = function() {
  return this.gridSize;
};
/**
 * @param {string} gridSize
 * @return {undefined}
 */
mxGraph.prototype.setGridSize = function(gridSize) {
  /** @type {string} */
  this.gridSize = gridSize;
};
/**
 * @return {?}
 */
mxGraph.prototype.getTolerance = function() {
  return this.tolerance;
};
/**
 * @param {number} tolerance
 * @return {undefined}
 */
mxGraph.prototype.setTolerance = function(tolerance) {
  /** @type {number} */
  this.tolerance = tolerance;
};
/**
 * @return {?}
 */
mxGraph.prototype.isVertexLabelsMovable = function() {
  return this.vertexLabelsMovable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setVertexLabelsMovable = function(a) {
  /** @type {boolean} */
  this.vertexLabelsMovable = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isEdgeLabelsMovable = function() {
  return this.edgeLabelsMovable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setEdgeLabelsMovable = function(a) {
  /** @type {boolean} */
  this.edgeLabelsMovable = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isSwimlaneNesting = function() {
  return this.swimlaneNesting;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setSwimlaneNesting = function(a) {
  /** @type {boolean} */
  this.swimlaneNesting = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isSwimlaneSelectionEnabled = function() {
  return this.swimlaneSelectionEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setSwimlaneSelectionEnabled = function(a) {
  /** @type {boolean} */
  this.swimlaneSelectionEnabled = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isMultigraph = function() {
  return this.multigraph;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setMultigraph = function(a) {
  /** @type {boolean} */
  this.multigraph = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isAllowLoops = function() {
  return this.allowLoops;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setAllowDanglingEdges = function(a) {
  /** @type {boolean} */
  this.allowDanglingEdges = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isAllowDanglingEdges = function() {
  return this.allowDanglingEdges;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setConnectableEdges = function(a) {
  /** @type {boolean} */
  this.connectableEdges = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isConnectableEdges = function() {
  return this.connectableEdges;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCloneInvalidEdges = function(a) {
  /** @type {boolean} */
  this.cloneInvalidEdges = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isCloneInvalidEdges = function() {
  return this.cloneInvalidEdges;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setAllowLoops = function(a) {
  /** @type {boolean} */
  this.allowLoops = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isDisconnectOnMove = function() {
  return this.disconnectOnMove;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setDisconnectOnMove = function(a) {
  /** @type {boolean} */
  this.disconnectOnMove = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isDropEnabled = function() {
  return this.dropEnabled;
};
/**
 * @param {boolean} dropBool
 * @return {undefined}
 */
mxGraph.prototype.setDropEnabled = function(dropBool) {
  /** @type {boolean} */
  this.dropEnabled = dropBool;
};
/**
 * @return {?}
 */
mxGraph.prototype.isSplitEnabled = function() {
  return this.splitEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setSplitEnabled = function(a) {
  /** @type {boolean} */
  this.splitEnabled = a;
};
/**
 * @param {!Object} shouldCapture
 * @return {?}
 */
mxGraph.prototype.getResizableCells = function(shouldCapture) {
  return this.model.filterCells(shouldCapture, mxUtils.bind(this, function(cX1) {
    return this.isCellResizable(cX1);
  }));
};
/**
 * @param {boolean} a
 * @return {?}
 */
mxGraph.prototype.isCellResizable = function(a) {
  var str = this.getCurrentCellStyle(a);
  return this.isCellsResizable() && !this.isCellLocked(a) && "0" != mxUtils.getValue(str, mxConstants.STYLE_RESIZABLE, "1");
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsResizable = function() {
  return this.cellsResizable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsResizable = function(a) {
  /** @type {boolean} */
  this.cellsResizable = a;
};
/**
 * @param {number} name
 * @param {number} replacement
 * @return {?}
 */
mxGraph.prototype.isTerminalPointMovable = function(name, replacement) {
  return true;
};
/**
 * @param {undefined} level
 * @return {?}
 */
mxGraph.prototype.isCellBendable = function(level) {
  var adjustedLevel = this.getCurrentCellStyle(level);
  return this.isCellsBendable() && !this.isCellLocked(level) && 0 != adjustedLevel[mxConstants.STYLE_BENDABLE];
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsBendable = function() {
  return this.cellsBendable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsBendable = function(a) {
  /** @type {boolean} */
  this.cellsBendable = a;
};
/**
 * @param {!Object} shouldCapture
 * @return {?}
 */
mxGraph.prototype.getEditableCells = function(shouldCapture) {
  return this.model.filterCells(shouldCapture, mxUtils.bind(this, function(evan) {
    return this.isCellEditable(evan);
  }));
};
/**
 * @param {string} record
 * @return {?}
 */
mxGraph.prototype.isCellEditable = function(record) {
  var style = this.getCurrentCellStyle(record);
  return this.isCellsEditable() && !this.isCellLocked(record) && 0 != style[mxConstants.STYLE_EDITABLE];
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsEditable = function() {
  return this.cellsEditable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsEditable = function(a) {
  /** @type {boolean} */
  this.cellsEditable = a;
};
/**
 * @param {!Function} label
 * @param {number} name
 * @param {?} language
 * @return {?}
 */
mxGraph.prototype.isCellDisconnectable = function(label, name, language) {
  return this.isCellsDisconnectable() && !this.isCellLocked(label);
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsDisconnectable = function() {
  return this.cellsDisconnectable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsDisconnectable = function(a) {
  /** @type {boolean} */
  this.cellsDisconnectable = a;
};
/**
 * @param {?} source
 * @return {?}
 */
mxGraph.prototype.isValidSource = function(source) {
  return null == source && this.allowDanglingEdges || null != source && (!this.model.isEdge(source) || this.connectableEdges) && this.isCellConnectable(source);
};
/**
 * @param {boolean} name
 * @return {?}
 */
mxGraph.prototype.isValidTarget = function(name) {
  return this.isValidSource(name);
};
/**
 * @param {boolean} b
 * @param {!Object} a
 * @return {?}
 */
mxGraph.prototype.isValidConnection = function(b, a) {
  return this.isValidSource(b) && this.isValidTarget(a);
};
/**
 * @param {boolean} enabled
 * @return {undefined}
 */
mxGraph.prototype.setConnectable = function(enabled) {
  this.connectionHandler.setEnabled(enabled);
};
/**
 * @return {?}
 */
mxGraph.prototype.isConnectable = function() {
  return this.connectionHandler.isEnabled();
};
/**
 * @param {boolean} show
 * @return {undefined}
 */
mxGraph.prototype.setTooltips = function(show) {
  this.tooltipHandler.setEnabled(show);
};
/**
 * @param {boolean} panning
 * @return {undefined}
 */
mxGraph.prototype.setPanning = function(panning) {
  /** @type {boolean} */
  this.panningHandler.panningEnabled = panning;
};
/**
 * @param {string} a
 * @return {?}
 */
mxGraph.prototype.isEditing = function(a) {
  if (null != this.cellEditor) {
    var b = this.cellEditor.getEditingCell();
    return null == a ? null != b : a == b;
  }
  return false;
};
/**
 * @param {string} style
 * @return {?}
 */
mxGraph.prototype.isAutoSizeCell = function(style) {
  style = this.getCurrentCellStyle(style);
  return this.isAutoSizeCells() || 1 == style[mxConstants.STYLE_AUTOSIZE];
};
/**
 * @return {?}
 */
mxGraph.prototype.isAutoSizeCells = function() {
  return this.autoSizeCells;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setAutoSizeCells = function(a) {
  /** @type {boolean} */
  this.autoSizeCells = a;
};
/**
 * @param {?} negative
 * @return {?}
 */
mxGraph.prototype.isExtendParent = function(negative) {
  return !this.getModel().isEdge(negative) && this.isExtendParents();
};
/**
 * @return {?}
 */
mxGraph.prototype.isExtendParents = function() {
  return this.extendParents;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setExtendParents = function(a) {
  /** @type {boolean} */
  this.extendParents = a;
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.isExtendParentsOnAdd = function(a) {
  return this.extendParentsOnAdd;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setExtendParentsOnAdd = function(a) {
  /** @type {boolean} */
  this.extendParentsOnAdd = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isExtendParentsOnMove = function() {
  return this.extendParentsOnMove;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setExtendParentsOnMove = function(a) {
  /** @type {boolean} */
  this.extendParentsOnMove = a;
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.isRecursiveResize = function(a) {
  return this.recursiveResize;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setRecursiveResize = function(a) {
  /** @type {boolean} */
  this.recursiveResize = a;
};
/**
 * @param {!Object} module
 * @return {?}
 */
mxGraph.prototype.isConstrainChild = function(module) {
  return this.isConstrainChildren() && !this.getModel().isEdge(this.getModel().getParent(module));
};
/**
 * @return {?}
 */
mxGraph.prototype.isConstrainChildren = function() {
  return this.constrainChildren;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setConstrainChildren = function(a) {
  /** @type {boolean} */
  this.constrainChildren = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isConstrainRelativeChildren = function() {
  return this.constrainRelativeChildren;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setConstrainRelativeChildren = function(a) {
  /** @type {boolean} */
  this.constrainRelativeChildren = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isAllowNegativeCoordinates = function() {
  return this.allowNegativeCoordinates;
};
/**
 * @param {boolean} zoomAware
 * @return {undefined}
 */
mxGraph.prototype.setAllowNegativeCoordinates = function(zoomAware) {
  /** @type {boolean} */
  this.allowNegativeCoordinates = zoomAware;
};
/**
 * @param {!Object} other
 * @return {?}
 */
mxGraph.prototype.getOverlap = function(other) {
  return this.isAllowOverlapParent(other) ? this.defaultOverlap : 0;
};
/**
 * @param {!Object} P2
 * @return {?}
 */
mxGraph.prototype.isAllowOverlapParent = function(P2) {
  return false;
};
/**
 * @param {!Object} container
 * @param {string} className
 * @return {?}
 */
mxGraph.prototype.getFoldableCells = function(container, className) {
  return this.model.filterCells(container, mxUtils.bind(this, function(code_cell) {
    return this.isCellFoldable(code_cell, className);
  }));
};
/**
 * @param {?} cell
 * @param {string} value
 * @return {?}
 */
mxGraph.prototype.isCellFoldable = function(cell, value) {
  value = this.getCurrentCellStyle(cell);
  return 0 < this.model.getChildCount(cell) && 0 != value[mxConstants.STYLE_FOLDABLE];
};
/**
 * @param {!Object} cell
 * @param {!Object} e
 * @param {!Array} editor
 * @return {?}
 */
mxGraph.prototype.isValidDropTarget = function(cell, e, editor) {
  return null != cell && (this.isSplitEnabled() && this.isSplitTarget(cell, e, editor) || !this.model.isEdge(cell) && (this.isSwimlane(cell) || 0 < this.model.getChildCount(cell) && !this.isCellCollapsed(cell)));
};
/**
 * @param {string} n
 * @param {!Object} list
 * @param {!Array} e
 * @return {?}
 */
mxGraph.prototype.isSplitTarget = function(n, list, e) {
  return this.model.isEdge(n) && null != list && 1 == list.length && this.isCellConnectable(list[0]) && null == this.getEdgeValidationError(n, this.model.getTerminal(n, true), list[0]) ? (e = this.model.getTerminal(n, true), n = this.model.getTerminal(n, false), !this.model.isAncestor(list[0], e) && !this.model.isAncestor(list[0], n)) : false;
};
/**
 * @param {!Object} data
 * @param {?} evt
 * @param {!Object} node
 * @param {!Object} value
 * @return {?}
 */
mxGraph.prototype.getDropTarget = function(data, evt, node, value) {
  if (!this.isSwimlaneNesting()) {
    /** @type {number} */
    var p = 0;
    for (; p < data.length; p++) {
      if (this.isSwimlane(data[p])) {
        return null;
      }
    }
  }
  p = mxUtils.convertPoint(this.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
  p.x -= this.panDx;
  p.y -= this.panDy;
  p = this.getSwimlaneAt(p.x, p.y);
  if (null == node) {
    node = p;
  } else {
    if (null != p) {
      var n = this.model.getParent(p);
      for (; null != n && this.isSwimlane(n) && n != node;) {
        n = this.model.getParent(n);
      }
      if (n == node) {
        node = p;
      }
    }
  }
  for (; null != node && !this.isValidDropTarget(node, data, evt) && !this.model.isLayer(node);) {
    node = this.model.getParent(node);
  }
  if (null == value || !value) {
    /** @type {!Object} */
    var target = node;
    for (; null != target && 0 > mxUtils.indexOf(data, target);) {
      target = this.model.getParent(target);
    }
  }
  return this.model.isLayer(node) || null != target ? null : node;
};
/**
 * @return {?}
 */
mxGraph.prototype.getDefaultParent = function() {
  var i = this.getCurrentRoot();
  if (null == i) {
    i = this.defaultParent;
    if (null == i) {
      i = this.model.getRoot();
      i = this.model.getChildAt(i, 0);
    }
  }
  return i;
};
/**
 * @param {string} addedRenderer
 * @return {undefined}
 */
mxGraph.prototype.setDefaultParent = function(addedRenderer) {
  /** @type {string} */
  this.defaultParent = addedRenderer;
};
/**
 * @param {?} cell
 * @return {?}
 */
mxGraph.prototype.getSwimlane = function(cell) {
  for (; null != cell && !this.isSwimlane(cell);) {
    cell = this.model.getParent(cell);
  }
  return cell;
};
/**
 * @param {!Object} y
 * @param {string} w
 * @param {!Object} n
 * @return {?}
 */
mxGraph.prototype.getSwimlaneAt = function(y, w, n) {
  if (null == n) {
    n = this.getCurrentRoot();
    if (null == n) {
      n = this.model.getRoot();
    }
  }
  if (null != n) {
    var requestsToPerform = this.model.getChildCount(n);
    /** @type {number} */
    var i = 0;
    for (; i < requestsToPerform; i++) {
      var input = this.model.getChildAt(n, i);
      if (null != input) {
        var d = this.getSwimlaneAt(y, w, input);
        if (null != d) {
          return d;
        }
        if (this.isCellVisible(input) && this.isSwimlane(input) && (d = this.view.getState(input), this.intersects(d, y, w))) {
          return input;
        }
      }
    }
  }
  return null;
};
/**
 * @param {!Object} y
 * @param {string} row
 * @param {!Object} x
 * @param {?} data
 * @param {?} name
 * @param {string} fn
 * @return {?}
 */
mxGraph.prototype.getCellAt = function(y, row, x, data, name, fn) {
  data = null != data ? data : true;
  name = null != name ? name : true;
  if (null == x) {
    x = this.getCurrentRoot();
    if (null == x) {
      x = this.getModel().getRoot();
    }
  }
  if (null != x) {
    /** @type {number} */
    var i = this.model.getChildCount(x) - 1;
    for (; 0 <= i; i--) {
      var key = this.model.getChildAt(x, i);
      var result = this.getCellAt(y, row, key, data, name, fn);
      if (null != result) {
        return result;
      }
      if (this.isCellVisible(key) && (name && this.model.isEdge(key) || data && this.model.isVertex(key)) && (result = this.view.getState(key), null != result && (null == fn || !fn(result, y, row)) && this.intersects(result, y, row))) {
        return key;
      }
    }
  }
  return null;
};
/**
 * @param {!Object} s
 * @param {!Object} x
 * @param {string} y
 * @return {?}
 */
mxGraph.prototype.intersects = function(s, x, y) {
  if (null != s) {
    var c = s.absolutePoints;
    if (null != c) {
      /** @type {number} */
      s = this.tolerance * this.tolerance;
      var r = c[0];
      /** @type {number} */
      var i = 1;
      for (; i < c.length; i++) {
        var v = c[i];
        if (mxUtils.ptSegDistSq(r.x, r.y, v.x, v.y, x, y) <= s) {
          return true;
        }
        r = v;
      }
    } else {
      if (r = mxUtils.toRadians(mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION) || 0), 0 != r && (c = Math.cos(-r), r = Math.sin(-r), i = new mxPoint(s.getCenterX(), s.getCenterY()), r = mxUtils.getRotatedPoint(new mxPoint(x, y), c, r, i), x = r.x, y = r.y), mxUtils.contains(s, x, y)) {
        return true;
      }
    }
  }
  return false;
};
/**
 * @param {?} img
 * @param {number} tx
 * @param {number} r
 * @return {?}
 */
mxGraph.prototype.hitsSwimlaneContent = function(img, tx, r) {
  var s = this.getView().getState(img);
  img = this.getStartSize(img);
  if (null != s) {
    var scaleFactor = this.getView().getScale();
    /** @type {number} */
    tx = tx - s.x;
    /** @type {number} */
    r = r - s.y;
    if (0 < img.width && 0 < tx && tx > img.width * scaleFactor || 0 < img.height && 0 < r && r > img.height * scaleFactor) {
      return true;
    }
  }
  return false;
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.getChildVertices = function(a) {
  return this.getChildCells(a, true, false);
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.getChildEdges = function(a) {
  return this.getChildCells(a, false, true);
};
/**
 * @param {?} a
 * @param {string} b
 * @param {?} i
 * @return {?}
 */
mxGraph.prototype.getChildCells = function(a, b, i) {
  a = null != a ? a : this.getDefaultParent();
  a = this.model.getChildCells(a, null != b ? b : false, null != i ? i : false);
  /** @type {!Array} */
  b = [];
  /** @type {number} */
  i = 0;
  for (; i < a.length; i++) {
    if (this.isCellVisible(a[i])) {
      b.push(a[i]);
    }
  }
  return b;
};
/**
 * @param {!Object} scope
 * @param {(Object|string)} id
 * @return {?}
 */
mxGraph.prototype.getConnections = function(scope, id) {
  return this.getEdges(scope, id, true, true, false);
};
/**
 * @param {!Object} url
 * @param {undefined} node
 * @return {?}
 */
mxGraph.prototype.getIncomingEdges = function(url, node) {
  return this.getEdges(url, node, true, false, false);
};
/**
 * @param {!Object} url
 * @param {undefined} node
 * @return {?}
 */
mxGraph.prototype.getOutgoingEdges = function(url, node) {
  return this.getEdges(url, node, false, true, false);
};
/**
 * @param {!Object} target
 * @param {string} object
 * @param {?} id
 * @param {?} name
 * @param {?} v
 * @param {string} e
 * @return {?}
 */
mxGraph.prototype.getEdges = function(target, object, id, name, v, e) {
  id = null != id ? id : true;
  name = null != name ? name : true;
  v = null != v ? v : true;
  e = null != e ? e : false;
  /** @type {!Array} */
  var parts = [];
  var list = this.isCellCollapsed(target);
  var val = this.model.getChildCount(target);
  /** @type {number} */
  var i = 0;
  for (; i < val; i++) {
    var key = this.model.getChildAt(target, i);
    if (list || !this.isCellVisible(key)) {
      /** @type {!Array<?>} */
      parts = parts.concat(this.model.getEdges(key, id, name));
    }
  }
  /** @type {!Array<?>} */
  parts = parts.concat(this.model.getEdges(target, id, name));
  /** @type {!Array} */
  list = [];
  /** @type {number} */
  i = 0;
  for (; i < parts.length; i++) {
    key = this.view.getState(parts[i]);
    val = null != key ? key.getVisibleTerminal(true) : this.view.getVisibleTerminal(parts[i], true);
    key = null != key ? key.getVisibleTerminal(false) : this.view.getVisibleTerminal(parts[i], false);
    if (v && val == key || val != key && (id && key == target && (null == object || this.isValidAncestor(val, object, e)) || name && val == target && (null == object || this.isValidAncestor(key, object, e)))) {
      list.push(parts[i]);
    }
  }
  return list;
};
/**
 * @param {!Object} type
 * @param {!Object} path
 * @param {!Object} node
 * @return {?}
 */
mxGraph.prototype.isValidAncestor = function(type, path, node) {
  return node ? this.model.isAncestor(path, type) : this.model.getParent(type) == path;
};
/**
 * @param {!Object} nodes
 * @param {?} g
 * @param {?} path
 * @param {?} duration
 * @return {?}
 */
mxGraph.prototype.getOpposites = function(nodes, g, path, duration) {
  path = null != path ? path : true;
  duration = null != duration ? duration : true;
  /** @type {!Array} */
  var t_chksum = [];
  var f = new mxDictionary;
  if (null != nodes) {
    /** @type {number} */
    var i = 0;
    for (; i < nodes.length; i++) {
      var r = this.view.getState(nodes[i]);
      var max = null != r ? r.getVisibleTerminal(true) : this.view.getVisibleTerminal(nodes[i], true);
      r = null != r ? r.getVisibleTerminal(false) : this.view.getVisibleTerminal(nodes[i], false);
      if (max == g && null != r && r != g && duration) {
        if (!f.get(r)) {
          f.put(r, true);
          t_chksum.push(r);
        }
      } else {
        if (r == g && null != max && max != g && path && !f.get(max)) {
          f.put(max, true);
          t_chksum.push(max);
        }
      }
    }
  }
  return t_chksum;
};
/**
 * @param {!Object} a
 * @param {!Object} b
 * @param {string} status
 * @return {?}
 */
mxGraph.prototype.getEdgesBetween = function(a, b, status) {
  status = null != status ? status : false;
  var nodes = this.getEdges(a);
  /** @type {!Array} */
  var newNodeCollection = [];
  /** @type {number} */
  var i = 0;
  for (; i < nodes.length; i++) {
    var bP = this.view.getState(nodes[i]);
    var comp = null != bP ? bP.getVisibleTerminal(true) : this.view.getVisibleTerminal(nodes[i], true);
    bP = null != bP ? bP.getVisibleTerminal(false) : this.view.getVisibleTerminal(nodes[i], false);
    if (comp == a && bP == b || !status && comp == b && bP == a) {
      newNodeCollection.push(nodes[i]);
    }
  }
  return newNodeCollection;
};
/**
 * @param {!Object} evt
 * @param {number} originFrameIndex
 * @return {?}
 */
mxGraph.prototype.getPointForEvent = function(evt, originFrameIndex) {
  evt = mxUtils.convertPoint(this.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
  var scale = this.view.scale;
  var t = this.view.translate;
  /** @type {number} */
  originFrameIndex = 0 != originFrameIndex ? this.gridSize / 2 : 0;
  evt.x = this.snap(evt.x / scale - t.x - originFrameIndex);
  evt.y = this.snap(evt.y / scale - t.y - originFrameIndex);
  return evt;
};
/**
 * @param {number} end
 * @param {number} min
 * @param {number} range
 * @param {number} size
 * @param {!Object} parent
 * @param {string} data
 * @param {!Object} node
 * @param {string} $
 * @param {?} elems
 * @return {?}
 */
mxGraph.prototype.getCells = function(end, min, range, size, parent, data, node, $, elems) {
  data = null != data ? data : [];
  if (0 < range || 0 < size || null != node) {
    var model = this.getModel();
    var glue = end + range;
    var i = min + size;
    if (null == parent) {
      parent = this.getCurrentRoot();
      if (null == parent) {
        parent = model.getRoot();
      }
    }
    if (null != parent) {
      var newParentTag = model.getChildCount(parent);
      /** @type {number} */
      var i = 0;
      for (; i < newParentTag; i++) {
        var element = model.getChildAt(parent, i);
        var s = this.view.getState(element);
        if (null != s && this.isCellVisible(element) && (null == $ || !$(s))) {
          var value = mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION) || 0;
          if (0 != value) {
            s = mxUtils.getBoundingBox(s, value);
          }
          if (value = null != node && model.isVertex(element) && mxUtils.intersects(node, s) || null != node && model.isEdge(element) && mxUtils.intersects(node, s) || null == node && (model.isEdge(element) || model.isVertex(element)) && s.x >= end && s.y + s.height <= i && s.y >= min && s.x + s.width <= glue) {
            data.push(element);
          }
          if (!(value && !elems)) {
            this.getCells(end, min, range, size, element, data, node, $, elems);
          }
        }
      }
    }
  }
  return data;
};
/**
 * @param {?} w
 * @param {?} h
 * @param {!Object} start
 * @param {number} beforeZero
 * @param {boolean} afterZero
 * @return {?}
 */
mxGraph.prototype.getCellsBeyond = function(w, h, start, beforeZero, afterZero) {
  /** @type {!Array} */
  var tobesorted = [];
  if (beforeZero || afterZero) {
    if (null == start && (start = this.getDefaultParent()), null != start) {
      var sectionLength = this.model.getChildCount(start);
      /** @type {number} */
      var i = 0;
      for (; i < sectionLength; i++) {
        var name = this.model.getChildAt(start, i);
        var size = this.view.getState(name);
        if (this.isCellVisible(name) && null != size && (!beforeZero || size.x >= w) && (!afterZero || size.y >= h)) {
          tobesorted.push(name);
        }
      }
    }
  }
  return tobesorted;
};
/**
 * @param {!Object} n
 * @param {string} max
 * @param {string} reverse
 * @return {?}
 */
mxGraph.prototype.findTreeRoots = function(n, max, reverse) {
  max = null != max ? max : false;
  reverse = null != reverse ? reverse : false;
  /** @type {!Array} */
  var res = [];
  if (null != n) {
    var menu = this.getModel();
    var requestsToPerform = menu.getChildCount(n);
    /** @type {null} */
    var addon = null;
    /** @type {number} */
    var maxDistanceAbove = 0;
    /** @type {number} */
    var i = 0;
    for (; i < requestsToPerform; i++) {
      var data = menu.getChildAt(n, i);
      if (this.model.isVertex(data) && this.isCellVisible(data)) {
        var value = this.getConnections(data, max ? n : null);
        /** @type {number} */
        var p = 0;
        /** @type {number} */
        var circlePixel = 0;
        /** @type {number} */
        var i = 0;
        for (; i < value.length; i++) {
          if (this.view.getVisibleTerminal(value[i], true) == data) {
            p++;
          } else {
            circlePixel++;
          }
        }
        if (reverse && 0 == p && 0 < circlePixel || !reverse && 0 == circlePixel && 0 < p) {
          res.push(data);
        }
        /** @type {number} */
        value = reverse ? circlePixel - p : p - circlePixel;
        if (value > maxDistanceAbove) {
          /** @type {number} */
          maxDistanceAbove = value;
          addon = data;
        }
      }
    }
    if (0 == res.length && null != addon) {
      res.push(addon);
    }
  }
  return res;
};
/**
 * @param {?} value
 * @param {?} data
 * @param {?} filter
 * @param {number} val
 * @param {!Object} node
 * @param {!Object} parent
 * @return {undefined}
 */
mxGraph.prototype.traverse = function(value, data, filter, val, node, parent) {
  if (null != filter && null != value && (data = null != data ? data : true, parent = null != parent ? parent : false, node = node || new mxDictionary, null == val || !node.get(val)) && (node.put(val, true), val = filter(value, val), null == val || val) && (val = this.model.getEdgeCount(value), 0 < val)) {
    /** @type {number} */
    var v = 0;
    for (; v < val; v++) {
      var i = this.model.getEdgeAt(value, v);
      /** @type {boolean} */
      var selected = this.model.getTerminal(i, true) == value;
      if (!(data && !parent != selected)) {
        selected = this.model.getTerminal(i, !selected);
        this.traverse(selected, data, filter, i, node, parent);
      }
    }
  }
};
/**
 * @param {(Object|string)} record
 * @return {?}
 */
mxGraph.prototype.isCellSelected = function(record) {
  return this.getSelectionModel().isSelected(record);
};
/**
 * @return {?}
 */
mxGraph.prototype.isSelectionEmpty = function() {
  return this.getSelectionModel().isEmpty();
};
/**
 * @return {?}
 */
mxGraph.prototype.clearSelection = function() {
  return this.getSelectionModel().clear();
};
/**
 * @return {?}
 */
mxGraph.prototype.getSelectionCount = function() {
  return this.getSelectionModel().cells.length;
};
/**
 * @return {?}
 */
mxGraph.prototype.getSelectionCell = function() {
  return this.getSelectionModel().cells[0];
};
/**
 * @return {?}
 */
mxGraph.prototype.getSelectionCells = function() {
  return this.getSelectionModel().cells.slice();
};
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxGraph.prototype.setSelectionCell = function(obj) {
  this.getSelectionModel().setCell(obj);
};
/**
 * @param {?} cells
 * @return {undefined}
 */
mxGraph.prototype.setSelectionCells = function(cells) {
  this.getSelectionModel().setCells(cells);
};
/**
 * @param {boolean} element
 * @return {undefined}
 */
mxGraph.prototype.addSelectionCell = function(element) {
  this.getSelectionModel().addCell(element);
};
/**
 * @param {(Object|string)} cells
 * @return {undefined}
 */
mxGraph.prototype.addSelectionCells = function(cells) {
  this.getSelectionModel().addCells(cells);
};
/**
 * @param {(Object|string)} index
 * @return {undefined}
 */
mxGraph.prototype.removeSelectionCell = function(index) {
  this.getSelectionModel().removeCell(index);
};
/**
 * @param {!Array} before
 * @return {undefined}
 */
mxGraph.prototype.removeSelectionCells = function(before) {
  this.getSelectionModel().removeCells(before);
};
/**
 * @param {!Object} value
 * @param {!Object} name
 * @return {?}
 */
mxGraph.prototype.selectRegion = function(value, name) {
  value = this.getCells(value.x, value.y, value.width, value.height);
  this.selectCellsForEvent(value, name);
  return value;
};
/**
 * @return {undefined}
 */
mxGraph.prototype.selectNextCell = function() {
  this.selectCell(true);
};
/**
 * @return {undefined}
 */
mxGraph.prototype.selectPreviousCell = function() {
  this.selectCell();
};
/**
 * @return {undefined}
 */
mxGraph.prototype.selectParentCell = function() {
  this.selectCell(false, true);
};
/**
 * @return {undefined}
 */
mxGraph.prototype.selectChildCell = function() {
  this.selectCell(false, false, true);
};
/**
 * @param {string} y
 * @param {number} val
 * @param {boolean} state
 * @return {undefined}
 */
mxGraph.prototype.selectCell = function(y, val, state) {
  var index = this.selectionModel;
  var n = 0 < index.cells.length ? index.cells[0] : null;
  if (1 < index.cells.length) {
    index.clear();
  }
  index = null != n ? this.model.getParent(n) : this.getDefaultParent();
  var mod = this.model.getChildCount(index);
  if (null == n && 0 < mod) {
    y = this.model.getChildAt(index, 0);
    this.setSelectionCell(y);
  } else {
    if (null != n && !val || null == this.view.getState(index) || null == this.model.getGeometry(index)) {
      if (null != n && state) {
        if (0 < this.model.getChildCount(n)) {
          y = this.model.getChildAt(n, 0);
          this.setSelectionCell(y);
        }
      } else {
        if (0 < mod) {
          val = index.getIndex(n);
          if (y) {
            val++;
            y = this.model.getChildAt(index, val % mod);
          } else {
            val--;
            y = this.model.getChildAt(index, 0 > val ? mod - 1 : val);
          }
          this.setSelectionCell(y);
        }
      }
    } else {
      if (this.getCurrentRoot() != index) {
        this.setSelectionCell(index);
      }
    }
  }
};
/**
 * @param {string} selector
 * @param {?} fn
 * @return {undefined}
 */
mxGraph.prototype.selectAll = function(selector, fn) {
  selector = selector || this.getDefaultParent();
  fn = fn ? this.model.filterDescendants(mxUtils.bind(this, function(elem) {
    return elem != selector && null != this.view.getState(elem);
  }), selector) : this.model.getChildren(selector);
  if (null != fn) {
    this.setSelectionCells(fn);
  }
};
/**
 * @param {string} type
 * @param {string} s
 * @return {undefined}
 */
mxGraph.prototype.selectVertices = function(type, s) {
  this.selectCells(true, false, type, s);
};
/**
 * @param {string} selection
 * @return {undefined}
 */
mxGraph.prototype.selectEdges = function(selection) {
  this.selectCells(false, true, selection);
};
/**
 * @param {string} template
 * @param {string} pg
 * @param {string} data
 * @param {string} target
 * @return {undefined}
 */
mxGraph.prototype.selectCells = function(template, pg, data, target) {
  data = data || this.getDefaultParent();
  var id = mxUtils.bind(this, function(cell) {
    return null != this.view.getState(cell) && ((target || 0 == this.model.getChildCount(cell)) && this.model.isVertex(cell) && template && !this.model.isEdge(this.model.getParent(cell)) || this.model.isEdge(cell) && pg);
  });
  data = this.model.filterDescendants(id, data);
  if (null != data) {
    this.setSelectionCells(data);
  }
};
/**
 * @param {!Object} a
 * @param {!Object} e
 * @return {undefined}
 */
mxGraph.prototype.selectCellForEvent = function(a, e) {
  var _ref_a = this.isCellSelected(a);
  if (this.isToggleEvent(e)) {
    if (_ref_a) {
      this.removeSelectionCell(a);
    } else {
      this.addSelectionCell(a);
    }
  } else {
    if (!(_ref_a && 1 == this.getSelectionCount())) {
      this.setSelectionCell(a);
    }
  }
};
/**
 * @param {(Object|string)} column
 * @param {!Object} e
 * @return {undefined}
 */
mxGraph.prototype.selectCellsForEvent = function(column, e) {
  if (this.isToggleEvent(e)) {
    this.addSelectionCells(column);
  } else {
    this.setSelectionCells(column);
  }
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxGraph.prototype.createHandler = function(state) {
  /** @type {null} */
  var element = null;
  if (null != state) {
    if (this.model.isEdge(state.cell)) {
      element = state.getVisibleTerminalState(true);
      var label = state.getVisibleTerminalState(false);
      var geo = this.getCellGeometry(state.cell);
      element = this.view.getEdgeStyle(state, null != geo ? geo.points : null, element, label);
      element = this.createEdgeHandler(state, element);
    } else {
      element = this.createVertexHandler(state);
    }
  }
  return element;
};
/**
 * @param {!Object} basecolumn
 * @return {?}
 */
mxGraph.prototype.createVertexHandler = function(basecolumn) {
  return new mxVertexHandler(basecolumn);
};
/**
 * @param {!Object} a
 * @param {!Object} item
 * @return {?}
 */
mxGraph.prototype.createEdgeHandler = function(a, item) {
  return item == mxEdgeStyle.Loop || item == mxEdgeStyle.ElbowConnector || item == mxEdgeStyle.SideToSide || item == mxEdgeStyle.TopToBottom ? this.createElbowEdgeHandler(a) : item == mxEdgeStyle.SegmentConnector || item == mxEdgeStyle.OrthConnector ? this.createEdgeSegmentHandler(a) : new mxEdgeHandler(a);
};
/**
 * @param {!Object} strip1
 * @return {?}
 */
mxGraph.prototype.createEdgeSegmentHandler = function(strip1) {
  return new mxEdgeSegmentHandler(strip1);
};
/**
 * @param {!Object} strip1
 * @return {?}
 */
mxGraph.prototype.createElbowEdgeHandler = function(strip1) {
  return new mxElbowEdgeHandler(strip1);
};
/**
 * @param {?} callback
 * @return {undefined}
 */
mxGraph.prototype.addMouseListener = function(callback) {
  if (null == this.mouseListeners) {
    /** @type {!Array} */
    this.mouseListeners = [];
  }
  this.mouseListeners.push(callback);
};
/**
 * @param {?} value
 * @return {undefined}
 */
mxGraph.prototype.removeMouseListener = function(value) {
  if (null != this.mouseListeners) {
    /** @type {number} */
    var i = 0;
    for (; i < this.mouseListeners.length; i++) {
      if (this.mouseListeners[i] == value) {
        this.mouseListeners.splice(i, 1);
        break;
      }
    }
  }
};
/**
 * @param {!Object} me
 * @param {number} evtName
 * @return {?}
 */
mxGraph.prototype.updateMouseEvent = function(me, evtName) {
  if (null == me.graphX || null == me.graphY) {
    var pt = mxUtils.convertPoint(this.container, me.getX(), me.getY());
    /** @type {number} */
    me.graphX = pt.x - this.panDx;
    /** @type {number} */
    me.graphY = pt.y - this.panDy;
    if (null == me.getCell() && this.isMouseDown && evtName == mxEvent.MOUSE_MOVE) {
      me.state = this.view.getState(this.getCellAt(pt.x, pt.y, null, null, null, function(cell) {
        return null == cell.shape || cell.shape.paintBackground != mxRectangleShape.prototype.paintBackground || "1" == mxUtils.getValue(cell.style, mxConstants.STYLE_POINTER_EVENTS, "1") || null != cell.shape.fill && cell.shape.fill != mxConstants.NONE;
      }));
    }
  }
  return me;
};
/**
 * @param {!Array} evt
 * @return {?}
 */
mxGraph.prototype.getStateForTouchEvent = function(evt) {
  var pt = mxEvent.getClientX(evt);
  evt = mxEvent.getClientY(evt);
  pt = mxUtils.convertPoint(this.container, pt, evt);
  return this.view.getState(this.getCellAt(pt.x, pt.y));
};
/**
 * @param {?} evtName
 * @param {!Object} me
 * @param {!Object} val
 * @return {?}
 */
mxGraph.prototype.isEventIgnored = function(evtName, me, val) {
  var d = mxEvent.isMouseEvent(me.getEvent());
  /** @type {boolean} */
  var b = false;
  if (me.getEvent() == this.lastEvent) {
    /** @type {boolean} */
    b = true;
  } else {
    this.lastEvent = me.getEvent();
  }
  if (null != this.eventSource && evtName != mxEvent.MOUSE_MOVE) {
    mxEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
    /** @type {null} */
    this.eventSource = this.mouseUpRedirect = this.mouseMoveRedirect = null;
  } else {
    if (!mxClient.IS_GC && null != this.eventSource && me.getSource() != this.eventSource) {
      /** @type {boolean} */
      b = true;
    } else {
      if (mxClient.IS_TOUCH && evtName == mxEvent.MOUSE_DOWN && !d && !mxEvent.isPenEvent(me.getEvent())) {
        this.eventSource = me.getSource();
        /** @type {null} */
        var pointerId = null;
        if (!(!mxClient.IS_ANDROID && mxClient.IS_LINUX && mxClient.IS_GC)) {
          pointerId = me.getEvent().pointerId;
        }
        this.mouseMoveRedirect = mxUtils.bind(this, function(event) {
          if (!(null != pointerId && event.pointerId != pointerId)) {
            this.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(event, this.getStateForTouchEvent(event)));
          }
        });
        this.mouseUpRedirect = mxUtils.bind(this, function(evt) {
          this.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, this.getStateForTouchEvent(evt)));
          /** @type {null} */
          pointerId = null;
        });
        mxEvent.addGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
      }
    }
  }
  if (this.isSyntheticEventIgnored(evtName, me, val)) {
    /** @type {boolean} */
    b = true;
  }
  if (!mxEvent.isPopupTrigger(this.lastEvent) && evtName != mxEvent.MOUSE_MOVE && 2 == this.lastEvent.detail) {
    return true;
  }
  if (evtName == mxEvent.MOUSE_UP && this.isMouseDown) {
    /** @type {boolean} */
    this.isMouseDown = false;
  } else {
    if (evtName != mxEvent.MOUSE_DOWN || this.isMouseDown) {
      if (!b && ((!mxClient.IS_FF || evtName != mxEvent.MOUSE_MOVE) && this.isMouseDown && this.isMouseTrigger != d || evtName == mxEvent.MOUSE_DOWN && this.isMouseDown || evtName == mxEvent.MOUSE_UP && !this.isMouseDown)) {
        /** @type {boolean} */
        b = true;
      }
    } else {
      /** @type {boolean} */
      this.isMouseDown = true;
      this.isMouseTrigger = d;
    }
  }
  if (!(b || evtName != mxEvent.MOUSE_DOWN)) {
    this.lastMouseX = me.getX();
    this.lastMouseY = me.getY();
  }
  return b;
};
/**
 * @param {?} evtName
 * @param {!Object} type
 * @param {boolean} shapeTypes
 * @return {?}
 */
mxGraph.prototype.isSyntheticEventIgnored = function(evtName, type, shapeTypes) {
  /** @type {boolean} */
  shapeTypes = false;
  type = mxEvent.isMouseEvent(type.getEvent());
  if (this.ignoreMouseEvents && type && evtName != mxEvent.MOUSE_MOVE) {
    /** @type {boolean} */
    this.ignoreMouseEvents = evtName != mxEvent.MOUSE_UP;
    /** @type {boolean} */
    shapeTypes = true;
  } else {
    if (mxClient.IS_FF && !type && evtName == mxEvent.MOUSE_UP) {
      /** @type {boolean} */
      this.ignoreMouseEvents = true;
    }
  }
  return shapeTypes;
};
/**
 * @param {number} evtName
 * @param {!Object} me
 * @return {?}
 */
mxGraph.prototype.isEventSourceIgnored = function(evtName, me) {
  var self = me.getSource();
  var type = null != self.nodeName ? self.nodeName.toLowerCase() : "";
  me = !mxEvent.isMouseEvent(me.getEvent()) || mxEvent.isLeftMouseButton(me.getEvent());
  return evtName == mxEvent.MOUSE_DOWN && me && ("select" == type || "option" == type || "input" == type && "checkbox" != self.type && "radio" != self.type && "button" != self.type && "submit" != self.type && "file" != self.type);
};
/**
 * @param {?} childType
 * @return {?}
 */
mxGraph.prototype.getEventState = function(childType) {
  return childType;
};
/**
 * @param {number} evtName
 * @param {!Object} me
 * @return {?}
 */
mxGraph.prototype.isPointerEventIgnored = function(evtName, me) {
  /** @type {boolean} */
  var c = false;
  if (mxClient.IS_ANDROID || !mxClient.IS_LINUX || !mxClient.IS_GC) {
    var identifier = me.getEvent().pointerId;
    if (evtName == mxEvent.MOUSE_DOWN) {
      if (null != this.currentPointerId && this.currentPointerId != identifier) {
        /** @type {boolean} */
        c = true;
      } else {
        if (null == this.currentPointerId) {
          this.currentPointerId = me.getEvent().pointerId;
        }
      }
    } else {
      if (evtName == mxEvent.MOUSE_MOVE) {
        if (null != this.currentPointerId && this.currentPointerId != identifier) {
          /** @type {boolean} */
          c = true;
        }
      } else {
        if (evtName == mxEvent.MOUSE_UP) {
          /** @type {null} */
          this.currentPointerId = null;
        }
      }
    }
  }
  return c;
};
/**
 * @param {number} evtName
 * @param {!Object} me
 * @param {!Object} type
 * @return {undefined}
 */
mxGraph.prototype.fireMouseEvent = function(evtName, me, type) {
  if (this.isEventSourceIgnored(evtName, me)) {
    if (null != this.tooltipHandler) {
      this.tooltipHandler.hide();
    }
  } else {
    if (this.isPointerEventIgnored(evtName, me)) {
      /** @type {boolean} */
      this.tapAndHoldValid = false;
    } else {
      if (null == type) {
        type = this;
      }
      me = this.updateMouseEvent(me, evtName);
      if (!this.nativeDblClickEnabled && !mxEvent.isPopupTrigger(me.getEvent()) || this.doubleTapEnabled && mxClient.IS_TOUCH && (mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent()))) {
        /** @type {number} */
        var zoom = (new Date).getTime();
        if (evtName == mxEvent.MOUSE_DOWN) {
          if (null != this.lastTouchEvent && this.lastTouchEvent != me.getEvent() && zoom - this.lastTouchTime < this.doubleTapTimeout && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance && 2 > this.doubleClickCounter) {
            if (this.doubleClickCounter++, zoom = false, evtName == mxEvent.MOUSE_UP ? me.getCell() == this.lastTouchCell && null != this.lastTouchCell && (this.lastTouchTime = 0, zoom = this.lastTouchCell, this.lastTouchCell = null, this.dblClick(me.getEvent(), zoom), zoom = true) : (this.fireDoubleClick = true, this.lastTouchTime = 0), zoom) {
              mxEvent.consume(me.getEvent());
              return;
            }
          } else {
            if (null == this.lastTouchEvent || this.lastTouchEvent != me.getEvent()) {
              this.lastTouchCell = me.getCell();
              this.lastTouchX = me.getX();
              this.lastTouchY = me.getY();
              /** @type {number} */
              this.lastTouchTime = zoom;
              this.lastTouchEvent = me.getEvent();
              /** @type {number} */
              this.doubleClickCounter = 0;
            }
          }
        } else {
          if ((this.isMouseDown || evtName == mxEvent.MOUSE_UP) && this.fireDoubleClick) {
            /** @type {boolean} */
            this.fireDoubleClick = false;
            zoom = this.lastTouchCell;
            /** @type {null} */
            this.lastTouchCell = null;
            /** @type {boolean} */
            this.isMouseDown = false;
            if ((null != zoom || (mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())) && (mxClient.IS_GC || mxClient.IS_SF)) && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance) {
              this.dblClick(me.getEvent(), zoom);
            } else {
              mxEvent.consume(me.getEvent());
            }
            return;
          }
        }
      }
      if (!this.isEventIgnored(evtName, me, type)) {
        me.state = this.getEventState(me.getState());
        this.fireEvent(new mxEventObject(mxEvent.FIRE_MOUSE_EVENT, "eventName", evtName, "event", me));
        if (mxClient.IS_OP || mxClient.IS_SF || mxClient.IS_GC || mxClient.IS_IE11 || mxClient.IS_IE && mxClient.IS_SVG || me.getEvent().target != this.container) {
          if (evtName == mxEvent.MOUSE_MOVE && this.isMouseDown && this.autoScroll && !mxEvent.isMultiTouchEvent(me.getEvent)) {
            this.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.autoExtend);
          } else {
            if (evtName == mxEvent.MOUSE_UP && this.ignoreScrollbars && this.translateToScrollPosition && (0 != this.container.scrollLeft || 0 != this.container.scrollTop)) {
              zoom = this.view.scale;
              var p = this.view.translate;
              this.view.setTranslate(p.x - this.container.scrollLeft / zoom, p.y - this.container.scrollTop / zoom);
              /** @type {number} */
              this.container.scrollLeft = 0;
              /** @type {number} */
              this.container.scrollTop = 0;
            }
          }
          if (null != this.mouseListeners) {
            /** @type {!Array} */
            zoom = [type, me];
            if (!me.getEvent().preventDefault) {
              /** @type {boolean} */
              me.getEvent().returnValue = true;
            }
            /** @type {number} */
            p = 0;
            for (; p < this.mouseListeners.length; p++) {
              var o = this.mouseListeners[p];
              if (evtName == mxEvent.MOUSE_DOWN) {
                o.mouseDown.apply(o, zoom);
              } else {
                if (evtName == mxEvent.MOUSE_MOVE) {
                  o.mouseMove.apply(o, zoom);
                } else {
                  if (evtName == mxEvent.MOUSE_UP) {
                    o.mouseUp.apply(o, zoom);
                  }
                }
              }
            }
          }
          if (evtName == mxEvent.MOUSE_UP) {
            this.click(me);
          }
        }
        if ((mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())) && evtName == mxEvent.MOUSE_DOWN && this.tapAndHoldEnabled && !this.tapAndHoldInProgress) {
          /** @type {boolean} */
          this.tapAndHoldInProgress = true;
          this.initialTouchX = me.getGraphX();
          this.initialTouchY = me.getGraphY();
          if (this.tapAndHoldThread) {
            window.clearTimeout(this.tapAndHoldThread);
          }
          this.tapAndHoldThread = window.setTimeout(mxUtils.bind(this, function() {
            if (this.tapAndHoldValid) {
              this.tapAndHold(me);
            }
            /** @type {boolean} */
            this.tapAndHoldValid = this.tapAndHoldInProgress = false;
          }), this.tapAndHoldDelay);
          /** @type {boolean} */
          this.tapAndHoldValid = true;
        } else {
          if (evtName == mxEvent.MOUSE_UP) {
            /** @type {boolean} */
            this.tapAndHoldValid = this.tapAndHoldInProgress = false;
          } else {
            if (this.tapAndHoldValid) {
              /** @type {boolean} */
              this.tapAndHoldValid = Math.abs(this.initialTouchX - me.getGraphX()) < this.tolerance && Math.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;
            }
          }
        }
        if (evtName == mxEvent.MOUSE_DOWN && this.isEditing() && !this.cellEditor.isEventSource(me.getEvent())) {
          this.stopEditing(!this.isInvokesStopCellEditing());
        }
        this.consumeMouseEvent(evtName, me, type);
      }
    }
  }
};
/**
 * @param {number} evtName
 * @param {!Event} me
 * @param {!Object} value
 * @return {undefined}
 */
mxGraph.prototype.consumeMouseEvent = function(evtName, me, value) {
  if (evtName == mxEvent.MOUSE_DOWN && mxEvent.isTouchEvent(me.getEvent())) {
    me.consume(false);
  }
};
/**
 * @param {number} edit
 * @param {boolean} text
 * @return {undefined}
 */
mxGraph.prototype.fireGestureEvent = function(edit, text) {
  /** @type {number} */
  this.lastTouchTime = 0;
  this.fireEvent(new mxEventObject(mxEvent.GESTURE, "event", edit, "cell", text));
};
/**
 * @return {undefined}
 */
mxGraph.prototype.destroy = function() {
  if (!this.destroyed) {
    /** @type {boolean} */
    this.destroyed = true;
    if (null != this.tooltipHandler) {
      this.tooltipHandler.destroy();
    }
    if (null != this.selectionCellsHandler) {
      this.selectionCellsHandler.destroy();
    }
    if (null != this.panningHandler) {
      this.panningHandler.destroy();
    }
    if (null != this.popupMenuHandler) {
      this.popupMenuHandler.destroy();
    }
    if (null != this.connectionHandler) {
      this.connectionHandler.destroy();
    }
    if (null != this.graphHandler) {
      this.graphHandler.destroy();
    }
    if (null != this.cellEditor) {
      this.cellEditor.destroy();
    }
    if (null != this.view) {
      this.view.destroy();
    }
    if (null != this.model && null != this.graphModelChangeListener) {
      this.model.removeListener(this.graphModelChangeListener);
      /** @type {null} */
      this.graphModelChangeListener = null;
    }
    /** @type {null} */
    this.container = null;
  }
};
/**
 * @param {string} image
 * @param {string} tooltip
 * @param {string} data
 * @param {string} path
 * @param {string} len
 * @param {string} iotype
 * @return {undefined}
 */
function mxCellOverlay(image, tooltip, data, path, len, iotype) {
  /** @type {string} */
  this.image = image;
  /** @type {string} */
  this.tooltip = tooltip;
  this.align = null != data ? data : this.align;
  this.verticalAlign = null != path ? path : this.verticalAlign;
  this.offset = null != len ? len : new mxPoint;
  this.cursor = null != iotype ? iotype : "help";
}
mxCellOverlay.prototype = new mxEventSource;
/** @type {function(string, string, string, string, string, string): undefined} */
mxCellOverlay.prototype.constructor = mxCellOverlay;
/** @type {null} */
mxCellOverlay.prototype.image = null;
/** @type {null} */
mxCellOverlay.prototype.tooltip = null;
/** @type {string} */
mxCellOverlay.prototype.align = mxConstants.ALIGN_RIGHT;
/** @type {string} */
mxCellOverlay.prototype.verticalAlign = mxConstants.ALIGN_BOTTOM;
/** @type {null} */
mxCellOverlay.prototype.offset = null;
/** @type {null} */
mxCellOverlay.prototype.cursor = null;
/** @type {number} */
mxCellOverlay.prototype.defaultOverlap = .5;
/**
 * @param {!Object} state
 * @return {?}
 */
mxCellOverlay.prototype.getBounds = function(state) {
  var data = state.view.graph.getModel().isEdge(state.cell);
  var scale = state.view.scale;
  var width = this.image.width;
  var height = this.image.height;
  if (data) {
    if (data = state.absolutePoints, 1 == data.length % 2) {
      data = data[Math.floor(data.length / 2)];
    } else {
      /** @type {number} */
      var j = data.length / 2;
      state = data[j - 1];
      data = data[j];
      data = new mxPoint(state.x + (data.x - state.x) / 2, state.y + (data.y - state.y) / 2);
    }
  } else {
    data = new mxPoint;
    data.x = this.align == mxConstants.ALIGN_LEFT ? state.x : this.align == mxConstants.ALIGN_CENTER ? state.x + state.width / 2 : state.x + state.width;
    data.y = this.verticalAlign == mxConstants.ALIGN_TOP ? state.y : this.verticalAlign == mxConstants.ALIGN_MIDDLE ? state.y + state.height / 2 : state.y + state.height;
  }
  return new mxRectangle(Math.round(data.x - (width * this.defaultOverlap - this.offset.x) * scale), Math.round(data.y - (height * this.defaultOverlap - this.offset.y) * scale), width * scale, height * scale);
};
/**
 * @return {?}
 */
mxCellOverlay.prototype.toString = function() {
  return this.tooltip;
};
/**
 * @param {string} out
 * @param {!Element} a
 * @return {undefined}
 */
function mxOutline(out, a) {
  /** @type {string} */
  this.source = out;
  if (null != a) {
    this.init(a);
  }
}
/** @type {null} */
mxOutline.prototype.source = null;
/** @type {null} */
mxOutline.prototype.container = null;
/** @type {boolean} */
mxOutline.prototype.enabled = true;
/** @type {boolean} */
mxOutline.prototype.suspended = false;
/** @type {number} */
mxOutline.prototype.border = 14;
/** @type {number} */
mxOutline.prototype.opacity = mxClient.IS_IE11 ? .9 : .7;
/**
 * @param {!Object} el
 * @return {undefined}
 */
mxOutline.prototype.init = function(el) {
  /** @type {!Object} */
  this.container = el;
  this.updateHandler = mxUtils.bind(this, function(b, canCreateDiscussions) {
    this.update(true);
  });
  this.source.getModel().addListener(mxEvent.CHANGE, this.updateHandler);
  this.source.addListener(mxEvent.REFRESH, this.updateHandler);
  el = this.source.getView();
  el.addListener(mxEvent.UP, this.updateHandler);
  el.addListener(mxEvent.DOWN, this.updateHandler);
  el.addListener(mxEvent.SCALE, this.updateHandler);
  el.addListener(mxEvent.TRANSLATE, this.updateHandler);
  el.addListener(mxEvent.SCALE_AND_TRANSLATE, this.updateHandler);
  this.scrollHandler = mxUtils.bind(this, function(b, canCreateDiscussions) {
    this.update(false);
  });
  mxEvent.addListener(this.source.container, "scroll", this.scrollHandler);
  this.source.addListener(mxEvent.PAN, this.scrollHandler);
  this.update(true);
};
/**
 * @return {?}
 */
mxOutline.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {boolean} state
 * @return {undefined}
 */
mxOutline.prototype.setEnabled = function(state) {
  /** @type {boolean} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxOutline.prototype.isSuspended = function() {
  return this.suspended;
};
/**
 * @param {boolean} value
 * @return {undefined}
 */
mxOutline.prototype.setSuspended = function(value) {
  /** @type {boolean} */
  this.suspended = value;
  this.update(true);
};
/**
 * @return {?}
 */
mxOutline.prototype.isScrolling = function() {
  return this.source.useScrollbarsForPanning && mxUtils.hasScrollbars(this.source.container);
};
/**
 * @return {?}
 */
mxOutline.prototype.createSvg = function() {
  /** @type {!Element} */
  var el = document.createElementNS(mxConstants.NS_SVG, "svg");
  /** @type {string} */
  el.style.position = "absolute";
  /** @type {string} */
  el.style.left = "0px";
  /** @type {string} */
  el.style.top = "0px";
  /** @type {string} */
  el.style.width = "100%";
  /** @type {string} */
  el.style.height = "100%";
  /** @type {string} */
  el.style.display = "block";
  /** @type {string} */
  el.style.padding = this.border + "px";
  /** @type {string} */
  el.style.boxSizing = "border-box";
  /** @type {string} */
  el.style.overflow = "visible";
  /** @type {string} */
  el.style.cursor = "default";
  el.setAttribute("shape-rendering", "optimizeSpeed");
  el.setAttribute("image-rendering", "optimizeSpeed");
  return el;
};
/**
 * @param {!Object} node
 * @return {undefined}
 */
mxOutline.prototype.addGestureListeners = function(node) {
  /** @type {null} */
  var start = null;
  /** @type {number} */
  var x = 0;
  /** @type {number} */
  var y = 0;
  /** @type {number} */
  var ratio = 1;
  var googleUpdateMode = mxUtils.bind(this, function(e) {
    if (this.isEnabled()) {
      start = new mxPoint(mxEvent.getClientX(e), mxEvent.getClientY(e));
      /** @type {number} */
      var w = node.clientWidth - 2 * this.border;
      /** @type {number} */
      var d = node.clientHeight - 2 * this.border;
      var rect = this.getViewBox();
      /** @type {number} */
      ratio = Math.max(rect.width / w, rect.height / d);
      if (mxEvent.getSource(e) != this.viewport) {
        if (this.isScrolling()) {
          /** @type {number} */
          w = w - rect.width / ratio;
          /** @type {number} */
          d = d - rect.height / ratio;
          var anchorBoundingBoxViewport = this.svg.getBoundingClientRect();
          /** @type {number} */
          this.source.container.scrollLeft = rect.x - w * ratio / 2 + (start.x - this.border - anchorBoundingBoxViewport.left) * ratio;
          /** @type {number} */
          this.source.container.scrollTop = rect.y - d * ratio / 2 + (start.y - this.border - anchorBoundingBoxViewport.top) * ratio;
        } else {
          rect = this.source.view.translate;
          d = this.viewport.getBoundingClientRect();
          /** @type {number} */
          w = (mxEvent.getClientX(e) - d.left) * ratio / this.source.view.scale;
          /** @type {number} */
          d = (mxEvent.getClientY(e) - d.top) * ratio / this.source.view.scale;
          this.source.getView().setTranslate(rect.x - w, rect.y - d);
          this.source.panGraph(0, 0);
        }
      }
      mxEvent.addGestureListeners(document, null, update, trialCounter);
      x = this.source.container.scrollLeft;
      y = this.source.container.scrollTop;
      mxEvent.consume(e);
    }
  });
  var update = mxUtils.bind(this, function(e) {
    if (this.isEnabled() && null != start) {
      if (this.isScrolling()) {
        this.source.container.scrollLeft = x + (mxEvent.getClientX(e) - start.x) * ratio;
        this.source.container.scrollTop = y + (mxEvent.getClientY(e) - start.y) * ratio;
      } else {
        this.source.panGraph((start.x - mxEvent.getClientX(e)) * ratio, (start.y - mxEvent.getClientY(e)) * ratio);
      }
      mxEvent.consume(e);
    }
  });
  var trialCounter = mxUtils.bind(this, function(e) {
    if (this.isEnabled() && null != start) {
      if (!this.isScrolling()) {
        /** @type {number} */
        var tmp2 = (mxEvent.getClientX(e) - start.x) * ratio / this.source.view.scale;
        /** @type {number} */
        var tmp1 = (mxEvent.getClientY(e) - start.y) * ratio / this.source.view.scale;
        var limitPoint = this.source.view.translate;
        this.source.getView().setTranslate(limitPoint.x - tmp2, limitPoint.y - tmp1);
        this.source.panGraph(0, 0);
      }
      mxEvent.removeGestureListeners(document, null, update, trialCounter);
      mxEvent.consume(e);
      /** @type {null} */
      start = null;
    }
  });
  mxEvent.addGestureListeners(node, googleUpdateMode, update, trialCounter);
};
/**
 * @return {?}
 */
mxOutline.prototype.getViewBox = function() {
  return this.source.getGraphBounds();
};
/**
 * @return {undefined}
 */
mxOutline.prototype.updateSvg = function() {
  if (null == this.svg) {
    this.svg = this.createSvg();
    this.addGestureListeners(this.svg);
    this.container.appendChild(this.svg);
  }
  var value = this.getViewBox();
  this.svg.setAttribute("viewBox", Math.round(value.x) + " " + Math.round(value.y) + " " + Math.round(value.width) + " " + Math.round(value.height));
  value = this.source.background;
  this.svg.style.backgroundColor = value == mxConstants.NONE ? "" : value;
  this.updateDrawPane();
};
/**
 * @return {undefined}
 */
mxOutline.prototype.updateDrawPane = function() {
  if (null != this.drawPane) {
    this.drawPane.parentNode.removeChild(this.drawPane);
  }
  this.drawPane = this.source.view.getDrawPane().cloneNode(true);
  this.drawPane.style.opacity = this.opacity;
  this.processSvg(this.drawPane);
  if (null != this.viewport) {
    this.svg.insertBefore(this.drawPane, this.viewport);
  } else {
    this.svg.appendChild(this.drawPane);
  }
};
/**
 * @param {!Node} theaterEl
 * @return {undefined}
 */
mxOutline.prototype.processSvg = function(theaterEl) {
  var f = mxClient.IS_IE11 ? Math.max(1, this.source.view.scale) : this.source.view.scale;
  Array.prototype.slice.call(theaterEl.getElementsByTagName("*")).forEach(mxUtils.bind(this, function(node) {
    if ("text" != node.nodeName && "foreignObject" != node.nodeName && "hidden" != node.getAttribute("visibility") && node instanceof SVGElement) {
      /** @type {number} */
      var maxHeight = parseInt(node.getAttribute("stroke-width") || 1);
      if (!isNaN(maxHeight)) {
        node.setAttribute("stroke-width", Math.max(mxClient.IS_IE11 ? 4 : 1, maxHeight / (5 * f)));
      }
      node.setAttribute("vector-effect", "non-scaling-stroke");
      /** @type {string} */
      node.style.cursor = "";
    } else {
      node.parentNode.removeChild(node);
    }
  }));
};
/**
 * @return {undefined}
 */
mxOutline.prototype.updateViewport = function() {
  if (null != this.svg) {
    if (null == this.viewport) {
      this.viewport = this.createViewport();
      this.svg.appendChild(this.viewport);
    }
    var table = this.source.container;
    table = new mxRectangle(table.scrollLeft, table.scrollTop, table.clientWidth, table.clientHeight);
    if (!this.isScrolling()) {
      /** @type {number} */
      table.x = -this.source.panDx;
      /** @type {number} */
      table.y = -this.source.panDy;
    }
    this.viewport.setAttribute("x", table.x);
    this.viewport.setAttribute("y", table.y);
    this.viewport.setAttribute("width", table.width);
    this.viewport.setAttribute("height", table.height);
  }
};
/**
 * @return {?}
 */
mxOutline.prototype.createViewport = function() {
  var node = this.svg.ownerDocument.createElementNS(mxConstants.NS_SVG, "rect");
  node.setAttribute("stroke-width", mxClient.IS_IE11 ? "12" : "3");
  node.setAttribute("stroke", HoverIcons.prototype.arrowFill);
  node.setAttribute("fill", HoverIcons.prototype.arrowFill);
  node.setAttribute("vector-effect", "non-scaling-stroke");
  node.setAttribute("fill-opacity", .2);
  /** @type {string} */
  node.style.cursor = "move";
  return node;
};
/**
 * @param {boolean} e
 * @return {undefined}
 */
mxOutline.prototype.update = function(e) {
  if (null != this.source && null != this.source.container) {
    if (null != this.thread) {
      window.clearTimeout(this.thread);
      /** @type {null} */
      this.thread = null;
    }
    this.fullUpdate = this.fullUpdate || e;
    this.thread = window.setTimeout(mxUtils.bind(this, function() {
      if (!this.isSuspended()) {
        if (this.fullUpdate) {
          this.updateSvg();
        }
        this.updateViewport();
      }
      /** @type {null} */
      this.thread = this.fullUpdate = null;
    }), this.isScrolling() ? 10 : 0);
  }
};
/**
 * @return {undefined}
 */
mxOutline.prototype.destroy = function() {
  if (null != this.svg) {
    this.svg.parentNode.removeChild(this.svg);
    /** @type {null} */
    this.svg = null;
  }
  if (null != this.source) {
    this.source.removeListener(this.updateHandler);
    this.source.getView().removeListener(this.updateHandler);
    this.source.getModel().removeListener(this.updateHandler);
    this.source.removeListener(mxEvent.PAN, this.scrollHandler);
    mxEvent.removeListener(this.source.container, "scroll", this.scrollHandler);
    /** @type {null} */
    this.source = null;
  }
};
/**
 * @param {string} data
 * @param {string} tag
 * @param {string} attrName
 * @param {!Object} value
 * @param {number} min
 * @param {string} max
 * @param {!Object} initialValue
 * @param {!Object} name
 * @param {!Object} key
 * @param {?} optModifiers
 * @return {undefined}
 */
function mxMultiplicity(data, tag, attrName, value, min, max, initialValue, name, key, optModifiers) {
  /** @type {string} */
  this.source = data;
  /** @type {string} */
  this.type = tag;
  /** @type {string} */
  this.attr = attrName;
  /** @type {!Object} */
  this.value = value;
  this.min = null != min ? min : 0;
  this.max = null != max ? max : "n";
  /** @type {!Object} */
  this.validNeighbors = initialValue;
  this.countError = mxResources.get(name) || name;
  this.typeError = mxResources.get(key) || key;
  this.validNeighborsAllowed = null != optModifiers ? optModifiers : true;
}
/** @type {null} */
mxMultiplicity.prototype.type = null;
/** @type {null} */
mxMultiplicity.prototype.attr = null;
/** @type {null} */
mxMultiplicity.prototype.value = null;
/** @type {null} */
mxMultiplicity.prototype.source = null;
/** @type {null} */
mxMultiplicity.prototype.min = null;
/** @type {null} */
mxMultiplicity.prototype.max = null;
/** @type {null} */
mxMultiplicity.prototype.validNeighbors = null;
/** @type {boolean} */
mxMultiplicity.prototype.validNeighborsAllowed = true;
/** @type {null} */
mxMultiplicity.prototype.countError = null;
/** @type {null} */
mxMultiplicity.prototype.typeError = null;
/**
 * @param {!Object} element
 * @param {string} t
 * @param {!Object} f
 * @param {!Object} s
 * @param {?} v
 * @param {?} n
 * @return {?}
 */
mxMultiplicity.prototype.check = function(element, t, f, s, v, n) {
  /** @type {string} */
  var coreCourseInvalidMessages = "";
  if (this.source && this.checkTerminal(element, f, t) || !this.source && this.checkTerminal(element, s, t)) {
    if (null != this.countError && (this.source && (0 == this.max || v >= this.max) || !this.source && (0 == this.max || n >= this.max))) {
      /** @type {string} */
      coreCourseInvalidMessages = coreCourseInvalidMessages + (this.countError + "\n");
    }
    if (null != this.validNeighbors && null != this.typeError && 0 < this.validNeighbors.length) {
      if (!this.checkNeighbors(element, t, f, s)) {
        /** @type {string} */
        coreCourseInvalidMessages = coreCourseInvalidMessages + (this.typeError + "\n");
      }
    }
  }
  return 0 < coreCourseInvalidMessages.length ? coreCourseInvalidMessages : null;
};
/**
 * @param {!Object} element
 * @param {string} file
 * @param {!Object} i
 * @param {!Object} s
 * @return {?}
 */
mxMultiplicity.prototype.checkNeighbors = function(element, file, i, s) {
  file = element.model.getValue(i);
  s = element.model.getValue(s);
  /** @type {boolean} */
  i = !this.validNeighborsAllowed;
  var spheres = this.validNeighbors;
  /** @type {number} */
  var iter_sph = 0;
  for (; iter_sph < spheres.length; iter_sph++) {
    if (this.source && this.checkType(element, s, spheres[iter_sph])) {
      i = this.validNeighborsAllowed;
      break;
    } else {
      if (!this.source && this.checkType(element, file, spheres[iter_sph])) {
        i = this.validNeighborsAllowed;
        break;
      }
    }
  }
  return i;
};
/**
 * @param {!Object} obj
 * @param {!Object} item
 * @param {string} size
 * @return {?}
 */
mxMultiplicity.prototype.checkTerminal = function(obj, item, size) {
  item = obj.model.getValue(item);
  return this.checkType(obj, item, this.type, this.attr, this.value);
};
/**
 * @param {!Object} t
 * @param {!Object} data
 * @param {undefined} value
 * @param {string} arg
 * @param {?} type
 * @return {?}
 */
mxMultiplicity.prototype.checkType = function(t, data, value, arg, type) {
  return null != data ? isNaN(data.nodeType) ? data == value : mxUtils.isNode(data, value, arg, type) : false;
};
/**
 * @param {!Object} vScale
 * @return {undefined}
 */
function mxLayoutManager(vScale) {
  this.undoHandler = mxUtils.bind(this, function(b, link) {
    if (this.isEnabled()) {
      this.beforeUndo(link.getProperty("edit"));
    }
  });
  this.moveHandler = mxUtils.bind(this, function(b, utils) {
    if (this.isEnabled()) {
      this.cellsMoved(utils.getProperty("cells"), utils.getProperty("event"));
    }
  });
  this.resizeHandler = mxUtils.bind(this, function(b, self) {
    if (this.isEnabled()) {
      this.cellsResized(self.getProperty("cells"), self.getProperty("bounds"), self.getProperty("previous"));
    }
  });
  this.setGraph(vScale);
}
mxLayoutManager.prototype = new mxEventSource;
/** @type {function(!Object): undefined} */
mxLayoutManager.prototype.constructor = mxLayoutManager;
/** @type {null} */
mxLayoutManager.prototype.graph = null;
/** @type {boolean} */
mxLayoutManager.prototype.bubbling = true;
/** @type {boolean} */
mxLayoutManager.prototype.enabled = true;
/** @type {null} */
mxLayoutManager.prototype.undoHandler = null;
/** @type {null} */
mxLayoutManager.prototype.moveHandler = null;
/** @type {null} */
mxLayoutManager.prototype.resizeHandler = null;
/**
 * @return {?}
 */
mxLayoutManager.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxLayoutManager.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxLayoutManager.prototype.isBubbling = function() {
  return this.bubbling;
};
/**
 * @param {!Object} a
 * @return {undefined}
 */
mxLayoutManager.prototype.setBubbling = function(a) {
  /** @type {!Object} */
  this.bubbling = a;
};
/**
 * @return {?}
 */
mxLayoutManager.prototype.getGraph = function() {
  return this.graph;
};
/**
 * @param {!Object} gf
 * @return {undefined}
 */
mxLayoutManager.prototype.setGraph = function(gf) {
  if (null != this.graph) {
    var undoMgr = this.graph.getModel();
    undoMgr.removeListener(this.undoHandler);
    this.graph.removeListener(this.moveHandler);
    this.graph.removeListener(this.resizeHandler);
  }
  /** @type {!Object} */
  this.graph = gf;
  if (null != this.graph) {
    undoMgr = this.graph.getModel();
    undoMgr.addListener(mxEvent.BEFORE_UNDO, this.undoHandler);
    this.graph.addListener(mxEvent.MOVE_CELLS, this.moveHandler);
    this.graph.addListener(mxEvent.RESIZE_CELLS, this.resizeHandler);
  }
};
/**
 * @param {!Object} content
 * @return {?}
 */
mxLayoutManager.prototype.hasLayout = function(content) {
  return null != this.getLayout(content, mxEvent.LAYOUT_CELLS);
};
/**
 * @param {!Object} i
 * @param {?} arr
 * @return {?}
 */
mxLayoutManager.prototype.getLayout = function(i, arr) {
  return null;
};
/**
 * @param {!Object} memberChangeInfo
 * @return {undefined}
 */
mxLayoutManager.prototype.beforeUndo = function(memberChangeInfo) {
  this.executeLayoutForCells(this.getCellsForChanges(memberChangeInfo.changes));
};
/**
 * @param {string} cells
 * @param {number} evt
 * @return {undefined}
 */
mxLayoutManager.prototype.cellsMoved = function(cells, evt) {
  if (null != cells && null != evt) {
    evt = mxUtils.convertPoint(this.getGraph().container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
    var me = this.getGraph().getModel();
    /** @type {number} */
    var i = 0;
    for (; i < cells.length; i++) {
      var _this = this.getLayout(me.getParent(cells[i]), mxEvent.MOVE_CELLS);
      if (null != _this) {
        _this.moveCell(cells[i], evt.x, evt.y);
      }
    }
  }
};
/**
 * @param {!Object} props
 * @param {?} a
 * @param {string} val
 * @return {undefined}
 */
mxLayoutManager.prototype.cellsResized = function(props, a, val) {
  if (null != props && null != a) {
    var vm = this.getGraph().getModel();
    /** @type {number} */
    var i = 0;
    for (; i < props.length; i++) {
      var $ = this.getLayout(vm.getParent(props[i]), mxEvent.RESIZE_CELLS);
      if (null != $) {
        $.resizeCell(props[i], a[i], val[i]);
      }
    }
  }
};
/**
 * @param {!NodeList} set
 * @return {?}
 */
mxLayoutManager.prototype.getCellsForChanges = function(set) {
  /** @type {!Array} */
  var collection = [];
  /** @type {number} */
  var i = 0;
  for (; i < set.length; i++) {
    var change = set[i];
    if (change instanceof mxRootChange) {
      return [];
    }
    /** @type {!Array<?>} */
    collection = collection.concat(this.getCellsForChange(change));
  }
  return collection;
};
/**
 * @param {!Object} change
 * @return {?}
 */
mxLayoutManager.prototype.getCellsForChange = function(change) {
  return change instanceof mxChildChange ? this.addCellsWithLayout(change.child, this.addCellsWithLayout(change.previous)) : change instanceof mxValueChange || change instanceof mxTerminalChange || change instanceof mxGeometryChange || change instanceof mxVisibleChange || change instanceof mxStyleChange ? this.addCellsWithLayout(change.cell) : [];
};
/**
 * @param {!Object} label
 * @param {string} expanded
 * @return {?}
 */
mxLayoutManager.prototype.addCellsWithLayout = function(label, expanded) {
  return this.addDescendantsWithLayout(label, this.addAncestorsWithLayout(label, expanded));
};
/**
 * @param {!Object} i
 * @param {string} level
 * @return {?}
 */
mxLayoutManager.prototype.addAncestorsWithLayout = function(i, level) {
  level = null != level ? level : [];
  if (null != i && (this.hasLayout(i) && level.push(i), this.isBubbling())) {
    var structFragmentOrCtab = this.getGraph().getModel();
    this.addAncestorsWithLayout(structFragmentOrCtab.getParent(i), level);
  }
  return level;
};
/**
 * @param {!Object} node
 * @param {string} min
 * @return {?}
 */
mxLayoutManager.prototype.addDescendantsWithLayout = function(node, min) {
  min = null != min ? min : [];
  if (null != node && this.hasLayout(node)) {
    var menu = this.getGraph().getModel();
    /** @type {number} */
    var i = 0;
    for (; i < menu.getChildCount(node); i++) {
      var message = menu.getChildAt(node, i);
      if (this.hasLayout(message)) {
        min.push(message);
        this.addDescendantsWithLayout(message, min);
      }
    }
  }
  return min;
};
/**
 * @param {!Object} href
 * @return {undefined}
 */
mxLayoutManager.prototype.executeLayoutForCells = function(href) {
  var targetFragment = this.getGraph().getModel();
  targetFragment.beginUpdate();
  try {
    var c = mxUtils.sortCells(href, false);
    this.layoutCells(c, true);
    this.layoutCells(c.reverse(), false);
  } finally {
    targetFragment.endUpdate();
  }
};
/**
 * @param {number} value
 * @param {string} undo
 * @return {undefined}
 */
mxLayoutManager.prototype.layoutCells = function(value, undo) {
  if (0 < value.length) {
    var that = this.getGraph().getModel();
    that.beginUpdate();
    try {
      /** @type {null} */
      var v = null;
      /** @type {number} */
      var i = 0;
      for (; i < value.length; i++) {
        if (value[i] != that.getRoot() && value[i] != v) {
          this.executeLayout(value[i], undo);
          v = value[i];
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.LAYOUT_CELLS, "cells", value));
    } finally {
      that.endUpdate();
    }
  }
};
/**
 * @param {undefined} c
 * @param {!Object} f
 * @return {undefined}
 */
mxLayoutManager.prototype.executeLayout = function(c, f) {
  f = this.getLayout(c, f ? mxEvent.BEGIN_UPDATE : mxEvent.END_UPDATE);
  if (null != f) {
    f.execute(c);
  }
};
/**
 * @return {undefined}
 */
mxLayoutManager.prototype.destroy = function() {
  this.setGraph(null);
};
/**
 * @param {!Object} vScale
 * @param {?} hTrim
 * @param {?} vTrim
 * @param {?} queueUpdate
 * @return {undefined}
 */
function mxSwimlaneManager(vScale, hTrim, vTrim, queueUpdate) {
  this.horizontal = null != hTrim ? hTrim : true;
  this.addEnabled = null != vTrim ? vTrim : true;
  this.resizeEnabled = null != queueUpdate ? queueUpdate : true;
  this.addHandler = mxUtils.bind(this, function(canCreateDiscussions, utils) {
    if (this.isEnabled() && this.isAddEnabled()) {
      this.cellsAdded(utils.getProperty("cells"));
    }
  });
  this.resizeHandler = mxUtils.bind(this, function(canCreateDiscussions, utils) {
    if (this.isEnabled() && this.isResizeEnabled()) {
      this.cellsResized(utils.getProperty("cells"));
    }
  });
  this.setGraph(vScale);
}
mxSwimlaneManager.prototype = new mxEventSource;
/** @type {function(!Object, ?, ?, ?): undefined} */
mxSwimlaneManager.prototype.constructor = mxSwimlaneManager;
/** @type {null} */
mxSwimlaneManager.prototype.graph = null;
/** @type {boolean} */
mxSwimlaneManager.prototype.enabled = true;
/** @type {boolean} */
mxSwimlaneManager.prototype.horizontal = true;
/** @type {boolean} */
mxSwimlaneManager.prototype.addEnabled = true;
/** @type {boolean} */
mxSwimlaneManager.prototype.resizeEnabled = true;
/** @type {null} */
mxSwimlaneManager.prototype.addHandler = null;
/** @type {null} */
mxSwimlaneManager.prototype.resizeHandler = null;
/**
 * @return {?}
 */
mxSwimlaneManager.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {boolean} state
 * @return {undefined}
 */
mxSwimlaneManager.prototype.setEnabled = function(state) {
  /** @type {boolean} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxSwimlaneManager.prototype.isHorizontal = function() {
  return this.horizontal;
};
/**
 * @param {number} string
 * @return {undefined}
 */
mxSwimlaneManager.prototype.setHorizontal = function(string) {
  /** @type {number} */
  this.horizontal = string;
};
/**
 * @return {?}
 */
mxSwimlaneManager.prototype.isAddEnabled = function() {
  return this.addEnabled;
};
/**
 * @param {?} enabled
 * @return {undefined}
 */
mxSwimlaneManager.prototype.setAddEnabled = function(enabled) {
  this.addEnabled = enabled;
};
/**
 * @return {?}
 */
mxSwimlaneManager.prototype.isResizeEnabled = function() {
  return this.resizeEnabled;
};
/**
 * @param {?} enabled
 * @return {undefined}
 */
mxSwimlaneManager.prototype.setResizeEnabled = function(enabled) {
  this.resizeEnabled = enabled;
};
/**
 * @return {?}
 */
mxSwimlaneManager.prototype.getGraph = function() {
  return this.graph;
};
/**
 * @param {!Object} gf
 * @return {undefined}
 */
mxSwimlaneManager.prototype.setGraph = function(gf) {
  if (null != this.graph) {
    this.graph.removeListener(this.addHandler);
    this.graph.removeListener(this.resizeHandler);
  }
  /** @type {!Object} */
  this.graph = gf;
  if (null != this.graph) {
    this.graph.addListener(mxEvent.ADD_CELLS, this.addHandler);
    this.graph.addListener(mxEvent.CELLS_RESIZED, this.resizeHandler);
  }
};
/**
 * @param {!Array} searchElement
 * @return {?}
 */
mxSwimlaneManager.prototype.isSwimlaneIgnored = function(searchElement) {
  return !this.getGraph().isSwimlane(searchElement);
};
/**
 * @param {!Array} value
 * @return {?}
 */
mxSwimlaneManager.prototype.isCellHorizontal = function(value) {
  return this.graph.isSwimlane(value) ? (value = this.graph.getCellStyle(value), 1 == mxUtils.getValue(value, mxConstants.STYLE_HORIZONTAL, 1)) : !this.isHorizontal();
};
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxSwimlaneManager.prototype.cellsAdded = function(obj) {
  if (null != obj) {
    var targetFragment = this.getGraph().getModel();
    targetFragment.beginUpdate();
    try {
      /** @type {number} */
      var i = 0;
      for (; i < obj.length; i++) {
        if (!this.isSwimlaneIgnored(obj[i])) {
          this.swimlaneAdded(obj[i]);
        }
      }
    } finally {
      targetFragment.endUpdate();
    }
  }
};
/**
 * @param {!Arguments} name
 * @return {undefined}
 */
mxSwimlaneManager.prototype.swimlaneAdded = function(name) {
  var item = this.getGraph().getModel();
  var n = item.getParent(name);
  var requestsToPerform = item.getChildCount(n);
  /** @type {null} */
  var handler = null;
  /** @type {number} */
  var i = 0;
  for (; i < requestsToPerform; i++) {
    var fn = item.getChildAt(n, i);
    if (fn != name && !this.isSwimlaneIgnored(fn) && (handler = item.getGeometry(fn), null != handler)) {
      break;
    }
  }
  if (null != handler) {
    item = null != n ? this.isCellHorizontal(n) : this.horizontal;
    this.resizeSwimlane(name, handler.width, handler.height, item);
  }
};
/**
 * @param {!Object} array
 * @return {undefined}
 */
mxSwimlaneManager.prototype.cellsResized = function(array) {
  if (null != array) {
    var me = this.getGraph().getModel();
    me.beginUpdate();
    try {
      /** @type {number} */
      var i = 0;
      for (; i < array.length; i++) {
        if (!this.isSwimlaneIgnored(array[i])) {
          var table = me.getGeometry(array[i]);
          if (null != table) {
            var bounds = new mxRectangle(0, 0, table.width, table.height);
            var l = array[i];
            var n = l;
            for (; null != n;) {
              l = n;
              n = me.getParent(n);
              var fBounds = this.graph.isSwimlane(n) ? this.graph.getStartSize(n) : new mxRectangle;
              bounds.width += fBounds.width;
              bounds.height += fBounds.height;
            }
            var PipeBinding = null != n ? this.isCellHorizontal(n) : this.horizontal;
            this.resizeSwimlane(l, bounds.width, bounds.height, PipeBinding);
          }
        }
      }
    } finally {
      me.endUpdate();
    }
  }
};
/**
 * @param {!Array} i
 * @param {number} width
 * @param {number} height
 * @param {number} k
 * @return {undefined}
 */
mxSwimlaneManager.prototype.resizeSwimlane = function(i, width, height, k) {
  var self = this.getGraph().getModel();
  self.beginUpdate();
  try {
    var n = this.isCellHorizontal(i);
    if (!this.isSwimlaneIgnored(i)) {
      var canvas = self.getGeometry(i);
      if (null != canvas && (k && canvas.height != height || !k && canvas.width != width)) {
        canvas = canvas.clone();
        if (k) {
          /** @type {number} */
          canvas.height = height;
        } else {
          /** @type {number} */
          canvas.width = width;
        }
        self.setGeometry(i, canvas);
      }
    }
    var overflowAdjust = this.graph.isSwimlane(i) ? this.graph.getStartSize(i) : new mxRectangle;
    /** @type {number} */
    width = width - overflowAdjust.width;
    /** @type {number} */
    height = height - overflowAdjust.height;
    var l = self.getChildCount(i);
    /** @type {number} */
    k = 0;
    for (; k < l; k++) {
      var square = self.getChildAt(i, k);
      this.resizeSwimlane(square, width, height, n);
    }
  } finally {
    self.endUpdate();
  }
};
/**
 * @return {undefined}
 */
mxSwimlaneManager.prototype.destroy = function() {
  this.setGraph(null);
};
/**
 * @param {!Object} self
 * @param {!Object} data
 * @param {!Object} range
 * @param {string} callback
 * @param {?} resolve
 * @param {?} validate
 * @return {undefined}
 */
function mxTemporaryCellStates(self, data, range, callback, resolve, validate) {
  data = null != data ? data : 1;
  /** @type {!Object} */
  this.view = self;
  /** @type {function(string, boolean): ?} */
  this.oldValidateCellState = self.validateCellState;
  this.oldBounds = self.getGraphBounds();
  this.oldStates = self.getStates();
  this.oldScale = self.getScale();
  /** @type {function(!Object): undefined} */
  this.oldDoRedrawShape = self.graph.cellRenderer.doRedrawShape;
  var NKScripting = this;
  if (null != resolve) {
    /**
     * @param {!Object} item
     * @return {undefined}
     */
    self.graph.cellRenderer.doRedrawShape = function(item) {
      /** @type {function(!Object): undefined} */
      var paint = item.shape.paint;
      /**
       * @param {!Object} node
       * @return {undefined}
       */
      item.shape.paint = function(node) {
        var value = resolve(item);
        if (null != value) {
          node.setLink(value, null != validate ? validate(item) : null);
        }
        paint.apply(this, arguments);
        if (null != value) {
          node.setLink(null);
        }
      };
      NKScripting.oldDoRedrawShape.apply(self.graph.cellRenderer, arguments);
      /** @type {function(!Object): undefined} */
      item.shape.paint = paint;
    };
  }
  /**
   * @param {string} license
   * @param {boolean} buildingApp
   * @return {?}
   */
  self.validateCellState = function(license, buildingApp) {
    return null == license || null == callback || callback(license) ? NKScripting.oldValidateCellState.apply(self, arguments) : null;
  };
  self.setStates(new mxDictionary);
  self.setScale(data);
  if (null != range) {
    self.resetValidationState();
    /** @type {null} */
    data = null;
    /** @type {number} */
    var index = 0;
    for (; index < range.length; index++) {
      var pattern = self.getBoundingBox(self.validateCellState(self.validateCell(range[index])));
      if (null == data) {
        data = pattern;
      } else {
        data.add(pattern);
      }
    }
    self.setGraphBounds(data || new mxRectangle);
  }
}
/** @type {null} */
mxTemporaryCellStates.prototype.view = null;
/** @type {null} */
mxTemporaryCellStates.prototype.oldStates = null;
/** @type {null} */
mxTemporaryCellStates.prototype.oldBounds = null;
/** @type {null} */
mxTemporaryCellStates.prototype.oldScale = null;
/**
 * @return {undefined}
 */
mxTemporaryCellStates.prototype.destroy = function() {
  this.view.setScale(this.oldScale);
  this.view.setStates(this.oldStates);
  this.view.setGraphBounds(this.oldBounds);
  this.view.validateCellState = this.oldValidateCellState;
  this.view.graph.cellRenderer.doRedrawShape = this.oldDoRedrawShape;
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxCellStatePreview(targetGraph) {
  this.deltas = new mxDictionary;
  /** @type {!Object} */
  this.graph = targetGraph;
}
/** @type {null} */
mxCellStatePreview.prototype.graph = null;
/** @type {null} */
mxCellStatePreview.prototype.deltas = null;
/** @type {number} */
mxCellStatePreview.prototype.count = 0;
/**
 * @return {?}
 */
mxCellStatePreview.prototype.isEmpty = function() {
  return 0 == this.count;
};
/**
 * @param {!Object} state
 * @param {number} x
 * @param {number} y
 * @param {?} duration
 * @param {?} ease
 * @return {?}
 */
mxCellStatePreview.prototype.moveState = function(state, x, y, duration, ease) {
  duration = null != duration ? duration : true;
  ease = null != ease ? ease : true;
  var data = this.deltas.get(state.cell);
  if (null == data) {
    data = {
      point : new mxPoint(x, y),
      state : state
    };
    this.deltas.put(state.cell, data);
    this.count++;
  } else {
    if (duration) {
      data.point.x += x;
      data.point.y += y;
    } else {
      /** @type {number} */
      data.point.x = x;
      /** @type {number} */
      data.point.y = y;
    }
  }
  if (ease) {
    this.addEdges(state);
  }
  return data.point;
};
/**
 * @param {?} result
 * @return {undefined}
 */
mxCellStatePreview.prototype.show = function(result) {
  this.deltas.visit(mxUtils.bind(this, function(b, c) {
    this.translateState(c.state, c.point.x, c.point.y);
  }));
  this.deltas.visit(mxUtils.bind(this, function(b, c) {
    this.revalidateState(c.state, c.point.x, c.point.y, result);
  }));
};
/**
 * @param {!Object} item
 * @param {?} value
 * @param {?} count
 * @return {undefined}
 */
mxCellStatePreview.prototype.translateState = function(item, value, count) {
  if (null != item) {
    var layer = this.graph.getModel();
    if (layer.isVertex(item.cell)) {
      item.view.updateCellState(item);
      var dest = layer.getGeometry(item.cell);
      if (!(0 == value && 0 == count || null == dest || dest.relative && null == this.deltas.get(item.cell))) {
        item.x += value;
        item.y += count;
      }
    }
    dest = layer.getChildCount(item.cell);
    /** @type {number} */
    var i = 0;
    for (; i < dest; i++) {
      this.translateState(item.view.getState(layer.getChildAt(item.cell, i)), value, count);
    }
  }
};
/**
 * @param {!Object} node
 * @param {?} fx
 * @param {?} fy
 * @param {?} selector
 * @return {undefined}
 */
mxCellStatePreview.prototype.revalidateState = function(node, fx, fy, selector) {
  if (null != node) {
    var self = this.graph.getModel();
    if (self.isEdge(node.cell)) {
      node.view.updateCellState(node);
    }
    var dest = this.graph.getCellGeometry(node.cell);
    var i = node.view.getState(self.getParent(node.cell));
    if (!(0 == fx && 0 == fy || null == dest || !dest.relative || !self.isVertex(node.cell) || null != i && !self.isVertex(i.cell) && null == this.deltas.get(node.cell))) {
      node.x += fx;
      node.y += fy;
    }
    this.graph.cellRenderer.redraw(node);
    if (null != selector) {
      selector(node);
    }
    dest = self.getChildCount(node.cell);
    /** @type {number} */
    i = 0;
    for (; i < dest; i++) {
      this.revalidateState(this.graph.view.getState(self.getChildAt(node.cell, i)), fx, fy, selector);
    }
  }
};
/**
 * @param {!Object} state
 * @return {undefined}
 */
mxCellStatePreview.prototype.addEdges = function(state) {
  var $ = this.graph.getModel();
  var prevVal = $.getEdgeCount(state.cell);
  /** @type {number} */
  var val = 0;
  for (; val < prevVal; val++) {
    var PRE_DIGEST_STATE = state.view.getState($.getEdgeAt(state.cell, val));
    if (null != PRE_DIGEST_STATE) {
      this.moveState(PRE_DIGEST_STATE, 0, 0);
    }
  }
};
/**
 * @param {!Object} p
 * @param {?} ytox
 * @param {string} ytoy
 * @param {number} dx
 * @param {number} dy
 * @return {undefined}
 */
function mxConnectionConstraint(p, ytox, ytoy, dx, dy) {
  /** @type {!Object} */
  this.point = p;
  this.perimeter = null != ytox ? ytox : true;
  /** @type {string} */
  this.name = ytoy;
  this.dx = dx ? dx : 0;
  this.dy = dy ? dy : 0;
}
/** @type {null} */
mxConnectionConstraint.prototype.point = null;
/** @type {null} */
mxConnectionConstraint.prototype.perimeter = null;
/** @type {null} */
mxConnectionConstraint.prototype.name = null;
/** @type {null} */
mxConnectionConstraint.prototype.dx = null;
/** @type {null} */
mxConnectionConstraint.prototype.dy = null;
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxGraphHandler(targetGraph) {
  /** @type {!Object} */
  this.graph = targetGraph;
  this.graph.addMouseListener(this);
  this.panHandler = mxUtils.bind(this, function() {
    if (!this.suspended) {
      this.updatePreview();
      this.updateHint();
    }
  });
  this.graph.addListener(mxEvent.PAN, this.panHandler);
  this.escapeHandler = mxUtils.bind(this, function(b, canCreateDiscussions) {
    this.reset();
  });
  this.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
  this.refreshHandler = mxUtils.bind(this, function(b, canCreateDiscussions) {
    if (this.refreshThread) {
      window.clearTimeout(this.refreshThread);
    }
    this.refreshThread = window.setTimeout(mxUtils.bind(this, function() {
      /** @type {null} */
      this.refreshThread = null;
      if (null != this.first && !this.suspended) {
        var d = this.currentDx;
        var e = this.currentDy;
        /** @type {number} */
        this.currentDy = this.currentDx = 0;
        this.updatePreview();
        this.bounds = this.graph.getView().getBounds(this.cells);
        this.pBounds = this.getPreviewBounds(this.cells);
        if (null != this.pBounds || this.livePreviewUsed) {
          this.currentDx = d;
          this.currentDy = e;
          this.updatePreview();
          this.updateHint();
          if (this.livePreviewUsed) {
            this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), false, true);
            this.updatePreview();
          }
        } else {
          this.reset();
        }
      }
    }), 0);
  });
  this.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler);
  this.graph.addListener(mxEvent.REFRESH, this.refreshHandler);
  this.keyHandler = mxUtils.bind(this, function(url) {
    if (!(null == this.graph.container || "hidden" == this.graph.container.style.visibility || null == this.first || this.suspended)) {
      url = this.graph.isCloneEvent(url) && this.graph.isCellsCloneable() && this.isCloneEnabled();
      if (url != this.cloning) {
        this.cloning = url;
        this.checkPreview();
        this.updatePreview();
      }
    }
  });
  mxEvent.addListener(document, "keydown", this.keyHandler);
  mxEvent.addListener(document, "keyup", this.keyHandler);
}
/** @type {null} */
mxGraphHandler.prototype.graph = null;
/** @type {number} */
mxGraphHandler.prototype.maxCells = mxClient.IS_IE ? 20 : 50;
/** @type {boolean} */
mxGraphHandler.prototype.enabled = true;
/** @type {boolean} */
mxGraphHandler.prototype.highlightEnabled = true;
/** @type {boolean} */
mxGraphHandler.prototype.cloneEnabled = true;
/** @type {boolean} */
mxGraphHandler.prototype.moveEnabled = true;
/** @type {boolean} */
mxGraphHandler.prototype.guidesEnabled = false;
/** @type {boolean} */
mxGraphHandler.prototype.handlesVisible = true;
/** @type {null} */
mxGraphHandler.prototype.guide = null;
/** @type {null} */
mxGraphHandler.prototype.currentDx = null;
/** @type {null} */
mxGraphHandler.prototype.currentDy = null;
/** @type {boolean} */
mxGraphHandler.prototype.updateCursor = true;
/** @type {boolean} */
mxGraphHandler.prototype.selectEnabled = true;
/** @type {boolean} */
mxGraphHandler.prototype.removeCellsFromParent = true;
/** @type {boolean} */
mxGraphHandler.prototype.removeEmptyParents = false;
/** @type {boolean} */
mxGraphHandler.prototype.connectOnDrop = false;
/** @type {boolean} */
mxGraphHandler.prototype.scrollOnMove = true;
/** @type {number} */
mxGraphHandler.prototype.minimumSize = 6;
/** @type {string} */
mxGraphHandler.prototype.previewColor = "black";
/** @type {boolean} */
mxGraphHandler.prototype.htmlPreview = false;
/** @type {null} */
mxGraphHandler.prototype.shape = null;
/** @type {boolean} */
mxGraphHandler.prototype.scaleGrid = false;
/** @type {boolean} */
mxGraphHandler.prototype.rotationEnabled = true;
/** @type {number} */
mxGraphHandler.prototype.maxLivePreview = 0;
/** @type {boolean} */
mxGraphHandler.prototype.allowLivePreview = mxClient.IS_SVG;
/**
 * @return {?}
 */
mxGraphHandler.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxGraphHandler.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxGraphHandler.prototype.isCloneEnabled = function() {
  return this.cloneEnabled;
};
/**
 * @param {?} a
 * @return {undefined}
 */
mxGraphHandler.prototype.setCloneEnabled = function(a) {
  this.cloneEnabled = a;
};
/**
 * @return {?}
 */
mxGraphHandler.prototype.isMoveEnabled = function() {
  return this.moveEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraphHandler.prototype.setMoveEnabled = function(a) {
  /** @type {boolean} */
  this.moveEnabled = a;
};
/**
 * @return {?}
 */
mxGraphHandler.prototype.isSelectEnabled = function() {
  return this.selectEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraphHandler.prototype.setSelectEnabled = function(a) {
  /** @type {boolean} */
  this.selectEnabled = a;
};
/**
 * @return {?}
 */
mxGraphHandler.prototype.isRemoveCellsFromParent = function() {
  return this.removeCellsFromParent;
};
/**
 * @param {!Object} a
 * @return {undefined}
 */
mxGraphHandler.prototype.setRemoveCellsFromParent = function(a) {
  /** @type {!Object} */
  this.removeCellsFromParent = a;
};
/**
 * @param {(Object|string)} cell
 * @param {string} target
 * @param {!Object} panel
 * @return {?}
 */
mxGraphHandler.prototype.isPropagateSelectionCell = function(cell, target, panel) {
  var parent = this.graph.model.getParent(cell);
  return target ? (target = this.graph.model.isEdge(cell) ? null : this.graph.getCellGeometry(cell), !this.graph.isSiblingSelected(cell) && (null != target && target.relative || !this.graph.isSwimlane(parent))) : (!this.graph.isToggleEvent(panel.getEvent()) || !this.graph.isSiblingSelected(cell) && !this.graph.isCellSelected(cell) && !this.graph.isSwimlane(parent) || this.graph.isCellSelected(parent)) && (this.graph.isToggleEvent(panel.getEvent()) || !this.graph.isCellSelected(parent));
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxGraphHandler.prototype.getInitialCellForEvent = function(me) {
  var e = me.getState();
  if (!(this.graph.isToggleEvent(me.getEvent()) && mxEvent.isAltDown(me.getEvent()) || null == e || this.graph.isCellSelected(e.cell))) {
    var model = this.graph.model;
    var tmp = this.graph.view.getState(model.getParent(e.cell));
    for (; null != tmp && !this.graph.isCellSelected(tmp.cell) && (model.isVertex(tmp.cell) || model.isEdge(tmp.cell)) && this.isPropagateSelectionCell(e.cell, true, me);) {
      e = tmp;
      tmp = this.graph.view.getState(this.graph.getModel().getParent(e.cell));
    }
  }
  return null != e ? e.cell : null;
};
/**
 * @param {!Object} name
 * @param {!Object} menu
 * @return {?}
 */
mxGraphHandler.prototype.isDelayedSelection = function(name, menu) {
  if (!this.graph.isToggleEvent(menu.getEvent()) || !mxEvent.isAltDown(menu.getEvent())) {
    for (; null != name;) {
      if (this.graph.selectionCellsHandler.isHandled(name)) {
        return this.graph.cellEditor.getEditingCell() != name;
      }
      name = this.graph.model.getParent(name);
    }
  }
  return this.graph.isToggleEvent(menu.getEvent()) && !mxEvent.isAltDown(menu.getEvent());
};
/**
 * @param {!Event} obj
 * @return {undefined}
 */
mxGraphHandler.prototype.selectDelayed = function(obj) {
  if (!this.graph.popupMenuHandler.isPopupTrigger(obj)) {
    var cell = obj.getCell();
    if (null == cell) {
      cell = this.cell;
    }
    this.selectCellForEvent(cell, obj);
  }
};
/**
 * @param {!Object} name
 * @param {!Object} t
 * @return {?}
 */
mxGraphHandler.prototype.selectCellForEvent = function(name, t) {
  var model = this.graph.view.getState(name);
  if (null != model) {
    if (!(t.isSource(model.control) || this.graph.isToggleEvent(t.getEvent()) && mxEvent.isAltDown(t.getEvent()))) {
      model = this.graph.getModel();
      var element = model.getParent(name);
      for (; null != this.graph.view.getState(element) && (model.isVertex(element) || model.isEdge(element) && !this.graph.isToggleEvent(t.getEvent())) && this.isPropagateSelectionCell(name, false, t);) {
        name = element;
        element = model.getParent(name);
      }
    }
    this.graph.selectCellForEvent(name, t.getEvent());
  }
  return name;
};
/**
 * @param {number} state
 * @param {!Event} from
 * @return {undefined}
 */
mxGraphHandler.prototype.consumeMouseEvent = function(state, from) {
  from.consume();
};
/**
 * @param {!Array} cell
 * @param {!Object} me
 * @return {undefined}
 */
mxGraphHandler.prototype.mouseDown = function(cell, me) {
  if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && null != me.getState() && !mxEvent.isMultiTouchEvent(me.getEvent()) && (cell = this.getInitialCellForEvent(me), this.delayedSelection = this.isDelayedSelection(cell, me), this.cell = null, this.isSelectEnabled() && !this.delayedSelection && this.graph.selectCellForEvent(cell, me.getEvent()), this.isMoveEnabled())) {
    var model = this.graph.model;
    var d = model.getGeometry(cell);
    if (this.graph.isCellMovable(cell) && (!model.isEdge(cell) || 1 < this.graph.getSelectionCount() || null != d.points && 0 < d.points.length || null == model.getTerminal(cell, true) || null == model.getTerminal(cell, false) || this.graph.allowDanglingEdges || this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable())) {
      this.start(cell, me.getX(), me.getY());
    } else {
      if (this.delayedSelection) {
        /** @type {!Array} */
        this.cell = cell;
      }
    }
    /** @type {boolean} */
    this.cellWasClicked = true;
    this.consumeMouseEvent(mxEvent.MOUSE_DOWN, me);
  }
};
/**
 * @return {?}
 */
mxGraphHandler.prototype.getGuideStates = function() {
  var a = this.graph.getDefaultParent();
  var model = this.graph.getModel();
  var drop_data = mxUtils.bind(this, function(element) {
    return null != this.graph.view.getState(element) && model.isVertex(element) && null != model.getGeometry(element) && !model.getGeometry(element).relative;
  });
  return this.graph.view.getCellStates(model.filterDescendants(drop_data, a));
};
/**
 * @param {?} cell
 * @return {?}
 */
mxGraphHandler.prototype.getCells = function(cell) {
  return !this.delayedSelection && this.graph.isCellMovable(cell) ? [cell] : this.graph.getMovableCells(this.graph.getSelectionCells());
};
/**
 * @param {!Object} el
 * @return {?}
 */
mxGraphHandler.prototype.getPreviewBounds = function(el) {
  el = this.getBoundingBox(el);
  if (null != el) {
    /** @type {number} */
    el.width = Math.max(0, el.width - 1);
    /** @type {number} */
    el.height = Math.max(0, el.height - 1);
    if (el.width < this.minimumSize) {
      el.x -= (this.minimumSize - el.width) / 2;
      el.width = this.minimumSize;
    } else {
      /** @type {number} */
      el.x = Math.round(el.x);
      /** @type {number} */
      el.width = Math.ceil(el.width);
    }
    if (el.height < this.minimumSize) {
      el.y -= (this.minimumSize - el.height) / 2;
      el.height = this.minimumSize;
    } else {
      /** @type {number} */
      el.y = Math.round(el.y);
      /** @type {number} */
      el.height = Math.ceil(el.height);
    }
  }
  return el;
};
/**
 * @param {!Object} o
 * @return {?}
 */
mxGraphHandler.prototype.getBoundingBox = function(o) {
  /** @type {null} */
  var result = null;
  if (null != o && 0 < o.length) {
    var utils = this.graph.getModel();
    /** @type {number} */
    var i = 0;
    for (; i < o.length; i++) {
      if (utils.isVertex(o[i]) || utils.isEdge(o[i])) {
        var node = this.graph.view.getState(o[i]);
        if (null != node) {
          var el = node;
          if (utils.isVertex(o[i]) && null != node.shape && null != node.shape.boundingBox) {
            el = node.shape.boundingBox;
          }
          if (null == result) {
            result = mxRectangle.fromRectangle(el);
          } else {
            result.add(el);
          }
        }
      }
    }
  }
  return result;
};
/**
 * @param {!Object} options
 * @return {?}
 */
mxGraphHandler.prototype.createPreviewShape = function(options) {
  options = new mxRectangleShape(options, null, this.previewColor);
  /** @type {boolean} */
  options.isDashed = true;
  if (this.htmlPreview) {
    options.dialect = mxConstants.DIALECT_STRICTHTML;
    options.init(this.graph.container);
  } else {
    options.dialect = mxConstants.DIALECT_SVG;
    options.init(this.graph.getView().getOverlayPane());
    /** @type {boolean} */
    options.pointerEvents = false;
    if (mxClient.IS_IOS) {
      /**
       * @return {?}
       */
      options.getSvgScreenOffset = function() {
        return 0;
      };
    }
  }
  return options;
};
/**
 * @param {!Object} el
 * @param {number} i
 * @param {?} id
 * @param {number} finished
 * @return {undefined}
 */
mxGraphHandler.prototype.start = function(el, i, id, finished) {
  /** @type {!Object} */
  this.cell = el;
  this.first = mxUtils.convertPoint(this.graph.container, i, id);
  this.cells = null != finished ? finished : this.getCells(this.cell);
  this.bounds = this.graph.getView().getBounds(this.cells);
  this.pBounds = this.getPreviewBounds(this.cells);
  this.allCells = new mxDictionary;
  /** @type {boolean} */
  this.cloning = false;
  /** @type {number} */
  i = this.cellCount = 0;
  for (; i < this.cells.length; i++) {
    this.cellCount += this.addStates(this.cells[i], this.allCells);
  }
  if (this.guidesEnabled) {
    this.guide = new mxGuide(this.graph, this.getGuideStates());
    var parent = this.graph.model.getParent(el);
    /** @type {boolean} */
    var f = 2 > this.graph.model.getChildCount(parent);
    var g = new mxDictionary;
    el = this.graph.getOpposites(this.graph.getEdges(this.cell), this.cell);
    /** @type {number} */
    i = 0;
    for (; i < el.length; i++) {
      id = this.graph.view.getState(el[i]);
      if (!(null == id || g.get(id))) {
        g.put(id, true);
      }
    }
    this.guide.isStateIgnored = mxUtils.bind(this, function(item) {
      var l = this.graph.model.getParent(item.cell);
      return null != item.cell && (!this.cloning && this.isCellMoving(item.cell) || item.cell != (this.target || parent) && !f && !g.get(item) && (null == this.target || 2 <= this.graph.model.getChildCount(this.target)) && l != (this.target || parent));
    });
  }
};
/**
 * @param {undefined} index
 * @param {!Object} state
 * @return {?}
 */
mxGraphHandler.prototype.addStates = function(index, state) {
  var c = this.graph.view.getState(index);
  /** @type {number} */
  var code = 0;
  if (null != c && null == state.get(index)) {
    state.put(index, c);
    code++;
    c = this.graph.model.getChildCount(index);
    /** @type {number} */
    var i = 0;
    for (; i < c; i++) {
      code = code + this.addStates(this.graph.model.getChildAt(index, i), state);
    }
  }
  return code;
};
/**
 * @param {!Object} a
 * @return {?}
 */
mxGraphHandler.prototype.isCellMoving = function(a) {
  return null != this.allCells.get(a);
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxGraphHandler.prototype.useGuidesForEvent = function(me) {
  return null != this.guide ? this.guide.isEnabledForEvent(me.getEvent()) && !this.isConstrainedEvent(me) : true;
};
/**
 * @param {number} pos
 * @return {?}
 */
mxGraphHandler.prototype.snap = function(pos) {
  var scale = this.scaleGrid ? this.graph.view.scale : 1;
  /** @type {number} */
  pos.x = this.graph.snap(pos.x / scale) * scale;
  /** @type {number} */
  pos.y = this.graph.snap(pos.y / scale) * scale;
  return pos;
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxGraphHandler.prototype.getDelta = function(e) {
  e = mxUtils.convertPoint(this.graph.container, e.getX(), e.getY());
  return new mxPoint(e.x - this.first.x - this.graph.panDx, e.y - this.first.y - this.graph.panDy);
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxGraphHandler.prototype.updateHint = function(data) {
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.removeHint = function() {
};
/**
 * @param {number} litresInCubicFeet
 * @return {?}
 */
mxGraphHandler.prototype.roundLength = function(litresInCubicFeet) {
  return Math.round(100 * litresInCubicFeet) / 100;
};
/**
 * @param {!Object} transform
 * @param {!Object} editor
 * @return {?}
 */
mxGraphHandler.prototype.isValidDropTarget = function(transform, editor) {
  return this.graph.model.getParent(this.cell) != transform;
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.checkPreview = function() {
  if (this.livePreviewActive && this.cloning) {
    this.resetLivePreview();
    /** @type {boolean} */
    this.livePreviewActive = false;
  } else {
    if (this.maxLivePreview >= this.cellCount && !this.livePreviewActive && this.allowLivePreview) {
      if (!(this.cloning && this.livePreviewActive)) {
        /** @type {boolean} */
        this.livePreviewUsed = this.livePreviewActive = true;
      }
    } else {
      if (!(this.livePreviewUsed || null != this.shape)) {
        this.shape = this.createPreviewShape(this.bounds);
      }
    }
  }
};
/**
 * @param {!Object} self
 * @param {!Object} me
 * @return {undefined}
 */
mxGraphHandler.prototype.mouseMove = function(self, me) {
  self = this.graph;
  if (me.isConsumed() || !self.isMouseDown || null == this.cell || null == this.first || null == this.bounds || this.suspended) {
    if (!(!this.isMoveEnabled() && !this.isCloneEnabled() || !this.updateCursor || me.isConsumed() || null == me.getState() && null == me.sourceState || self.isMouseDown)) {
      i = self.getCursorForMouseEvent(me);
      if (null == i && self.isEnabled() && self.isCellMovable(me.getCell())) {
        i = self.getModel().isEdge(me.getCell()) ? mxConstants.CURSOR_MOVABLE_EDGE : mxConstants.CURSOR_MOVABLE_VERTEX;
      }
      if (null != i && null != me.sourceState) {
        me.sourceState.setCursor(i);
      }
    }
  } else {
    if (mxEvent.isMultiTouchEvent(me.getEvent())) {
      this.reset();
    } else {
      var i = this.getDelta(me);
      var height = self.tolerance;
      if (null != this.shape || this.livePreviewActive || Math.abs(i.x) > height || Math.abs(i.y) > height) {
        if (null == this.highlight) {
          this.highlight = new mxCellHighlight(this.graph, mxConstants.DROP_TARGET_COLOR, 3);
        }
        height = self.isCloneEvent(me.getEvent()) && self.isCellsCloneable() && this.isCloneEnabled();
        var end = self.isGridEnabledEvent(me.getEvent());
        var value = me.getCell();
        value = null != value && 0 > mxUtils.indexOf(this.cells, value) ? value : self.getCellAt(me.getGraphX(), me.getGraphY(), null, null, null, mxUtils.bind(this, function(action, p, canCreateDiscussions) {
          return 0 <= mxUtils.indexOf(this.cells, action.cell);
        }));
        /** @type {boolean} */
        var g = true;
        /** @type {null} */
        var target = null;
        this.cloning = height;
        if (self.isDropEnabled() && this.highlightEnabled) {
          target = self.getDropTarget(this.cells, me.getEvent(), value, height);
        }
        var state = self.getView().getState(target);
        /** @type {boolean} */
        var unpack = false;
        if (null != state && (height || this.isValidDropTarget(target, me))) {
          if (this.target != target) {
            this.target = target;
            this.setHighlightColor(mxConstants.DROP_TARGET_COLOR);
          }
          /** @type {boolean} */
          unpack = true;
        } else {
          /** @type {null} */
          this.target = null;
          if (this.connectOnDrop && null != value && 1 == this.cells.length && self.getModel().isVertex(value) && self.isCellConnectable(value)) {
            state = self.getView().getState(value);
            if (null != state) {
              self = null == self.getEdgeValidationError(null, this.cell, value) ? mxConstants.VALID_COLOR : mxConstants.INVALID_CONNECT_TARGET_COLOR;
              this.setHighlightColor(self);
              /** @type {boolean} */
              unpack = true;
            }
          }
        }
        if (null != state && unpack) {
          this.highlight.highlight(state);
        } else {
          this.highlight.hide();
        }
        if (null != this.guide && this.useGuidesForEvent(me)) {
          i = this.guide.move(this.bounds, i, end, height);
          /** @type {boolean} */
          g = false;
        } else {
          i = this.graph.snapDelta(i, this.bounds, !end, false, false);
        }
        if (null != this.guide && g) {
          this.guide.hide();
        }
        if (this.isConstrainedEvent(me)) {
          if (Math.abs(i.x) > Math.abs(i.y)) {
            /** @type {number} */
            i.y = 0;
          } else {
            /** @type {number} */
            i.x = 0;
          }
        }
        this.checkPreview();
        if (this.currentDx != i.x || this.currentDy != i.y) {
          this.currentDx = i.x;
          this.currentDy = i.y;
          this.updatePreview();
        }
      }
      this.updateHint(me);
      this.consumeMouseEvent(mxEvent.MOUSE_MOVE, me);
      mxEvent.consume(me.getEvent());
    }
  }
};
/**
 * @param {!Object} child
 * @return {?}
 */
mxGraphHandler.prototype.isConstrainedEvent = function(child) {
  return (null == this.target || this.graph.isCloneEvent(child.getEvent())) && this.graph.isConstrainedEvent(child.getEvent());
};
/**
 * @param {boolean} size
 * @return {undefined}
 */
mxGraphHandler.prototype.updatePreview = function(size) {
  if (this.livePreviewUsed && !size) {
    if (null != this.cells) {
      this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), false);
      this.updateLivePreview(this.currentDx, this.currentDy);
    }
  } else {
    this.updatePreviewShape();
  }
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.updatePreviewShape = function() {
  if (null != this.shape && null != this.pBounds) {
    this.shape.bounds = new mxRectangle(Math.round(this.pBounds.x + this.currentDx), Math.round(this.pBounds.y + this.currentDy), this.pBounds.width, this.pBounds.height);
    this.shape.redraw();
  }
};
/**
 * @param {number} size
 * @param {number} offset
 * @return {undefined}
 */
mxGraphHandler.prototype.updateLivePreview = function(size, offset) {
  if (!this.suspended) {
    /** @type {!Array} */
    var triangles = [];
    if (null != this.allCells) {
      this.allCells.visit(mxUtils.bind(this, function(n, self) {
        n = this.graph.view.getState(self.cell);
        if (n != self) {
          self.destroy();
          if (null != n) {
            this.allCells.put(self.cell, n);
          } else {
            this.allCells.remove(self.cell);
          }
          /** @type {!Object} */
          self = n;
        }
        if (null != self && (n = self.clone(), triangles.push([self, n]), null != self.shape && (null == self.shape.originalPointerEvents && (self.shape.originalPointerEvents = self.shape.pointerEvents), self.shape.pointerEvents = false, null != self.text && (null == self.text.originalPointerEvents && (self.text.originalPointerEvents = self.text.pointerEvents), self.text.pointerEvents = false)), this.graph.model.isVertex(self.cell))) {
          if (self.x += size, self.y += offset, this.cloning) {
            if (null != self.text) {
              self.text.updateBoundingBox();
              if (null != self.text.boundingBox) {
                self.text.boundingBox.x += size;
                self.text.boundingBox.y += offset;
              }
              if (null != self.text.unrotatedBoundingBox) {
                self.text.unrotatedBoundingBox.x += size;
                self.text.unrotatedBoundingBox.y += offset;
              }
            }
          } else {
            self.view.graph.cellRenderer.redraw(self, true);
            self.view.invalidate(self.cell);
            /** @type {boolean} */
            self.invalid = false;
            if (null != self.control && null != self.control.node) {
              /** @type {string} */
              self.control.node.style.visibility = "hidden";
            }
          }
        }
      }));
    }
    if (0 == triangles.length) {
      this.reset();
    } else {
      var scale = this.graph.view.scale;
      /** @type {number} */
      var i = 0;
      for (; i < triangles.length; i++) {
        var data = triangles[i][0];
        if (this.graph.model.isEdge(data.cell)) {
          var options = this.graph.getCellGeometry(data.cell);
          /** @type {!Array} */
          var points = [];
          if (null != options && null != options.points) {
            /** @type {number} */
            var pos = 0;
            for (; pos < options.points.length; pos++) {
              if (null != options.points[pos]) {
                points.push(new mxPoint(options.points[pos].x + size / scale, options.points[pos].y + offset / scale));
              }
            }
          }
          options = data.visibleSourceState;
          pos = data.visibleTargetState;
          var args = triangles[i][1].absolutePoints;
          if (null != options && this.isCellMoving(options.cell)) {
            data.view.updateFixedTerminalPoint(data, options, true, this.graph.getConnectionConstraint(data, options, true));
          } else {
            options = args[0];
            data.setAbsoluteTerminalPoint(new mxPoint(options.x + size, options.y + offset), true);
            /** @type {null} */
            options = null;
          }
          if (null != pos && this.isCellMoving(pos.cell)) {
            data.view.updateFixedTerminalPoint(data, pos, false, this.graph.getConnectionConstraint(data, pos, false));
          } else {
            pos = args[args.length - 1];
            data.setAbsoluteTerminalPoint(new mxPoint(pos.x + size, pos.y + offset), false);
            /** @type {null} */
            pos = null;
          }
          data.view.updatePoints(data, points, options, pos);
          data.view.updateFloatingTerminalPoints(data, options, pos);
          data.view.updateEdgeLabelOffset(data);
          /** @type {boolean} */
          data.invalid = false;
          if (!this.cloning) {
            data.view.graph.cellRenderer.redraw(data, true);
          }
        }
      }
      this.graph.view.validate();
      this.redrawHandles(triangles);
      this.resetPreviewStates(triangles);
    }
  }
};
/**
 * @param {!Array} polys
 * @return {undefined}
 */
mxGraphHandler.prototype.redrawHandles = function(polys) {
  /** @type {number} */
  var i = 0;
  for (; i < polys.length; i++) {
    var _donut_chart_file_type_attach = this.graph.selectionCellsHandler.getHandler(polys[i][0].cell);
    if (null != _donut_chart_file_type_attach) {
      _donut_chart_file_type_attach.redraw(true);
    }
  }
};
/**
 * @param {!Array} polys
 * @return {undefined}
 */
mxGraphHandler.prototype.resetPreviewStates = function(polys) {
  /** @type {number} */
  var i = 0;
  for (; i < polys.length; i++) {
    polys[i][0].setState(polys[i][1]);
  }
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.suspend = function() {
  if (!this.suspended) {
    if (this.livePreviewUsed) {
      this.updateLivePreview(0, 0);
    }
    if (null != this.shape) {
      /** @type {string} */
      this.shape.node.style.visibility = "hidden";
    }
    if (null != this.guide) {
      this.guide.setVisible(false);
    }
    /** @type {boolean} */
    this.suspended = true;
  }
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.resume = function() {
  if (this.suspended) {
    /** @type {null} */
    this.suspended = null;
    if (this.livePreviewUsed) {
      /** @type {boolean} */
      this.livePreviewActive = true;
    }
    if (null != this.shape) {
      /** @type {string} */
      this.shape.node.style.visibility = "visible";
    }
    if (null != this.guide) {
      this.guide.setVisible(true);
    }
  }
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.resetLivePreview = function() {
  if (null != this.allCells) {
    this.allCells.visit(mxUtils.bind(this, function(a, e) {
      if (null != e.shape && null != e.shape.originalPointerEvents) {
        e.shape.pointerEvents = e.shape.originalPointerEvents;
        /** @type {null} */
        e.shape.originalPointerEvents = null;
        /** @type {null} */
        e.shape.bounds = null;
        if (null != e.text) {
          e.text.pointerEvents = e.text.originalPointerEvents;
          /** @type {null} */
          e.text.originalPointerEvents = null;
        }
      }
      if (null != e.control && null != e.control.node && "hidden" == e.control.node.style.visibility) {
        /** @type {string} */
        e.control.node.style.visibility = "";
      }
      if (!this.cloning) {
        if (null != e.text) {
          e.text.updateBoundingBox();
        }
      }
      e.view.invalidate(e.cell);
    }));
    this.graph.view.validate();
  }
};
/**
 * @param {!NodeList} keys
 * @param {boolean} order
 * @param {number} i
 * @return {undefined}
 */
mxGraphHandler.prototype.setHandlesVisibleForCells = function(keys, order, i) {
  if (i || this.handlesVisible != order) {
    /** @type {boolean} */
    this.handlesVisible = order;
    /** @type {number} */
    i = 0;
    for (; i < keys.length; i++) {
      var m = this.graph.selectionCellsHandler.getHandler(keys[i]);
      if (null != m) {
        m.setHandlesVisible(order);
        if (order) {
          m.redraw();
        }
      }
    }
  }
};
/**
 * @param {!Function} color
 * @return {undefined}
 */
mxGraphHandler.prototype.setHighlightColor = function(color) {
  if (null != this.highlight) {
    this.highlight.setHighlightColor(color);
  }
};
/**
 * @param {!Object} graph
 * @param {!Event} me
 * @return {undefined}
 */
mxGraphHandler.prototype.mouseUp = function(graph, me) {
  if (!me.isConsumed()) {
    if (this.livePreviewUsed && this.resetLivePreview(), null == this.cell || null == this.first || null == this.shape && !this.livePreviewUsed || null == this.currentDx || null == this.currentDy) {
      if (this.isSelectEnabled() && this.delayedSelection && null != this.cell) {
        this.selectDelayed(me);
      }
    } else {
      graph = this.graph;
      var e = me.getCell();
      if (this.connectOnDrop && null == this.target && null != e && graph.getModel().isVertex(e) && graph.isCellConnectable(e) && graph.isEdgeValid(null, this.cell, e)) {
        graph.connectionHandler.connect(this.cell, e, me.getEvent());
      } else {
        e = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();
        var s = graph.getView().scale;
        var x = this.roundLength(this.currentDx / s);
        s = this.roundLength(this.currentDy / s);
        var target = this.target;
        if (graph.isSplitEnabled() && graph.isSplitTarget(target, this.cells, me.getEvent())) {
          graph.splitEdge(target, this.cells, null, x, s, me.getGraphX(), me.getGraphY());
        } else {
          this.moveCells(this.cells, x, s, e, this.target, me.getEvent());
        }
      }
    }
  }
  if (this.cellWasClicked) {
    this.consumeMouseEvent(mxEvent.MOUSE_UP, me);
  }
  this.reset();
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.reset = function() {
  if (this.livePreviewUsed) {
    this.resetLivePreview();
    this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), true);
  }
  this.destroyShapes();
  this.removeHint();
  /** @type {boolean} */
  this.delayedSelection = false;
  /** @type {null} */
  this.livePreviewUsed = this.livePreviewActive = null;
  /** @type {boolean} */
  this.cellWasClicked = false;
  /** @type {null} */
  this.cellCount = this.currentDy = this.currentDx = this.suspended = null;
  /** @type {boolean} */
  this.cloning = false;
  /** @type {null} */
  this.cell = this.cells = this.first = this.target = this.guides = this.pBounds = this.allCells = null;
};
/**
 * @param {!Object} s
 * @param {?} name
 * @param {?} evt
 * @return {?}
 */
mxGraphHandler.prototype.shouldRemoveCellsFromParent = function(s, name, evt) {
  if (this.graph.getModel().isVertex(s) && (s = this.graph.getView().getState(s), null != s)) {
    evt = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
    var z = mxUtils.toRadians(mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION) || 0);
    if (0 != z) {
      /** @type {number} */
      name = Math.cos(-z);
      /** @type {number} */
      z = Math.sin(-z);
      var ct = new mxPoint(s.getCenterX(), s.getCenterY());
      evt = mxUtils.getRotatedPoint(evt, name, z, ct);
    }
    return !mxUtils.contains(s, evt.x, evt.y);
  }
  return false;
};
/**
 * @param {!Array} cells
 * @param {!Object} target
 * @param {number} color
 * @param {boolean} callback
 * @param {number} parent
 * @param {(Object|string)} start
 * @return {undefined}
 */
mxGraphHandler.prototype.moveCells = function(cells, target, color, callback, parent, start) {
  if (callback) {
    cells = this.graph.getCloneableCells(cells);
  }
  var source = this.graph.getModel().getParent(this.cell);
  if (null == parent && null != start && this.isRemoveCellsFromParent() && this.shouldRemoveCellsFromParent(source, cells, start)) {
    parent = this.graph.getDefaultParent();
  }
  callback = callback && !this.graph.isCellLocked(parent || this.graph.getDefaultParent());
  this.graph.getModel().beginUpdate();
  try {
    /** @type {!Array} */
    source = [];
    if (!callback && null != parent && this.removeEmptyParents) {
      var range = new mxDictionary;
      /** @type {number} */
      var i = 0;
      for (; i < cells.length; i++) {
        range.put(cells[i], true);
      }
      /** @type {number} */
      i = 0;
      for (; i < cells.length; i++) {
        var m = this.graph.model.getParent(cells[i]);
        if (!(null == m || range.get(m))) {
          range.put(m, true);
          source.push(m);
        }
      }
    }
    cells = this.graph.moveCells(cells, target, color, callback, parent, start);
    /** @type {!Array} */
    target = [];
    /** @type {number} */
    i = 0;
    for (; i < source.length; i++) {
      if (this.shouldRemoveParent(source[i])) {
        target.push(source[i]);
      }
    }
    this.graph.removeCells(target, false);
  } finally {
    this.graph.getModel().endUpdate();
  }
  if (callback) {
    this.graph.setSelectionCells(cells);
  }
  if (this.isSelectEnabled() && this.scrollOnMove) {
    this.graph.scrollCellToVisible(cells[0]);
  }
};
/**
 * @param {!Object} d
 * @return {?}
 */
mxGraphHandler.prototype.shouldRemoveParent = function(d) {
  d = this.graph.view.getState(d);
  return null != d && (this.graph.model.isEdge(d.cell) || this.graph.model.isVertex(d.cell)) && this.graph.isCellDeletable(d.cell) && 0 == this.graph.model.getChildCount(d.cell) && this.graph.isTransparentState(d);
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.destroyShapes = function() {
  if (null != this.shape) {
    this.shape.destroy();
    /** @type {null} */
    this.shape = null;
  }
  if (null != this.guide) {
    this.guide.destroy();
    /** @type {null} */
    this.guide = null;
  }
  if (null != this.highlight) {
    this.highlight.destroy();
    /** @type {null} */
    this.highlight = null;
  }
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.panHandler);
  if (null != this.escapeHandler) {
    this.graph.removeListener(this.escapeHandler);
    /** @type {null} */
    this.escapeHandler = null;
  }
  if (null != this.refreshHandler) {
    this.graph.getModel().removeListener(this.refreshHandler);
    this.graph.removeListener(this.refreshHandler);
    /** @type {null} */
    this.refreshHandler = null;
  }
  mxEvent.removeListener(document, "keydown", this.keyHandler);
  mxEvent.removeListener(document, "keyup", this.keyHandler);
  this.destroyShapes();
  this.removeHint();
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxPanningHandler(targetGraph) {
  if (null != targetGraph) {
    /** @type {!Object} */
    this.graph = targetGraph;
    this.graph.addMouseListener(this);
    this.forcePanningHandler = mxUtils.bind(this, function(evtName, e) {
      evtName = e.getProperty("eventName");
      e = e.getProperty("event");
      if (evtName == mxEvent.MOUSE_DOWN && this.isForcePanningEvent(e)) {
        this.start(e);
        /** @type {boolean} */
        this.active = true;
        this.fireEvent(new mxEventObject(mxEvent.PAN_START, "event", e));
        e.consume();
      }
    });
    this.graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.forcePanningHandler);
    this.gestureHandler = mxUtils.bind(this, function(e, wm) {
      if (this.isPinchEnabled()) {
        e = wm.getProperty("event");
        if (mxEvent.isConsumed(e) || "gesturestart" != e.type) {
          if ("gestureend" == e.type && null != this.initialScale) {
            /** @type {null} */
            this.initialScale = null;
          }
        } else {
          this.initialScale = this.graph.view.scale;
          if (!(this.active || null == this.mouseDownEvent)) {
            this.start(this.mouseDownEvent);
            /** @type {null} */
            this.mouseDownEvent = null;
          }
        }
        if (null != this.initialScale) {
          this.zoomGraph(e);
        }
      }
    });
    this.graph.addListener(mxEvent.GESTURE, this.gestureHandler);
    this.mouseUpListener = mxUtils.bind(this, function() {
      if (this.active) {
        this.reset();
      }
    });
    mxEvent.addGestureListeners(document, null, null, this.mouseUpListener);
    mxEvent.addListener(document, "mouseleave", this.mouseUpListener);
  }
}
mxPanningHandler.prototype = new mxEventSource;
/** @type {function(!Object): undefined} */
mxPanningHandler.prototype.constructor = mxPanningHandler;
/** @type {null} */
mxPanningHandler.prototype.graph = null;
/** @type {boolean} */
mxPanningHandler.prototype.useLeftButtonForPanning = false;
/** @type {boolean} */
mxPanningHandler.prototype.usePopupTrigger = true;
/** @type {boolean} */
mxPanningHandler.prototype.ignoreCell = false;
/** @type {boolean} */
mxPanningHandler.prototype.previewEnabled = true;
/** @type {boolean} */
mxPanningHandler.prototype.useGrid = false;
/** @type {boolean} */
mxPanningHandler.prototype.panningEnabled = true;
/** @type {boolean} */
mxPanningHandler.prototype.pinchEnabled = true;
/** @type {number} */
mxPanningHandler.prototype.maxScale = 8;
/** @type {number} */
mxPanningHandler.prototype.minScale = .01;
/** @type {null} */
mxPanningHandler.prototype.dx = null;
/** @type {null} */
mxPanningHandler.prototype.dy = null;
/** @type {number} */
mxPanningHandler.prototype.startX = 0;
/** @type {number} */
mxPanningHandler.prototype.startY = 0;
/**
 * @return {?}
 */
mxPanningHandler.prototype.isActive = function() {
  return this.active || null != this.initialScale;
};
/**
 * @return {?}
 */
mxPanningHandler.prototype.isPanningEnabled = function() {
  return this.panningEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxPanningHandler.prototype.setPanningEnabled = function(a) {
  /** @type {boolean} */
  this.panningEnabled = a;
};
/**
 * @return {?}
 */
mxPanningHandler.prototype.isPinchEnabled = function() {
  return this.pinchEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxPanningHandler.prototype.setPinchEnabled = function(a) {
  /** @type {boolean} */
  this.pinchEnabled = a;
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxPanningHandler.prototype.isPanningTrigger = function(me) {
  var evt = me.getEvent();
  return this.useLeftButtonForPanning && null == me.getState() && mxEvent.isLeftMouseButton(evt) || mxEvent.isControlDown(evt) && mxEvent.isShiftDown(evt) || this.usePopupTrigger && mxEvent.isPopupTrigger(evt);
};
/**
 * @param {!Object} event
 * @return {?}
 */
mxPanningHandler.prototype.isForcePanningEvent = function(event) {
  return this.ignoreCell || mxEvent.isMultiTouchEvent(event.getEvent());
};
/**
 * @param {!Object} e
 * @param {!Object} element
 * @return {undefined}
 */
mxPanningHandler.prototype.mouseDown = function(e, element) {
  /** @type {!Object} */
  this.mouseDownEvent = element;
  if (!element.isConsumed() && this.isPanningEnabled() && !this.active && this.isPanningTrigger(element)) {
    this.start(element);
    this.consumePanningTrigger(element);
  }
};
/**
 * @param {!Object} item
 * @return {undefined}
 */
mxPanningHandler.prototype.start = function(item) {
  /** @type {number} */
  this.dx0 = -this.graph.container.scrollLeft;
  /** @type {number} */
  this.dy0 = -this.graph.container.scrollTop;
  this.startX = item.getX();
  this.startY = item.getY();
  /** @type {null} */
  this.dy = this.dx = null;
  /** @type {boolean} */
  this.panningTrigger = true;
};
/**
 * @param {!Event} s
 * @return {undefined}
 */
mxPanningHandler.prototype.consumePanningTrigger = function(s) {
  s.consume();
};
/**
 * @param {boolean} state
 * @param {!Object} event
 * @return {undefined}
 */
mxPanningHandler.prototype.mouseMove = function(state, event) {
  /** @type {number} */
  this.dx = event.getX() - this.startX;
  /** @type {number} */
  this.dy = event.getY() - this.startY;
  if (this.active) {
    if (this.previewEnabled) {
      if (this.useGrid) {
        this.dx = this.graph.snap(this.dx);
        this.dy = this.graph.snap(this.dy);
      }
      this.graph.panGraph(this.dx + this.dx0, this.dy + this.dy0);
    }
    this.fireEvent(new mxEventObject(mxEvent.PAN, "event", event));
  } else {
    if (this.panningTrigger) {
      state = this.active;
      /** @type {boolean} */
      this.active = Math.abs(this.dx) > this.graph.tolerance || Math.abs(this.dy) > this.graph.tolerance;
      if (!state && this.active) {
        this.fireEvent(new mxEventObject(mxEvent.PAN_START, "event", event));
      }
    }
  }
  if (this.active || this.panningTrigger) {
    event.consume();
  }
};
/**
 * @param {!Audio} scale
 * @param {!Function} e
 * @return {undefined}
 */
mxPanningHandler.prototype.mouseUp = function(scale, e) {
  if (this.active) {
    if (null != this.dx && null != this.dy) {
      if (!this.graph.useScrollbarsForPanning || !mxUtils.hasScrollbars(this.graph.container)) {
        scale = this.graph.getView().scale;
        var translate = this.graph.getView().translate;
        this.graph.panGraph(0, 0);
        this.panGraph(translate.x + this.dx / scale, translate.y + this.dy / scale);
      }
      e.consume();
    }
    this.fireEvent(new mxEventObject(mxEvent.PAN_END, "event", e));
  }
  this.reset();
};
/**
 * @param {string} e
 * @return {undefined}
 */
mxPanningHandler.prototype.zoomGraph = function(e) {
  /** @type {number} */
  var scale = Math.round(this.initialScale * e.scale * 100) / 100;
  if (null != this.minScale) {
    /** @type {number} */
    scale = Math.max(this.minScale, scale);
  }
  if (null != this.maxScale) {
    /** @type {number} */
    scale = Math.min(this.maxScale, scale);
  }
  if (this.graph.view.scale != scale) {
    this.graph.zoomTo(scale);
    mxEvent.consume(e);
  }
};
/**
 * @return {undefined}
 */
mxPanningHandler.prototype.reset = function() {
  /** @type {boolean} */
  this.panningTrigger = this.graph.isMouseDown = false;
  /** @type {null} */
  this.mouseDownEvent = null;
  /** @type {boolean} */
  this.active = false;
  /** @type {null} */
  this.dy = this.dx = null;
};
/**
 * @param {number} dx
 * @param {number} dy
 * @return {undefined}
 */
mxPanningHandler.prototype.panGraph = function(dx, dy) {
  this.graph.getView().setTranslate(dx, dy);
};
/**
 * @return {undefined}
 */
mxPanningHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.forcePanningHandler);
  this.graph.removeListener(this.gestureHandler);
  mxEvent.removeGestureListeners(document, null, null, this.mouseUpListener);
  mxEvent.removeListener(document, "mouseleave", this.mouseUpListener);
};
/**
 * @param {!Object} targetGraph
 * @param {?} srcDoc
 * @return {undefined}
 */
function mxPopupMenuHandler(targetGraph, srcDoc) {
  if (null != targetGraph) {
    /** @type {!Object} */
    this.graph = targetGraph;
    this.factoryMethod = srcDoc;
    this.graph.addMouseListener(this);
    this.gestureHandler = mxUtils.bind(this, function(canCreateDiscussions, isSlidingUp) {
      /** @type {boolean} */
      this.inTolerance = false;
    });
    this.graph.addListener(mxEvent.GESTURE, this.gestureHandler);
    this.init();
  }
}
mxPopupMenuHandler.prototype = new mxPopupMenu;
/** @type {function(!Object, ?): undefined} */
mxPopupMenuHandler.prototype.constructor = mxPopupMenuHandler;
/** @type {null} */
mxPopupMenuHandler.prototype.graph = null;
/** @type {boolean} */
mxPopupMenuHandler.prototype.selectOnPopup = true;
/** @type {boolean} */
mxPopupMenuHandler.prototype.clearSelectionOnBackground = true;
/** @type {null} */
mxPopupMenuHandler.prototype.triggerX = null;
/** @type {null} */
mxPopupMenuHandler.prototype.triggerY = null;
/** @type {null} */
mxPopupMenuHandler.prototype.screenX = null;
/** @type {null} */
mxPopupMenuHandler.prototype.screenY = null;
/**
 * @return {undefined}
 */
mxPopupMenuHandler.prototype.init = function() {
  mxPopupMenu.prototype.init.apply(this);
  mxEvent.addGestureListeners(this.div, mxUtils.bind(this, function(a) {
    this.graph.tooltipHandler.hide();
  }));
};
/**
 * @param {!Object} gib
 * @return {?}
 */
mxPopupMenuHandler.prototype.isSelectOnPopup = function(gib) {
  return this.selectOnPopup;
};
/**
 * @param {!Object} e
 * @param {!Event} me
 * @return {undefined}
 */
mxPopupMenuHandler.prototype.mouseDown = function(e, me) {
  if (this.isEnabled() && !mxEvent.isMultiTouchEvent(me.getEvent())) {
    this.hideMenu();
    this.triggerX = me.getGraphX();
    this.triggerY = me.getGraphY();
    this.screenX = mxEvent.getMainEvent(me.getEvent()).screenX;
    this.screenY = mxEvent.getMainEvent(me.getEvent()).screenY;
    this.popupTrigger = this.isPopupTrigger(me);
    /** @type {boolean} */
    this.inTolerance = true;
  }
};
/**
 * @param {?} callback
 * @param {?} event
 * @return {undefined}
 */
mxPopupMenuHandler.prototype.mouseMove = function(callback, event) {
  if (this.inTolerance && null != this.screenX && null != this.screenY && (Math.abs(mxEvent.getMainEvent(event.getEvent()).screenX - this.screenX) > this.graph.tolerance || Math.abs(mxEvent.getMainEvent(event.getEvent()).screenY - this.screenY) > this.graph.tolerance)) {
    /** @type {boolean} */
    this.inTolerance = false;
  }
};
/**
 * @param {number} event
 * @param {!Object} self
 * @param {string} callback
 * @return {undefined}
 */
mxPopupMenuHandler.prototype.mouseUp = function(event, self, callback) {
  /** @type {boolean} */
  event = null == callback;
  callback = null != callback ? callback : mxUtils.bind(this, function(unit2) {
    var xhair = mxUtils.getScrollOrigin();
    this.popup(self.getX() + xhair.x + 1, self.getY() + xhair.y + 1, unit2, self.getEvent());
  });
  if (this.popupTrigger && this.inTolerance && null != this.triggerX && null != this.triggerY) {
    var cell = this.getCellForPopupEvent(self);
    if (this.graph.isEnabled() && this.isSelectOnPopup(self) && null != cell && !this.graph.isCellSelected(cell)) {
      this.graph.setSelectionCell(cell);
    } else {
      if (this.clearSelectionOnBackground && null == cell) {
        this.graph.clearSelection();
      }
    }
    this.graph.tooltipHandler.hide();
    callback(cell);
    if (event) {
      self.consume();
    }
  }
  /** @type {boolean} */
  this.inTolerance = this.popupTrigger = false;
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxPopupMenuHandler.prototype.getCellForPopupEvent = function(me) {
  return me.getCell();
};
/**
 * @return {undefined}
 */
mxPopupMenuHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.gestureHandler);
  mxPopupMenu.prototype.destroy.apply(this);
};
/**
 * @param {!Object} graph
 * @param {string} data
 * @param {string} name
 * @param {string} force
 * @return {undefined}
 */
function mxCellMarker(graph, data, name, force) {
  mxEventSource.call(this);
  if (null != graph) {
    /** @type {!Object} */
    this.graph = graph;
    this.validColor = null != data ? data : mxConstants.DEFAULT_VALID_COLOR;
    this.invalidColor = null != name ? name : mxConstants.DEFAULT_INVALID_COLOR;
    this.hotspot = null != force ? force : mxConstants.DEFAULT_HOTSPOT;
    this.highlight = new mxCellHighlight(graph);
  }
}
mxUtils.extend(mxCellMarker, mxEventSource);
/** @type {null} */
mxCellMarker.prototype.graph = null;
/** @type {boolean} */
mxCellMarker.prototype.enabled = true;
/** @type {number} */
mxCellMarker.prototype.hotspot = mxConstants.DEFAULT_HOTSPOT;
/** @type {boolean} */
mxCellMarker.prototype.hotspotEnabled = false;
/** @type {null} */
mxCellMarker.prototype.validColor = null;
/** @type {null} */
mxCellMarker.prototype.invalidColor = null;
/** @type {null} */
mxCellMarker.prototype.currentColor = null;
/** @type {null} */
mxCellMarker.prototype.validState = null;
/** @type {null} */
mxCellMarker.prototype.markedState = null;
/**
 * @param {boolean} state
 * @return {undefined}
 */
mxCellMarker.prototype.setEnabled = function(state) {
  /** @type {boolean} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxCellMarker.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} a
 * @return {undefined}
 */
mxCellMarker.prototype.setHotspot = function(a) {
  /** @type {string} */
  this.hotspot = a;
};
/**
 * @return {?}
 */
mxCellMarker.prototype.getHotspot = function() {
  return this.hotspot;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxCellMarker.prototype.setHotspotEnabled = function(a) {
  /** @type {boolean} */
  this.hotspotEnabled = a;
};
/**
 * @return {?}
 */
mxCellMarker.prototype.isHotspotEnabled = function() {
  return this.hotspotEnabled;
};
/**
 * @return {?}
 */
mxCellMarker.prototype.hasValidState = function() {
  return null != this.validState;
};
/**
 * @return {?}
 */
mxCellMarker.prototype.getValidState = function() {
  return this.validState;
};
/**
 * @return {?}
 */
mxCellMarker.prototype.getMarkedState = function() {
  return this.markedState;
};
/**
 * @return {undefined}
 */
mxCellMarker.prototype.reset = function() {
  /** @type {null} */
  this.validState = null;
  if (null != this.markedState) {
    /** @type {null} */
    this.markedState = null;
    this.unmark();
  }
};
/**
 * @param {!Object} name
 * @return {?}
 */
mxCellMarker.prototype.process = function(name) {
  /** @type {null} */
  var payload = null;
  if (this.isEnabled()) {
    payload = this.getState(name);
    this.setCurrentState(payload, name);
  }
  return payload;
};
/**
 * @param {string} key
 * @param {!Object} s
 * @param {number} data
 * @return {undefined}
 */
mxCellMarker.prototype.setCurrentState = function(key, s, data) {
  var isKey = null != key ? this.isValidState(key) : false;
  data = null != data ? data : this.getMarkerColor(s.getEvent(), key, isKey);
  this.validState = isKey ? key : null;
  if (key != this.markedState || data != this.currentColor) {
    /** @type {number} */
    this.currentColor = data;
    if (null != key && null != this.currentColor) {
      /** @type {string} */
      this.markedState = key;
      this.mark();
    } else {
      if (null != this.markedState) {
        /** @type {null} */
        this.markedState = null;
        this.unmark();
      }
    }
  }
};
/**
 * @param {!Object} type
 * @param {string} name
 * @return {undefined}
 */
mxCellMarker.prototype.markCell = function(type, name) {
  type = this.graph.getView().getState(type);
  if (null != type) {
    this.currentColor = null != name ? name : this.validColor;
    /** @type {!Object} */
    this.markedState = type;
    this.mark();
  }
};
/**
 * @return {undefined}
 */
mxCellMarker.prototype.mark = function() {
  this.highlight.setHighlightColor(this.currentColor);
  this.highlight.highlight(this.markedState);
  this.fireEvent(new mxEventObject(mxEvent.MARK, "state", this.markedState));
};
/**
 * @return {undefined}
 */
mxCellMarker.prototype.unmark = function() {
  this.mark();
};
/**
 * @param {string} key
 * @return {?}
 */
mxCellMarker.prototype.isValidState = function(key) {
  return true;
};
/**
 * @param {?} envId
 * @param {string} url
 * @param {number} isKey
 * @return {?}
 */
mxCellMarker.prototype.getMarkerColor = function(envId, url, isKey) {
  return isKey ? this.validColor : this.invalidColor;
};
/**
 * @param {!Object} key
 * @return {?}
 */
mxCellMarker.prototype.getState = function(key) {
  var obj = this.graph.getView();
  var target = this.getCell(key);
  obj = this.getStateToMark(obj.getState(target));
  return null != obj && this.intersects(obj, key) ? obj : null;
};
/**
 * @param {!Object} o
 * @return {?}
 */
mxCellMarker.prototype.getCell = function(o) {
  return o.getCell();
};
/**
 * @param {?} a
 * @return {?}
 */
mxCellMarker.prototype.getStateToMark = function(a) {
  return a;
};
/**
 * @param {!Object} value
 * @param {!Object} start
 * @return {?}
 */
mxCellMarker.prototype.intersects = function(value, start) {
  return this.hotspotEnabled ? mxUtils.intersectsHotspot(value, start.getGraphX(), start.getGraphY(), this.hotspot, mxConstants.MIN_HOTSPOT_SIZE, mxConstants.MAX_HOTSPOT_SIZE) : true;
};
/**
 * @return {undefined}
 */
mxCellMarker.prototype.destroy = function() {
  this.graph.getView().removeListener(this.resetHandler);
  this.graph.getModel().removeListener(this.resetHandler);
  this.highlight.destroy();
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxSelectionCellsHandler(targetGraph) {
  mxEventSource.call(this);
  /** @type {!Object} */
  this.graph = targetGraph;
  this.handlers = new mxDictionary;
  this.graph.addMouseListener(this);
  this.refreshHandler = mxUtils.bind(this, function(b, canCreateDiscussions) {
    if (this.isEnabled()) {
      this.refresh();
    }
  });
  this.graph.getSelectionModel().addListener(mxEvent.CHANGE, this.refreshHandler);
  this.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.SCALE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.TRANSLATE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.DOWN, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.UP, this.refreshHandler);
}
mxUtils.extend(mxSelectionCellsHandler, mxEventSource);
/** @type {null} */
mxSelectionCellsHandler.prototype.graph = null;
/** @type {boolean} */
mxSelectionCellsHandler.prototype.enabled = true;
/** @type {null} */
mxSelectionCellsHandler.prototype.refreshHandler = null;
/** @type {number} */
mxSelectionCellsHandler.prototype.maxHandlers = 100;
/** @type {null} */
mxSelectionCellsHandler.prototype.handlers = null;
/**
 * @return {?}
 */
mxSelectionCellsHandler.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {boolean} state
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.setEnabled = function(state) {
  /** @type {boolean} */
  this.enabled = state;
};
/**
 * @param {!Object} name
 * @return {?}
 */
mxSelectionCellsHandler.prototype.getHandler = function(name) {
  return this.handlers.get(name);
};
/**
 * @param {!Object} name
 * @return {?}
 */
mxSelectionCellsHandler.prototype.isHandled = function(name) {
  return null != this.getHandler(name);
};
/**
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.reset = function() {
  this.handlers.visit(function(a, b) {
    b.reset.apply(b);
  });
};
/**
 * @return {?}
 */
mxSelectionCellsHandler.prototype.getHandledSelectionCells = function() {
  return this.graph.getSelectionCells();
};
/**
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.refresh = function() {
  var c = this.handlers;
  this.handlers = new mxDictionary;
  var a = mxUtils.sortCells(this.getHandledSelectionCells(), false);
  /** @type {number} */
  var i = 0;
  for (; i < a.length; i++) {
    var opts = this.graph.view.getState(a[i]);
    if (null != opts) {
      var args = c.remove(a[i]);
      if (null != args) {
        if (args.state != opts) {
          args.destroy();
          /** @type {null} */
          args = null;
        } else {
          if (!this.isHandlerActive(args)) {
            if (null != args.refresh) {
              args.refresh();
            }
            args.redraw();
          }
        }
      }
      if (null != args) {
        this.handlers.put(a[i], args);
      }
    }
  }
  c.visit(mxUtils.bind(this, function(canCreateDiscussions, g) {
    this.fireEvent(new mxEventObject(mxEvent.REMOVE, "state", g.state));
    g.destroy();
  }));
  /** @type {number} */
  i = 0;
  for (; i < a.length; i++) {
    opts = this.graph.view.getState(a[i]);
    if (null != opts) {
      args = this.handlers.get(a[i]);
      if (null == args) {
        args = this.graph.createHandler(opts);
        this.fireEvent(new mxEventObject(mxEvent.ADD, "state", opts));
        this.handlers.put(a[i], args);
      } else {
        args.updateParentHighlight();
      }
    }
  }
};
/**
 * @param {?} a
 * @return {?}
 */
mxSelectionCellsHandler.prototype.isHandlerActive = function(a) {
  return null != a.index;
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.updateHandler = function(data) {
  var b = this.handlers.remove(data.cell);
  if (null != b) {
    var e = b.index;
    var x = b.startX;
    var y = b.startY;
    b.destroy();
    b = this.graph.createHandler(data);
    if (null != b) {
      this.handlers.put(data.cell, b);
      if (null != e && null != x && null != y) {
        b.start(x, y, e);
      }
    }
  }
};
/**
 * @param {!Object} e
 * @param {?} ch
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.mouseDown = function(e, ch) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    /** @type {!Array} */
    var es = [e, ch];
    this.handlers.visit(function(canCreateDiscussions, d) {
      d.mouseDown.apply(d, es);
    });
  }
};
/**
 * @param {?} new_yaw
 * @param {?} new_pitch
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.mouseMove = function(new_yaw, new_pitch) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    /** @type {!Array} */
    var c = [new_yaw, new_pitch];
    this.handlers.visit(function(canCreateDiscussions, o) {
      o.mouseMove.apply(o, c);
    });
  }
};
/**
 * @param {?} callback
 * @param {?} where
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.mouseUp = function(callback, where) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    /** @type {!Array} */
    var args = [callback, where];
    this.handlers.visit(function(canCreateDiscussions, d) {
      d.mouseUp.apply(d, args);
    });
  }
};
/**
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  if (null != this.refreshHandler) {
    this.graph.getSelectionModel().removeListener(this.refreshHandler);
    this.graph.getModel().removeListener(this.refreshHandler);
    this.graph.getView().removeListener(this.refreshHandler);
    /** @type {null} */
    this.refreshHandler = null;
  }
};
/**
 * @param {!Object} targetGraph
 * @param {?} srcDoc
 * @return {undefined}
 */
function mxConnectionHandler(targetGraph, srcDoc) {
  mxEventSource.call(this);
  if (null != targetGraph) {
    /** @type {!Object} */
    this.graph = targetGraph;
    this.factoryMethod = srcDoc;
    this.init();
    this.escapeHandler = mxUtils.bind(this, function(canCreateDiscussions, isSlidingUp) {
      this.reset();
    });
    this.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
  }
}
mxUtils.extend(mxConnectionHandler, mxEventSource);
/** @type {null} */
mxConnectionHandler.prototype.graph = null;
/** @type {boolean} */
mxConnectionHandler.prototype.factoryMethod = true;
/** @type {boolean} */
mxConnectionHandler.prototype.moveIconFront = false;
/** @type {boolean} */
mxConnectionHandler.prototype.moveIconBack = false;
/** @type {null} */
mxConnectionHandler.prototype.connectImage = null;
/** @type {boolean} */
mxConnectionHandler.prototype.targetConnectImage = false;
/** @type {boolean} */
mxConnectionHandler.prototype.enabled = true;
/** @type {boolean} */
mxConnectionHandler.prototype.select = true;
/** @type {boolean} */
mxConnectionHandler.prototype.createTarget = false;
/** @type {null} */
mxConnectionHandler.prototype.marker = null;
/** @type {null} */
mxConnectionHandler.prototype.constraintHandler = null;
/** @type {null} */
mxConnectionHandler.prototype.error = null;
/** @type {boolean} */
mxConnectionHandler.prototype.waypointsEnabled = false;
/** @type {boolean} */
mxConnectionHandler.prototype.ignoreMouseDown = false;
/** @type {null} */
mxConnectionHandler.prototype.first = null;
mxConnectionHandler.prototype.connectIconOffset = new mxPoint(0, mxConstants.TOOLTIP_VERTICAL_OFFSET);
/** @type {null} */
mxConnectionHandler.prototype.edgeState = null;
/** @type {null} */
mxConnectionHandler.prototype.changeHandler = null;
/** @type {null} */
mxConnectionHandler.prototype.drillHandler = null;
/** @type {number} */
mxConnectionHandler.prototype.mouseDownCounter = 0;
/** @type {boolean} */
mxConnectionHandler.prototype.movePreviewAway = false;
/** @type {boolean} */
mxConnectionHandler.prototype.outlineConnect = false;
/** @type {boolean} */
mxConnectionHandler.prototype.livePreview = false;
/** @type {null} */
mxConnectionHandler.prototype.cursor = null;
/** @type {boolean} */
mxConnectionHandler.prototype.insertBeforeSource = false;
/**
 * @return {?}
 */
mxConnectionHandler.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {boolean} state
 * @return {undefined}
 */
mxConnectionHandler.prototype.setEnabled = function(state) {
  /** @type {boolean} */
  this.enabled = state;
};
/**
 * @param {!Object} y2
 * @param {string} i
 * @param {string} item
 * @param {number} f
 * @param {number} x0
 * @return {?}
 */
mxConnectionHandler.prototype.isInsertBefore = function(y2, i, item, f, x0) {
  return this.insertBeforeSource && i != item;
};
/**
 * @param {number} blurElems
 * @return {?}
 */
mxConnectionHandler.prototype.isCreateTarget = function(blurElems) {
  return this.createTarget;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxConnectionHandler.prototype.setCreateTarget = function(a) {
  /** @type {boolean} */
  this.createTarget = a;
};
/**
 * @return {?}
 */
mxConnectionHandler.prototype.createShape = function() {
  var options = this.livePreview && null != this.edgeState ? this.graph.cellRenderer.createShape(this.edgeState) : new mxPolyline([], mxConstants.INVALID_COLOR);
  options.dialect = mxConstants.DIALECT_SVG;
  options.scale = this.graph.view.scale;
  /** @type {number} */
  options.svgStrokeTolerance = 0;
  /** @type {boolean} */
  options.pointerEvents = false;
  /** @type {boolean} */
  options.isDashed = true;
  options.init(this.graph.getView().getOverlayPane());
  mxEvent.redirectMouseEvents(options.node, this.graph, null);
  return options;
};
/**
 * @return {undefined}
 */
mxConnectionHandler.prototype.init = function() {
  this.graph.addMouseListener(this);
  this.marker = this.createMarker();
  this.constraintHandler = new mxConstraintHandler(this.graph);
  this.changeHandler = mxUtils.bind(this, function(a) {
    if (null != this.iconState) {
      this.iconState = this.graph.getView().getState(this.iconState.cell);
    }
    if (null != this.iconState) {
      this.redrawIcons(this.icons, this.iconState);
      this.constraintHandler.reset();
    } else {
      if (null != this.previous && null == this.graph.view.getState(this.previous.cell)) {
        this.reset();
      }
    }
  });
  this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
  this.graph.getView().addListener(mxEvent.SCALE, this.changeHandler);
  this.graph.getView().addListener(mxEvent.TRANSLATE, this.changeHandler);
  this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.changeHandler);
  this.drillHandler = mxUtils.bind(this, function(a) {
    this.reset();
  });
  this.graph.addListener(mxEvent.START_EDITING, this.drillHandler);
  this.graph.getView().addListener(mxEvent.DOWN, this.drillHandler);
  this.graph.getView().addListener(mxEvent.UP, this.drillHandler);
};
/**
 * @param {?} cell
 * @return {?}
 */
mxConnectionHandler.prototype.isConnectableCell = function(cell) {
  return true;
};
/**
 * @return {?}
 */
mxConnectionHandler.prototype.createMarker = function() {
  var tree = new mxCellMarker(this.graph);
  /** @type {boolean} */
  tree.hotspotEnabled = true;
  tree.getCell = mxUtils.bind(this, function(s) {
    var name = mxCellMarker.prototype.getCell.apply(tree, arguments);
    /** @type {null} */
    this.error = null;
    if (null == name && null != this.currentPoint) {
      name = this.graph.getCellAt(this.currentPoint.x, this.currentPoint.y);
    }
    if (null != name && !this.graph.isCellConnectable(name)) {
      var element = this.graph.getModel().getParent(name);
      if (this.graph.getModel().isVertex(element) && this.graph.isCellConnectable(element)) {
        name = element;
      }
    }
    if (this.graph.isSwimlane(name) && null != this.currentPoint && this.graph.hitsSwimlaneContent(name, this.currentPoint.x, this.currentPoint.y) || !this.isConnectableCell(name)) {
      /** @type {null} */
      name = null;
    }
    if (null != name) {
      if (this.isConnecting()) {
        if (null != this.previous) {
          this.error = this.validateConnection(this.previous.cell, name);
          if (null != this.error && 0 == this.error.length) {
            /** @type {null} */
            name = null;
            if (this.isCreateTarget(s.getEvent())) {
              /** @type {null} */
              this.error = null;
            }
          }
        }
      } else {
        if (!this.isValidSource(name, s)) {
          /** @type {null} */
          name = null;
        }
      }
    } else {
      if (!(!this.isConnecting() || this.isCreateTarget(s.getEvent()) || this.graph.allowDanglingEdges)) {
        /** @type {string} */
        this.error = "";
      }
    }
    return name;
  });
  tree.isValidState = mxUtils.bind(this, function(b) {
    return this.isConnecting() ? null == this.error : mxCellMarker.prototype.isValidState.apply(tree, arguments);
  });
  tree.getMarkerColor = mxUtils.bind(this, function(b, canCreateDiscussions, isSlidingUp) {
    return null == this.connectImage || this.isConnecting() ? mxCellMarker.prototype.getMarkerColor.apply(tree, arguments) : null;
  });
  tree.intersects = mxUtils.bind(this, function(b, canCreateDiscussions) {
    return null != this.connectImage || this.isConnecting() ? true : mxCellMarker.prototype.intersects.apply(tree, arguments);
  });
  return tree;
};
/**
 * @param {string} value
 * @param {number} x
 * @param {number} y
 * @param {!Object} d
 * @return {undefined}
 */
mxConnectionHandler.prototype.start = function(value, x, y, d) {
  /** @type {string} */
  this.previous = value;
  this.first = new mxPoint(x, y);
  this.edgeState = null != d ? d : this.createEdgeState(null);
  this.marker.currentColor = this.marker.validColor;
  /** @type {string} */
  this.marker.markedState = value;
  this.marker.mark();
  this.fireEvent(new mxEventObject(mxEvent.START, "state", this.previous));
};
/**
 * @return {?}
 */
mxConnectionHandler.prototype.isConnecting = function() {
  return null != this.first && null != this.shape;
};
/**
 * @param {boolean} source
 * @param {?} x
 * @return {?}
 */
mxConnectionHandler.prototype.isValidSource = function(source, x) {
  return this.graph.isValidSource(source);
};
/**
 * @param {!Object} name
 * @return {?}
 */
mxConnectionHandler.prototype.isValidTarget = function(name) {
  return true;
};
/**
 * @param {!Object} args
 * @param {undefined} value
 * @return {?}
 */
mxConnectionHandler.prototype.validateConnection = function(args, value) {
  return this.isValidTarget(value) ? this.graph.getEdgeValidationError(null, args, value) : "";
};
/**
 * @param {?} cur
 * @return {?}
 */
mxConnectionHandler.prototype.getConnectImage = function(cur) {
  return this.connectImage;
};
/**
 * @param {?} elem
 * @return {?}
 */
mxConnectionHandler.prototype.isMoveIconToFrontForState = function(elem) {
  return null != elem.text && elem.text.node.parentNode == this.graph.container ? true : this.moveIconFront;
};
/**
 * @param {?} elem
 * @return {?}
 */
mxConnectionHandler.prototype.createIcons = function(elem) {
  var table = this.getConnectImage(elem);
  if (null != table && null != elem) {
    this.iconState = elem;
    /** @type {!Array} */
    var c = [];
    var bounds = new mxRectangle(0, 0, table.width, table.height);
    var element = new mxImageShape(bounds, table.src, null, null, 0);
    /** @type {boolean} */
    element.preserveImageAspect = false;
    if (this.isMoveIconToFrontForState(elem)) {
      element.dialect = mxConstants.DIALECT_STRICTHTML;
      element.init(this.graph.container);
    } else {
      element.dialect = mxConstants.DIALECT_SVG;
      element.init(this.graph.getView().getOverlayPane());
      if (this.moveIconBack && null != element.node.previousSibling) {
        element.node.parentNode.insertBefore(element.node, element.node.parentNode.firstChild);
      }
    }
    element.node.style.cursor = mxConstants.CURSOR_CONNECT;
    var update = mxUtils.bind(this, function() {
      return null != this.currentState ? this.currentState : elem;
    });
    table = mxUtils.bind(this, function(evt) {
      if (!mxEvent.isConsumed(evt)) {
        this.icon = element;
        this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, update()));
      }
    });
    mxEvent.redirectMouseEvents(element.node, this.graph, update, table);
    c.push(element);
    this.redrawIcons(c, this.iconState);
    return c;
  }
  return null;
};
/**
 * @param {!Object} d
 * @param {?} trans
 * @return {undefined}
 */
mxConnectionHandler.prototype.redrawIcons = function(d, trans) {
  if (null != d && null != d[0] && null != trans) {
    trans = this.getIconPosition(d[0], trans);
    d[0].bounds.x = trans.x;
    d[0].bounds.y = trans.y;
    d[0].redraw();
  }
};
/**
 * @param {!Object} _
 * @param {?} s
 * @return {?}
 */
mxConnectionHandler.prototype.getIconPosition = function(_, s) {
  var cos = this.graph.getView().scale;
  var width = s.getCenterX();
  var bottom = s.getCenterY();
  if (this.graph.isSwimlane(s.cell)) {
    var a = this.graph.getStartSize(s.cell);
    width = 0 != a.width ? s.x + a.width * cos / 2 : width;
    bottom = 0 != a.height ? s.y + a.height * cos / 2 : bottom;
    a = mxUtils.toRadians(mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION) || 0);
    if (0 != a) {
      /** @type {number} */
      cos = Math.cos(a);
      /** @type {number} */
      a = Math.sin(a);
      s = new mxPoint(s.getCenterX(), s.getCenterY());
      bottom = mxUtils.getRotatedPoint(new mxPoint(width, bottom), cos, a, s);
      width = bottom.x;
      bottom = bottom.y;
    }
  }
  return new mxPoint(width - _.bounds.width / 2, bottom - _.bounds.height / 2);
};
/**
 * @return {undefined}
 */
mxConnectionHandler.prototype.destroyIcons = function() {
  if (null != this.icons) {
    /** @type {number} */
    var i = 0;
    for (; i < this.icons.length; i++) {
      this.icons[i].destroy();
    }
    /** @type {null} */
    this.iconState = this.selectedIcon = this.icon = this.icons = null;
  }
};
/**
 * @param {!Event} object
 * @return {?}
 */
mxConnectionHandler.prototype.isStartEvent = function(object) {
  return null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentConstraint || null != this.previous && null == this.error && (null == this.icons || null != this.icons && null != this.icon);
};
/**
 * @param {string} item
 * @param {!Event} me
 * @return {undefined}
 */
mxConnectionHandler.prototype.mouseDown = function(item, me) {
  this.mouseDownCounter++;
  if (this.isEnabled() && this.graph.isEnabled() && !me.isConsumed() && !this.isConnecting() && this.isStartEvent(me)) {
    if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentPoint) {
      this.sourceConstraint = this.constraintHandler.currentConstraint;
      this.previous = this.constraintHandler.currentFocus;
      this.first = this.constraintHandler.currentPoint.clone();
    } else {
      this.first = new mxPoint(me.getGraphX(), me.getGraphY());
    }
    this.edgeState = this.createEdgeState(me);
    /** @type {number} */
    this.mouseDownCounter = 1;
    if (this.waypointsEnabled && null == this.shape) {
      /** @type {null} */
      this.waypoints = null;
      this.shape = this.createShape();
      if (null != this.edgeState) {
        this.shape.apply(this.edgeState);
      }
    }
    if (null == this.previous && null != this.edgeState) {
      item = this.graph.getPointForEvent(me.getEvent());
      this.edgeState.cell.geometry.setTerminalPoint(item, true);
    }
    this.fireEvent(new mxEventObject(mxEvent.START, "state", this.previous));
    me.consume();
  }
  this.selectedIcon = this.icon;
  /** @type {null} */
  this.icon = null;
};
/**
 * @param {?} data
 * @return {?}
 */
mxConnectionHandler.prototype.isImmediateConnectSource = function(data) {
  return !this.graph.isCellMovable(data.cell);
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxConnectionHandler.prototype.createEdgeState = function(me) {
  return null;
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxConnectionHandler.prototype.isOutlineConnectEvent = function(me) {
  if (mxEvent.isShiftDown(me.getEvent()) && mxEvent.isAltDown(me.getEvent())) {
    return false;
  }
  var n = mxUtils.getOffset(this.graph.container);
  var e = me.getEvent();
  var d = mxEvent.getClientX(e);
  e = mxEvent.getClientY(e);
  /** @type {!Element} */
  var doc = document.documentElement;
  /** @type {number} */
  var df = this.currentPoint.x - this.graph.container.scrollLeft + n.x - ((window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0));
  /** @type {number} */
  n = this.currentPoint.y - this.graph.container.scrollTop + n.y - ((window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0));
  return this.outlineConnect && (mxEvent.isShiftDown(me.getEvent()) && !mxEvent.isAltDown(me.getEvent()) || me.isSource(this.marker.highlight.shape) || !mxEvent.isShiftDown(me.getEvent()) && mxEvent.isAltDown(me.getEvent()) && null != me.getState() || this.marker.highlight.isHighlightAt(d, e) || (df != d || n != e) && null == me.getState() && this.marker.highlight.isHighlightAt(df, n));
};
/**
 * @param {!Object} me
 * @param {?} width
 * @return {undefined}
 */
mxConnectionHandler.prototype.updateCurrentState = function(me, width) {
  this.constraintHandler.update(me, null == this.first, false, null == this.first || me.isSource(this.marker.highlight.shape) ? null : width);
  if (null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentConstraint) {
    if (null != this.marker.highlight && null != this.marker.highlight.state && this.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell) {
      if ("transparent" != this.marker.highlight.shape.stroke) {
        /** @type {string} */
        this.marker.highlight.shape.stroke = "transparent";
        this.marker.highlight.repaint();
      }
    } else {
      this.marker.markCell(this.constraintHandler.currentFocus.cell, "transparent");
    }
    if (null != this.previous) {
      this.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);
      if (null == this.error) {
        this.currentState = this.constraintHandler.currentFocus;
      }
      if (null != this.error || null != this.currentState && !this.isCellEnabled(this.currentState.cell)) {
        this.constraintHandler.reset();
      }
    }
  } else {
    if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {
      this.marker.reset();
      /** @type {null} */
      this.currentState = null;
    } else {
      this.marker.process(me);
      this.currentState = this.marker.getValidState();
    }
    if (!(null == this.currentState || this.isCellEnabled(this.currentState.cell))) {
      this.constraintHandler.reset();
      this.marker.reset();
      /** @type {null} */
      this.currentState = null;
    }
    var result = this.isOutlineConnectEvent(me);
    if (null != this.currentState && result) {
      if (me.isSource(this.marker.highlight.shape)) {
        width = new mxPoint(me.getGraphX(), me.getGraphY());
      }
      result = this.graph.getOutlineConstraint(width, this.currentState, me);
      this.constraintHandler.setFocus(me, this.currentState, false);
      this.constraintHandler.currentConstraint = result;
      this.constraintHandler.currentPoint = width;
    }
    if (this.outlineConnect && null != this.marker.highlight && null != this.marker.highlight.shape) {
      width = this.graph.view.scale;
      if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus) {
        this.marker.highlight.shape.stroke = mxConstants.OUTLINE_HIGHLIGHT_COLOR;
        /** @type {number} */
        this.marker.highlight.shape.strokewidth = mxConstants.OUTLINE_HIGHLIGHT_STROKEWIDTH / width / width;
        this.marker.highlight.repaint();
      } else {
        if (this.marker.hasValidState()) {
          if (this.graph.isCellConnectable(me.getCell()) && this.marker.getValidState() != me.getState()) {
            /** @type {string} */
            this.marker.highlight.shape.stroke = "transparent";
            /** @type {null} */
            this.currentState = null;
          } else {
            this.marker.highlight.shape.stroke = mxConstants.DEFAULT_VALID_COLOR;
          }
          /** @type {number} */
          this.marker.highlight.shape.strokewidth = mxConstants.HIGHLIGHT_STROKEWIDTH / width / width;
          this.marker.highlight.repaint();
        }
      }
    }
  }
};
/**
 * @param {?} a
 * @return {?}
 */
mxConnectionHandler.prototype.isCellEnabled = function(a) {
  return true;
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxConnectionHandler.prototype.convertWaypoint = function(data) {
  var scale = this.graph.getView().getScale();
  var geo = this.graph.getView().getTranslate();
  /** @type {number} */
  data.x = data.x / scale - geo.x;
  /** @type {number} */
  data.y = data.y / scale - geo.y;
};
/**
 * @param {!Object} me
 * @param {!Object} variable
 * @return {undefined}
 */
mxConnectionHandler.prototype.snapToPreview = function(me, variable) {
  if (!mxEvent.isAltDown(me.getEvent()) && null != this.previous) {
    /** @type {number} */
    var c = this.graph.gridSize * this.graph.view.scale / 2;
    var current = null != this.sourceConstraint ? this.first : new mxPoint(this.previous.getCenterX(), this.previous.getCenterY());
    if (Math.abs(current.x - me.getGraphX()) < c) {
      variable.x = current.x;
    }
    if (Math.abs(current.y - me.getGraphY()) < c) {
      variable.y = current.y;
    }
  }
};
/**
 * @param {!Object} value
 * @param {!Object} me
 * @return {undefined}
 */
mxConnectionHandler.prototype.mouseMove = function(value, me) {
  if (me.isConsumed() || !this.ignoreMouseDown && null == this.first && this.graph.isMouseDown) {
    this.constraintHandler.reset();
  } else {
    if (!(this.isEnabled() || null == this.currentState)) {
      this.destroyIcons();
      /** @type {null} */
      this.currentState = null;
    }
    value = this.graph.getView();
    var s = value.scale;
    var i = value.translate;
    value = new mxPoint(me.getGraphX(), me.getGraphY());
    /** @type {null} */
    this.error = null;
    if (this.graph.isGridEnabledEvent(me.getEvent())) {
      value = new mxPoint((this.graph.snap(value.x / s - i.x) + i.x) * s, (this.graph.snap(value.y / s - i.y) + i.y) * s);
    }
    this.snapToPreview(me, value);
    /** @type {!Object} */
    this.currentPoint = value;
    if ((null != this.first || this.isEnabled() && this.graph.isEnabled()) && (null != this.shape || null == this.first || Math.abs(me.getGraphX() - this.first.x) > this.graph.tolerance || Math.abs(me.getGraphY() - this.first.y) > this.graph.tolerance)) {
      this.updateCurrentState(me, value);
    }
    if (null != this.first) {
      /** @type {null} */
      var labelWidth = null;
      /** @type {!Object} */
      s = value;
      if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentPoint) {
        labelWidth = this.constraintHandler.currentConstraint;
        s = this.constraintHandler.currentPoint.clone();
      } else {
        if (null != this.previous && mxEvent.isShiftDown(me.getEvent()) && !this.graph.isIgnoreTerminalEvent(me.getEvent())) {
          if (Math.abs(this.previous.getCenterX() - value.x) < Math.abs(this.previous.getCenterY() - value.y)) {
            value.x = this.previous.getCenterX();
          } else {
            value.y = this.previous.getCenterY();
          }
        }
      }
      i = this.first;
      if (null != this.selectedIcon) {
        var size = this.selectedIcon.bounds.width;
        var factor = this.selectedIcon.bounds.height;
        if (null != this.currentState && this.targetConnectImage) {
          size = this.getIconPosition(this.selectedIcon, this.currentState);
          this.selectedIcon.bounds.x = size.x;
          this.selectedIcon.bounds.y = size.y;
        } else {
          size = new mxRectangle(me.getGraphX() + this.connectIconOffset.x, me.getGraphY() + this.connectIconOffset.y, size, factor);
          this.selectedIcon.bounds = size;
        }
        this.selectedIcon.redraw();
      }
      if (null != this.edgeState) {
        this.updateEdgeState(s, labelWidth);
        s = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];
        i = this.edgeState.absolutePoints[0];
      } else {
        if (null != this.currentState && null == this.constraintHandler.currentConstraint) {
          size = this.getTargetPerimeterPoint(this.currentState, me);
          if (null != size) {
            s = size;
          }
        }
        if (null == this.sourceConstraint && null != this.previous) {
          size = this.getSourcePerimeterPoint(this.previous, null != this.waypoints && 0 < this.waypoints.length ? this.waypoints[0] : s, me);
          if (null != size) {
            i = size;
          }
        }
      }
      if (null == this.currentState && this.movePreviewAway) {
        size = i;
        if (null != this.edgeState && 2 <= this.edgeState.absolutePoints.length) {
          labelWidth = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];
          if (null != labelWidth) {
            size = labelWidth;
          }
        }
        /** @type {number} */
        labelWidth = s.x - size.x;
        /** @type {number} */
        size = s.y - size.y;
        /** @type {number} */
        factor = Math.sqrt(labelWidth * labelWidth + size * size);
        if (0 == factor) {
          return;
        }
        this.originalPoint = s.clone();
        s.x -= 4 * labelWidth / factor;
        s.y -= 4 * size / factor;
      } else {
        /** @type {null} */
        this.originalPoint = null;
      }
      if (null == this.shape && (labelWidth = Math.abs(me.getGraphX() - this.first.x), size = Math.abs(me.getGraphY() - this.first.y), labelWidth > this.graph.tolerance || size > this.graph.tolerance)) {
        this.shape = this.createShape();
        if (null != this.edgeState) {
          this.shape.apply(this.edgeState);
        }
        this.updateCurrentState(me, value);
      }
      if (null != this.shape) {
        if (null != this.edgeState) {
          this.shape.points = this.edgeState.absolutePoints;
        } else {
          /** @type {!Array} */
          value = [i];
          if (null != this.waypoints) {
            /** @type {!Array<?>} */
            value = value.concat(this.waypoints);
          }
          value.push(s);
          /** @type {!Object} */
          this.shape.points = value;
        }
        this.drawPreview();
      }
      if (null != this.cursor) {
        this.graph.container.style.cursor = this.cursor;
      }
      mxEvent.consume(me.getEvent());
      me.consume();
    } else {
      if (this.isEnabled() && this.graph.isEnabled()) {
        if (this.previous != this.currentState && null == this.edgeState) {
          this.destroyIcons();
          if (null != this.currentState && null == this.error && null == this.constraintHandler.currentConstraint) {
            this.icons = this.createIcons(this.currentState);
            if (null == this.icons) {
              this.currentState.setCursor(mxConstants.CURSOR_CONNECT);
              me.consume();
            }
          }
          this.previous = this.currentState;
        } else {
          if (!(this.previous != this.currentState || null == this.currentState || null != this.icons || this.graph.isMouseDown)) {
            me.consume();
          }
        }
      } else {
        this.constraintHandler.reset();
      }
    }
    if (!this.graph.isMouseDown && null != this.currentState && null != this.icons) {
      /** @type {boolean} */
      value = false;
      s = me.getSource();
      /** @type {number} */
      i = 0;
      for (; i < this.icons.length && !value; i++) {
        /** @type {boolean} */
        value = s == this.icons[i].node || s.parentNode == this.icons[i].node;
      }
      if (!value) {
        this.updateIcons(this.currentState, this.icons, me);
      }
    }
  }
};
/**
 * @param {!Object} b
 * @param {number} i
 * @return {undefined}
 */
mxConnectionHandler.prototype.updateEdgeState = function(b, i) {
  if (null != this.sourceConstraint && null != this.sourceConstraint.point) {
    this.edgeState.style[mxConstants.STYLE_EXIT_X] = this.sourceConstraint.point.x;
    this.edgeState.style[mxConstants.STYLE_EXIT_Y] = this.sourceConstraint.point.y;
  }
  if (null != i && null != i.point) {
    this.edgeState.style[mxConstants.STYLE_ENTRY_X] = i.point.x;
    this.edgeState.style[mxConstants.STYLE_ENTRY_Y] = i.point.y;
  } else {
    delete this.edgeState.style[mxConstants.STYLE_ENTRY_X];
    delete this.edgeState.style[mxConstants.STYLE_ENTRY_Y];
  }
  /** @type {!Array} */
  this.edgeState.absolutePoints = [null, null != this.currentState ? null : b];
  this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);
  if (null != this.currentState) {
    if (null == i) {
      i = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);
    }
    this.edgeState.setAbsoluteTerminalPoint(null, false);
    this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, i);
  }
  /** @type {null} */
  b = null;
  if (null != this.waypoints) {
    /** @type {!Array} */
    b = [];
    /** @type {number} */
    i = 0;
    for (; i < this.waypoints.length; i++) {
      var xyz = this.waypoints[i].clone();
      this.convertWaypoint(xyz);
      b[i] = xyz;
    }
  }
  this.graph.view.updatePoints(this.edgeState, b, this.previous, this.currentState);
  this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);
};
/**
 * @param {!Object} self
 * @param {!Object} o
 * @return {?}
 */
mxConnectionHandler.prototype.getTargetPerimeterPoint = function(self, o) {
  /** @type {null} */
  o = null;
  var query = self.view;
  var func = query.getPerimeterFunction(self);
  if (null != func) {
    var undefined = null != this.waypoints && 0 < this.waypoints.length ? this.waypoints[this.waypoints.length - 1] : new mxPoint(this.previous.getCenterX(), this.previous.getCenterY());
    self = func(query.getPerimeterBounds(self), this.edgeState, undefined, false);
    if (null != self) {
      /** @type {!Object} */
      o = self;
    }
  } else {
    o = new mxPoint(self.getCenterX(), self.getCenterY());
  }
  return o;
};
/**
 * @param {!Object} point
 * @param {number} threshold
 * @param {!Object} type
 * @return {?}
 */
mxConnectionHandler.prototype.getSourcePerimeterPoint = function(point, threshold, type) {
  /** @type {null} */
  type = null;
  var node = point.view;
  var resolveSaddlePointWithAvg = node.getPerimeterFunction(point);
  var ct = new mxPoint(point.getCenterX(), point.getCenterY());
  if (null != resolveSaddlePointWithAvg) {
    var g = mxUtils.getValue(point.style, mxConstants.STYLE_ROTATION, 0);
    /** @type {number} */
    var r = Math.PI / 180 * -g;
    if (0 != g) {
      threshold = mxUtils.getRotatedPoint(new mxPoint(threshold.x, threshold.y), Math.cos(r), Math.sin(r), ct);
    }
    point = resolveSaddlePointWithAvg(node.getPerimeterBounds(point), point, threshold, false);
    if (null != point) {
      if (0 != g) {
        point = mxUtils.getRotatedPoint(new mxPoint(point.x, point.y), Math.cos(-r), Math.sin(-r), ct);
      }
      /** @type {!Object} */
      type = point;
    }
  } else {
    type = ct;
  }
  return type;
};
/**
 * @param {?} urls
 * @param {?} callback
 * @param {!Object} page
 * @return {undefined}
 */
mxConnectionHandler.prototype.updateIcons = function(urls, callback, page) {
};
/**
 * @param {!Object} job
 * @return {?}
 */
mxConnectionHandler.prototype.isStopEvent = function(job) {
  return null != job.getState();
};
/**
 * @param {!Object} me
 * @return {undefined}
 */
mxConnectionHandler.prototype.addWaypointForEvent = function(me) {
  var destination = mxUtils.convertPoint(this.graph.container, me.getX(), me.getY());
  /** @type {number} */
  var scale = Math.abs(destination.x - this.first.x);
  /** @type {number} */
  destination = Math.abs(destination.y - this.first.y);
  if (null != this.waypoints || 1 < this.mouseDownCounter && (scale > this.graph.tolerance || destination > this.graph.tolerance)) {
    if (null == this.waypoints) {
      /** @type {!Array} */
      this.waypoints = [];
    }
    scale = this.graph.view.scale;
    destination = new mxPoint(this.graph.snap(me.getGraphX() / scale) * scale, this.graph.snap(me.getGraphY() / scale) * scale);
    this.waypoints.push(destination);
  }
};
/**
 * @param {!Object} element
 * @param {!Object} state
 * @return {?}
 */
mxConnectionHandler.prototype.checkConstraints = function(element, state) {
  return null == element || null == state || null == element.point || null == state.point || !element.point.equals(state.point) || element.dx != state.dx || element.dy != state.dy || element.perimeter != state.perimeter;
};
/**
 * @param {!Object} opt
 * @param {!Event} me
 * @return {undefined}
 */
mxConnectionHandler.prototype.mouseUp = function(opt, me) {
  if (!me.isConsumed() && this.isConnecting()) {
    if (this.waypointsEnabled && !this.isStopEvent(me)) {
      this.addWaypointForEvent(me);
      me.consume();
      return;
    }
    opt = this.sourceConstraint;
    var selector = this.constraintHandler.currentConstraint;
    var n = null != this.previous ? this.previous.cell : null;
    /** @type {null} */
    var e = null;
    if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus) {
      e = this.constraintHandler.currentFocus.cell;
    }
    if (null == e && null != this.currentState) {
      e = this.currentState.cell;
    }
    if (null != this.error || null != n && null != e && n == e && !this.checkConstraints(opt, selector)) {
      if (null != this.previous && null != this.marker.validState && this.previous.cell == this.marker.validState.cell) {
        this.graph.selectCellForEvent(this.marker.source, me.getEvent());
      }
      if (null != this.error && 0 < this.error.length) {
        this.graph.validationAlert(this.error);
      }
    } else {
      this.connect(n, e, me.getEvent(), me.getCell());
    }
    this.destroyIcons();
    me.consume();
  }
  if (null != this.first) {
    this.reset();
  }
};
/**
 * @return {undefined}
 */
mxConnectionHandler.prototype.reset = function() {
  if (null != this.shape) {
    this.shape.destroy();
    /** @type {null} */
    this.shape = null;
  }
  if (null != this.cursor && null != this.graph.container) {
    /** @type {string} */
    this.graph.container.style.cursor = "";
  }
  this.destroyIcons();
  this.marker.reset();
  this.constraintHandler.reset();
  /** @type {null} */
  this.sourceConstraint = this.error = this.previous = this.edgeState = this.currentPoint = this.originalPoint = null;
  /** @type {number} */
  this.mouseDownCounter = 0;
  /** @type {null} */
  this.first = null;
  this.fireEvent(new mxEventObject(mxEvent.RESET));
};
/**
 * @return {undefined}
 */
mxConnectionHandler.prototype.drawPreview = function() {
  this.updatePreview(null == this.error);
  if (null != this.edgeState) {
    this.edgeState.shape = this.shape;
    this.graph.cellRenderer.postConfigureShape(this.edgeState);
    /** @type {null} */
    this.edgeState.shape = null;
  }
  this.shape.redraw();
};
/**
 * @param {boolean} dataUrl
 * @return {undefined}
 */
mxConnectionHandler.prototype.updatePreview = function(dataUrl) {
  this.shape.strokewidth = this.getEdgeWidth(dataUrl);
  this.shape.stroke = this.getEdgeColor(dataUrl);
};
/**
 * @param {boolean} ls
 * @return {?}
 */
mxConnectionHandler.prototype.getEdgeColor = function(ls) {
  return ls ? mxConstants.VALID_COLOR : mxConstants.INVALID_COLOR;
};
/**
 * @param {boolean} dataurl
 * @return {?}
 */
mxConnectionHandler.prototype.getEdgeWidth = function(dataurl) {
  return dataurl ? 3 : 1;
};
/**
 * @param {string} i
 * @param {string} element
 * @param {number} target
 * @param {number} index
 * @return {undefined}
 */
mxConnectionHandler.prototype.connect = function(i, element, target, index) {
  if (null != element || this.isCreateTarget(target) || this.graph.allowDanglingEdges) {
    var me = this.graph.getModel();
    /** @type {boolean} */
    var fileSet = false;
    /** @type {null} */
    var value = null;
    me.beginUpdate();
    try {
      if (null != i && null == element && !this.graph.isIgnoreTerminalEvent(target) && this.isCreateTarget(target) && (element = this.createTargetVertex(target, i), null != element)) {
        index = this.graph.getDropTarget([element], target, index);
        /** @type {boolean} */
        fileSet = true;
        if (null != index && this.graph.getModel().isEdge(index)) {
          index = this.graph.getDefaultParent();
        } else {
          var start = this.graph.getView().getState(index);
          if (null != start) {
            var target = me.getGeometry(element);
            target.x -= start.origin.x;
            target.y -= start.origin.y;
          }
        }
        this.graph.addCell(element, index);
      }
      var name = this.graph.getDefaultParent();
      if (null != i && null != element && me.getParent(i) == me.getParent(element) && me.getParent(me.getParent(i)) != me.getRoot()) {
        name = me.getParent(i);
        if (null != i.geometry && i.geometry.relative && null != element.geometry && element.geometry.relative) {
          name = me.getParent(name);
        }
      }
      /** @type {null} */
      var prev = start = null;
      if (null != this.edgeState) {
        start = this.edgeState.cell.value;
        prev = this.edgeState.cell.style;
      }
      value = this.insertEdge(name, null, start, i, element, prev);
      if (null != value) {
        this.graph.setConnectionConstraint(value, i, true, this.sourceConstraint);
        this.graph.setConnectionConstraint(value, element, false, this.constraintHandler.currentConstraint);
        if (null != this.edgeState) {
          me.setGeometry(value, this.edgeState.cell.geometry);
        }
        name = me.getParent(i);
        if (this.isInsertBefore(value, i, element, target, index)) {
          /** @type {string} */
          target = i;
          for (; null != target.parent && null != target.geometry && target.geometry.relative && target.parent != value.parent;) {
            target = this.graph.model.getParent(target);
          }
          if (null != target && null != target.parent && target.parent == value.parent) {
            me.add(name, value, target.parent.getIndex(target));
          }
        }
        var query = me.getGeometry(value);
        if (null == query) {
          query = new mxGeometry;
          /** @type {boolean} */
          query.relative = true;
          me.setGeometry(value, query);
        }
        if (null != this.waypoints && 0 < this.waypoints.length) {
          var scale = this.graph.view.scale;
          var geo = this.graph.view.translate;
          /** @type {!Array} */
          query.points = [];
          /** @type {number} */
          i = 0;
          for (; i < this.waypoints.length; i++) {
            var pt = this.waypoints[i];
            query.points.push(new mxPoint(pt.x / scale - geo.x, pt.y / scale - geo.y));
          }
        }
        if (null == element) {
          var geo = this.graph.view.translate;
          scale = this.graph.view.scale;
          pt = null != this.originalPoint ? new mxPoint(this.originalPoint.x / scale - geo.x, this.originalPoint.y / scale - geo.y) : new mxPoint(this.currentPoint.x / scale - geo.x, this.currentPoint.y / scale - geo.y);
          pt.x -= this.graph.panDx / this.graph.view.scale;
          pt.y -= this.graph.panDy / this.graph.view.scale;
          query.setTerminalPoint(pt, false);
        }
        this.fireEvent(new mxEventObject(mxEvent.CONNECT, "cell", value, "terminal", element, "event", target, "target", index, "terminalInserted", fileSet));
      }
    } catch (logEntry) {
      mxLog.show();
      mxLog.debug(logEntry.message);
    } finally {
      me.endUpdate();
    }
    if (this.select) {
      this.selectCells(value, fileSet ? element : null);
    }
  }
};
/**
 * @param {string} edge
 * @param {boolean} target
 * @return {undefined}
 */
mxConnectionHandler.prototype.selectCells = function(edge, target) {
  this.graph.setSelectionCell(edge);
};
/**
 * @param {(Object|string)} parent
 * @param {string} node
 * @param {string} source
 * @param {string} i
 * @param {string} value
 * @param {?} type
 * @return {?}
 */
mxConnectionHandler.prototype.insertEdge = function(parent, node, source, i, value, type) {
  if (null == this.factoryMethod) {
    return this.graph.insertEdge(parent, node, source, i, value, type);
  }
  node = this.createEdge(source, i, value, type);
  return node = this.graph.addEdge(node, parent, i, value);
};
/**
 * @param {!Object} item
 * @param {number} i
 * @return {?}
 */
mxConnectionHandler.prototype.createTargetVertex = function(item, i) {
  item = this.graph.getCellGeometry(i);
  for (; null != item && item.relative;) {
    i = this.graph.getModel().getParent(i);
    item = this.graph.getCellGeometry(i);
  }
  var target = this.graph.cloneCell(i);
  item = this.graph.getModel().getGeometry(target);
  if (null != item) {
    var t = this.graph.view.translate;
    var scale = this.graph.view.scale;
    var pt = new mxPoint(this.currentPoint.x / scale - t.x, this.currentPoint.y / scale - t.y);
    /** @type {number} */
    item.x = Math.round(pt.x - item.width / 2 - this.graph.panDx / scale);
    /** @type {number} */
    item.y = Math.round(pt.y - item.height / 2 - this.graph.panDy / scale);
    pt = this.getAlignmentTolerance();
    if (0 < pt) {
      var pixel = this.graph.view.getState(i);
      if (null != pixel) {
        /** @type {number} */
        i = pixel.x / scale - t.x;
        /** @type {number} */
        t = pixel.y / scale - t.y;
        if (Math.abs(i - item.x) <= pt) {
          /** @type {number} */
          item.x = Math.round(i);
        }
        if (Math.abs(t - item.y) <= pt) {
          /** @type {number} */
          item.y = Math.round(t);
        }
      }
    }
  }
  return target;
};
/**
 * @param {?} a
 * @return {?}
 */
mxConnectionHandler.prototype.getAlignmentTolerance = function(a) {
  return this.graph.isGridEnabled() ? this.graph.gridSize / 2 : this.graph.tolerance;
};
/**
 * @param {string} source
 * @param {string} d
 * @param {string} b
 * @param {!Object} name
 * @return {?}
 */
mxConnectionHandler.prototype.createEdge = function(source, d, b, name) {
  /** @type {null} */
  var g = null;
  if (null != this.factoryMethod) {
    g = this.factoryMethod(d, b, name);
  }
  if (null == g) {
    g = new mxCell(source || "");
    g.setEdge(true);
    g.setStyle(name);
    source = new mxGeometry;
    /** @type {boolean} */
    source.relative = true;
    g.setGeometry(source);
  }
  return g;
};
/**
 * @return {undefined}
 */
mxConnectionHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  if (null != this.shape) {
    this.shape.destroy();
    /** @type {null} */
    this.shape = null;
  }
  if (null != this.marker) {
    this.marker.destroy();
    /** @type {null} */
    this.marker = null;
  }
  if (null != this.constraintHandler) {
    this.constraintHandler.destroy();
    /** @type {null} */
    this.constraintHandler = null;
  }
  if (null != this.changeHandler) {
    this.graph.getModel().removeListener(this.changeHandler);
    this.graph.getView().removeListener(this.changeHandler);
    /** @type {null} */
    this.changeHandler = null;
  }
  if (null != this.drillHandler) {
    this.graph.removeListener(this.drillHandler);
    this.graph.getView().removeListener(this.drillHandler);
    /** @type {null} */
    this.drillHandler = null;
  }
  if (null != this.escapeHandler) {
    this.graph.removeListener(this.escapeHandler);
    /** @type {null} */
    this.escapeHandler = null;
  }
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxConstraintHandler(targetGraph) {
  /** @type {!Object} */
  this.graph = targetGraph;
  this.resetHandler = mxUtils.bind(this, function(b, canCreateDiscussions) {
    if (null != this.currentFocus && null == this.graph.view.getState(this.currentFocus.cell)) {
      this.reset();
    } else {
      this.redraw();
    }
  });
  this.graph.model.addListener(mxEvent.CHANGE, this.resetHandler);
  this.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.resetHandler);
  this.graph.view.addListener(mxEvent.TRANSLATE, this.resetHandler);
  this.graph.view.addListener(mxEvent.SCALE, this.resetHandler);
  this.graph.addListener(mxEvent.ROOT, this.resetHandler);
}
mxConstraintHandler.prototype.pointImage = new mxImage(mxClient.imageBasePath + "/point.gif", 5, 5);
/** @type {null} */
mxConstraintHandler.prototype.graph = null;
/** @type {boolean} */
mxConstraintHandler.prototype.enabled = true;
/** @type {string} */
mxConstraintHandler.prototype.highlightColor = mxConstants.DEFAULT_VALID_COLOR;
/**
 * @return {?}
 */
mxConstraintHandler.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {boolean} state
 * @return {undefined}
 */
mxConstraintHandler.prototype.setEnabled = function(state) {
  /** @type {boolean} */
  this.enabled = state;
};
/**
 * @return {undefined}
 */
mxConstraintHandler.prototype.reset = function() {
  if (null != this.focusIcons) {
    /** @type {number} */
    var i = 0;
    for (; i < this.focusIcons.length; i++) {
      this.focusIcons[i].destroy();
    }
    /** @type {null} */
    this.focusIcons = null;
  }
  if (null != this.focusHighlight) {
    this.focusHighlight.destroy();
    /** @type {null} */
    this.focusHighlight = null;
  }
  /** @type {null} */
  this.focusPoints = this.currentFocus = this.currentPoint = this.currentFocusArea = this.currentConstraint = null;
};
/**
 * @param {!Function} names
 * @return {?}
 */
mxConstraintHandler.prototype.getTolerance = function(names) {
  return this.graph.getTolerance();
};
/**
 * @param {!Object} dbRow
 * @param {?} queryContext
 * @param {?} row
 * @return {?}
 */
mxConstraintHandler.prototype.getImageForConstraint = function(dbRow, queryContext, row) {
  return this.pointImage;
};
/**
 * @param {!Function} type
 * @param {!Object} who
 * @return {?}
 */
mxConstraintHandler.prototype.isEventIgnored = function(type, who) {
  return false;
};
/**
 * @param {!Object} tag
 * @param {number} prefix
 * @return {?}
 */
mxConstraintHandler.prototype.isStateIgnored = function(tag, prefix) {
  return false;
};
/**
 * @return {undefined}
 */
mxConstraintHandler.prototype.destroyIcons = function() {
  if (null != this.focusIcons) {
    /** @type {number} */
    var i = 0;
    for (; i < this.focusIcons.length; i++) {
      this.focusIcons[i].destroy();
    }
    /** @type {null} */
    this.focusPoints = this.focusIcons = null;
  }
};
/**
 * @return {undefined}
 */
mxConstraintHandler.prototype.destroyFocusHighlight = function() {
  if (null != this.focusHighlight) {
    this.focusHighlight.destroy();
    /** @type {null} */
    this.focusHighlight = null;
  }
};
/**
 * @param {number} event
 * @return {?}
 */
mxConstraintHandler.prototype.isKeepFocusEvent = function(event) {
  return mxEvent.isShiftDown(event.getEvent()) && !mxEvent.isAltDown(event.getEvent());
};
/**
 * @param {number} obj
 * @param {!Object} edge
 * @return {?}
 */
mxConstraintHandler.prototype.getCellForEvent = function(obj, edge) {
  var el = obj.getCell();
  if (!(null != el || null == edge || obj.getGraphX() == edge.x && obj.getGraphY() == edge.y)) {
    el = this.graph.getCellAt(edge.x, edge.y);
  }
  if (!(null == el || this.graph.isCellConnectable(el))) {
    obj = this.graph.getModel().getParent(el);
    if (this.graph.getModel().isVertex(obj) && this.graph.isCellConnectable(obj)) {
      /** @type {number} */
      el = obj;
    }
  }
  return this.graph.isCellLocked(el) ? null : el;
};
/**
 * @param {number} name
 * @param {boolean} w
 * @param {boolean} h
 * @param {!Object} start
 * @return {undefined}
 */
mxConstraintHandler.prototype.update = function(name, w, h, start) {
  if (this.isEnabled() && !this.isEventIgnored(name)) {
    if (null == this.mouseleaveHandler && null != this.graph.container) {
      this.mouseleaveHandler = mxUtils.bind(this, function() {
        this.reset();
      });
      mxEvent.addListener(this.graph.container, "mouseleave", this.resetHandler);
    }
    var s = this.getTolerance(name);
    var y = null != start ? start.x : name.getGraphX();
    var time1 = null != start ? start.y : name.getGraphY();
    y = new mxRectangle(y - s, time1 - s, 2 * s, 2 * s);
    s = new mxRectangle(name.getGraphX() - s, name.getGraphY() - s, 2 * s, 2 * s);
    var node = this.graph.view.getState(this.getCellForEvent(name, start));
    if (!(this.isKeepFocusEvent(name) || null != this.currentFocusArea && null != this.currentFocus && null == node && this.graph.getModel().isVertex(this.currentFocus.cell) && mxUtils.intersects(this.currentFocusArea, s) || node == this.currentFocus)) {
      /** @type {null} */
      this.currentFocus = this.currentFocusArea = null;
      this.setFocus(name, node, w);
    }
    /** @type {null} */
    name = this.currentPoint = this.currentConstraint = null;
    if (null != this.focusIcons && null != this.constraints && (null == node || this.currentFocus == node)) {
      time1 = s.getCenterX();
      var l = s.getCenterY();
      /** @type {number} */
      var i = 0;
      for (; i < this.focusIcons.length; i++) {
        /** @type {number} */
        var argR = time1 - this.focusIcons[i].bounds.getCenterX();
        /** @type {number} */
        var arg = l - this.focusIcons[i].bounds.getCenterY();
        /** @type {number} */
        argR = argR * argR + arg * arg;
        if ((this.intersects(this.focusIcons[i], s, w, h) || null != start && this.intersects(this.focusIcons[i], y, w, h)) && (null == name || argR < name)) {
          this.currentConstraint = this.constraints[i];
          this.currentPoint = this.focusPoints[i];
          /** @type {number} */
          name = argR;
          argR = this.focusIcons[i].bounds.clone();
          argR.grow(mxConstants.HIGHLIGHT_SIZE + 1);
          --argR.width;
          --argR.height;
          if (null == this.focusHighlight) {
            arg = this.createHighlightShape();
            arg.dialect = mxConstants.DIALECT_SVG;
            /** @type {boolean} */
            arg.pointerEvents = false;
            arg.init(this.graph.getView().getOverlayPane());
            this.focusHighlight = arg;
            var update = mxUtils.bind(this, function() {
              return null != this.currentFocus ? this.currentFocus : node;
            });
            mxEvent.redirectMouseEvents(arg.node, this.graph, update);
          }
          this.focusHighlight.bounds = argR;
          this.focusHighlight.redraw();
        }
      }
    }
    if (null == this.currentConstraint) {
      this.destroyFocusHighlight();
    }
  } else {
    /** @type {null} */
    this.currentPoint = this.currentFocus = this.currentConstraint = null;
  }
};
/**
 * @return {undefined}
 */
mxConstraintHandler.prototype.redraw = function() {
  if (null != this.currentFocus && null != this.constraints && null != this.focusIcons) {
    var table = this.graph.view.getState(this.currentFocus.cell);
    this.currentFocus = table;
    this.currentFocusArea = new mxRectangle(table.x, table.y, table.width, table.height);
    /** @type {number} */
    var i = 0;
    for (; i < this.constraints.length; i++) {
      var d = this.graph.getConnectionPoint(table, this.constraints[i]);
      var bounds = this.getImageForConstraint(table, this.constraints[i], d);
      bounds = new mxRectangle(Math.round(d.x - bounds.width / 2), Math.round(d.y - bounds.height / 2), bounds.width, bounds.height);
      this.focusIcons[i].bounds = bounds;
      this.focusIcons[i].redraw();
      this.currentFocusArea.add(this.focusIcons[i].bounds);
      this.focusPoints[i] = d;
    }
  }
};
/**
 * @param {!Function} view
 * @param {!Object} table
 * @param {number} i
 * @return {undefined}
 */
mxConstraintHandler.prototype.setFocus = function(view, table, i) {
  this.constraints = null != table && !this.isStateIgnored(table, i) && this.graph.isCellConnectable(table.cell) ? this.isEnabled() ? this.graph.getAllConnectionConstraints(table, i) || [] : [] : null;
  if (null != this.constraints) {
    /** @type {!Object} */
    this.currentFocus = table;
    this.currentFocusArea = new mxRectangle(table.x, table.y, table.width, table.height);
    if (null != this.focusIcons) {
      /** @type {number} */
      i = 0;
      for (; i < this.focusIcons.length; i++) {
        this.focusIcons[i].destroy();
      }
      /** @type {null} */
      this.focusPoints = this.focusIcons = null;
    }
    /** @type {!Array} */
    this.focusPoints = [];
    /** @type {!Array} */
    this.focusIcons = [];
    /** @type {number} */
    i = 0;
    for (; i < this.constraints.length; i++) {
      var data = this.graph.getConnectionPoint(table, this.constraints[i]);
      var x = this.getImageForConstraint(table, this.constraints[i], data);
      var t = x.src;
      x = new mxRectangle(Math.round(data.x - x.width / 2), Math.round(data.y - x.height / 2), x.width, x.height);
      t = new mxImageShape(x, t);
      t.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
      /** @type {boolean} */
      t.preserveImageAspect = false;
      t.init(this.graph.getView().getDecoratorPane());
      if (null != t.node.previousSibling) {
        t.node.parentNode.insertBefore(t.node, t.node.parentNode.firstChild);
      }
      x = mxUtils.bind(this, function() {
        return null != this.currentFocus ? this.currentFocus : table;
      });
      t.redraw();
      mxEvent.redirectMouseEvents(t.node, this.graph, x);
      this.currentFocusArea.add(t.bounds);
      this.focusIcons.push(t);
      this.focusPoints.push(data);
    }
    this.currentFocusArea.grow(this.getTolerance(view));
  } else {
    this.destroyIcons();
    this.destroyFocusHighlight();
  }
};
/**
 * @return {?}
 */
mxConstraintHandler.prototype.createHighlightShape = function() {
  var control = new mxRectangleShape(null, this.highlightColor, this.highlightColor, mxConstants.HIGHLIGHT_STROKEWIDTH);
  control.opacity = mxConstants.HIGHLIGHT_OPACITY;
  return control;
};
/**
 * @param {!Object} obj
 * @param {!Object} value
 * @param {string} target
 * @param {boolean} pos
 * @return {?}
 */
mxConstraintHandler.prototype.intersects = function(obj, value, target, pos) {
  return mxUtils.intersects(obj.bounds, value);
};
/**
 * @return {undefined}
 */
mxConstraintHandler.prototype.destroy = function() {
  this.reset();
  if (null != this.resetHandler) {
    this.graph.model.removeListener(this.resetHandler);
    this.graph.view.removeListener(this.resetHandler);
    this.graph.removeListener(this.resetHandler);
    /** @type {null} */
    this.resetHandler = null;
  }
  if (null != this.mouseleaveHandler && null != this.graph.container) {
    mxEvent.removeListener(this.graph.container, "mouseleave", this.mouseleaveHandler);
    /** @type {null} */
    this.mouseleaveHandler = null;
  }
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxRubberband(targetGraph) {
  if (null != targetGraph) {
    /** @type {!Object} */
    this.graph = targetGraph;
    this.graph.addMouseListener(this);
    this.forceRubberbandHandler = mxUtils.bind(this, function(a, b) {
      a = b.getProperty("eventName");
      b = b.getProperty("event");
      if (a == mxEvent.MOUSE_DOWN && this.isForceRubberbandEvent(b)) {
        a = mxUtils.getOffset(this.graph.container);
        var p = mxUtils.getScrollOrigin(this.graph.container);
        p.x -= a.x;
        p.y -= a.y;
        this.start(b.getX() + p.x, b.getY() + p.y);
        b.consume(false);
      }
    });
    this.graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.forceRubberbandHandler);
    this.panHandler = mxUtils.bind(this, function() {
      this.repaint();
    });
    this.graph.addListener(mxEvent.PAN, this.panHandler);
    this.gestureHandler = mxUtils.bind(this, function(b, canCreateDiscussions) {
      if (null != this.first) {
        this.reset();
      }
    });
    this.graph.addListener(mxEvent.GESTURE, this.gestureHandler);
    if (mxClient.IS_IE) {
      mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
        this.destroy();
      }));
    }
  }
}
/** @type {number} */
mxRubberband.prototype.defaultOpacity = 20;
/** @type {boolean} */
mxRubberband.prototype.enabled = true;
/** @type {null} */
mxRubberband.prototype.div = null;
/** @type {null} */
mxRubberband.prototype.sharedDiv = null;
/** @type {number} */
mxRubberband.prototype.currentX = 0;
/** @type {number} */
mxRubberband.prototype.currentY = 0;
/** @type {boolean} */
mxRubberband.prototype.fadeOut = false;
/**
 * @return {?}
 */
mxRubberband.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {boolean} state
 * @return {undefined}
 */
mxRubberband.prototype.setEnabled = function(state) {
  /** @type {boolean} */
  this.enabled = state;
};
/**
 * @param {!Object} event
 * @return {?}
 */
mxRubberband.prototype.isForceRubberbandEvent = function(event) {
  return mxEvent.isAltDown(event.getEvent());
};
/**
 * @param {number} e
 * @param {!Object} me
 * @return {undefined}
 */
mxRubberband.prototype.mouseDown = function(e, me) {
  if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && null == me.getState() && !mxEvent.isMultiTouchEvent(me.getEvent())) {
    e = mxUtils.getOffset(this.graph.container);
    var p = mxUtils.getScrollOrigin(this.graph.container);
    p.x -= e.x;
    p.y -= e.y;
    this.start(me.getX() + p.x, me.getY() + p.y);
    me.consume(false);
  }
};
/**
 * @param {!Object} x
 * @param {string} height
 * @return {undefined}
 */
mxRubberband.prototype.start = function(x, height) {
  /**
   * @param {!Object} that
   * @return {?}
   */
  function update(that) {
    that = new mxMouseEvent(that);
    var events = mxUtils.convertPoint(node, that.getX(), that.getY());
    that.graphX = events.x;
    that.graphY = events.y;
    return that;
  }
  this.first = new mxPoint(x, height);
  var node = this.graph.container;
  this.dragHandler = mxUtils.bind(this, function(obj) {
    this.mouseMove(this.graph, update(obj));
  });
  this.dropHandler = mxUtils.bind(this, function(obj) {
    this.mouseUp(this.graph, update(obj));
  });
  if (mxClient.IS_FF) {
    mxEvent.addGestureListeners(document, null, this.dragHandler, this.dropHandler);
  }
};
/**
 * @param {!Array} e
 * @param {!Object} me
 * @return {undefined}
 */
mxRubberband.prototype.mouseMove = function(e, me) {
  if (!me.isConsumed() && null != this.first) {
    var p = mxUtils.getScrollOrigin(this.graph.container);
    e = mxUtils.getOffset(this.graph.container);
    p.x -= e.x;
    p.y -= e.y;
    e = me.getX() + p.x;
    p = me.getY() + p.y;
    /** @type {number} */
    var dphi = this.first.x - e;
    /** @type {number} */
    var pct = this.first.y - p;
    var tol = this.graph.tolerance;
    if (null != this.div || Math.abs(dphi) > tol || Math.abs(pct) > tol) {
      if (null == this.div) {
        this.div = this.createShape();
      }
      mxUtils.clearSelection();
      this.update(e, p);
      me.consume();
    }
  }
};
/**
 * @return {?}
 */
mxRubberband.prototype.createShape = function() {
  if (null == this.sharedDiv) {
    /** @type {!Element} */
    this.sharedDiv = document.createElement("div");
    /** @type {string} */
    this.sharedDiv.className = "mxRubberband";
    mxUtils.setOpacity(this.sharedDiv, this.defaultOpacity);
  }
  this.graph.container.appendChild(this.sharedDiv);
  var shape = this.sharedDiv;
  if (mxClient.IS_SVG && (!mxClient.IS_IE || 10 <= document.documentMode) && this.fadeOut) {
    /** @type {null} */
    this.sharedDiv = null;
  }
  return shape;
};
/**
 * @param {?} areaSets
 * @param {?} highlightSubsets
 * @return {?}
 */
mxRubberband.prototype.isActive = function(areaSets, highlightSubsets) {
  return null != this.div && "none" != this.div.style.display;
};
/**
 * @param {?} editor
 * @param {!Event} e
 * @return {undefined}
 */
mxRubberband.prototype.mouseUp = function(editor, e) {
  editor = this.isActive();
  this.reset();
  if (editor) {
    this.execute(e.getEvent());
    e.consume();
  }
};
/**
 * @param {!Object} i
 * @return {undefined}
 */
mxRubberband.prototype.execute = function(i) {
  var d = new mxRectangle(this.x, this.y, this.width, this.height);
  this.graph.selectRegion(d, i);
};
/**
 * @return {undefined}
 */
mxRubberband.prototype.reset = function() {
  if (null != this.div) {
    if (mxClient.IS_SVG && (!mxClient.IS_IE || 10 <= document.documentMode) && this.fadeOut) {
      var div = this.div;
      mxUtils.setPrefixedStyle(div.style, "transition", "all 0.2s linear");
      /** @type {string} */
      div.style.pointerEvents = "none";
      /** @type {number} */
      div.style.opacity = 0;
      window.setTimeout(function() {
        div.parentNode.removeChild(div);
      }, 200);
    } else {
      this.div.parentNode.removeChild(this.div);
    }
  }
  mxEvent.removeGestureListeners(document, null, this.dragHandler, this.dropHandler);
  /** @type {null} */
  this.dropHandler = this.dragHandler = null;
  /** @type {number} */
  this.currentY = this.currentX = 0;
  /** @type {null} */
  this.div = this.first = null;
};
/**
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxRubberband.prototype.update = function(x, y) {
  /** @type {number} */
  this.currentX = x;
  /** @type {number} */
  this.currentY = y;
  this.repaint();
};
/**
 * @return {undefined}
 */
mxRubberband.prototype.repaint = function() {
  if (null != this.div) {
    /** @type {number} */
    var n = this.currentX - this.graph.panDx;
    /** @type {number} */
    var height = this.currentY - this.graph.panDy;
    /** @type {number} */
    this.x = Math.min(this.first.x, n);
    /** @type {number} */
    this.y = Math.min(this.first.y, height);
    /** @type {number} */
    this.width = Math.max(this.first.x, n) - this.x;
    /** @type {number} */
    this.height = Math.max(this.first.y, height) - this.y;
    /** @type {string} */
    this.div.style.left = this.x + 0 + "px";
    /** @type {string} */
    this.div.style.top = this.y + 0 + "px";
    /** @type {string} */
    this.div.style.width = Math.max(1, this.width) + "px";
    /** @type {string} */
    this.div.style.height = Math.max(1, this.height) + "px";
  }
};
/**
 * @return {undefined}
 */
mxRubberband.prototype.destroy = function() {
  if (!this.destroyed) {
    /** @type {boolean} */
    this.destroyed = true;
    this.graph.removeMouseListener(this);
    this.graph.removeListener(this.forceRubberbandHandler);
    this.graph.removeListener(this.panHandler);
    this.reset();
    if (null != this.sharedDiv) {
      /** @type {null} */
      this.sharedDiv = null;
    }
  }
};
/**
 * @param {!Object} state
 * @param {string} name
 * @param {string} m
 * @param {!Object} _succeeded
 * @return {undefined}
 */
function mxHandle(state, name, m, _succeeded) {
  this.graph = state.view.graph;
  /** @type {!Object} */
  this.state = state;
  this.cursor = null != name ? name : this.cursor;
  this.image = null != m ? m : this.image;
  this.shape = null != _succeeded ? _succeeded : null;
  this.init();
}
/** @type {string} */
mxHandle.prototype.cursor = "default";
/** @type {null} */
mxHandle.prototype.image = null;
/** @type {boolean} */
mxHandle.prototype.ignoreGrid = false;
/**
 * @param {?} time_in_millis
 * @return {undefined}
 */
mxHandle.prototype.getPosition = function(time_in_millis) {
};
/**
 * @param {?} ignoreActions
 * @param {?} jump
 * @param {!Object} callback
 * @return {undefined}
 */
mxHandle.prototype.setPosition = function(ignoreActions, jump, callback) {
};
/**
 * @param {!Object} ast
 * @return {undefined}
 */
mxHandle.prototype.execute = function(ast) {
};
/**
 * @param {!Arguments} key
 * @return {undefined}
 */
mxHandle.prototype.copyStyle = function(key) {
  this.graph.setCellStyles(key, this.state.style[key], [this.state.cell]);
};
/**
 * @param {!Object} me
 * @return {undefined}
 */
mxHandle.prototype.processEvent = function(me) {
  var scale = this.graph.view.scale;
  var start = this.graph.view.translate;
  start = new mxPoint(me.getGraphX() / scale - start.x, me.getGraphY() / scale - start.y);
  if (null != this.shape && null != this.shape.bounds) {
    start.x -= this.shape.bounds.width / scale / 4;
    start.y -= this.shape.bounds.height / scale / 4;
  }
  /** @type {number} */
  scale = -mxUtils.toRadians(this.getRotation());
  /** @type {number} */
  var y = -mxUtils.toRadians(this.getTotalRotation()) - scale;
  start = this.flipPoint(this.rotatePoint(this.snapPoint(this.rotatePoint(start, scale), this.ignoreGrid || !this.graph.isGridEnabledEvent(me.getEvent())), y));
  this.setPosition(this.state.getPaintBounds(), start, me);
  this.redraw();
};
/**
 * @return {undefined}
 */
mxHandle.prototype.positionChanged = function() {
  if (null != this.state.text) {
    this.state.text.apply(this.state);
  }
  if (null != this.state.shape) {
    this.state.shape.apply(this.state);
  }
  this.graph.cellRenderer.redraw(this.state, true);
};
/**
 * @return {?}
 */
mxHandle.prototype.getRotation = function() {
  return null != this.state.shape ? this.state.shape.getRotation() : 0;
};
/**
 * @return {?}
 */
mxHandle.prototype.getTotalRotation = function() {
  return null != this.state.shape ? this.state.shape.getShapeRotation() : 0;
};
/**
 * @return {undefined}
 */
mxHandle.prototype.init = function() {
  var from = this.isHtmlRequired();
  if (null != this.image) {
    this.shape = new mxImageShape(new mxRectangle(0, 0, this.image.width, this.image.height), this.image.src);
    /** @type {boolean} */
    this.shape.preserveImageAspect = false;
  } else {
    if (null == this.shape) {
      this.shape = this.createShape(from);
    }
  }
  this.initShape(from);
};
/**
 * @param {string} bounds
 * @return {?}
 */
mxHandle.prototype.createShape = function(bounds) {
  bounds = new mxRectangle(0, 0, mxConstants.HANDLE_SIZE, mxConstants.HANDLE_SIZE);
  return new mxRectangleShape(bounds, mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
};
/**
 * @param {?} item
 * @return {undefined}
 */
mxHandle.prototype.initShape = function(item) {
  if (item && this.shape.isHtmlAllowed()) {
    this.shape.dialect = mxConstants.DIALECT_STRICTHTML;
    this.shape.init(this.graph.container);
  } else {
    this.shape.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
    if (null != this.cursor) {
      this.shape.init(this.graph.getView().getOverlayPane());
    }
  }
  mxEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);
  this.shape.node.style.cursor = this.cursor;
};
/**
 * @return {undefined}
 */
mxHandle.prototype.redraw = function() {
  if (null != this.shape && null != this.state.shape) {
    var p = this.getPosition(this.state.getPaintBounds());
    if (null != p) {
      var y = mxUtils.toRadians(this.getTotalRotation());
      p = this.rotatePoint(this.flipPoint(p), y);
      y = this.graph.view.scale;
      var t = this.graph.view.translate;
      /** @type {number} */
      this.shape.bounds.x = Math.floor((p.x + t.x) * y - this.shape.bounds.width / 2);
      /** @type {number} */
      this.shape.bounds.y = Math.floor((p.y + t.y) * y - this.shape.bounds.height / 2);
      this.shape.redraw();
    }
  }
};
/**
 * @return {?}
 */
mxHandle.prototype.isHtmlRequired = function() {
  return null != this.state.text && this.state.text.node.parentNode == this.graph.container;
};
/**
 * @param {?} angle
 * @param {number} x
 * @return {?}
 */
mxHandle.prototype.rotatePoint = function(angle, x) {
  var ellipse = this.state.getCellBounds();
  ellipse = new mxPoint(ellipse.getCenterX(), ellipse.getCenterY());
  return mxUtils.getRotatedPoint(angle, Math.cos(x), Math.sin(x), ellipse);
};
/**
 * @param {!Object} npoint
 * @return {?}
 */
mxHandle.prototype.flipPoint = function(npoint) {
  if (null != this.state.shape) {
    var arg_json = this.state.getCellBounds();
    if (this.state.shape.flipH) {
      /** @type {number} */
      npoint.x = 2 * arg_json.x + arg_json.width - npoint.x;
    }
    if (this.state.shape.flipV) {
      /** @type {number} */
      npoint.y = 2 * arg_json.y + arg_json.height - npoint.y;
    }
  }
  return npoint;
};
/**
 * @param {!Object} pt
 * @param {?} lastRotate
 * @return {?}
 */
mxHandle.prototype.snapPoint = function(pt, lastRotate) {
  if (!lastRotate) {
    pt.x = this.graph.snap(pt.x);
    pt.y = this.graph.snap(pt.y);
  }
  return pt;
};
/**
 * @param {boolean} isVisible
 * @return {undefined}
 */
mxHandle.prototype.setVisible = function(isVisible) {
  if (null != this.shape && null != this.shape.node) {
    /** @type {string} */
    this.shape.node.style.display = isVisible ? "" : "none";
  }
};
/**
 * @return {undefined}
 */
mxHandle.prototype.reset = function() {
  this.setVisible(true);
  this.state.style = this.graph.getCellStyle(this.state.cell);
  this.positionChanged();
};
/**
 * @return {undefined}
 */
mxHandle.prototype.destroy = function() {
  if (null != this.shape) {
    this.shape.destroy();
    /** @type {null} */
    this.shape = null;
  }
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
function mxVertexHandler(value) {
  if (null != value) {
    /** @type {!Object} */
    this.state = value;
    this.init();
    this.escapeHandler = mxUtils.bind(this, function(b, canCreateDiscussions) {
      if (this.livePreview && null != this.index) {
        this.state.view.graph.cellRenderer.redraw(this.state, true);
        this.state.view.invalidate(this.state.cell);
        /** @type {boolean} */
        this.state.invalid = false;
        this.state.view.validate();
      }
      this.reset();
    });
    this.state.view.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
  }
}
/** @type {null} */
mxVertexHandler.prototype.graph = null;
/** @type {null} */
mxVertexHandler.prototype.state = null;
/** @type {boolean} */
mxVertexHandler.prototype.singleSizer = false;
/** @type {null} */
mxVertexHandler.prototype.index = null;
/** @type {boolean} */
mxVertexHandler.prototype.allowHandleBoundsCheck = true;
/** @type {null} */
mxVertexHandler.prototype.handleImage = null;
/** @type {boolean} */
mxVertexHandler.prototype.handlesVisible = true;
/** @type {number} */
mxVertexHandler.prototype.tolerance = 0;
/** @type {boolean} */
mxVertexHandler.prototype.rotationEnabled = false;
/** @type {boolean} */
mxVertexHandler.prototype.parentHighlightEnabled = false;
/** @type {boolean} */
mxVertexHandler.prototype.rotationRaster = true;
/** @type {string} */
mxVertexHandler.prototype.rotationCursor = "crosshair";
/** @type {boolean} */
mxVertexHandler.prototype.livePreview = false;
/** @type {boolean} */
mxVertexHandler.prototype.movePreviewToFront = false;
/** @type {boolean} */
mxVertexHandler.prototype.manageSizers = false;
/** @type {boolean} */
mxVertexHandler.prototype.constrainGroupByChildren = false;
/** @type {number} */
mxVertexHandler.prototype.rotationHandleVSpacing = -16;
/** @type {number} */
mxVertexHandler.prototype.horizontalOffset = 0;
/** @type {number} */
mxVertexHandler.prototype.verticalOffset = 0;
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.init = function() {
  this.graph = this.state.view.graph;
  this.selectionBounds = this.getSelectionBounds(this.state);
  this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
  this.selectionBorder = this.createSelectionShape(this.bounds);
  this.selectionBorder.dialect = mxConstants.DIALECT_SVG;
  /** @type {boolean} */
  this.selectionBorder.pointerEvents = false;
  /** @type {number} */
  this.selectionBorder.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
  this.selectionBorder.init(this.graph.getView().getOverlayPane());
  mxEvent.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);
  if (this.graph.isCellMovable(this.state.cell) && !this.graph.isCellLocked(this.state.cell)) {
    this.selectionBorder.setCursor(mxConstants.CURSOR_MOVABLE_VERTEX);
  }
  if (0 >= mxGraphHandler.prototype.maxCells || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells) {
    var other = this.graph.isCellResizable(this.state.cell) && !this.graph.isCellLocked(this.state.cell);
    /** @type {!Array} */
    this.sizers = [];
    if (other || this.graph.isLabelMovable(this.state.cell) && 2 <= this.state.width && 2 <= this.state.height) {
      /** @type {number} */
      var b = 0;
      if (other) {
        if (!this.singleSizer) {
          this.sizers.push(this.createSizer("nw-resize", b++));
          this.sizers.push(this.createSizer("n-resize", b++));
          this.sizers.push(this.createSizer("ne-resize", b++));
          this.sizers.push(this.createSizer("w-resize", b++));
          this.sizers.push(this.createSizer("e-resize", b++));
          this.sizers.push(this.createSizer("sw-resize", b++));
          this.sizers.push(this.createSizer("s-resize", b++));
        }
        this.sizers.push(this.createSizer("se-resize", b++));
      }
      other = this.graph.model.getGeometry(this.state.cell);
      if (!(null == other || other.relative || this.graph.isSwimlane(this.state.cell) || !this.graph.isLabelMovable(this.state.cell))) {
        this.labelShape = this.createSizer(mxConstants.CURSOR_LABEL_HANDLE, mxEvent.LABEL_HANDLE, mxConstants.LABEL_HANDLE_SIZE, mxConstants.LABEL_HANDLE_FILLCOLOR);
        this.sizers.push(this.labelShape);
      }
    } else {
      if (this.graph.isCellMovable(this.state.cell) && !other && 2 > this.state.width && 2 > this.state.height) {
        this.labelShape = this.createSizer(mxConstants.CURSOR_MOVABLE_VERTEX, mxEvent.LABEL_HANDLE, null, mxConstants.LABEL_HANDLE_FILLCOLOR);
        this.sizers.push(this.labelShape);
      }
    }
  }
  if (this.isRotationHandleVisible()) {
    this.rotationShape = this.createSizer(this.rotationCursor, mxEvent.ROTATION_HANDLE, mxConstants.HANDLE_SIZE + 3, mxConstants.HANDLE_FILLCOLOR);
    this.sizers.push(this.rotationShape);
  }
  if (!this.graph.isCellLocked(this.state.cell)) {
    this.customHandles = this.createCustomHandles();
  }
  this.redraw();
  if (this.constrainGroupByChildren) {
    this.updateMinBounds();
  }
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.isRotationHandleVisible = function() {
  return this.graph.isEnabled() && this.rotationEnabled && !this.graph.isCellLocked(this.state.cell) && this.graph.isCellRotatable(this.state.cell) && (0 >= mxGraphHandler.prototype.maxCells || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells);
};
/**
 * @param {!Object} child
 * @return {?}
 */
mxVertexHandler.prototype.isConstrainedEvent = function(child) {
  return mxEvent.isShiftDown(child.getEvent()) || "fixed" == this.state.style[mxConstants.STYLE_ASPECT];
};
/**
 * @param {?} requestWaterMask
 * @param {!Object} f
 * @return {?}
 */
mxVertexHandler.prototype.isCenteredEvent = function(requestWaterMask, f) {
  return false;
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.createCustomHandles = function() {
  return null;
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.updateMinBounds = function() {
  var scale = this.graph.getChildCells(this.state.cell);
  if (0 < scale.length && (this.minBounds = this.graph.view.getBounds(scale), null != this.minBounds)) {
    scale = this.state.view.scale;
    var geo = this.state.view.translate;
    this.minBounds.x -= this.state.x;
    this.minBounds.y -= this.state.y;
    this.minBounds.x /= scale;
    this.minBounds.y /= scale;
    this.minBounds.width /= scale;
    this.minBounds.height /= scale;
    /** @type {number} */
    this.x0 = this.state.x / scale - geo.x;
    /** @type {number} */
    this.y0 = this.state.y / scale - geo.y;
  }
};
/**
 * @param {!Object} aroundRect
 * @return {?}
 */
mxVertexHandler.prototype.getSelectionBounds = function(aroundRect) {
  return new mxRectangle(Math.round(aroundRect.x), Math.round(aroundRect.y), Math.round(aroundRect.width), Math.round(aroundRect.height));
};
/**
 * @param {!Arguments} className
 * @return {?}
 */
mxVertexHandler.prototype.createParentHighlightShape = function(className) {
  return this.createSelectionShape(className);
};
/**
 * @param {!Array} o
 * @return {?}
 */
mxVertexHandler.prototype.createSelectionShape = function(o) {
  o = new mxRectangleShape(mxRectangle.fromRectangle(o), null, this.getSelectionColor());
  o.strokewidth = this.getSelectionStrokeWidth();
  o.isDashed = this.isSelectionDashed();
  return o;
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.getSelectionColor = function() {
  return this.graph.isCellEditable(this.state.cell) ? mxConstants.VERTEX_SELECTION_COLOR : mxConstants.LOCKED_HANDLE_FILLCOLOR;
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.getSelectionStrokeWidth = function() {
  return mxConstants.VERTEX_SELECTION_STROKEWIDTH;
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.isSelectionDashed = function() {
  return mxConstants.VERTEX_SELECTION_DASHED;
};
/**
 * @param {string} direction
 * @param {number} element
 * @param {string} value
 * @param {!Object} options
 * @return {?}
 */
mxVertexHandler.prototype.createSizer = function(direction, element, value, options) {
  value = value || mxConstants.HANDLE_SIZE;
  value = new mxRectangle(0, 0, value, value);
  options = this.createSizerShape(value, element, options);
  if (options.isHtmlAllowed() && null != this.state.text && this.state.text.node.parentNode == this.graph.container) {
    --options.bounds.height;
    --options.bounds.width;
    options.dialect = mxConstants.DIALECT_STRICTHTML;
    options.init(this.graph.container);
  } else {
    options.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
    options.init(this.graph.getView().getOverlayPane());
  }
  mxEvent.redirectMouseEvents(options.node, this.graph, this.state);
  if (this.graph.isEnabled()) {
    options.setCursor(direction);
  }
  if (!this.isSizerVisible(element)) {
    /** @type {boolean} */
    options.visible = false;
  }
  return options;
};
/**
 * @param {number} suppressDisabledCheck
 * @return {?}
 */
mxVertexHandler.prototype.isSizerVisible = function(suppressDisabledCheck) {
  return true;
};
/**
 * @param {!Object} bounds
 * @param {number} scope
 * @param {boolean} positionOptions
 * @return {?}
 */
mxVertexHandler.prototype.createSizerShape = function(bounds, scope, positionOptions) {
  return null != this.handleImage ? (bounds = new mxRectangle(bounds.x, bounds.y, this.handleImage.width, this.handleImage.height), bounds = new mxImageShape(bounds, this.handleImage.src), bounds.preserveImageAspect = false, bounds) : scope == mxEvent.ROTATION_HANDLE ? new mxEllipse(bounds, positionOptions || mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR) : new mxRectangleShape(bounds, positionOptions || mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
};
/**
 * @param {!Object} m
 * @param {number} b
 * @param {number} center
 * @return {undefined}
 */
mxVertexHandler.prototype.moveSizerTo = function(m, b, center) {
  if (null != m) {
    /** @type {number} */
    m.bounds.x = Math.floor(b - m.bounds.width / 2);
    /** @type {number} */
    m.bounds.y = Math.floor(center - m.bounds.height / 2);
    if (null != m.node && "none" != m.node.style.display) {
      m.redraw();
    }
  }
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxVertexHandler.prototype.getHandleForEvent = function(me) {
  var tol = mxEvent.isMouseEvent(me.getEvent()) ? 1 : this.tolerance;
  var _ctx$request$query$si = this.allowHandleBoundsCheck && (mxClient.IS_IE || 0 < tol) ? new mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
  tol = mxUtils.bind(this, function(source) {
    var size = null != source && source.constructor != mxImageShape && this.allowHandleBoundsCheck ? source.strokewidth + source.svgStrokeTolerance : null;
    size = null != size ? new mxRectangle(me.getGraphX() - Math.floor(size / 2), me.getGraphY() - Math.floor(size / 2), size, size) : _ctx$request$query$si;
    return null != source && (me.isSource(source) || source.intersectsRectangle(size));
  });
  if (tol(this.rotationShape)) {
    return mxEvent.ROTATION_HANDLE;
  }
  if (tol(this.labelShape)) {
    return mxEvent.LABEL_HANDLE;
  }
  if (null != this.sizers) {
    /** @type {number} */
    var i = 0;
    for (; i < this.sizers.length; i++) {
      if (tol(this.sizers[i])) {
        return i;
      }
    }
  }
  if (null != this.customHandles && this.isCustomHandleEvent(me)) {
    /** @type {number} */
    i = this.customHandles.length - 1;
    for (; 0 <= i; i--) {
      if (tol(this.customHandles[i].shape)) {
        return mxEvent.CUSTOM_HANDLE - i;
      }
    }
  }
  return null;
};
/**
 * @param {!Object} me1
 * @return {?}
 */
mxVertexHandler.prototype.isCustomHandleEvent = function(me1) {
  return true;
};
/**
 * @param {number} item
 * @param {!Event} me
 * @return {undefined}
 */
mxVertexHandler.prototype.mouseDown = function(item, me) {
  if (!me.isConsumed() && this.graph.isEnabled()) {
    item = this.getHandleForEvent(me);
    if (null != item) {
      this.start(me.getGraphX(), me.getGraphY(), item);
      me.consume();
    }
  }
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.isLivePreviewBorder = function() {
  return null != this.state.shape && null == this.state.shape.fill && null == this.state.shape.stroke;
};
/**
 * @param {number} x
 * @param {number} y
 * @param {!Object} i
 * @return {undefined}
 */
mxVertexHandler.prototype.start = function(x, y, i) {
  if (null != this.selectionBorder) {
    if (this.livePreviewActive = this.livePreview && 0 == this.graph.model.getChildCount(this.state.cell), this.inTolerance = true, this.childOffsetY = this.childOffsetX = 0, this.index = i, this.startX = x, this.startY = y, this.index <= mxEvent.CUSTOM_HANDLE && this.isGhostPreview()) {
      this.ghostPreview = this.createGhostPreview();
    } else {
      x = this.state.view.graph.model;
      y = x.getParent(this.state.cell);
      if (this.state.view.currentRoot != y && (x.isVertex(y) || x.isEdge(y))) {
        this.parentState = this.state.view.graph.view.getState(y);
      }
      /** @type {string} */
      this.selectionBorder.node.style.display = i == mxEvent.ROTATION_HANDLE ? "inline" : "none";
      if (!this.livePreviewActive || this.isLivePreviewBorder()) {
        this.preview = this.createSelectionShape(this.bounds);
        if (mxClient.IS_SVG && 0 != Number(this.state.style[mxConstants.STYLE_ROTATION] || "0") || null == this.state.text || this.state.text.node.parentNode != this.graph.container) {
          this.preview.dialect = mxConstants.DIALECT_SVG;
          this.preview.init(this.graph.view.getOverlayPane());
        } else {
          this.preview.dialect = mxConstants.DIALECT_STRICTHTML;
          this.preview.init(this.graph.container);
        }
      }
      if (i == mxEvent.ROTATION_HANDLE) {
        y = this.getRotationHandlePosition();
        /** @type {number} */
        x = y.x - this.state.getCenterX();
        /** @type {number} */
        y = y.y - this.state.getCenterY();
        /** @type {number} */
        this.startAngle = 0 != x ? 180 * Math.atan(y / x) / Math.PI + 90 : 0;
        /** @type {number} */
        this.startDist = Math.sqrt(x * x + y * y);
      }
      if (this.livePreviewActive) {
        this.hideSizers();
        if (i == mxEvent.ROTATION_HANDLE) {
          /** @type {string} */
          this.rotationShape.node.style.display = "";
        } else {
          if (i == mxEvent.LABEL_HANDLE) {
            /** @type {string} */
            this.labelShape.node.style.display = "";
          } else {
            if (null != this.sizers && null != this.sizers[i]) {
              /** @type {string} */
              this.sizers[i].node.style.display = "";
            } else {
              if (i <= mxEvent.CUSTOM_HANDLE && null != this.customHandles) {
                this.customHandles[mxEvent.CUSTOM_HANDLE - i].setVisible(true);
              }
            }
          }
        }
        i = this.graph.getEdges(this.state.cell);
        /** @type {!Array} */
        this.edgeHandlers = [];
        /** @type {number} */
        x = 0;
        for (; x < i.length; x++) {
          y = this.graph.selectionCellsHandler.getHandler(i[x]);
          if (null != y) {
            this.edgeHandlers.push(y);
          }
        }
      }
    }
  }
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.createGhostPreview = function() {
  var state = this.graph.cellRenderer.createShape(this.state);
  state.init(this.graph.view.getOverlayPane());
  state.scale = this.state.view.scale;
  state.bounds = this.bounds;
  /** @type {boolean} */
  state.outline = true;
  return state;
};
/**
 * @param {boolean} value
 * @return {undefined}
 */
mxVertexHandler.prototype.setHandlesVisible = function(value) {
  /** @type {boolean} */
  this.handlesVisible = value;
  if (null != this.sizers) {
    /** @type {number} */
    var i = 0;
    for (; i < this.sizers.length; i++) {
      /** @type {string} */
      this.sizers[i].node.style.display = value ? "" : "none";
    }
  }
  if (null != this.customHandles) {
    /** @type {number} */
    i = 0;
    for (; i < this.customHandles.length; i++) {
      this.customHandles[i].setVisible(value);
    }
  }
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.hideSizers = function() {
  this.setHandlesVisible(false);
};
/**
 * @param {!Event} me
 * @return {undefined}
 */
mxVertexHandler.prototype.checkTolerance = function(me) {
  if (this.inTolerance && null != this.startX && null != this.startY && (mxEvent.isMouseEvent(me.getEvent()) || Math.abs(me.getGraphX() - this.startX) > this.graph.tolerance || Math.abs(me.getGraphY() - this.startY) > this.graph.tolerance)) {
    /** @type {boolean} */
    this.inTolerance = false;
  }
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxVertexHandler.prototype.updateHint = function(data) {
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.removeHint = function() {
};
/**
 * @param {number} litresInCubicFeet
 * @return {?}
 */
mxVertexHandler.prototype.roundAngle = function(litresInCubicFeet) {
  return Math.round(10 * litresInCubicFeet) / 10;
};
/**
 * @param {number} litresInCubicFeet
 * @return {?}
 */
mxVertexHandler.prototype.roundLength = function(litresInCubicFeet) {
  return Math.round(100 * litresInCubicFeet) / 100;
};
/**
 * @param {?} e
 * @param {!Event} me
 * @return {undefined}
 */
mxVertexHandler.prototype.mouseMove = function(e, me) {
  if (me.isConsumed() || null == this.index) {
    if (!(this.graph.isMouseDown || null == this.getHandleForEvent(me))) {
      me.consume(false);
    }
  } else {
    this.checkTolerance(me);
    if (!this.inTolerance) {
      if (this.index <= mxEvent.CUSTOM_HANDLE) {
        if (null != this.customHandles) {
          this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].processEvent(me);
          /** @type {boolean} */
          this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].active = true;
          if (null != this.ghostPreview) {
            this.ghostPreview.apply(this.state);
            /** @type {number} */
            this.ghostPreview.strokewidth = this.getSelectionStrokeWidth() / this.ghostPreview.scale / this.ghostPreview.scale;
            this.ghostPreview.isDashed = this.isSelectionDashed();
            this.ghostPreview.stroke = this.getSelectionColor();
            this.ghostPreview.redraw();
            if (null != this.selectionBounds) {
              /** @type {string} */
              this.selectionBorder.node.style.display = "none";
            }
          } else {
            if (this.movePreviewToFront) {
              this.moveToFront();
            }
            this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].positionChanged();
          }
        }
      } else {
        if (this.index == mxEvent.LABEL_HANDLE) {
          this.moveLabel(me);
        } else {
          if (this.index == mxEvent.ROTATION_HANDLE) {
            this.rotateVertex(me);
          } else {
            this.resizeVertex(me);
          }
          this.updateHint(me);
        }
      }
    }
    me.consume();
  }
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.isGhostPreview = function() {
  return 0 < this.state.view.graph.model.getChildCount(this.state.cell);
};
/**
 * @param {!Event} me
 * @return {undefined}
 */
mxVertexHandler.prototype.moveLabel = function(me) {
  var point = new mxPoint(me.getGraphX(), me.getGraphY());
  var geo = this.graph.view.translate;
  var scale = this.graph.view.scale;
  if (this.graph.isGridEnabledEvent(me.getEvent())) {
    /** @type {number} */
    point.x = (this.graph.snap(point.x / scale - geo.x) + geo.x) * scale;
    /** @type {number} */
    point.y = (this.graph.snap(point.y / scale - geo.y) + geo.y) * scale;
  }
  this.moveSizerTo(this.sizers[null != this.rotationShape ? this.sizers.length - 2 : this.sizers.length - 1], point.x, point.y);
};
/**
 * @param {!Object} me
 * @return {undefined}
 */
mxVertexHandler.prototype.rotateVertex = function(me) {
  var pt = new mxPoint(me.getGraphX(), me.getGraphY());
  /** @type {number} */
  var argR = this.state.x + this.state.width / 2 - pt.x;
  /** @type {number} */
  var arg = this.state.y + this.state.height / 2 - pt.y;
  /** @type {number} */
  this.currentAlpha = 0 != argR ? 180 * Math.atan(arg / argR) / Math.PI + 90 : 0 > arg ? 180 : 0;
  if (0 < argR) {
    this.currentAlpha -= 180;
  }
  this.currentAlpha -= this.startAngle;
  if (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent())) {
    /** @type {number} */
    argR = pt.x - this.state.getCenterX();
    /** @type {number} */
    arg = pt.y - this.state.getCenterY();
    /** @type {number} */
    me = Math.sqrt(argR * argR + arg * arg);
    /** @type {number} */
    raster = 2 > me - this.startDist ? 15 : 25 > me - this.startDist ? 5 : 1;
    /** @type {number} */
    this.currentAlpha = Math.round(this.currentAlpha / raster) * raster;
  } else {
    this.currentAlpha = this.roundAngle(this.currentAlpha);
  }
  /** @type {number} */
  this.selectionBorder.rotation = this.currentAlpha;
  this.selectionBorder.redraw();
  if (this.livePreviewActive) {
    this.redrawHandles();
  }
};
/**
 * @param {!Object} me
 * @return {undefined}
 */
mxVertexHandler.prototype.resizeVertex = function(me) {
  var w = new mxPoint(this.state.getCenterX(), this.state.getCenterY());
  var r = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
  var e = new mxPoint(me.getGraphX(), me.getGraphY());
  var translate = this.graph.view.translate;
  var scale = this.graph.view.scale;
  /** @type {number} */
  var b = Math.cos(-r);
  /** @type {number} */
  var a = Math.sin(-r);
  /** @type {number} */
  var x = e.x - this.startX;
  /** @type {number} */
  var y = e.y - this.startY;
  /** @type {number} */
  e = a * x + b * y;
  /** @type {number} */
  x = b * x - a * y;
  /** @type {number} */
  y = e;
  b = this.graph.getCellGeometry(this.state.cell);
  this.unscaledBounds = this.union(b, x / scale, y / scale, this.index, this.graph.isGridEnabledEvent(me.getEvent()), 1, new mxPoint(0, 0), this.isConstrainedEvent(me), this.isCenteredEvent(this.state, me));
  if (!b.relative) {
    a = this.graph.getMaximumGraphBounds();
    if (null != a && null != this.parentState) {
      a = mxRectangle.fromRectangle(a);
      a.x -= (this.parentState.x - translate.x * scale) / scale;
      a.y -= (this.parentState.y - translate.y * scale) / scale;
    }
    if (this.graph.isConstrainChild(this.state.cell)) {
      e = this.graph.getCellContainmentArea(this.state.cell);
      if (null != e) {
        x = this.graph.getOverlap(this.state.cell);
        if (0 < x) {
          e = mxRectangle.fromRectangle(e);
          e.x -= e.width * x;
          e.y -= e.height * x;
          e.width += 2 * e.width * x;
          e.height += 2 * e.height * x;
        }
        if (null == a) {
          a = e;
        } else {
          a = mxRectangle.fromRectangle(a);
          a.intersect(e);
        }
      }
    }
    if (null != a) {
      if (this.unscaledBounds.x < a.x) {
        this.unscaledBounds.width -= a.x - this.unscaledBounds.x;
        this.unscaledBounds.x = a.x;
      }
      if (this.unscaledBounds.y < a.y) {
        this.unscaledBounds.height -= a.y - this.unscaledBounds.y;
        this.unscaledBounds.y = a.y;
      }
      if (this.unscaledBounds.x + this.unscaledBounds.width > a.x + a.width) {
        this.unscaledBounds.width -= this.unscaledBounds.x + this.unscaledBounds.width - a.x - a.width;
      }
      if (this.unscaledBounds.y + this.unscaledBounds.height > a.y + a.height) {
        this.unscaledBounds.height -= this.unscaledBounds.y + this.unscaledBounds.height - a.y - a.height;
      }
    }
  }
  e = this.bounds;
  this.bounds = new mxRectangle((null != this.parentState ? this.parentState.x : translate.x * scale) + this.unscaledBounds.x * scale, (null != this.parentState ? this.parentState.y : translate.y * scale) + this.unscaledBounds.y * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);
  if (b.relative && null != this.parentState) {
    this.bounds.x += this.state.x - this.parentState.x;
    this.bounds.y += this.state.y - this.parentState.y;
  }
  /** @type {number} */
  b = Math.cos(r);
  /** @type {number} */
  a = Math.sin(r);
  r = new mxPoint(this.bounds.getCenterX(), this.bounds.getCenterY());
  /** @type {number} */
  x = r.x - w.x;
  /** @type {number} */
  y = r.y - w.y;
  /** @type {number} */
  w = b * x - a * y - x;
  /** @type {number} */
  r = a * x + b * y - y;
  /** @type {number} */
  x = this.bounds.x - this.state.x;
  /** @type {number} */
  y = this.bounds.y - this.state.y;
  /** @type {number} */
  translate = b * x - a * y;
  /** @type {number} */
  b = a * x + b * y;
  this.bounds.x += w;
  this.bounds.y += r;
  this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + w / scale);
  this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + r / scale);
  this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);
  this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);
  if (this.graph.isCellCollapsed(this.state.cell) || 0 == w && 0 == r) {
    /** @type {number} */
    this.childOffsetY = this.childOffsetX = 0;
  } else {
    /** @type {number} */
    this.childOffsetX = this.state.x - this.bounds.x + translate;
    /** @type {number} */
    this.childOffsetY = this.state.y - this.bounds.y + b;
  }
  if (!e.equals(this.bounds)) {
    if (this.livePreviewActive) {
      this.updateLivePreview(me);
    }
    if (null != this.preview) {
      this.drawPreview();
    } else {
      this.updateParentHighlight();
    }
  }
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxVertexHandler.prototype.updateLivePreview = function(data) {
  var scale = this.graph.view.scale;
  var geo = this.graph.view.translate;
  data = this.state.clone();
  this.state.x = this.bounds.x;
  this.state.y = this.bounds.y;
  this.state.origin = new mxPoint(this.state.x / scale - geo.x, this.state.y / scale - geo.y);
  this.state.width = this.bounds.width;
  this.state.height = this.bounds.height;
  scale = this.state.absoluteOffset;
  new mxPoint(scale.x, scale.y);
  /** @type {number} */
  this.state.absoluteOffset.x = 0;
  /** @type {number} */
  this.state.absoluteOffset.y = 0;
  scale = this.graph.getCellGeometry(this.state.cell);
  if (null != scale) {
    geo = scale.offset || this.EMPTY_POINT;
    if (!(null == geo || scale.relative)) {
      /** @type {number} */
      this.state.absoluteOffset.x = this.state.view.scale * geo.x;
      /** @type {number} */
      this.state.absoluteOffset.y = this.state.view.scale * geo.y;
    }
    this.state.view.updateVertexLabelOffset(this.state);
  }
  this.state.view.graph.cellRenderer.redraw(this.state, true);
  this.state.view.invalidate(this.state.cell);
  /** @type {boolean} */
  this.state.invalid = false;
  this.state.view.validate();
  this.redrawHandles();
  if (this.movePreviewToFront) {
    this.moveToFront();
  }
  if (null != this.state.control && null != this.state.control.node) {
    /** @type {string} */
    this.state.control.node.style.visibility = "hidden";
  }
  this.state.setState(data);
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.moveToFront = function() {
  if (null != this.state.text && null != this.state.text.node && null != this.state.text.node.nextSibling || null != this.state.shape && null != this.state.shape.node && null != this.state.shape.node.nextSibling && (null == this.state.text || this.state.shape.node.nextSibling != this.state.text.node)) {
    if (null != this.state.shape && null != this.state.shape.node) {
      this.state.shape.node.parentNode.appendChild(this.state.shape.node);
    }
    if (null != this.state.text && null != this.state.text.node) {
      this.state.text.node.parentNode.appendChild(this.state.text.node);
    }
  }
};
/**
 * @param {undefined} id
 * @param {!Event} e
 * @return {undefined}
 */
mxVertexHandler.prototype.mouseUp = function(id, e) {
  if (null != this.index && null != this.state) {
    var point = new mxPoint(e.getGraphX(), e.getGraphY());
    id = this.index;
    /** @type {null} */
    this.index = null;
    if (null == this.ghostPreview) {
      this.state.view.invalidate(this.state.cell, false, false);
      this.state.view.validate();
    }
    this.graph.getModel().beginUpdate();
    try {
      if (id <= mxEvent.CUSTOM_HANDLE) {
        if (null != this.customHandles) {
          var value = this.state.view.graph.getCellStyle(this.state.cell);
          /** @type {boolean} */
          this.customHandles[mxEvent.CUSTOM_HANDLE - id].active = false;
          this.customHandles[mxEvent.CUSTOM_HANDLE - id].execute(e);
          if (null != this.customHandles && null != this.customHandles[mxEvent.CUSTOM_HANDLE - id]) {
            this.state.style = value;
            this.customHandles[mxEvent.CUSTOM_HANDLE - id].positionChanged();
          }
        }
      } else {
        if (id == mxEvent.ROTATION_HANDLE) {
          if (null != this.currentAlpha) {
            /** @type {number} */
            var cell = this.currentAlpha - (this.state.style[mxConstants.STYLE_ROTATION] || 0);
            if (0 != cell) {
              this.rotateCell(this.state.cell, cell);
            }
          } else {
            this.rotateClick();
          }
        } else {
          var innerBarWidth = this.graph.isGridEnabledEvent(e.getEvent());
          var theta = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
          /** @type {number} */
          var uv1v = Math.cos(-theta);
          /** @type {number} */
          var uv2v = Math.sin(-theta);
          /** @type {number} */
          var deltaX = point.x - this.startX;
          /** @type {number} */
          var deltaY = point.y - this.startY;
          /** @type {number} */
          value = uv2v * deltaX + uv1v * deltaY;
          /** @type {number} */
          deltaX = uv1v * deltaX - uv2v * deltaY;
          /** @type {number} */
          deltaY = value;
          var lowestDeltaXY = this.graph.view.scale;
          var state = this.isRecursiveResize(this.state, e);
          this.resizeCell(this.state.cell, this.roundLength(deltaX / lowestDeltaXY), this.roundLength(deltaY / lowestDeltaXY), id, innerBarWidth, this.isConstrainedEvent(e), state);
        }
      }
    } finally {
      this.graph.getModel().endUpdate();
    }
    e.consume();
    this.reset();
    this.redrawHandles();
  }
};
/**
 * @param {?} a
 * @param {!Event} b
 * @return {?}
 */
mxVertexHandler.prototype.isRecursiveResize = function(a, b) {
  return this.graph.isRecursiveResize(this.state);
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.rotateClick = function() {
};
/**
 * @param {(Object|string)} cell
 * @param {number} data
 * @param {?} model
 * @return {undefined}
 */
mxVertexHandler.prototype.rotateCell = function(cell, data, model) {
  if (0 != data) {
    var self = this.graph.getModel();
    if (self.isVertex(cell) || self.isEdge(cell)) {
      if (!self.isEdge(cell)) {
        var value = (this.graph.getCurrentCellStyle(cell)[mxConstants.STYLE_ROTATION] || 0) + data;
        this.graph.setCellStyles(mxConstants.STYLE_ROTATION, value, [cell]);
      }
      value = this.graph.getCellGeometry(cell);
      if (null != value) {
        var validatedModel = this.graph.getCellGeometry(model);
        if (!(null == validatedModel || self.isEdge(model))) {
          value = value.clone();
          value.rotate(data, new mxPoint(validatedModel.width / 2, validatedModel.height / 2));
          self.setGeometry(cell, value);
        }
        if (self.isVertex(cell) && !value.relative || self.isEdge(cell)) {
          model = self.getChildCount(cell);
          /** @type {number} */
          value = 0;
          for (; value < model; value++) {
            this.rotateCell(self.getChildAt(cell, value), data, cell);
          }
        }
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.reset = function() {
  if (null != this.sizers && null != this.index && null != this.sizers[this.index] && "none" == this.sizers[this.index].node.style.display) {
    /** @type {string} */
    this.sizers[this.index].node.style.display = "";
  }
  /** @type {null} */
  this.index = this.inTolerance = this.currentAlpha = null;
  if (null != this.preview) {
    this.preview.destroy();
    /** @type {null} */
    this.preview = null;
  }
  if (null != this.ghostPreview) {
    this.ghostPreview.destroy();
    /** @type {null} */
    this.ghostPreview = null;
  }
  if (this.livePreviewActive && null != this.sizers) {
    /** @type {number} */
    var i = 0;
    for (; i < this.sizers.length; i++) {
      if (null != this.sizers[i]) {
        /** @type {string} */
        this.sizers[i].node.style.display = "";
      }
    }
    if (null != this.state.control && null != this.state.control.node) {
      /** @type {string} */
      this.state.control.node.style.visibility = "";
    }
  }
  if (null != this.customHandles) {
    /** @type {number} */
    i = 0;
    for (; i < this.customHandles.length; i++) {
      if (this.customHandles[i].active) {
        /** @type {boolean} */
        this.customHandles[i].active = false;
        this.customHandles[i].reset();
      } else {
        this.customHandles[i].setVisible(true);
      }
    }
  }
  if (null != this.selectionBorder) {
    /** @type {string} */
    this.selectionBorder.node.style.display = "inline";
    this.selectionBounds = this.getSelectionBounds(this.state);
    this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
    this.drawPreview();
  }
  this.removeHint();
  this.redrawHandles();
  /** @type {null} */
  this.edgeHandlers = null;
  /** @type {boolean} */
  this.handlesVisible = true;
  /** @type {null} */
  this.livePreviewActive = this.unscaledBounds = null;
};
/**
 * @param {!Object} index
 * @param {!Object} res
 * @param {number} o
 * @param {number} s
 * @param {?} width
 * @param {?} cb
 * @param {number} value
 * @return {undefined}
 */
mxVertexHandler.prototype.resizeCell = function(index, res, o, s, width, cb, value) {
  res = this.graph.model.getGeometry(index);
  if (null != res) {
    if (s == mxEvent.LABEL_HANDLE) {
      /** @type {number} */
      s = -mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
      /** @type {number} */
      value = Math.cos(s);
      /** @type {number} */
      o = Math.sin(s);
      s = this.graph.view.scale;
      value = mxUtils.getRotatedPoint(new mxPoint(Math.round((this.labelShape.bounds.getCenterX() - this.startX) / s), Math.round((this.labelShape.bounds.getCenterY() - this.startY) / s)), value, o);
      res = res.clone();
      if (null == res.offset) {
        /** @type {number} */
        res.offset = value;
      } else {
        res.offset.x += value.x;
        res.offset.y += value.y;
      }
      this.graph.model.setGeometry(index, res);
    } else {
      if (null != this.unscaledBounds) {
        s = this.graph.view.scale;
        if (!(0 == this.childOffsetX && 0 == this.childOffsetY)) {
          this.moveChildren(index, Math.round(this.childOffsetX / s), Math.round(this.childOffsetY / s));
        }
        this.graph.resizeCell(index, this.unscaledBounds, value);
      }
    }
  }
};
/**
 * @param {!Object} i
 * @param {number} n
 * @param {number} m
 * @return {undefined}
 */
mxVertexHandler.prototype.moveChildren = function(i, n, m) {
  var layer = this.graph.getModel();
  var $sendIcon = layer.getChildCount(i);
  /** @type {number} */
  var y = 0;
  for (; y < $sendIcon; y++) {
    var cell = layer.getChildAt(i, y);
    var d = this.graph.getCellGeometry(cell);
    if (null != d) {
      d = d.clone();
      d.translate(n, m);
      layer.setGeometry(cell, d);
    }
  }
};
/**
 * @param {number} a
 * @param {number} i
 * @param {number} b
 * @param {number} x
 * @param {number} h
 * @param {!Object} scale
 * @param {number} p
 * @param {number} s
 * @param {?} result
 * @return {?}
 */
mxVertexHandler.prototype.union = function(a, i, b, x, h, scale, p, s, result) {
  h = null != h ? h && this.graph.gridEnabled : this.graph.gridEnabled;
  if (this.singleSizer) {
    return x = a.x + a.width + i, p = a.y + a.height + b, h && (x = this.graph.snap(x / scale) * scale, p = this.graph.snap(p / scale) * scale), scale = new mxRectangle(a.x, a.y, 0, 0), scale.add(new mxRectangle(x, p, 0, 0)), scale;
  }
  var size = a.width;
  var k = a.height;
  /** @type {number} */
  var top = a.x - p.x * scale;
  var y = top + size;
  /** @type {number} */
  a = a.y - p.y * scale;
  var d = a + k;
  /** @type {number} */
  var height = top + size / 2;
  /** @type {number} */
  var digits = a + k / 2;
  if (4 < x) {
    d = d + b;
    /** @type {number} */
    d = h ? this.graph.snap(d / scale) * scale : Math.round(d / scale) * scale;
  } else {
    if (3 > x) {
      a = a + b;
      /** @type {number} */
      a = h ? this.graph.snap(a / scale) * scale : Math.round(a / scale) * scale;
    }
  }
  if (0 == x || 3 == x || 5 == x) {
    top = top + i;
    /** @type {number} */
    top = h ? this.graph.snap(top / scale) * scale : Math.round(top / scale) * scale;
  } else {
    if (2 == x || 4 == x || 7 == x) {
      y = y + i;
      /** @type {number} */
      y = h ? this.graph.snap(y / scale) * scale : Math.round(y / scale) * scale;
    }
  }
  /** @type {number} */
  h = y - top;
  /** @type {number} */
  b = d - a;
  if (s) {
    s = this.graph.getCellGeometry(this.state.cell);
    if (null != s) {
      /** @type {number} */
      s = s.width / s.height;
      if (1 == x || 2 == x || 7 == x || 6 == x) {
        /** @type {number} */
        h = b * s;
      } else {
        /** @type {number} */
        b = h / s;
      }
      if (0 == x) {
        /** @type {number} */
        top = y - h;
        /** @type {number} */
        a = d - b;
      }
    }
  }
  if (result) {
    /** @type {number} */
    h = h + (h - size);
    /** @type {number} */
    b = b + (b - k);
    /** @type {number} */
    top = top + (height - (top + h / 2));
    /** @type {number} */
    a = a + (digits - (a + b / 2));
  }
  if (0 > h) {
    /** @type {number} */
    top = top + h;
    /** @type {number} */
    h = Math.abs(h);
  }
  if (0 > b) {
    /** @type {number} */
    a = a + b;
    /** @type {number} */
    b = Math.abs(b);
  }
  x = new mxRectangle(top + p.x * scale, a + p.y * scale, h, b);
  if (null != this.minBounds) {
    /** @type {number} */
    x.width = Math.max(x.width, this.minBounds.x * scale + this.minBounds.width * scale + Math.max(0, this.x0 * scale - x.x));
    /** @type {number} */
    x.height = Math.max(x.height, this.minBounds.y * scale + this.minBounds.height * scale + Math.max(0, this.y0 * scale - x.y));
  }
  return x;
};
/**
 * @param {!Function} elem
 * @return {undefined}
 */
mxVertexHandler.prototype.redraw = function(elem) {
  this.selectionBounds = this.getSelectionBounds(this.state);
  this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
  this.drawPreview();
  if (!elem) {
    this.redrawHandles();
  }
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.getHandlePadding = function() {
  var xyzMax = new mxPoint(0, 0);
  var margin = this.tolerance;
  if (null != this.sizers && 0 < this.sizers.length && null != this.sizers[0] && (this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * margin || this.bounds.height < 2 * this.sizers[0].bounds.height + 2 * margin)) {
    /** @type {number} */
    margin = margin / 2;
    xyzMax.x = this.sizers[0].bounds.width + margin;
    xyzMax.y = this.sizers[0].bounds.height + margin;
  }
  return xyzMax;
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.getSizerBounds = function() {
  return this.bounds;
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.redrawHandles = function() {
  var point = this.getSizerBounds();
  var b = this.tolerance;
  /** @type {number} */
  this.verticalOffset = this.horizontalOffset = 0;
  if (null != this.customHandles) {
    /** @type {number} */
    var i = 0;
    for (; i < this.customHandles.length; i++) {
      var value = this.customHandles[i].shape.node.style.display;
      this.customHandles[i].redraw();
      this.customHandles[i].shape.node.style.display = value;
      /** @type {string} */
      this.customHandles[i].shape.node.style.visibility = this.handlesVisible && this.isCustomHandleVisible(this.customHandles[i]) ? "" : "hidden";
    }
  }
  if (null != this.sizers && 0 < this.sizers.length && null != this.sizers[0]) {
    if (null == this.index && this.manageSizers && 8 <= this.sizers.length) {
      i = this.getHandlePadding();
      this.horizontalOffset = i.x;
      this.verticalOffset = i.y;
      if (0 != this.horizontalOffset || 0 != this.verticalOffset) {
        point = new mxRectangle(point.x, point.y, point.width, point.height);
        point.x -= this.horizontalOffset / 2;
        point.width += this.horizontalOffset;
        point.y -= this.verticalOffset / 2;
        point.height += this.verticalOffset;
      }
      if (8 <= this.sizers.length) {
        if (point.width < 2 * this.sizers[0].bounds.width + 2 * b || point.height < 2 * this.sizers[0].bounds.height + 2 * b) {
          /** @type {string} */
          this.sizers[0].node.style.display = "none";
          /** @type {string} */
          this.sizers[2].node.style.display = "none";
          /** @type {string} */
          this.sizers[5].node.style.display = "none";
          /** @type {string} */
          this.sizers[7].node.style.display = "none";
        } else {
          if (this.handlesVisible) {
            /** @type {string} */
            this.sizers[0].node.style.display = "";
            /** @type {string} */
            this.sizers[2].node.style.display = "";
            /** @type {string} */
            this.sizers[5].node.style.display = "";
            /** @type {string} */
            this.sizers[7].node.style.display = "";
          }
        }
      }
    }
    b = point.x + point.width;
    i = point.y + point.height;
    if (this.singleSizer) {
      this.moveSizerTo(this.sizers[0], b, i);
    } else {
      value = point.x + point.width / 2;
      var t = point.y + point.height / 2;
      if (8 <= this.sizers.length) {
        /** @type {!Array<string>} */
        var panes = "nw-resize n-resize ne-resize e-resize se-resize s-resize sw-resize w-resize".split(" ");
        var angle = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
        /** @type {number} */
        var cos = Math.cos(angle);
        /** @type {number} */
        var sin = Math.sin(angle);
        /** @type {number} */
        angle = Math.round(4 * angle / Math.PI);
        var ct = new mxPoint(point.getCenterX(), point.getCenterY());
        var result = mxUtils.getRotatedPoint(new mxPoint(point.x, point.y), cos, sin, ct);
        this.moveSizerTo(this.sizers[0], result.x, result.y);
        this.sizers[0].setCursor(panes[mxUtils.mod(0 + angle, panes.length)]);
        result.x = value;
        result.y = point.y;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[1], result.x, result.y);
        this.sizers[1].setCursor(panes[mxUtils.mod(1 + angle, panes.length)]);
        result.x = b;
        result.y = point.y;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[2], result.x, result.y);
        this.sizers[2].setCursor(panes[mxUtils.mod(2 + angle, panes.length)]);
        result.x = point.x;
        result.y = t;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[3], result.x, result.y);
        this.sizers[3].setCursor(panes[mxUtils.mod(7 + angle, panes.length)]);
        result.x = b;
        result.y = t;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[4], result.x, result.y);
        this.sizers[4].setCursor(panes[mxUtils.mod(3 + angle, panes.length)]);
        result.x = point.x;
        result.y = i;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[5], result.x, result.y);
        this.sizers[5].setCursor(panes[mxUtils.mod(6 + angle, panes.length)]);
        result.x = value;
        result.y = i;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[6], result.x, result.y);
        this.sizers[6].setCursor(panes[mxUtils.mod(5 + angle, panes.length)]);
        result.x = b;
        result.y = i;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[7], result.x, result.y);
        this.sizers[7].setCursor(panes[mxUtils.mod(4 + angle, panes.length)]);
        result.x = value + this.state.absoluteOffset.x;
        result.y = t + this.state.absoluteOffset.y;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[8], result.x, result.y);
      } else {
        if (2 <= this.state.width && 2 <= this.state.height) {
          this.moveSizerTo(this.sizers[0], value + this.state.absoluteOffset.x, t + this.state.absoluteOffset.y);
        } else {
          this.moveSizerTo(this.sizers[0], this.state.x, this.state.y);
        }
      }
    }
  }
  if (null != this.rotationShape) {
    angle = mxUtils.toRadians(null != this.currentAlpha ? this.currentAlpha : this.state.style[mxConstants.STYLE_ROTATION] || "0");
    /** @type {number} */
    cos = Math.cos(angle);
    /** @type {number} */
    sin = Math.sin(angle);
    ct = new mxPoint(this.state.getCenterX(), this.state.getCenterY());
    result = mxUtils.getRotatedPoint(this.getRotationHandlePosition(), cos, sin, ct);
    if (null != this.rotationShape.node) {
      this.moveSizerTo(this.rotationShape, result.x, result.y);
      /** @type {string} */
      this.rotationShape.node.style.visibility = this.state.view.graph.isEditing() || !this.handlesVisible ? "hidden" : "";
    }
  }
  if (null != this.selectionBorder) {
    /** @type {number} */
    this.selectionBorder.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
  }
  if (null != this.edgeHandlers) {
    /** @type {number} */
    i = 0;
    for (; i < this.edgeHandlers.length; i++) {
      this.edgeHandlers[i].redraw();
    }
  }
};
/**
 * @param {?} a
 * @return {?}
 */
mxVertexHandler.prototype.isCustomHandleVisible = function(a) {
  return !this.graph.isEditing() && 1 == this.state.view.graph.getSelectionCount();
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.getRotationHandlePosition = function() {
  return new mxPoint(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.rotationHandleVSpacing);
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.isParentHighlightVisible = function() {
  return !this.graph.isCellSelected(this.graph.model.getParent(this.state.cell));
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.destroyParentHighlight = function() {
  if (null != this.parentHighlight.state) {
    delete this.parentHighlight.state.parentHighlight;
    delete this.parentHighlight.state;
  }
  this.parentHighlight.destroy();
  /** @type {null} */
  this.parentHighlight = null;
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.updateParentHighlight = function() {
  if (!this.isDestroyed()) {
    var one = this.isParentHighlightVisible();
    var foo = this.graph.model.getParent(this.state.cell);
    var two = this.graph.view.getState(foo);
    if (null != this.parentHighlight) {
      if (this.graph.model.isVertex(foo) && one) {
        one = this.parentHighlight.bounds;
        if (!(null == two || one.x == two.x && one.y == two.y && one.width == two.width && one.height == two.height)) {
          this.parentHighlight.bounds = mxRectangle.fromRectangle(two);
          this.parentHighlight.redraw();
        }
      } else {
        this.destroyParentHighlight();
      }
    } else {
      if (this.parentHighlightEnabled && one && this.graph.model.isVertex(foo) && null != two && null == two.parentHighlight) {
        this.parentHighlight = this.createParentHighlightShape(two);
        this.parentHighlight.dialect = mxConstants.DIALECT_SVG;
        /** @type {boolean} */
        this.parentHighlight.pointerEvents = false;
        /** @type {number} */
        this.parentHighlight.rotation = Number(two.style[mxConstants.STYLE_ROTATION] || "0");
        this.parentHighlight.init(this.graph.getView().getOverlayPane());
        this.parentHighlight.redraw();
        two.parentHighlight = this.parentHighlight;
        this.parentHighlight.state = two;
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.drawPreview = function() {
  if (null != this.preview) {
    this.preview.bounds = this.bounds;
    if (this.preview.node.parentNode == this.graph.container) {
      /** @type {number} */
      this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);
      /** @type {number} */
      this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);
    }
    /** @type {number} */
    this.preview.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
    this.preview.redraw();
  }
  this.selectionBorder.bounds = this.getSelectionBorderBounds();
  this.selectionBorder.redraw();
  this.updateParentHighlight();
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.getSelectionBorderBounds = function() {
  return this.bounds;
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.isDestroyed = function() {
  return null == this.selectionBorder;
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.destroy = function() {
  if (null != this.escapeHandler) {
    this.state.view.graph.removeListener(this.escapeHandler);
    /** @type {null} */
    this.escapeHandler = null;
  }
  if (null != this.preview) {
    this.preview.destroy();
    /** @type {null} */
    this.preview = null;
  }
  if (null != this.ghostPreview) {
    this.ghostPreview.destroy();
    /** @type {null} */
    this.ghostPreview = null;
  }
  if (null != this.selectionBorder) {
    this.selectionBorder.destroy();
    /** @type {null} */
    this.selectionBorder = null;
  }
  if (null != this.parentHighlight) {
    this.destroyParentHighlight();
  }
  /** @type {null} */
  this.labelShape = null;
  this.removeHint();
  if (null != this.sizers) {
    /** @type {number} */
    var i = 0;
    for (; i < this.sizers.length; i++) {
      this.sizers[i].destroy();
    }
    /** @type {null} */
    this.sizers = null;
  }
  if (null != this.customHandles) {
    /** @type {number} */
    i = 0;
    for (; i < this.customHandles.length; i++) {
      this.customHandles[i].destroy();
    }
    /** @type {null} */
    this.customHandles = null;
  }
};
/**
 * @param {!Object} context
 * @return {undefined}
 */
function mxEdgeHandler(context) {
  if (null != context && null != context.shape) {
    /** @type {!Object} */
    this.state = context;
    this.init();
    this.escapeHandler = mxUtils.bind(this, function(b, canCreateDiscussions) {
      /** @type {boolean} */
      b = null != this.index;
      this.reset();
      if (b) {
        this.graph.cellRenderer.redraw(this.state, false, context.view.isRendering());
      }
    });
    this.state.view.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
  }
}
/** @type {null} */
mxEdgeHandler.prototype.graph = null;
/** @type {null} */
mxEdgeHandler.prototype.state = null;
/** @type {null} */
mxEdgeHandler.prototype.marker = null;
/** @type {null} */
mxEdgeHandler.prototype.constraintHandler = null;
/** @type {null} */
mxEdgeHandler.prototype.error = null;
/** @type {null} */
mxEdgeHandler.prototype.shape = null;
/** @type {null} */
mxEdgeHandler.prototype.bends = null;
/** @type {null} */
mxEdgeHandler.prototype.labelShape = null;
/** @type {boolean} */
mxEdgeHandler.prototype.cloneEnabled = true;
/** @type {boolean} */
mxEdgeHandler.prototype.addEnabled = false;
/** @type {boolean} */
mxEdgeHandler.prototype.removeEnabled = false;
/** @type {boolean} */
mxEdgeHandler.prototype.dblClickRemoveEnabled = false;
/** @type {boolean} */
mxEdgeHandler.prototype.mergeRemoveEnabled = false;
/** @type {boolean} */
mxEdgeHandler.prototype.straightRemoveEnabled = false;
/** @type {boolean} */
mxEdgeHandler.prototype.virtualBendsEnabled = false;
/** @type {number} */
mxEdgeHandler.prototype.virtualBendOpacity = 20;
/** @type {boolean} */
mxEdgeHandler.prototype.parentHighlightEnabled = false;
/** @type {boolean} */
mxEdgeHandler.prototype.preferHtml = false;
/** @type {boolean} */
mxEdgeHandler.prototype.allowHandleBoundsCheck = true;
/** @type {boolean} */
mxEdgeHandler.prototype.snapToTerminals = false;
/** @type {null} */
mxEdgeHandler.prototype.handleImage = null;
/** @type {number} */
mxEdgeHandler.prototype.tolerance = 0;
/** @type {boolean} */
mxEdgeHandler.prototype.outlineConnect = false;
/** @type {boolean} */
mxEdgeHandler.prototype.manageLabelHandle = false;
/**
 * @return {undefined}
 */
mxEdgeHandler.prototype.init = function() {
  this.graph = this.state.view.graph;
  this.marker = this.createMarker();
  this.constraintHandler = new mxConstraintHandler(this.graph);
  /** @type {!Array} */
  this.points = [];
  this.abspoints = this.getSelectionPoints(this.state);
  this.shape = this.createSelectionShape(this.abspoints);
  this.shape.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
  this.shape.init(this.graph.getView().getOverlayPane());
  /** @type {number} */
  this.shape.svgStrokeTolerance = 0;
  /** @type {boolean} */
  this.shape.pointerEvents = false;
  mxEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);
  if (this.graph.isCellMovable(this.state.cell)) {
    this.shape.setCursor(mxConstants.CURSOR_MOVABLE_EDGE);
  }
  /** @type {boolean} */
  this.preferHtml = null != this.state.text && this.state.text.node.parentNode == this.graph.container;
  if (!this.preferHtml) {
    var nextAtom = this.state.getVisibleTerminalState(true);
    if (null != nextAtom) {
      /** @type {boolean} */
      this.preferHtml = null != nextAtom.text && nextAtom.text.node.parentNode == this.graph.container;
    }
    if (!this.preferHtml) {
      nextAtom = this.state.getVisibleTerminalState(false);
      if (null != nextAtom) {
        /** @type {boolean} */
        this.preferHtml = null != nextAtom.text && nextAtom.text.node.parentNode == this.graph.container;
      }
    }
  }
  if (this.graph.isCellEditable(this.state.cell) && (this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells || 0 >= mxGraphHandler.prototype.maxCells)) {
    this.bends = this.createBends();
    if (this.isVirtualBendsEnabled()) {
      this.virtualBends = this.createVirtualBends();
    }
  }
  this.label = new mxPoint(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
  this.labelShape = this.createLabelHandleShape();
  this.initBend(this.labelShape);
  if (this.graph.isCellEditable(this.state.cell)) {
    this.labelShape.setCursor(mxConstants.CURSOR_LABEL_HANDLE);
    this.customHandles = this.createCustomHandles();
  }
  this.updateParentHighlight();
  this.redraw();
};
/** @type {function(): ?} */
mxEdgeHandler.prototype.isParentHighlightVisible = mxVertexHandler.prototype.isParentHighlightVisible;
/** @type {function(): undefined} */
mxEdgeHandler.prototype.destroyParentHighlight = mxVertexHandler.prototype.destroyParentHighlight;
/** @type {function(): undefined} */
mxEdgeHandler.prototype.updateParentHighlight = mxVertexHandler.prototype.updateParentHighlight;
/**
 * @return {?}
 */
mxEdgeHandler.prototype.createCustomHandles = function() {
  return null;
};
/**
 * @param {?} a
 * @return {?}
 */
mxEdgeHandler.prototype.isVirtualBendsEnabled = function(a) {
  return this.virtualBendsEnabled && (null == this.state.style[mxConstants.STYLE_EDGE] || this.state.style[mxConstants.STYLE_EDGE] == mxConstants.NONE || 1 == this.state.style[mxConstants.STYLE_NOEDGESTYLE]) && "arrow" != mxUtils.getValue(this.state.style, mxConstants.STYLE_SHAPE, null);
};
/**
 * @param {?} a
 * @return {?}
 */
mxEdgeHandler.prototype.isCellEnabled = function(a) {
  return true;
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxEdgeHandler.prototype.isAddPointEvent = function(evt) {
  return mxEvent.isShiftDown(evt);
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxEdgeHandler.prototype.isRemovePointEvent = function(evt) {
  return mxEvent.isShiftDown(evt);
};
/**
 * @param {?} a
 * @return {?}
 */
mxEdgeHandler.prototype.getSelectionPoints = function(a) {
  return a.absolutePoints;
};
/**
 * @param {?} o
 * @return {?}
 */
mxEdgeHandler.prototype.createParentHighlightShape = function(o) {
  o = new mxRectangleShape(mxRectangle.fromRectangle(o), null, this.getSelectionColor());
  o.strokewidth = this.getSelectionStrokeWidth();
  o.isDashed = this.isSelectionDashed();
  return o;
};
/**
 * @param {!Object} item
 * @return {?}
 */
mxEdgeHandler.prototype.createSelectionShape = function(item) {
  item = new this.state.shape.constructor;
  /** @type {boolean} */
  item.outline = true;
  item.apply(this.state);
  item.isDashed = this.isSelectionDashed();
  item.stroke = this.getSelectionColor();
  /** @type {boolean} */
  item.isShadow = false;
  return item;
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.getSelectionColor = function() {
  return this.graph.isCellEditable(this.state.cell) ? mxConstants.EDGE_SELECTION_COLOR : mxConstants.LOCKED_HANDLE_FILLCOLOR;
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.getSelectionStrokeWidth = function() {
  return mxConstants.EDGE_SELECTION_STROKEWIDTH;
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.isSelectionDashed = function() {
  return mxConstants.EDGE_SELECTION_DASHED;
};
/**
 * @param {?} cell
 * @return {?}
 */
mxEdgeHandler.prototype.isConnectableCell = function(cell) {
  return true;
};
/**
 * @param {!Object} x
 * @param {string} y
 * @return {?}
 */
mxEdgeHandler.prototype.getCellAt = function(x, y) {
  return this.outlineConnect ? null : this.graph.getCellAt(x, y);
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.createMarker = function() {
  var iterator = new mxCellMarker(this.graph);
  var self = this;
  /**
   * @param {!Object} o
   * @return {?}
   */
  iterator.getCell = function(o) {
    var t = mxCellMarker.prototype.getCell.apply(this, arguments);
    if (!(t != self.state.cell && null != t || null == self.currentPoint)) {
      t = self.graph.getCellAt(self.currentPoint.x, self.currentPoint.y);
    }
    if (null != t && !this.graph.isCellConnectable(t)) {
      var cell = this.graph.getModel().getParent(t);
      if (this.graph.getModel().isVertex(cell) && this.graph.isCellConnectable(cell)) {
        t = cell;
      }
    }
    cell = self.graph.getModel();
    if (this.graph.isSwimlane(t) && null != self.currentPoint && this.graph.hitsSwimlaneContent(t, self.currentPoint.x, self.currentPoint.y) || !self.isConnectableCell(t) || t == self.state.cell || null != t && !self.graph.connectableEdges && cell.isEdge(t) || cell.isAncestor(self.state.cell, t)) {
      /** @type {null} */
      t = null;
    }
    if (!this.graph.isCellConnectable(t)) {
      /** @type {null} */
      t = null;
    }
    return t;
  };
  /**
   * @param {!Object} state
   * @return {?}
   */
  iterator.isValidState = function(state) {
    var data = self.graph.getModel();
    data = self.graph.view.getTerminalPort(state, self.graph.view.getState(data.getTerminal(self.state.cell, !self.isSource)), !self.isSource);
    data = null != data ? data.cell : null;
    self.error = self.validateConnection(self.isSource ? state.cell : data, self.isSource ? data : state.cell);
    return null == self.error;
  };
  return iterator;
};
/**
 * @param {!Object} i
 * @param {!Object} v
 * @return {?}
 */
mxEdgeHandler.prototype.validateConnection = function(i, v) {
  return this.graph.getEdgeValidationError(this.state.cell, i, v);
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.createBends = function() {
  var value = this.state.cell;
  /** @type {!Array} */
  var b = [];
  /** @type {number} */
  var clojIsReversed = 0;
  for (; clojIsReversed < this.abspoints.length; clojIsReversed++) {
    if (this.isHandleVisible(clojIsReversed)) {
      /** @type {boolean} */
      var error = clojIsReversed == this.abspoints.length - 1;
      /** @type {boolean} */
      var ls = 0 == clojIsReversed || error;
      if (ls || this.graph.isCellBendable(value)) {
        mxUtils.bind(this, function(entity) {
          var self = this.createHandleShape(entity, null, entity == this.abspoints.length - 1);
          this.initBend(self, mxUtils.bind(this, mxUtils.bind(this, function() {
            if (this.dblClickRemoveEnabled) {
              this.removePoint(this.state, entity);
            }
          })));
          if (this.isHandleEnabled(clojIsReversed)) {
            self.setCursor(ls ? mxConstants.CURSOR_TERMINAL_HANDLE : mxConstants.CURSOR_BEND_HANDLE);
          }
          b.push(self);
          if (!ls) {
            this.points.push(new mxPoint(0, 0));
            /** @type {string} */
            self.node.style.visibility = "hidden";
          }
        })(clojIsReversed);
      }
    }
  }
  return b;
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.createVirtualBends = function() {
  /** @type {!Array} */
  var yRanges = [];
  if (this.graph.isCellBendable(this.state.cell)) {
    /** @type {number} */
    var ki$13 = 1;
    for (; ki$13 < this.abspoints.length; ki$13++) {
      mxUtils.bind(this, function(range) {
        this.initBend(range);
        range.setCursor(mxConstants.CURSOR_VIRTUAL_BEND_HANDLE);
        yRanges.push(range);
      })(this.createHandleShape());
    }
  }
  return yRanges;
};
/**
 * @param {number} isSlidingUp
 * @return {?}
 */
mxEdgeHandler.prototype.isHandleEnabled = function(isSlidingUp) {
  return true;
};
/**
 * @param {number} isSlidingUp
 * @return {?}
 */
mxEdgeHandler.prototype.isHandleVisible = function(isSlidingUp) {
  var value = this.state.getVisibleTerminalState(true);
  var BidirectionalSubject = this.state.getVisibleTerminalState(false);
  var number = this.graph.getCellGeometry(this.state.cell);
  return (null != number ? this.graph.view.getEdgeStyle(this.state, number.points, value, BidirectionalSubject) : null) != mxEdgeStyle.EntityRelation || 0 == isSlidingUp || isSlidingUp == this.abspoints.length - 1;
};
/**
 * @param {number} size
 * @return {?}
 */
mxEdgeHandler.prototype.createHandleShape = function(size) {
  if (null != this.handleImage) {
    return size = new mxImageShape(new mxRectangle(0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src), size.preserveImageAspect = false, size;
  }
  size = mxConstants.HANDLE_SIZE;
  if (this.preferHtml) {
    --size;
  }
  return new mxRectangleShape(new mxRectangle(0, 0, size, size), mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.createLabelHandleShape = function() {
  if (null != this.labelHandleImage) {
    var size = new mxImageShape(new mxRectangle(0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);
    /** @type {boolean} */
    size.preserveImageAspect = false;
    return size;
  }
  size = mxConstants.LABEL_HANDLE_SIZE;
  return new mxRectangleShape(new mxRectangle(0, 0, size, size), mxConstants.LABEL_HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
};
/**
 * @param {!Object} options
 * @param {?} a_val
 * @return {undefined}
 */
mxEdgeHandler.prototype.initBend = function(options, a_val) {
  if (this.preferHtml) {
    options.dialect = mxConstants.DIALECT_STRICTHTML;
    options.init(this.graph.container);
  } else {
    options.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
    options.init(this.graph.getView().getOverlayPane());
  }
  mxEvent.redirectMouseEvents(options.node, this.graph, this.state, null, null, null, a_val);
  if (mxClient.IS_TOUCH) {
    options.node.setAttribute("pointer-events", "none");
  }
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxEdgeHandler.prototype.getHandleForEvent = function(me) {
  /** @type {null} */
  var result = null;
  if (null != this.state) {
    /**
     * @param {number} arg
     * @return {?}
     */
    var activate = function(arg) {
      if (null != arg && (me.isSource(arg) || arg.intersectsRectangle(length))) {
        /** @type {number} */
        var argR = me.getGraphX() - arg.bounds.getCenterX();
        /** @type {number} */
        arg = me.getGraphY() - arg.bounds.getCenterY();
        /** @type {number} */
        argR = argR * argR + arg * arg;
        if (null == it_max || argR <= it_max) {
          return it_max = argR, true;
        }
      }
      return false;
    };
    var i = mxEvent.isMouseEvent(me.getEvent()) ? 1 : this.tolerance;
    var length = this.allowHandleBoundsCheck && (mxClient.IS_IE || 0 < i) ? new mxRectangle(me.getGraphX() - i, me.getGraphY() - i, 2 * i, 2 * i) : null;
    /** @type {null} */
    var it_max = null;
    if (null != this.customHandles && this.isCustomHandleEvent(me)) {
      /** @type {number} */
      i = this.customHandles.length - 1;
      for (; 0 <= i; i--) {
        if (activate(this.customHandles[i].shape)) {
          return mxEvent.CUSTOM_HANDLE - i;
        }
      }
    }
    if (me.isSource(this.state.text) || activate(this.labelShape)) {
      result = mxEvent.LABEL_HANDLE;
    }
    if (null != this.bends) {
      /** @type {number} */
      i = 0;
      for (; i < this.bends.length; i++) {
        if (activate(this.bends[i])) {
          /** @type {number} */
          result = i;
        }
      }
    }
    if (null != this.virtualBends && this.isAddVirtualBendEvent(me)) {
      /** @type {number} */
      i = 0;
      for (; i < this.virtualBends.length; i++) {
        if (activate(this.virtualBends[i])) {
          /** @type {number} */
          result = mxEvent.VIRTUAL_HANDLE - i;
        }
      }
    }
  }
  return result;
};
/**
 * @param {!Object} object
 * @return {?}
 */
mxEdgeHandler.prototype.isAddVirtualBendEvent = function(object) {
  return true;
};
/**
 * @param {!Object} me1
 * @return {?}
 */
mxEdgeHandler.prototype.isCustomHandleEvent = function(me1) {
  return true;
};
/**
 * @param {number} item
 * @param {!Object} me
 * @return {undefined}
 */
mxEdgeHandler.prototype.mouseDown = function(item, me) {
  if (this.graph.isCellEditable(this.state.cell)) {
    item = this.getHandleForEvent(me);
    if (null != this.bends && null != this.bends[item]) {
      var me = this.bends[item].bounds;
      this.snapPoint = new mxPoint(me.getCenterX(), me.getCenterY());
    }
    if (this.addEnabled && null == item && this.isAddPointEvent(me.getEvent())) {
      this.addPoint(this.state, me.getEvent());
      me.consume();
    } else {
      if (null != item && !me.isConsumed() && this.graph.isEnabled()) {
        if (this.removeEnabled && this.isRemovePointEvent(me.getEvent())) {
          this.removePoint(this.state, item);
        } else {
          if (item != mxEvent.LABEL_HANDLE || this.graph.isLabelMovable(me.getCell())) {
            if (item <= mxEvent.VIRTUAL_HANDLE) {
              mxUtils.setOpacity(this.virtualBends[mxEvent.VIRTUAL_HANDLE - item].node, 100);
            }
            this.start(me.getX(), me.getY(), item);
          }
        }
        me.consume();
      }
    }
  }
};
/**
 * @param {number} start
 * @param {number} end
 * @param {number} k
 * @return {undefined}
 */
mxEdgeHandler.prototype.start = function(start, end, k) {
  /** @type {number} */
  this.startX = start;
  /** @type {number} */
  this.startY = end;
  /** @type {boolean} */
  this.isSource = null == this.bends ? false : 0 == k;
  /** @type {boolean} */
  this.isTarget = null == this.bends ? false : k == this.bends.length - 1;
  /** @type {boolean} */
  this.isLabel = k == mxEvent.LABEL_HANDLE;
  if (this.isSource || this.isTarget) {
    if (start = this.state.cell, end = this.graph.model.getTerminal(start, this.isSource), null == end && this.graph.isTerminalPointMovable(start, this.isSource) || null != end && this.graph.isCellDisconnectable(start, end, this.isSource)) {
      /** @type {number} */
      this.index = k;
    }
  } else {
    /** @type {number} */
    this.index = k;
  }
  if (this.index <= mxEvent.CUSTOM_HANDLE && this.index > mxEvent.VIRTUAL_HANDLE && null != this.customHandles) {
    /** @type {number} */
    k = 0;
    for (; k < this.customHandles.length; k++) {
      if (k != mxEvent.CUSTOM_HANDLE - this.index) {
        this.customHandles[k].setVisible(false);
      }
    }
  }
};
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
mxEdgeHandler.prototype.clonePreviewState = function(a, b) {
  return this.state.clone();
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.getSnapToTerminalTolerance = function() {
  return 2;
};
/**
 * @param {!Object} data
 * @param {?} linkedEntities
 * @return {undefined}
 */
mxEdgeHandler.prototype.updateHint = function(data, linkedEntities) {
};
/**
 * @return {undefined}
 */
mxEdgeHandler.prototype.removeHint = function() {
};
/**
 * @param {number} pNumber
 * @return {?}
 */
mxEdgeHandler.prototype.roundLength = function(pNumber) {
  return Math.round(pNumber);
};
/**
 * @param {!Object} menu
 * @return {?}
 */
mxEdgeHandler.prototype.isSnapToTerminalsEvent = function(menu) {
  return this.snapToTerminals && !mxEvent.isAltDown(menu.getEvent());
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxEdgeHandler.prototype.getPointForEvent = function(me) {
  var data = this.graph.getView();
  var scale = data.scale;
  var point = new mxPoint(this.roundLength(me.getGraphX() / scale) * scale, this.roundLength(me.getGraphY() / scale) * scale);
  var e = this.getSnapToTerminalTolerance();
  /** @type {boolean} */
  var f = false;
  /** @type {boolean} */
  var g = false;
  if (0 < e && this.isSnapToTerminalsEvent(me)) {
    /**
     * @param {number} val
     * @return {undefined}
     */
    var prev = function(val) {
      if (null != val) {
        regularLight.call(this, new mxPoint(data.getRoutingCenterX(val), data.getRoutingCenterY(val)));
      }
    };
    /**
     * @param {number} i
     * @return {undefined}
     */
    var regularLight = function(i) {
      if (null != i) {
        var x = i.x;
        if (Math.abs(point.x - x) < e) {
          point.x = x;
          /** @type {boolean} */
          f = true;
        }
        i = i.y;
        if (Math.abs(point.y - i) < e) {
          /** @type {number} */
          point.y = i;
          /** @type {boolean} */
          g = true;
        }
      }
    };
    prev.call(this, this.state.getVisibleTerminalState(true));
    prev.call(this, this.state.getVisibleTerminalState(false));
    prev = this.state.absolutePoints;
    if (null != prev) {
      /** @type {number} */
      var i = 0;
      for (; i < prev.length; i++) {
        if ((0 < i || !this.state.isFloatingTerminalPoint(true)) && (i < prev.length - 1 || !this.state.isFloatingTerminalPoint(false))) {
          regularLight.call(this, this.state.absolutePoints[i]);
        }
      }
    }
  }
  if (this.graph.isGridEnabledEvent(me.getEvent())) {
    me = data.translate;
    if (!f) {
      /** @type {number} */
      point.x = (this.graph.snap(point.x / scale - me.x) + me.x) * scale;
    }
    if (!g) {
      /** @type {number} */
      point.y = (this.graph.snap(point.y / scale - me.y) + me.y) * scale;
    }
  }
  return point;
};
/**
 * @param {?} me
 * @return {?}
 */
mxEdgeHandler.prototype.getPreviewTerminalState = function(me) {
  this.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);
  if (null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentConstraint) {
    return null != this.marker.highlight && null != this.marker.highlight.state && this.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell ? "transparent" != this.marker.highlight.shape.stroke && (this.marker.highlight.shape.stroke = "transparent", this.marker.highlight.repaint()) : this.marker.markCell(this.constraintHandler.currentFocus.cell, "transparent"), me = this.graph.getModel(), me = this.graph.view.getTerminalPort(this.state, this.graph.view.getState(me.getTerminal(this.state.cell, 
    !this.isSource)), !this.isSource), me = null != me ? me.cell : null, this.error = this.validateConnection(this.isSource ? this.constraintHandler.currentFocus.cell : me, this.isSource ? me : this.constraintHandler.currentFocus.cell), me = null, null == this.error && (me = this.constraintHandler.currentFocus), (null != this.error || null != me && !this.isCellEnabled(me.cell)) && this.constraintHandler.reset(), me;
  }
  if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {
    return this.marker.reset(), null;
  }
  this.marker.process(me);
  me = this.marker.getValidState();
  if (!(null == me || this.isCellEnabled(me.cell))) {
    this.constraintHandler.reset();
    this.marker.reset();
  }
  return this.marker.getValidState();
};
/**
 * @param {!Object} result
 * @param {!Object} event
 * @return {?}
 */
mxEdgeHandler.prototype.getPreviewPoints = function(result, event) {
  var items = this.graph.getCellGeometry(this.state.cell);
  items = null != items.points ? items.points.slice() : null;
  var item = new mxPoint(result.x, result.y);
  /** @type {null} */
  var data = null;
  if (this.isSource || this.isTarget) {
    if (this.graph.resetEdgesOnConnect) {
      /** @type {null} */
      items = null;
    }
  } else {
    if (this.convertPoint(item, false), null == items) {
      /** @type {!Array} */
      items = [item];
    } else {
      if (this.index <= mxEvent.VIRTUAL_HANDLE) {
        items.splice(mxEvent.VIRTUAL_HANDLE - this.index, 0, item);
      }
      if (!this.isSource && !this.isTarget) {
        /** @type {number} */
        var stack = 0;
        for (; stack < this.bends.length; stack++) {
          if (stack != this.index) {
            var i = this.bends[stack];
            if (null != i && mxUtils.contains(i.bounds, result.x, result.y)) {
              if (this.index <= mxEvent.VIRTUAL_HANDLE) {
                items.splice(mxEvent.VIRTUAL_HANDLE - this.index, 1);
              } else {
                items.splice(this.index - 1, 1);
              }
              data = items;
            }
          }
        }
        if (null == data && this.straightRemoveEnabled && (null == event || !mxEvent.isAltDown(event.getEvent()))) {
          /** @type {number} */
          event = this.graph.tolerance * this.graph.tolerance;
          stack = this.state.absolutePoints.slice();
          /** @type {!Object} */
          stack[this.index] = result;
          var value = this.state.getVisibleTerminalState(true);
          if (null != value && (i = this.graph.getConnectionConstraint(this.state, value, true), null == i || null == this.graph.getConnectionPoint(value, i))) {
            stack[0] = new mxPoint(value.view.getRoutingCenterX(value), value.view.getRoutingCenterY(value));
          }
          value = this.state.getVisibleTerminalState(false);
          if (null != value && (i = this.graph.getConnectionConstraint(this.state, value, false), null == i || null == this.graph.getConnectionPoint(value, i))) {
            stack[stack.length - 1] = new mxPoint(value.view.getRoutingCenterX(value), value.view.getRoutingCenterY(value));
          }
          i = this.index;
          if (0 < i && i < stack.length - 1 && mxUtils.ptSegDistSq(stack[i - 1].x, stack[i - 1].y, stack[i + 1].x, stack[i + 1].y, result.x, result.y) < event) {
            items.splice(i - 1, 1);
            data = items;
          }
        }
      }
      if (null == data && this.index > mxEvent.VIRTUAL_HANDLE) {
        items[this.index - 1] = item;
      }
    }
  }
  return null != data ? data : items;
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxEdgeHandler.prototype.isOutlineConnectEvent = function(me) {
  if (mxEvent.isShiftDown(me.getEvent()) && mxEvent.isAltDown(me.getEvent())) {
    return false;
  }
  var n = mxUtils.getOffset(this.graph.container);
  var e = me.getEvent();
  var d = mxEvent.getClientX(e);
  e = mxEvent.getClientY(e);
  /** @type {!Element} */
  var doc = document.documentElement;
  /** @type {number} */
  var df = this.currentPoint.x - this.graph.container.scrollLeft + n.x - ((window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0));
  /** @type {number} */
  n = this.currentPoint.y - this.graph.container.scrollTop + n.y - ((window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0));
  return this.outlineConnect && (mxEvent.isShiftDown(me.getEvent()) && !mxEvent.isAltDown(me.getEvent()) || me.isSource(this.marker.highlight.shape) || !mxEvent.isShiftDown(me.getEvent()) && mxEvent.isAltDown(me.getEvent()) && null != me.getState() || this.marker.highlight.isHighlightAt(d, e) || (df != d || n != e) && null == me.getState() && this.marker.highlight.isHighlightAt(df, n));
};
/**
 * @param {!Object} parent
 * @param {!Object} first
 * @param {string} args
 * @param {!Object} me
 * @param {boolean} color
 * @return {undefined}
 */
mxEdgeHandler.prototype.updatePreviewState = function(parent, first, args, me, color) {
  var i = this.isSource ? args : this.state.getVisibleTerminalState(true);
  var url = this.isTarget ? args : this.state.getVisibleTerminalState(false);
  var index = this.graph.getConnectionConstraint(parent, i, true);
  var log = this.graph.getConnectionConstraint(parent, url, false);
  var result = this.constraintHandler.currentConstraint;
  if (null == result && color) {
    if (null != args) {
      if (me.isSource(this.marker.highlight.shape)) {
        first = new mxPoint(me.getGraphX(), me.getGraphY());
      }
      result = this.graph.getOutlineConstraint(first, args, me);
      this.constraintHandler.setFocus(me, args, this.isSource);
      this.constraintHandler.currentConstraint = result;
      /** @type {!Object} */
      this.constraintHandler.currentPoint = first;
    } else {
      result = new mxConnectionConstraint;
    }
  }
  if (this.outlineConnect && null != this.marker.highlight && null != this.marker.highlight.shape) {
    var r = this.graph.view.scale;
    if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus) {
      this.marker.highlight.shape.stroke = color ? mxConstants.OUTLINE_HIGHLIGHT_COLOR : "transparent";
      /** @type {number} */
      this.marker.highlight.shape.strokewidth = mxConstants.OUTLINE_HIGHLIGHT_STROKEWIDTH / r / r;
      this.marker.highlight.repaint();
    } else {
      if (this.marker.hasValidState()) {
        this.marker.highlight.shape.stroke = this.graph.isCellConnectable(me.getCell()) && this.marker.getValidState() != me.getState() ? "transparent" : mxConstants.DEFAULT_VALID_COLOR;
        /** @type {number} */
        this.marker.highlight.shape.strokewidth = mxConstants.HIGHLIGHT_STROKEWIDTH / r / r;
        this.marker.highlight.repaint();
      }
    }
  }
  if (this.isSource) {
    index = result;
  } else {
    if (this.isTarget) {
      log = result;
    }
  }
  if (this.isSource || this.isTarget) {
    if (null != result && null != result.point) {
      parent.style[this.isSource ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X] = result.point.x;
      parent.style[this.isSource ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y] = result.point.y;
    } else {
      delete parent.style[this.isSource ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X];
      delete parent.style[this.isSource ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y];
    }
  }
  parent.setVisibleTerminalState(i, true);
  parent.setVisibleTerminalState(url, false);
  if (!(this.isSource && null == i)) {
    parent.view.updateFixedTerminalPoint(parent, i, true, index);
  }
  if (!(this.isTarget && null == url)) {
    parent.view.updateFixedTerminalPoint(parent, url, false, log);
  }
  if ((this.isSource || this.isTarget) && null == args) {
    parent.setAbsoluteTerminalPoint(first, this.isSource);
    if (null == this.marker.getMarkedState()) {
      /** @type {(null|string)} */
      this.error = this.graph.allowDanglingEdges ? null : "";
    }
  }
  parent.view.updatePoints(parent, this.points, i, url);
  parent.view.updateFloatingTerminalPoints(parent, i, url);
};
/**
 * @param {!Object} e
 * @param {!Object} self
 * @return {undefined}
 */
mxEdgeHandler.prototype.mouseMove = function(e, self) {
  if (null != this.index && null != this.marker) {
    this.currentPoint = this.getPointForEvent(self);
    /** @type {null} */
    this.error = null;
    if (null != this.snapPoint && mxEvent.isShiftDown(self.getEvent()) && !this.graph.isIgnoreTerminalEvent(self.getEvent()) && null == this.constraintHandler.currentFocus && this.constraintHandler.currentFocus != this.state) {
      if (Math.abs(this.snapPoint.x - this.currentPoint.x) < Math.abs(this.snapPoint.y - this.currentPoint.y)) {
        this.currentPoint.x = this.snapPoint.x;
      } else {
        this.currentPoint.y = this.snapPoint.y;
      }
    }
    if (this.index <= mxEvent.CUSTOM_HANDLE && this.index > mxEvent.VIRTUAL_HANDLE) {
      if (null != this.customHandles) {
        this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].processEvent(self);
        this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].positionChanged();
        if (null != this.shape && null != this.shape.node) {
          /** @type {string} */
          this.shape.node.style.display = "none";
        }
      }
    } else {
      if (this.isLabel) {
        this.label.x = this.currentPoint.x;
        this.label.y = this.currentPoint.y;
      } else {
        this.points = this.getPreviewPoints(this.currentPoint, self);
        e = this.isSource || this.isTarget ? this.getPreviewTerminalState(self) : null;
        if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentPoint) {
          this.currentPoint = this.constraintHandler.currentPoint.clone();
        } else {
          if (this.outlineConnect) {
            var pureColor = this.isSource || this.isTarget ? this.isOutlineConnectEvent(self) : false;
            if (pureColor) {
              e = this.marker.highlight.state;
            } else {
              if (null != e && e != self.getState() && this.graph.isCellConnectable(self.getCell()) && null != this.marker.highlight.shape) {
                /** @type {string} */
                this.marker.highlight.shape.stroke = "transparent";
                this.marker.highlight.repaint();
                /** @type {null} */
                e = null;
              }
            }
          }
        }
        if (!(null == e || this.isCellEnabled(e.cell))) {
          /** @type {null} */
          e = null;
          this.marker.reset();
        }
        var tagspace = this.clonePreviewState(this.currentPoint, null != e ? e.cell : null);
        this.updatePreviewState(tagspace, this.currentPoint, e, self, pureColor);
        this.setPreviewColor(null == this.error ? this.marker.validColor : this.marker.invalidColor);
        this.abspoints = tagspace.absolutePoints;
        /** @type {boolean} */
        this.active = true;
        this.updateHint(self, this.currentPoint);
      }
    }
    this.drawPreview();
    mxEvent.consume(self.getEvent());
    self.consume();
  } else {
    if (mxClient.IS_IE && null != this.getHandleForEvent(self)) {
      self.consume(false);
    }
  }
};
/**
 * @param {undefined} target
 * @param {!Object} e
 * @return {undefined}
 */
mxEdgeHandler.prototype.mouseUp = function(target, e) {
  if (null != this.index && null != this.marker) {
    if (null != this.shape && null != this.shape.node) {
      /** @type {string} */
      this.shape.node.style.display = "";
    }
    target = this.state.cell;
    var index = this.index;
    /** @type {null} */
    this.index = null;
    if (e.getX() != this.startX || e.getY() != this.startY) {
      var i = !this.graph.isIgnoreTerminalEvent(e.getEvent()) && this.graph.isCloneEvent(e.getEvent()) && this.cloneEnabled && this.graph.isCellsCloneable();
      if (null != this.error) {
        if (0 < this.error.length) {
          this.graph.validationAlert(this.error);
        }
      } else {
        if (index <= mxEvent.CUSTOM_HANDLE && index > mxEvent.VIRTUAL_HANDLE) {
          if (null != this.customHandles) {
            var self = this.graph.getModel();
            self.beginUpdate();
            try {
              this.customHandles[mxEvent.CUSTOM_HANDLE - index].execute(e);
              if (null != this.shape && null != this.shape.node) {
                this.shape.apply(this.state);
                this.shape.redraw();
              }
            } finally {
              self.endUpdate();
            }
          }
        } else {
          if (this.isLabel) {
            this.moveLabel(this.state, this.label.x, this.label.y);
          } else {
            if (this.isSource || this.isTarget) {
              if (index = null, null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus && (index = this.constraintHandler.currentFocus.cell), null == index && this.marker.hasValidState() && null != this.marker.highlight && null != this.marker.highlight.shape && "transparent" != this.marker.highlight.shape.stroke && "white" != this.marker.highlight.shape.stroke && (index = this.marker.validState.cell), null != index) {
                self = this.graph.getModel();
                var node = self.getParent(target);
                self.beginUpdate();
                try {
                  if (i) {
                    var p = self.getGeometry(target);
                    i = this.graph.cloneCell(target);
                    self.add(node, i, self.getChildCount(node));
                    if (null != p) {
                      p = p.clone();
                      self.setGeometry(i, p);
                    }
                    var attr = self.getTerminal(target, !this.isSource);
                    this.graph.connectCell(i, attr, !this.isSource);
                    target = i;
                  }
                  target = this.connect(target, index, this.isSource, i, e);
                } finally {
                  self.endUpdate();
                }
              } else {
                if (this.graph.isAllowDanglingEdges()) {
                  p = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];
                  p.x = this.roundLength(p.x / this.graph.view.scale - this.graph.view.translate.x);
                  p.y = this.roundLength(p.y / this.graph.view.scale - this.graph.view.translate.y);
                  attr = this.graph.getView().getState(this.graph.getModel().getParent(target));
                  if (null != attr) {
                    p.x -= attr.origin.x;
                    p.y -= attr.origin.y;
                  }
                  p.x -= this.graph.panDx / this.graph.view.scale;
                  p.y -= this.graph.panDy / this.graph.view.scale;
                  target = this.changeTerminalPoint(target, p, this.isSource, i);
                }
              }
            } else {
              if (this.active) {
                target = this.changePoints(target, this.points, i);
              } else {
                this.graph.getView().invalidate(this.state.cell);
                this.graph.getView().validate(this.state.cell);
              }
            }
          }
        }
      }
    } else {
      if (this.graph.isToggleEvent(e.getEvent())) {
        this.graph.selectCellForEvent(this.state.cell, e.getEvent());
      }
    }
    if (null != this.marker) {
      this.reset();
      if (target != this.state.cell) {
        this.graph.setSelectionCell(target);
      }
    }
    e.consume();
  }
};
/**
 * @return {undefined}
 */
mxEdgeHandler.prototype.reset = function() {
  if (this.active) {
    this.refresh();
  }
  /** @type {null} */
  this.snapPoint = this.points = this.label = this.index = this.error = null;
  /** @type {boolean} */
  this.active = this.isTarget = this.isSource = this.isLabel = false;
  if (this.livePreview && null != this.sizers) {
    /** @type {number} */
    var i = 0;
    for (; i < this.sizers.length; i++) {
      if (null != this.sizers[i]) {
        /** @type {string} */
        this.sizers[i].node.style.display = "";
      }
    }
  }
  if (null != this.marker) {
    this.marker.reset();
  }
  if (null != this.constraintHandler) {
    this.constraintHandler.reset();
  }
  if (null != this.customHandles) {
    /** @type {number} */
    i = 0;
    for (; i < this.customHandles.length; i++) {
      this.customHandles[i].reset();
    }
  }
  this.setPreviewColor(mxConstants.EDGE_SELECTION_COLOR);
  this.removeHint();
  this.redraw();
};
/**
 * @param {!Object} v
 * @return {undefined}
 */
mxEdgeHandler.prototype.setPreviewColor = function(v) {
  if (null != this.shape) {
    /** @type {!Object} */
    this.shape.stroke = v;
  }
};
/**
 * @param {!Object} target
 * @param {string} p
 * @return {?}
 */
mxEdgeHandler.prototype.convertPoint = function(target, p) {
  var scale = this.graph.getView().getScale();
  var geo = this.graph.getView().getTranslate();
  if (p) {
    target.x = this.graph.snap(target.x);
    target.y = this.graph.snap(target.y);
  }
  /** @type {number} */
  target.x = Math.round(target.x / scale - geo.x);
  /** @type {number} */
  target.y = Math.round(target.y / scale - geo.y);
  p = this.graph.getView().getState(this.graph.getModel().getParent(this.state.cell));
  if (null != p) {
    target.x -= p.origin.x;
    target.y -= p.origin.y;
  }
  return target;
};
/**
 * @param {!Object} event
 * @param {number} start
 * @param {number} end
 * @return {undefined}
 */
mxEdgeHandler.prototype.moveLabel = function(event, start, end) {
  var me = this.graph.getModel();
  var value = me.getGeometry(event.cell);
  if (null != value) {
    var bppp = this.graph.getView().scale;
    value = value.clone();
    if (value.relative) {
      var v = this.graph.getView().getRelativePoint(event, start, end);
      /** @type {number} */
      value.x = Math.round(1E4 * v.x) / 1E4;
      /** @type {number} */
      value.y = Math.round(v.y);
      value.offset = new mxPoint(0, 0);
      v = this.graph.view.getPoint(event, value);
      value.offset = new mxPoint(Math.round((start - v.x) / bppp), Math.round((end - v.y) / bppp));
    } else {
      var p = event.absolutePoints;
      v = p[0];
      p = p[p.length - 1];
      if (null != v && null != p) {
        value.offset = new mxPoint(Math.round((start - (v.x + (p.x - v.x) / 2)) / bppp), Math.round((end - (v.y + (p.y - v.y) / 2)) / bppp));
        /** @type {number} */
        value.x = 0;
        /** @type {number} */
        value.y = 0;
      }
    }
    me.setGeometry(event.cell, value);
  }
};
/**
 * @param {string} node
 * @param {boolean} value
 * @param {string} source
 * @param {?} s
 * @param {!Object} width
 * @return {?}
 */
mxEdgeHandler.prototype.connect = function(node, value, source, s, width) {
  s = this.graph.getModel();
  s.getParent(node);
  s.beginUpdate();
  try {
    var dashes = this.constraintHandler.currentConstraint;
    if (null == dashes) {
      dashes = new mxConnectionConstraint;
    }
    this.graph.connectCell(node, value, source, dashes);
  } finally {
    s.endUpdate();
  }
  return node;
};
/**
 * @param {string} id
 * @param {string} width
 * @param {boolean} color
 * @param {?} img
 * @return {?}
 */
mxEdgeHandler.prototype.changeTerminalPoint = function(id, width, color, img) {
  var self = this.graph.getModel();
  self.beginUpdate();
  try {
    if (img) {
      var node = self.getParent(id);
      var term = self.getTerminal(id, !color);
      id = this.graph.cloneCell(id);
      self.add(node, id, self.getChildCount(node));
      self.setTerminal(id, term, !color);
    }
    var res = self.getGeometry(id);
    if (null != res) {
      res = res.clone();
      res.setTerminalPoint(width, color);
      self.setGeometry(id, res);
      this.graph.connectCell(id, null, color, new mxConnectionConstraint);
    }
  } finally {
    self.endUpdate();
  }
  return id;
};
/**
 * @param {string} id
 * @param {?} points
 * @param {?} reg
 * @return {?}
 */
mxEdgeHandler.prototype.changePoints = function(id, points, reg) {
  var self = this.graph.getModel();
  self.beginUpdate();
  try {
    if (reg) {
      var node = self.getParent(id);
      var term = self.getTerminal(id, true);
      var g = self.getTerminal(id, false);
      id = this.graph.cloneCell(id);
      self.add(node, id, self.getChildCount(node));
      self.setTerminal(id, term, true);
      self.setTerminal(id, g, false);
    }
    var p = self.getGeometry(id);
    if (null != p) {
      p = p.clone();
      p.points = points;
      self.setGeometry(id, p);
    }
  } finally {
    self.endUpdate();
  }
  return id;
};
/**
 * @param {?} y
 * @param {undefined} evt
 * @return {undefined}
 */
mxEdgeHandler.prototype.addPoint = function(y, evt) {
  var c = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
  var ret = this.graph.isGridEnabledEvent(evt);
  this.convertPoint(c, ret);
  this.addPointAt(y, c.x, c.y);
  mxEvent.consume(evt);
};
/**
 * @param {?} data
 * @param {number} x
 * @param {number} s
 * @return {undefined}
 */
mxEdgeHandler.prototype.addPointAt = function(data, x, s) {
  var model = this.graph.getCellGeometry(data.cell);
  x = new mxPoint(x, s);
  if (null != model) {
    model = model.clone();
    var p = this.graph.view.translate;
    s = this.graph.view.scale;
    p = new mxPoint(p.x * s, p.y * s);
    var element = this.graph.model.getParent(this.state.cell);
    if (this.graph.model.isVertex(element)) {
      p = this.graph.view.getState(element);
      p = new mxPoint(p.x, p.y);
    }
    s = mxUtils.findNearestSegment(data, x.x * s + p.x, x.y * s + p.y);
    if (null == model.points) {
      /** @type {!Array} */
      model.points = [x];
    } else {
      model.points.splice(s, 0, x);
    }
    this.graph.getModel().setGeometry(data.cell, model);
    this.refresh();
    this.redraw();
  }
};
/**
 * @param {?} e
 * @param {number} index
 * @return {undefined}
 */
mxEdgeHandler.prototype.removePoint = function(e, index) {
  if (0 < index && index < this.abspoints.length - 1) {
    var geo = this.graph.getCellGeometry(this.state.cell);
    if (null != geo && null != geo.points) {
      geo = geo.clone();
      geo.points.splice(index - 1, 1);
      this.graph.getModel().setGeometry(e.cell, geo);
      this.refresh();
      this.redraw();
    }
  }
};
/**
 * @param {number} value
 * @return {?}
 */
mxEdgeHandler.prototype.getHandleFillColor = function(value) {
  /** @type {boolean} */
  value = 0 == value;
  var cell = this.state.cell;
  var index = this.graph.getModel().getTerminal(cell, value);
  var a4 = mxConstants.HANDLE_FILLCOLOR;
  if (null != index && !this.graph.isCellDisconnectable(cell, index, value) || null == index && !this.graph.isTerminalPointMovable(cell, value)) {
    a4 = mxConstants.LOCKED_HANDLE_FILLCOLOR;
  } else {
    if (null != index && this.graph.isCellDisconnectable(cell, index, value)) {
      a4 = mxConstants.CONNECT_HANDLE_FILLCOLOR;
    }
  }
  return a4;
};
/**
 * @param {!Function} elem
 * @return {undefined}
 */
mxEdgeHandler.prototype.redraw = function(elem) {
  if (null != this.state) {
    this.abspoints = this.state.absolutePoints.slice();
    var p = this.graph.getModel().getGeometry(this.state.cell);
    if (null != p && (p = p.points, null != this.bends && 0 < this.bends.length && null != p)) {
      if (null == this.points) {
        /** @type {!Array} */
        this.points = [];
      }
      /** @type {number} */
      var i = 1;
      for (; i < this.bends.length - 1; i++) {
        if (null != this.bends[i] && null != this.abspoints[i]) {
          this.points[i - 1] = p[i - 1];
        }
      }
    }
    this.drawPreview();
    if (!elem) {
      this.redrawHandles();
    }
  }
};
/**
 * @return {undefined}
 */
mxEdgeHandler.prototype.redrawHandles = function() {
  var i = this.state.cell;
  var s = this.labelShape.bounds;
  this.label = new mxPoint(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
  this.labelShape.bounds = new mxRectangle(Math.round(this.label.x - s.width / 2), Math.round(this.label.y - s.height / 2), s.width, s.height);
  s = this.graph.getLabel(i);
  this.labelShape.visible = null != s && 0 < s.length && this.graph.isCellEditable(this.state.cell) && this.graph.isLabelMovable(i);
  if (null != this.bends && 0 < this.bends.length) {
    /** @type {number} */
    var c = this.abspoints.length - 1;
    i = this.abspoints[0];
    var p = i.x;
    var j = i.y;
    s = this.bends[0].bounds;
    this.bends[0].bounds = new mxRectangle(Math.floor(p - s.width / 2), Math.floor(j - s.height / 2), s.width, s.height);
    this.bends[0].fill = this.getHandleFillColor(0);
    this.bends[0].redraw();
    if (this.manageLabelHandle) {
      this.checkLabelHandle(this.bends[0].bounds);
    }
    c = this.abspoints[c];
    p = c.x;
    j = c.y;
    /** @type {number} */
    var key = this.bends.length - 1;
    s = this.bends[key].bounds;
    this.bends[key].bounds = new mxRectangle(Math.floor(p - s.width / 2), Math.floor(j - s.height / 2), s.width, s.height);
    this.bends[key].fill = this.getHandleFillColor(key);
    this.bends[key].redraw();
    if (this.manageLabelHandle) {
      this.checkLabelHandle(this.bends[key].bounds);
    }
    this.redrawInnerBends(i, c);
  }
  if (null != this.abspoints && null != this.virtualBends && 0 < this.virtualBends.length) {
    c = this.abspoints[0];
    /** @type {number} */
    i = 0;
    for (; i < this.virtualBends.length; i++) {
      if (null != this.virtualBends[i] && null != this.abspoints[i + 1]) {
        p = this.abspoints[i + 1];
        s = this.virtualBends[i];
        s.bounds = new mxRectangle(Math.floor(c.x + (p.x - c.x) / 2 - s.bounds.width / 2), Math.floor(c.y + (p.y - c.y) / 2 - s.bounds.height / 2), s.bounds.width, s.bounds.height);
        s.redraw();
        mxUtils.setOpacity(s.node, this.virtualBendOpacity);
        c = p;
        if (this.manageLabelHandle) {
          this.checkLabelHandle(s.bounds);
        }
      }
    }
  }
  if (null != this.labelShape) {
    this.labelShape.redraw();
  }
  if (null != this.customHandles) {
    /** @type {number} */
    i = 0;
    for (; i < this.customHandles.length; i++) {
      s = this.customHandles[i].shape.node.style.display;
      this.customHandles[i].redraw();
      this.customHandles[i].shape.node.style.display = s;
      /** @type {string} */
      this.customHandles[i].shape.node.style.visibility = this.isCustomHandleVisible(this.customHandles[i]) ? "" : "hidden";
    }
  }
};
/**
 * @param {?} a
 * @return {?}
 */
mxEdgeHandler.prototype.isCustomHandleVisible = function(a) {
  return !this.graph.isEditing() && 1 == this.state.view.graph.getSelectionCount();
};
/**
 * @param {boolean} value
 * @return {undefined}
 */
mxEdgeHandler.prototype.setHandlesVisible = function(value) {
  if (null != this.bends) {
    /** @type {number} */
    var i = 0;
    for (; i < this.bends.length; i++) {
      /** @type {string} */
      this.bends[i].node.style.display = value ? "" : "none";
    }
  }
  if (null != this.virtualBends) {
    /** @type {number} */
    i = 0;
    for (; i < this.virtualBends.length; i++) {
      /** @type {string} */
      this.virtualBends[i].node.style.display = value ? "" : "none";
    }
  }
  if (null != this.labelShape) {
    /** @type {string} */
    this.labelShape.node.style.display = value ? "" : "none";
  }
  if (null != this.customHandles) {
    /** @type {number} */
    i = 0;
    for (; i < this.customHandles.length; i++) {
      this.customHandles[i].setVisible(value);
    }
  }
};
/**
 * @param {number} i
 * @param {number} x
 * @return {undefined}
 */
mxEdgeHandler.prototype.redrawInnerBends = function(i, x) {
  /** @type {number} */
  i = 1;
  for (; i < this.bends.length - 1; i++) {
    if (null != this.bends[i]) {
      if (null != this.abspoints[i]) {
        x = this.abspoints[i].x;
        var y = this.abspoints[i].y;
        var table = this.bends[i].bounds;
        /** @type {string} */
        this.bends[i].node.style.visibility = "visible";
        this.bends[i].bounds = new mxRectangle(Math.round(x - table.width / 2), Math.round(y - table.height / 2), table.width, table.height);
        if (this.manageLabelHandle) {
          this.checkLabelHandle(this.bends[i].bounds);
        } else {
          if (null == this.handleImage && this.labelShape.visible && mxUtils.intersects(this.bends[i].bounds, this.labelShape.bounds)) {
            w = mxConstants.HANDLE_SIZE + 3;
            h = mxConstants.HANDLE_SIZE + 3;
            this.bends[i].bounds = new mxRectangle(Math.round(x - w / 2), Math.round(y - h / 2), w, h);
          }
        }
        this.bends[i].redraw();
      } else {
        this.bends[i].destroy();
        /** @type {null} */
        this.bends[i] = null;
      }
    }
  }
};
/**
 * @param {!Object} o
 * @return {undefined}
 */
mxEdgeHandler.prototype.checkLabelHandle = function(o) {
  if (null != this.labelShape) {
    var point = this.labelShape.bounds;
    if (mxUtils.intersects(o, point)) {
      if (o.getCenterY() < point.getCenterY()) {
        point.y = o.y + o.height;
      } else {
        /** @type {number} */
        point.y = o.y - point.height;
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxEdgeHandler.prototype.drawPreview = function() {
  try {
    if (this.isLabel) {
      var table = this.labelShape.bounds;
      var size = new mxRectangle(Math.round(this.label.x - table.width / 2), Math.round(this.label.y - table.height / 2), table.width, table.height);
      if (!this.labelShape.bounds.equals(size)) {
        this.labelShape.bounds = size;
        this.labelShape.redraw();
      }
    }
    if (!(null == this.shape || mxUtils.equalPoints(this.shape.points, this.abspoints))) {
      this.shape.apply(this.state);
      this.shape.points = this.abspoints.slice();
      this.shape.scale = this.state.view.scale;
      this.shape.isDashed = this.isSelectionDashed();
      this.shape.stroke = this.getSelectionColor();
      /** @type {number} */
      this.shape.strokewidth = this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;
      /** @type {boolean} */
      this.shape.isShadow = false;
      this.shape.redraw();
    }
    this.updateParentHighlight();
  } catch (c) {
  }
};
/**
 * @return {undefined}
 */
mxEdgeHandler.prototype.refresh = function() {
  if (null != this.state) {
    this.abspoints = this.getSelectionPoints(this.state);
    /** @type {!Array} */
    this.points = [];
    if (null != this.bends) {
      this.destroyBends(this.bends);
      this.bends = this.createBends();
    }
    if (null != this.virtualBends) {
      this.destroyBends(this.virtualBends);
      this.virtualBends = this.createVirtualBends();
    }
    if (null != this.customHandles) {
      this.destroyBends(this.customHandles);
      this.customHandles = this.createCustomHandles();
    }
    if (null != this.labelShape && null != this.labelShape.node && null != this.labelShape.node.parentNode) {
      this.labelShape.node.parentNode.appendChild(this.labelShape.node);
    }
  }
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.isDestroyed = function() {
  return null == this.shape;
};
/**
 * @param {!Object} birds
 * @return {undefined}
 */
mxEdgeHandler.prototype.destroyBends = function(birds) {
  if (null != birds) {
    /** @type {number} */
    var i = 0;
    for (; i < birds.length; i++) {
      if (null != birds[i]) {
        birds[i].destroy();
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxEdgeHandler.prototype.destroy = function() {
  if (null != this.escapeHandler) {
    this.state.view.graph.removeListener(this.escapeHandler);
    /** @type {null} */
    this.escapeHandler = null;
  }
  if (null != this.marker) {
    this.marker.destroy();
    /** @type {null} */
    this.marker = null;
  }
  if (null != this.shape) {
    this.shape.destroy();
    /** @type {null} */
    this.shape = null;
  }
  if (null != this.labelShape) {
    this.labelShape.destroy();
    /** @type {null} */
    this.labelShape = null;
  }
  if (null != this.constraintHandler) {
    this.constraintHandler.destroy();
    /** @type {null} */
    this.constraintHandler = null;
  }
  if (null != this.parentHighlight) {
    this.destroyParentHighlight();
  }
  this.destroyBends(this.virtualBends);
  /** @type {null} */
  this.virtualBends = null;
  this.destroyBends(this.customHandles);
  /** @type {null} */
  this.customHandles = null;
  this.destroyBends(this.bends);
  /** @type {null} */
  this.bends = null;
  this.removeHint();
};
/**
 * @param {?} p1__3354_SHARP_
 * @return {undefined}
 */
function mxElbowEdgeHandler(p1__3354_SHARP_) {
  mxEdgeHandler.call(this, p1__3354_SHARP_);
}
mxUtils.extend(mxElbowEdgeHandler, mxEdgeHandler);
/** @type {boolean} */
mxElbowEdgeHandler.prototype.flipEnabled = true;
/** @type {string} */
mxElbowEdgeHandler.prototype.doubleClickOrientationResource = "none" != mxClient.language ? "doubleClickOrientation" : "";
/**
 * @return {?}
 */
mxElbowEdgeHandler.prototype.createBends = function() {
  /** @type {!Array} */
  var connection_mutator = [];
  var cm = this.createHandleShape(0);
  this.initBend(cm);
  cm.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
  connection_mutator.push(cm);
  connection_mutator.push(this.createVirtualBend(mxUtils.bind(this, function(evt) {
    if (!mxEvent.isConsumed(evt) && this.flipEnabled) {
      this.graph.flipEdge(this.state.cell, evt);
      mxEvent.consume(evt);
    }
  })));
  this.points.push(new mxPoint(0, 0));
  cm = this.createHandleShape(2, null, true);
  this.initBend(cm);
  cm.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
  connection_mutator.push(cm);
  return connection_mutator;
};
/**
 * @param {?} a
 * @return {?}
 */
mxElbowEdgeHandler.prototype.createVirtualBend = function(a) {
  var self = this.createHandleShape();
  this.initBend(self, a);
  self.setCursor(this.getCursorForBend());
  if (!this.graph.isCellBendable(this.state.cell)) {
    /** @type {string} */
    self.node.style.display = "none";
  }
  return self;
};
/**
 * @return {?}
 */
mxElbowEdgeHandler.prototype.getCursorForBend = function() {
  return this.state.style[mxConstants.STYLE_EDGE] == mxEdgeStyle.TopToBottom || this.state.style[mxConstants.STYLE_EDGE] == mxConstants.EDGESTYLE_TOPTOBOTTOM || (this.state.style[mxConstants.STYLE_EDGE] == mxEdgeStyle.ElbowConnector || this.state.style[mxConstants.STYLE_EDGE] == mxConstants.EDGESTYLE_ELBOW) && this.state.style[mxConstants.STYLE_ELBOW] == mxConstants.ELBOW_VERTICAL ? "row-resize" : "col-resize";
};
/**
 * @param {string} targetNode
 * @return {?}
 */
mxElbowEdgeHandler.prototype.getTooltipForNode = function(targetNode) {
  /** @type {null} */
  var name = null;
  if (!(null == this.bends || null == this.bends[1] || targetNode != this.bends[1].node && targetNode.parentNode != this.bends[1].node)) {
    name = this.doubleClickOrientationResource;
    name = mxResources.get(name) || name;
  }
  return name;
};
/**
 * @param {!Object} data
 * @param {string} p
 * @return {?}
 */
mxElbowEdgeHandler.prototype.convertPoint = function(data, p) {
  var scale = this.graph.getView().getScale();
  var geo = this.graph.getView().getTranslate();
  var position = this.state.origin;
  if (p) {
    data.x = this.graph.snap(data.x);
    data.y = this.graph.snap(data.y);
  }
  /** @type {number} */
  data.x = Math.round(data.x / scale - geo.x - position.x);
  /** @type {number} */
  data.y = Math.round(data.y / scale - geo.y - position.y);
  return data;
};
/**
 * @param {!Object} r
 * @param {number} w
 * @return {undefined}
 */
mxElbowEdgeHandler.prototype.redrawInnerBends = function(r, w) {
  var bend = this.graph.getModel().getGeometry(this.state.cell);
  var s = this.state.absolutePoints;
  /** @type {null} */
  var p = null;
  if (1 < s.length) {
    r = s[1];
    w = s[s.length - 2];
  } else {
    if (null != bend.points && 0 < bend.points.length) {
      p = s[0];
    }
  }
  p = null == p ? new mxPoint(r.x + (w.x - r.x) / 2, r.y + (w.y - r.y) / 2) : new mxPoint(this.graph.getView().scale * (p.x + this.graph.getView().translate.x + this.state.origin.x), this.graph.getView().scale * (p.y + this.graph.getView().translate.y + this.state.origin.y));
  w = this.bends[1].bounds;
  r = w.width;
  w = w.height;
  r = new mxRectangle(Math.round(p.x - r / 2), Math.round(p.y - w / 2), r, w);
  if (this.manageLabelHandle) {
    this.checkLabelHandle(r);
  } else {
    if (null == this.handleImage && this.labelShape.visible && mxUtils.intersects(r, this.labelShape.bounds)) {
      r = mxConstants.HANDLE_SIZE + 3;
      w = mxConstants.HANDLE_SIZE + 3;
      r = new mxRectangle(Math.floor(p.x - r / 2), Math.floor(p.y - w / 2), r, w);
    }
  }
  /** @type {!Object} */
  this.bends[1].bounds = r;
  this.bends[1].redraw();
  if (this.manageLabelHandle) {
    this.checkLabelHandle(this.bends[1].bounds);
  }
};
/**
 * @param {?} p1__3354_SHARP_
 * @return {undefined}
 */
function mxEdgeSegmentHandler(p1__3354_SHARP_) {
  mxEdgeHandler.call(this, p1__3354_SHARP_);
}
mxUtils.extend(mxEdgeSegmentHandler, mxElbowEdgeHandler);
/**
 * @return {?}
 */
mxEdgeSegmentHandler.prototype.getCurrentPoints = function() {
  var segPoints = this.state.absolutePoints;
  if (null != segPoints) {
    /** @type {number} */
    var right = Math.max(1, this.graph.view.scale);
    if (2 == segPoints.length || 3 == segPoints.length && (Math.abs(segPoints[0].x - segPoints[1].x) < right && Math.abs(segPoints[1].x - segPoints[2].x) < right || Math.abs(segPoints[0].y - segPoints[1].y) < right && Math.abs(segPoints[1].y - segPoints[2].y) < right)) {
      right = segPoints[0].x + (segPoints[segPoints.length - 1].x - segPoints[0].x) / 2;
      var bottom = segPoints[0].y + (segPoints[segPoints.length - 1].y - segPoints[0].y) / 2;
      /** @type {!Array} */
      segPoints = [segPoints[0], new mxPoint(right, bottom), new mxPoint(right, bottom), segPoints[segPoints.length - 1]];
    }
  }
  return segPoints;
};
/**
 * @param {!Object} a
 * @return {?}
 */
mxEdgeSegmentHandler.prototype.getPreviewPoints = function(a) {
  if (this.isSource || this.isTarget) {
    return mxElbowEdgeHandler.prototype.getPreviewPoints.apply(this, arguments);
  }
  var value = this.getCurrentPoints();
  var node = this.convertPoint(value[0].clone(), false);
  a = this.convertPoint(a.clone(), false);
  /** @type {!Array} */
  var values = [];
  /** @type {number} */
  var i = 1;
  for (; i < value.length; i++) {
    var p = this.convertPoint(value[i].clone(), false);
    if (i == this.index) {
      if (0 == Math.round(node.x - p.x)) {
        node.x = a.x;
        p.x = a.x;
      }
      if (0 == Math.round(node.y - p.y)) {
        node.y = a.y;
        p.y = a.y;
      }
    }
    if (i < value.length - 1) {
      values.push(p);
    }
    node = p;
  }
  if (1 == values.length) {
    value = this.state.getVisibleTerminalState(true);
    node = this.state.getVisibleTerminalState(false);
    p = this.state.view.getScale();
    var currPaperPosition = this.state.view.getTranslate();
    i = values[0].x * p + currPaperPosition.x;
    p = values[0].y * p + currPaperPosition.y;
    if (null != value && mxUtils.contains(value, i, p) || null != node && mxUtils.contains(node, i, p)) {
      /** @type {!Array} */
      values = [a, a];
    }
  }
  return values;
};
/**
 * @param {!Object} name
 * @param {!Object} a
 * @param {!Object} obj
 * @param {!Object} proplist
 * @return {undefined}
 */
mxEdgeSegmentHandler.prototype.updatePreviewState = function(name, a, obj, proplist) {
  mxEdgeHandler.prototype.updatePreviewState.apply(this, arguments);
  if (!this.isSource && !this.isTarget) {
    a = this.convertPoint(a.clone(), false);
    var ref = name.absolutePoints;
    var value = ref[0];
    var target = ref[1];
    /** @type {!Array} */
    var points = [];
    /** @type {number} */
    var i = 2;
    for (; i < ref.length; i++) {
      var object = ref[i];
      if (!(0 == Math.round(value.x - target.x) && 0 == Math.round(target.x - object.x) || 0 == Math.round(value.y - target.y) && 0 == Math.round(target.y - object.y))) {
        points.push(this.convertPoint(target.clone(), false));
      }
      value = target;
      target = object;
    }
    value = this.state.getVisibleTerminalState(true);
    target = this.state.getVisibleTerminalState(false);
    i = this.state.absolutePoints;
    if (0 == points.length && (0 == Math.round(ref[0].x - ref[ref.length - 1].x) || 0 == Math.round(ref[0].y - ref[ref.length - 1].y))) {
      /** @type {!Array} */
      points = [a, a];
    } else {
      if (5 == ref.length && 2 == points.length && null != value && null != target && null != i && 0 == Math.round(i[0].x - i[i.length - 1].x)) {
        points = this.graph.getView();
        i = points.getScale();
        object = points.getTranslate();
        /** @type {number} */
        ref = points.getRoutingCenterY(value) / i - object.y;
        var args = this.graph.getConnectionConstraint(name, value, true);
        if (null != args) {
          args = this.graph.getConnectionPoint(value, args);
          if (null != args) {
            this.convertPoint(args, false);
            ref = args.y;
          }
        }
        /** @type {number} */
        points = points.getRoutingCenterY(target) / i - object.y;
        if (i = this.graph.getConnectionConstraint(name, target, false)) {
          args = this.graph.getConnectionPoint(target, i);
          if (null != args) {
            this.convertPoint(args, false);
            points = args.y;
          }
        }
        /** @type {!Array} */
        points = [new mxPoint(a.x, ref), new mxPoint(a.x, points)];
      }
    }
    /** @type {!Array} */
    this.points = points;
    name.view.updateFixedTerminalPoints(name, value, target);
    name.view.updatePoints(name, this.points, value, target);
    name.view.updateFloatingTerminalPoints(name, value, target);
  }
};
/**
 * @param {!Object} p
 * @param {?} t
 * @param {?} n
 * @param {?} s
 * @param {!Object} width
 * @return {?}
 */
mxEdgeSegmentHandler.prototype.connect = function(p, t, n, s, width) {
  var me = this.graph.getModel();
  var g = me.getGeometry(p);
  /** @type {null} */
  var prev = null;
  if (null != g && null != g.points && 0 < g.points.length) {
    var participants = this.abspoints;
    var p = participants[0];
    var p0 = participants[1];
    /** @type {!Array} */
    prev = [];
    /** @type {number} */
    var i = 2;
    for (; i < participants.length; i++) {
      var p1 = participants[i];
      if (!(0 == Math.round(p.x - p0.x) && 0 == Math.round(p0.x - p1.x) || 0 == Math.round(p.y - p0.y) && 0 == Math.round(p0.y - p1.y))) {
        prev.push(this.convertPoint(p0.clone(), false));
      }
      p = p0;
      p0 = p1;
    }
  }
  me.beginUpdate();
  try {
    if (null != prev) {
      g = me.getGeometry(p);
      if (null != g) {
        g = g.clone();
        /** @type {!Array} */
        g.points = prev;
        me.setGeometry(p, g);
      }
    }
    p = mxEdgeHandler.prototype.connect.apply(this, arguments);
  } finally {
    me.endUpdate();
  }
  return p;
};
/**
 * @param {string} topnode
 * @return {?}
 */
mxEdgeSegmentHandler.prototype.getTooltipForNode = function(topnode) {
  return null;
};
/**
 * @param {!Object} obj
 * @param {?} fn
 * @param {number} key
 * @return {undefined}
 */
mxEdgeSegmentHandler.prototype.start = function(obj, fn, key) {
  mxEdgeHandler.prototype.start.apply(this, arguments);
  if (!(null == this.bends || null == this.bends[key] || this.isSource || this.isTarget)) {
    mxUtils.setOpacity(this.bends[key].node, 100);
  }
};
/**
 * @return {?}
 */
mxEdgeSegmentHandler.prototype.createBends = function() {
  /** @type {!Array} */
  var a = [];
  var self = this.createHandleShape(0);
  this.initBend(self);
  self.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
  a.push(self);
  var pointsByColumns = this.getCurrentPoints();
  if (this.graph.isCellBendable(this.state.cell)) {
    if (null == this.points) {
      /** @type {!Array} */
      this.points = [];
    }
    /** @type {number} */
    var i = 0;
    for (; i < pointsByColumns.length - 1; i++) {
      self = this.createVirtualBend();
      a.push(self);
      /** @type {boolean} */
      var vertical = 0 == Math.round(pointsByColumns[i].x - pointsByColumns[i + 1].x);
      if (0 == Math.round(pointsByColumns[i].y - pointsByColumns[i + 1].y) && i < pointsByColumns.length - 2) {
        /** @type {boolean} */
        vertical = 0 == Math.round(pointsByColumns[i].x - pointsByColumns[i + 2].x);
      }
      self.setCursor(vertical ? "col-resize" : "row-resize");
      this.points.push(new mxPoint(0, 0));
    }
  }
  self = this.createHandleShape(pointsByColumns.length, null, true);
  this.initBend(self);
  self.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
  a.push(self);
  return a;
};
/**
 * @return {undefined}
 */
mxEdgeSegmentHandler.prototype.redraw = function() {
  this.refresh();
  mxEdgeHandler.prototype.redraw.apply(this, arguments);
};
/**
 * @param {number} a
 * @param {!Object} b
 * @return {undefined}
 */
mxEdgeSegmentHandler.prototype.redrawInnerBends = function(a, b) {
  if (this.graph.isCellBendable(this.state.cell)) {
    var points = this.getCurrentPoints();
    if (null != points && 1 < points.length) {
      /** @type {boolean} */
      var d = false;
      if (4 == points.length && 0 == Math.round(points[1].x - points[2].x) && 0 == Math.round(points[1].y - points[2].y)) {
        if (d = true, 0 == Math.round(points[0].y - points[points.length - 1].y)) {
          var x = points[0].x + (points[points.length - 1].x - points[0].x) / 2;
          points[1] = new mxPoint(x, points[1].y);
          points[2] = new mxPoint(x, points[2].y);
        } else {
          x = points[0].y + (points[points.length - 1].y - points[0].y) / 2;
          points[1] = new mxPoint(points[1].x, x);
          points[2] = new mxPoint(points[2].x, x);
        }
      }
      /** @type {number} */
      x = 0;
      for (; x < points.length - 1; x++) {
        if (null != this.bends[x + 1]) {
          a = points[x];
          b = points[x + 1];
          a = new mxPoint(a.x + (b.x - a.x) / 2, a.y + (b.y - a.y) / 2);
          b = this.bends[x + 1].bounds;
          this.bends[x + 1].bounds = new mxRectangle(Math.floor(a.x - b.width / 2), Math.floor(a.y - b.height / 2), b.width, b.height);
          this.bends[x + 1].redraw();
          if (this.manageLabelHandle) {
            this.checkLabelHandle(this.bends[x + 1].bounds);
          }
        }
      }
      if (d) {
        mxUtils.setOpacity(this.bends[1].node, this.virtualBendOpacity);
        mxUtils.setOpacity(this.bends[3].node, this.virtualBendOpacity);
      }
    }
  }
};
/**
 * @param {!Object} gf
 * @param {!Object} target
 * @return {undefined}
 */
function mxKeyHandler(gf, target) {
  if (null != gf) {
    /** @type {!Object} */
    this.graph = gf;
    this.target = target || document.documentElement;
    /** @type {!Array} */
    this.normalKeys = [];
    /** @type {!Array} */
    this.shiftKeys = [];
    /** @type {!Array} */
    this.controlKeys = [];
    /** @type {!Array} */
    this.controlShiftKeys = [];
    this.keydownHandler = mxUtils.bind(this, function(e) {
      this.keyDown(e);
    });
    mxEvent.addListener(this.target, "keydown", this.keydownHandler);
    if (mxClient.IS_IE) {
      mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
        this.destroy();
      }));
    }
  }
}
/** @type {null} */
mxKeyHandler.prototype.graph = null;
/** @type {null} */
mxKeyHandler.prototype.target = null;
/** @type {null} */
mxKeyHandler.prototype.normalKeys = null;
/** @type {null} */
mxKeyHandler.prototype.shiftKeys = null;
/** @type {null} */
mxKeyHandler.prototype.controlKeys = null;
/** @type {null} */
mxKeyHandler.prototype.controlShiftKeys = null;
/** @type {boolean} */
mxKeyHandler.prototype.enabled = true;
/**
 * @return {?}
 */
mxKeyHandler.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {boolean} state
 * @return {undefined}
 */
mxKeyHandler.prototype.setEnabled = function(state) {
  /** @type {boolean} */
  this.enabled = state;
};
/**
 * @param {?} keyCode
 * @param {?} action
 * @return {undefined}
 */
mxKeyHandler.prototype.bindKey = function(keyCode, action) {
  this.normalKeys[keyCode] = action;
};
/**
 * @param {?} url
 * @param {?} eTag
 * @return {undefined}
 */
mxKeyHandler.prototype.bindShiftKey = function(url, eTag) {
  this.shiftKeys[url] = eTag;
};
/**
 * @param {?} url
 * @param {?} eTag
 * @return {undefined}
 */
mxKeyHandler.prototype.bindControlKey = function(url, eTag) {
  this.controlKeys[url] = eTag;
};
/**
 * @param {?} url
 * @param {?} eTag
 * @return {undefined}
 */
mxKeyHandler.prototype.bindControlShiftKey = function(url, eTag) {
  this.controlShiftKeys[url] = eTag;
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxKeyHandler.prototype.isControlDown = function(evt) {
  return mxEvent.isControlDown(evt);
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxKeyHandler.prototype.getFunction = function(evt) {
  return null == evt || mxEvent.isAltDown(evt) ? null : this.isControlDown(evt) ? mxEvent.isShiftDown(evt) ? this.controlShiftKeys[evt.keyCode] : this.controlKeys[evt.keyCode] : mxEvent.isShiftDown(evt) ? this.shiftKeys[evt.keyCode] : this.normalKeys[evt.keyCode];
};
/**
 * @param {string} e
 * @return {?}
 */
mxKeyHandler.prototype.isGraphEvent = function(e) {
  var target = mxEvent.getSource(e);
  return target == this.target || target.parentNode == this.target || null != this.graph.cellEditor && this.graph.cellEditor.isEventSource(e) ? true : mxUtils.isAncestorNode(this.graph.container, target);
};
/**
 * @param {!Object} e
 * @return {undefined}
 */
mxKeyHandler.prototype.keyDown = function(e) {
  if (this.isEnabledForEvent(e)) {
    if (27 == e.keyCode) {
      this.escape(e);
    } else {
      if (!this.isEventIgnored(e)) {
        var func = this.getFunction(e);
        if (null != func) {
          func(e);
          mxEvent.consume(e);
        }
      }
    }
  }
};
/**
 * @param {boolean} evt
 * @return {?}
 */
mxKeyHandler.prototype.isEnabledForEvent = function(evt) {
  return this.graph.isEnabled() && !mxEvent.isConsumed(evt) && this.isGraphEvent(evt) && this.isEnabled();
};
/**
 * @param {!Function} propertyName
 * @return {?}
 */
mxKeyHandler.prototype.isEventIgnored = function(propertyName) {
  return this.graph.isEditing();
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxKeyHandler.prototype.escape = function(value) {
  if (this.graph.isEscapeEnabled()) {
    this.graph.escape(value);
  }
};
/**
 * @return {undefined}
 */
mxKeyHandler.prototype.destroy = function() {
  if (null != this.target && null != this.keydownHandler) {
    mxEvent.removeListener(this.target, "keydown", this.keydownHandler);
    /** @type {null} */
    this.keydownHandler = null;
  }
  /** @type {null} */
  this.target = null;
};
/**
 * @param {!Object} src
 * @param {number} delay
 * @return {undefined}
 */
function mxTooltipHandler(src, delay) {
  if (null != src) {
    /** @type {!Object} */
    this.graph = src;
    this.delay = delay || 500;
    this.graph.addMouseListener(this);
  }
}
/** @type {number} */
mxTooltipHandler.prototype.zIndex = 10005;
/** @type {null} */
mxTooltipHandler.prototype.graph = null;
/** @type {null} */
mxTooltipHandler.prototype.delay = null;
/** @type {boolean} */
mxTooltipHandler.prototype.ignoreTouchEvents = true;
/** @type {boolean} */
mxTooltipHandler.prototype.hideOnHover = false;
/** @type {boolean} */
mxTooltipHandler.prototype.destroyed = false;
/** @type {boolean} */
mxTooltipHandler.prototype.enabled = true;
/**
 * @return {?}
 */
mxTooltipHandler.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {boolean} state
 * @return {undefined}
 */
mxTooltipHandler.prototype.setEnabled = function(state) {
  /** @type {boolean} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxTooltipHandler.prototype.isHideOnHover = function() {
  return this.hideOnHover;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxTooltipHandler.prototype.setHideOnHover = function(a) {
  /** @type {boolean} */
  this.hideOnHover = a;
};
/**
 * @return {undefined}
 */
mxTooltipHandler.prototype.init = function() {
  if (null != document.body) {
    /** @type {!Element} */
    this.div = document.createElement("div");
    /** @type {string} */
    this.div.className = "mxTooltip";
    /** @type {string} */
    this.div.style.visibility = "hidden";
    document.body.appendChild(this.div);
    mxEvent.addGestureListeners(this.div, mxUtils.bind(this, function(node) {
      if ("A" != mxEvent.getSource(node).nodeName) {
        this.hideTooltip();
      }
    }));
  }
};
/**
 * @param {!Object} source
 * @return {?}
 */
mxTooltipHandler.prototype.getStateForEvent = function(source) {
  return source.getState();
};
/**
 * @param {!Object} e
 * @param {!Object} element
 * @return {undefined}
 */
mxTooltipHandler.prototype.mouseDown = function(e, element) {
  this.reset(element, false);
  this.hideTooltip();
};
/**
 * @param {!Object} args
 * @param {!Object} me
 * @return {undefined}
 */
mxTooltipHandler.prototype.mouseMove = function(args, me) {
  if (me.getX() != this.lastX || me.getY() != this.lastY) {
    this.reset(me, true);
    args = this.getStateForEvent(me);
    if (this.isHideOnHover() || args != this.state || me.getSource() != this.node && (!this.stateSource || null != args && this.stateSource == (me.isSource(args.shape) || !me.isSource(args.text)))) {
      this.hideTooltip();
    }
  }
  this.lastX = me.getX();
  this.lastY = me.getY();
};
/**
 * @param {?} editor
 * @param {!Object} e
 * @return {undefined}
 */
mxTooltipHandler.prototype.mouseUp = function(editor, e) {
  this.reset(e, true);
  this.hideTooltip();
};
/**
 * @return {undefined}
 */
mxTooltipHandler.prototype.resetTimer = function() {
  if (null != this.thread) {
    window.clearTimeout(this.thread);
    /** @type {null} */
    this.thread = null;
  }
};
/**
 * @param {!Object} t
 * @param {string} url
 * @param {!Object} data
 * @return {undefined}
 */
mxTooltipHandler.prototype.reset = function(t, url, data) {
  if (!this.ignoreTouchEvents || mxEvent.isMouseEvent(t.getEvent())) {
    if (this.resetTimer(), data = null != data ? data : this.getStateForEvent(t), url && this.isEnabled() && null != data && (null == this.div || "hidden" == this.div.style.visibility)) {
      var nodes = t.getSource();
      var type = t.getX();
      var options = t.getY();
      var g = t.isSource(data.shape) || t.isSource(data.text);
      this.thread = window.setTimeout(mxUtils.bind(this, function() {
        if (!this.graph.isEditing() && !this.graph.popupMenuHandler.isMenuShowing() && !this.graph.isMouseDown) {
          var result = this.graph.getTooltip(data, nodes, type, options);
          this.show(result, type, options);
          this.state = data;
          this.node = nodes;
          this.stateSource = g;
        }
      }), this.delay);
    }
  }
};
/**
 * @return {undefined}
 */
mxTooltipHandler.prototype.hide = function() {
  this.resetTimer();
  this.hideTooltip();
};
/**
 * @return {undefined}
 */
mxTooltipHandler.prototype.hideTooltip = function() {
  if (null != this.div) {
    /** @type {string} */
    this.div.style.visibility = "hidden";
    /** @type {string} */
    this.div.innerText = "";
  }
};
/**
 * @param {!Object} html
 * @param {string} x
 * @param {string} y
 * @return {undefined}
 */
mxTooltipHandler.prototype.show = function(html, x, y) {
  if (!this.destroyed && null != html && 0 < html.length) {
    if (null == this.div) {
      this.init();
    }
    var chart = mxUtils.getScrollOrigin();
    this.div.style.zIndex = this.zIndex;
    /** @type {string} */
    this.div.style.left = x + chart.x + "px";
    /** @type {string} */
    this.div.style.top = y + mxConstants.TOOLTIP_VERTICAL_OFFSET + chart.y + "px";
    if (mxUtils.isNode(html)) {
      /** @type {string} */
      this.div.innerText = "";
      this.div.appendChild(html);
    } else {
      this.div.innerHTML = html.replace(/\n/g, "<br>");
    }
    /** @type {string} */
    this.div.style.visibility = "";
    mxUtils.fit(this.div);
  }
};
/**
 * @return {undefined}
 */
mxTooltipHandler.prototype.destroy = function() {
  if (!this.destroyed) {
    this.graph.removeMouseListener(this);
    mxEvent.release(this.div);
    if (null != this.div && null != this.div.parentNode) {
      this.div.parentNode.removeChild(this.div);
    }
    /** @type {boolean} */
    this.destroyed = true;
    /** @type {null} */
    this.div = null;
  }
};
/**
 * @param {?} a
 * @param {?} b
 * @param {string} variableNames
 * @return {undefined}
 */
function mxCellTracker(a, b, variableNames) {
  mxCellMarker.call(this, a, b);
  this.graph.addMouseListener(this);
  if (null != variableNames) {
    /** @type {string} */
    this.getCell = variableNames;
  }
  if (mxClient.IS_IE) {
    mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
      this.destroy();
    }));
  }
}
mxUtils.extend(mxCellTracker, mxCellMarker);
/**
 * @param {!Object} item
 * @param {?} event
 * @return {undefined}
 */
mxCellTracker.prototype.mouseDown = function(item, event) {
};
/**
 * @param {?} scheduled
 * @param {!Object} callback
 * @return {undefined}
 */
mxCellTracker.prototype.mouseMove = function(scheduled, callback) {
  if (this.isEnabled()) {
    this.process(callback);
  }
};
/**
 * @param {?} offset
 * @param {?} callback
 * @return {undefined}
 */
mxCellTracker.prototype.mouseUp = function(offset, callback) {
};
/**
 * @return {undefined}
 */
mxCellTracker.prototype.destroy = function() {
  if (!this.destroyed) {
    /** @type {boolean} */
    this.destroyed = true;
    this.graph.removeMouseListener(this);
    mxCellMarker.prototype.destroy.apply(this);
  }
};
/**
 * @param {!Object} g
 * @param {string} data
 * @param {number} name
 * @param {!Object} force
 * @return {undefined}
 */
function mxCellHighlight(g, data, name, force) {
  if (null != g) {
    /** @type {!Object} */
    this.graph = g;
    this.highlightColor = null != data ? data : mxConstants.DEFAULT_VALID_COLOR;
    this.strokeWidth = null != name ? name : mxConstants.HIGHLIGHT_STROKEWIDTH;
    this.dashed = null != force ? force : false;
    this.opacity = mxConstants.HIGHLIGHT_OPACITY;
    this.repaintHandler = mxUtils.bind(this, function() {
      if (null != this.state) {
        var STATE_BEFORECHANGEOFFSET = this.graph.view.getState(this.state.cell);
        if (null == STATE_BEFORECHANGEOFFSET) {
          this.hide();
        } else {
          this.state = STATE_BEFORECHANGEOFFSET;
          this.repaint();
        }
      }
    });
    this.graph.getView().addListener(mxEvent.SCALE, this.repaintHandler);
    this.graph.getView().addListener(mxEvent.TRANSLATE, this.repaintHandler);
    this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.repaintHandler);
    this.graph.getModel().addListener(mxEvent.CHANGE, this.repaintHandler);
    this.resetHandler = mxUtils.bind(this, function() {
      this.hide();
    });
    this.graph.getView().addListener(mxEvent.DOWN, this.resetHandler);
    this.graph.getView().addListener(mxEvent.UP, this.resetHandler);
  }
}
/** @type {boolean} */
mxCellHighlight.prototype.keepOnTop = false;
/** @type {null} */
mxCellHighlight.prototype.graph = null;
/** @type {null} */
mxCellHighlight.prototype.state = null;
/** @type {number} */
mxCellHighlight.prototype.spacing = 2;
/** @type {null} */
mxCellHighlight.prototype.resetHandler = null;
/**
 * @param {string} color
 * @return {undefined}
 */
mxCellHighlight.prototype.setHighlightColor = function(color) {
  /** @type {string} */
  this.highlightColor = color;
  if (null != this.shape) {
    /** @type {string} */
    this.shape.stroke = color;
  }
};
/**
 * @return {undefined}
 */
mxCellHighlight.prototype.drawHighlight = function() {
  this.shape = this.createShape();
  this.repaint();
  if (!(this.keepOnTop || this.shape.node.parentNode.firstChild == this.shape.node)) {
    this.shape.node.parentNode.insertBefore(this.shape.node, this.shape.node.parentNode.firstChild);
  }
};
/**
 * @return {?}
 */
mxCellHighlight.prototype.createShape = function() {
  var data = this.graph.cellRenderer.createShape(this.state);
  data.svgStrokeTolerance = this.graph.tolerance;
  data.points = this.state.absolutePoints;
  data.apply(this.state);
  data.stroke = this.highlightColor;
  data.opacity = this.opacity;
  data.isDashed = this.dashed;
  /** @type {boolean} */
  data.isShadow = false;
  data.dialect = mxConstants.DIALECT_SVG;
  data.init(this.graph.getView().getOverlayPane());
  mxEvent.redirectMouseEvents(data.node, this.graph, this.state);
  if (this.graph.dialect != mxConstants.DIALECT_SVG) {
    /** @type {boolean} */
    data.pointerEvents = false;
  } else {
    /** @type {string} */
    data.svgPointerEvents = "stroke";
  }
  return data;
};
/**
 * @param {?} multiplier
 * @return {?}
 */
mxCellHighlight.prototype.getStrokeWidth = function(multiplier) {
  return this.strokeWidth;
};
/**
 * @return {undefined}
 */
mxCellHighlight.prototype.repaint = function() {
  if (null != this.state && null != this.shape) {
    this.shape.scale = this.state.view.scale;
    if (this.graph.model.isEdge(this.state.cell)) {
      this.shape.strokewidth = this.getStrokeWidth();
      this.shape.points = this.state.absolutePoints;
      /** @type {boolean} */
      this.shape.outline = false;
    } else {
      this.shape.bounds = new mxRectangle(this.state.x - this.spacing, this.state.y - this.spacing, this.state.width + 2 * this.spacing, this.state.height + 2 * this.spacing);
      /** @type {number} */
      this.shape.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
      /** @type {number} */
      this.shape.strokewidth = this.getStrokeWidth() / this.state.view.scale;
      /** @type {boolean} */
      this.shape.outline = true;
    }
    if (null != this.state.shape) {
      this.shape.setCursor(this.state.shape.getCursor());
    }
    this.shape.redraw();
  }
};
/**
 * @return {undefined}
 */
mxCellHighlight.prototype.hide = function() {
  this.highlight(null);
};
/**
 * @param {!Object} state
 * @return {undefined}
 */
mxCellHighlight.prototype.highlight = function(state) {
  if (this.state != state) {
    if (null != this.shape) {
      this.shape.destroy();
      /** @type {null} */
      this.shape = null;
    }
    /** @type {!Object} */
    this.state = state;
    if (null != this.state) {
      this.drawHighlight();
    }
  }
};
/**
 * @param {!Object} x
 * @param {?} y
 * @return {?}
 */
mxCellHighlight.prototype.isHighlightAt = function(x, y) {
  /** @type {boolean} */
  var c = false;
  if (null != this.shape && null != document.elementFromPoint) {
    /** @type {(Element|null)} */
    x = document.elementFromPoint(x, y);
    for (; null != x;) {
      if (x == this.shape.node) {
        /** @type {boolean} */
        c = true;
        break;
      }
      /** @type {(Node|null)} */
      x = x.parentNode;
    }
  }
  return c;
};
/**
 * @return {undefined}
 */
mxCellHighlight.prototype.destroy = function() {
  this.graph.getView().removeListener(this.resetHandler);
  this.graph.getView().removeListener(this.repaintHandler);
  this.graph.getModel().removeListener(this.repaintHandler);
  if (null != this.shape) {
    this.shape.destroy();
    /** @type {null} */
    this.shape = null;
  }
};
var mxCodecRegistry = {
  codecs : [],
  aliases : [],
  register : function(module) {
    if (null != module) {
      var name = module.getName();
      /** @type {!Object} */
      mxCodecRegistry.codecs[name] = module;
      var alias = mxUtils.getFunctionName(module.template.constructor);
      if (alias != name) {
        mxCodecRegistry.addAlias(alias, name);
      }
    }
    return module;
  },
  addAlias : function(alias, name) {
    /** @type {string} */
    mxCodecRegistry.aliases[alias] = name;
  },
  getCodec : function(func) {
    /** @type {null} */
    var name = null;
    if (null != func) {
      name = mxUtils.getFunctionName(func);
      var aliasedName = mxCodecRegistry.aliases[name];
      if (null != aliasedName) {
        name = aliasedName;
      }
      name = mxCodecRegistry.codecs[name];
      if (null == name) {
        try {
          name = new mxObjectCodec(new func);
          mxCodecRegistry.register(name);
        } catch (d) {
        }
      }
    }
    return name;
  }
};
/**
 * @param {!Object} doc
 * @return {undefined}
 */
function mxCodec(doc) {
  this.document = doc || mxUtils.createXmlDocument();
  /** @type {!Array} */
  this.objects = [];
}
/** @type {null} */
mxCodec.allowlist = null;
/** @type {null} */
mxCodec.prototype.document = null;
/** @type {null} */
mxCodec.prototype.objects = null;
/** @type {null} */
mxCodec.prototype.elements = null;
/** @type {boolean} */
mxCodec.prototype.encodeDefaults = false;
/**
 * @param {?} key
 * @param {!Object} value
 * @return {?}
 */
mxCodec.prototype.putObject = function(key, value) {
  return this.objects[key] = value;
};
/**
 * @param {!Object} id
 * @return {?}
 */
mxCodec.prototype.getObject = function(id) {
  /** @type {null} */
  var result = null;
  if (null != id) {
    result = this.objects[id];
    if (null == result) {
      result = this.lookup(id);
      if (null == result) {
        id = this.getElementById(id);
        if (null != id) {
          result = this.decode(id);
        }
      }
    }
  }
  return result;
};
/**
 * @param {!Object} i
 * @return {?}
 */
mxCodec.prototype.lookup = function(i) {
  return null;
};
/**
 * @param {string} element
 * @return {?}
 */
mxCodec.prototype.getElementById = function(element) {
  this.updateElements();
  return this.elements[element];
};
/**
 * @return {undefined}
 */
mxCodec.prototype.updateElements = function() {
  if (null == this.elements) {
    this.elements = {};
    if (null != this.document.documentElement) {
      this.addElement(this.document.documentElement);
    }
  }
};
/**
 * @param {!Object} element
 * @return {undefined}
 */
mxCodec.prototype.addElement = function(element) {
  if (element.nodeType == mxConstants.NODETYPE_ELEMENT) {
    var name = element.getAttribute("id");
    if (null != name) {
      if (null == this.elements[name]) {
        /** @type {!Object} */
        this.elements[name] = element;
      } else {
        if (this.elements[name] != element) {
          throw Error(name + ": Duplicate ID");
        }
      }
    }
  }
  element = element.firstChild;
  for (; null != element;) {
    this.addElement(element);
    element = element.nextSibling;
  }
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxCodec.prototype.getId = function(value) {
  /** @type {null} */
  var ret = null;
  if (null != value) {
    ret = this.reference(value);
    if (null == ret && value instanceof mxCell) {
      ret = value.getId();
      if (null == ret) {
        ret = mxCellPath.create(value);
        if (0 == ret.length) {
          /** @type {string} */
          ret = "root";
        }
      }
    }
  }
  return ret;
};
/**
 * @param {!Object} name
 * @return {?}
 */
mxCodec.prototype.reference = function(name) {
  return null;
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxCodec.prototype.encode = function(value) {
  /** @type {null} */
  var result = null;
  if (null != value && null != value.constructor) {
    var c = mxCodecRegistry.getCodec(value.constructor);
    if (null != c) {
      result = c.encode(this, value);
    } else {
      if (mxUtils.isNode(value)) {
        result = mxUtils.importNode(this.document, value, true);
      } else {
        mxLog.warn("mxCodec.encode: No codec for " + mxUtils.getFunctionName(value.constructor));
      }
    }
  }
  return result;
};
/**
 * @param {!Object} v
 * @param {!Object} options
 * @return {?}
 */
mxCodec.prototype.decode = function(v, options) {
  this.updateElements();
  /** @type {null} */
  var a = null;
  if (null != v && v.nodeType == mxConstants.NODETYPE_ELEMENT) {
    a = this.getConstructor(v.nodeName);
    a = mxCodecRegistry.getCodec(a);
    if (null != a) {
      a = a.decode(this, v, options);
    } else {
      a = v.cloneNode(true);
      a.removeAttribute("as");
    }
  }
  return a;
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxCodec.prototype.getConstructor = function(value) {
  /** @type {null} */
  var result = null;
  try {
    if (null == mxCodec.allowlist || 0 <= mxUtils.indexOf(mxCodec.allowlist, value)) {
      result = window[value];
    } else {
      if (null != window.console) {
        console.error("mxCodec.getConstructor: " + value + " not allowed in mxCodec.allowlist");
      }
    }
  } catch (c) {
  }
  return result;
};
/**
 * @param {?} node
 * @param {!Object} a
 * @param {number} repeats
 * @return {undefined}
 */
mxCodec.prototype.encodeCell = function(node, a, repeats) {
  a.appendChild(this.encode(node));
  if (null == repeats || repeats) {
    repeats = node.getChildCount();
    /** @type {number} */
    var i = 0;
    for (; i < repeats; i++) {
      this.encodeCell(node.getChildAt(i), a);
    }
  }
};
/**
 * @param {!Object} n22
 * @return {?}
 */
mxCodec.prototype.isCellCodec = function(n22) {
  return null != n22 && "function" == typeof n22.isCellCodec ? n22.isCellCodec() : false;
};
/**
 * @param {!Object} b
 * @param {?} status
 * @return {?}
 */
mxCodec.prototype.decodeCell = function(b, status) {
  status = null != status ? status : true;
  /** @type {null} */
  var c = null;
  if (null != b && b.nodeType == mxConstants.NODETYPE_ELEMENT) {
    c = mxCodecRegistry.getCodec(b.nodeName);
    if (!this.isCellCodec(c)) {
      var t = b.firstChild;
      for (; null != t && !this.isCellCodec(c);) {
        c = mxCodecRegistry.getCodec(t.nodeName);
        t = t.nextSibling;
      }
    }
    if (!this.isCellCodec(c)) {
      c = mxCodecRegistry.getCodec(mxCell);
    }
    c = c.decode(this, b);
    if (status) {
      this.insertIntoGraph(c);
    }
  }
  return c;
};
/**
 * @param {!Object} self
 * @return {undefined}
 */
mxCodec.prototype.insertIntoGraph = function(self) {
  var parent = self.parent;
  var source = self.getTerminal(true);
  var target = self.getTerminal(false);
  self.setTerminal(null, false);
  self.setTerminal(null, true);
  /** @type {null} */
  self.parent = null;
  if (null != parent) {
    if (parent == self) {
      throw Error(parent.id + ": Self Reference");
    }
    parent.insert(self);
  }
  if (null != source) {
    source.insertEdge(self, true);
  }
  if (null != target) {
    target.insertEdge(self, false);
  }
};
/**
 * @param {!Object} name
 * @param {!Object} value
 * @param {?} key
 * @return {undefined}
 */
mxCodec.prototype.setAttribute = function(name, value, key) {
  if (null != value && null != key) {
    name.setAttribute(value, key);
  }
};
/**
 * @param {string} template
 * @param {string} v
 * @param {string} data
 * @param {!Object} mapping
 * @return {undefined}
 */
function mxObjectCodec(template, v, data, mapping) {
  /** @type {string} */
  this.template = template;
  this.exclude = null != v ? v : [];
  this.idrefs = null != data ? data : [];
  this.mapping = null != mapping ? mapping : [];
  this.reverse = {};
  var id;
  for (id in this.mapping) {
    /** @type {string} */
    this.reverse[this.mapping[id]] = id;
  }
}
/** @type {boolean} */
mxObjectCodec.allowEval = false;
/** @type {null} */
mxObjectCodec.prototype.template = null;
/** @type {null} */
mxObjectCodec.prototype.exclude = null;
/** @type {null} */
mxObjectCodec.prototype.idrefs = null;
/** @type {null} */
mxObjectCodec.prototype.mapping = null;
/** @type {null} */
mxObjectCodec.prototype.reverse = null;
/**
 * @return {?}
 */
mxObjectCodec.prototype.getName = function() {
  return mxUtils.getFunctionName(this.template.constructor);
};
/**
 * @return {?}
 */
mxObjectCodec.prototype.cloneTemplate = function() {
  return new this.template.constructor;
};
/**
 * @param {!Object} s
 * @return {?}
 */
mxObjectCodec.prototype.getFieldName = function(s) {
  if (null != s) {
    var mapped = this.reverse[s];
    if (null != mapped) {
      s = mapped;
    }
  }
  return s;
};
/**
 * @param {string} name
 * @return {?}
 */
mxObjectCodec.prototype.getAttributeName = function(name) {
  if (null != name) {
    var aliasedName = this.mapping[name];
    if (null != aliasedName) {
      name = aliasedName;
    }
  }
  return name;
};
/**
 * @param {!Object} url
 * @param {string} value
 * @param {!Object} str
 * @param {boolean} index
 * @return {?}
 */
mxObjectCodec.prototype.isExcluded = function(url, value, str, index) {
  return value == mxObjectIdentity.FIELD_NAME || 0 <= mxUtils.indexOf(this.exclude, value);
};
/**
 * @param {!Object} node
 * @param {string} obj
 * @param {!Object} path
 * @param {boolean} state
 * @return {?}
 */
mxObjectCodec.prototype.isReference = function(node, obj, path, state) {
  return 0 <= mxUtils.indexOf(this.idrefs, obj);
};
/**
 * @param {!Object} a
 * @param {!Object} b
 * @return {?}
 */
mxObjectCodec.prototype.encode = function(a, b) {
  var d = a.document.createElement(this.getName());
  b = this.beforeEncode(a, b, d);
  this.encodeObject(a, b, d);
  return this.afterEncode(a, b, d);
};
/**
 * @param {!Object} o
 * @param {!Object} value
 * @param {undefined} m
 * @return {undefined}
 */
mxObjectCodec.prototype.encodeObject = function(o, value, m) {
  o.setAttribute(m, "id", o.getId(value));
  var item;
  for (item in value) {
    /** @type {string} */
    var key = item;
    var type = value[key];
    if (!(null == type || this.isExcluded(value, key, type, true))) {
      if (mxUtils.isInteger(key)) {
        /** @type {null} */
        key = null;
      }
      this.encodeValue(o, value, key, type, m);
    }
  }
};
/**
 * @param {(Object|string)} name
 * @param {!Object} value
 * @param {string} path
 * @param {?} key
 * @param {!Object} prop
 * @return {undefined}
 */
mxObjectCodec.prototype.encodeValue = function(name, value, path, key, prop) {
  if (null != key) {
    if (this.isReference(value, path, key, true)) {
      var val = name.getId(key);
      if (null == val) {
        mxLog.warn("mxObjectCodec.encode: No ID for " + this.getName() + "." + path + "=" + key);
        return;
      }
      key = val;
    }
    val = this.template[path];
    if (null == path || name.encodeDefaults || val != key) {
      path = this.getAttributeName(path);
      this.writeAttribute(name, value, path, key, prop);
    }
  }
};
/**
 * @param {string} type
 * @param {!Object} a
 * @param {!Object} callback
 * @param {number} value
 * @param {!Object} name
 * @return {undefined}
 */
mxObjectCodec.prototype.writeAttribute = function(type, a, callback, value, name) {
  if ("object" != typeof value) {
    this.writePrimitiveAttribute(type, a, callback, value, name);
  } else {
    this.writeComplexAttribute(type, a, callback, value, name);
  }
};
/**
 * @param {!HTMLElement} el
 * @param {!Object} result
 * @param {!Object} key
 * @param {number} value
 * @param {!Object} item
 * @return {undefined}
 */
mxObjectCodec.prototype.writePrimitiveAttribute = function(el, result, key, value, item) {
  value = this.convertAttributeToXml(el, result, key, value, item);
  if (null == key) {
    result = el.document.createElement("add");
    if ("function" == typeof value) {
      result.appendChild(el.document.createTextNode(value));
    } else {
      el.setAttribute(result, "value", value);
    }
    item.appendChild(result);
  } else {
    if ("function" != typeof value) {
      el.setAttribute(item, key, value);
    }
  }
};
/**
 * @param {!Object} t
 * @param {!Object} uuid
 * @param {!Object} type
 * @param {undefined} str
 * @param {!Object} e
 * @return {undefined}
 */
mxObjectCodec.prototype.writeComplexAttribute = function(t, uuid, type, str, e) {
  t = t.encode(str);
  if (null != t) {
    if (null != type) {
      t.setAttribute("as", type);
    }
    e.appendChild(t);
  } else {
    mxLog.warn("mxObjectCodec.encode: No node for " + this.getName() + "." + type + ": " + str);
  }
};
/**
 * @param {!HTMLElement} href
 * @param {!Object} parent
 * @param {!Object} num
 * @param {number} sel
 * @return {?}
 */
mxObjectCodec.prototype.convertAttributeToXml = function(href, parent, num, sel) {
  if (this.isBooleanAttribute(href, parent, num, sel)) {
    /** @type {string} */
    sel = 1 == sel ? "1" : "0";
  }
  return sel;
};
/**
 * @param {!HTMLElement} attrValue
 * @param {!Object} attrName
 * @param {!Object} value
 * @param {number} node
 * @return {?}
 */
mxObjectCodec.prototype.isBooleanAttribute = function(attrValue, attrName, value, node) {
  return "undefined" == typeof node.length && (1 == node || 0 == node);
};
/**
 * @param {!Object} a
 * @param {!Object} c
 * @param {!Object} d
 * @return {?}
 */
mxObjectCodec.prototype.convertAttributeFromXml = function(a, c, d) {
  var w = c.value;
  if (this.isNumericAttribute(a, c, d) && (w = parseFloat(w), isNaN(w) || !isFinite(w))) {
    /** @type {number} */
    w = 0;
  }
  return w;
};
/**
 * @param {!Object} templateName
 * @param {!Object} obj
 * @param {!Object} time
 * @return {?}
 */
mxObjectCodec.prototype.isNumericAttribute = function(templateName, obj, time) {
  return time.constructor == mxGeometry && ("x" == obj.name || "y" == obj.name || "width" == obj.name || "height" == obj.name) || time.constructor == mxPoint && ("x" == obj.name || "y" == obj.name) || mxUtils.isNumeric(obj.value);
};
/**
 * @param {!Object} rect
 * @param {!Object} linesstrip
 * @param {?} optionsValue
 * @return {?}
 */
mxObjectCodec.prototype.beforeEncode = function(rect, linesstrip, optionsValue) {
  return linesstrip;
};
/**
 * @param {!Object} v03
 * @param {!Object} v13
 * @param {?} v23
 * @return {?}
 */
mxObjectCodec.prototype.afterEncode = function(v03, v13, v23) {
  return v23;
};
/**
 * @param {!Object} c
 * @param {!Object} a
 * @param {!Function} width
 * @return {?}
 */
mxObjectCodec.prototype.decode = function(c, a, width) {
  var key = a.getAttribute("id");
  var value = c.objects[key];
  if (null == value) {
    value = width || this.cloneTemplate();
    if (null != key) {
      c.putObject(key, value);
    }
  }
  a = this.beforeDecode(c, a, value);
  this.decodeNode(c, a, value);
  return this.afterDecode(c, a, value);
};
/**
 * @param {!Object} a
 * @param {!Object} i
 * @param {!Object} tree
 * @return {undefined}
 */
mxObjectCodec.prototype.decodeNode = function(a, i, tree) {
  if (null != i) {
    this.decodeAttributes(a, i, tree);
    this.decodeChildren(a, i, tree);
  }
};
/**
 * @param {!Object} mask
 * @param {!Object} val
 * @param {!Object} key
 * @return {undefined}
 */
mxObjectCodec.prototype.decodeAttributes = function(mask, val, key) {
  val = val.attributes;
  if (null != val) {
    /** @type {number} */
    var bufferIdx = 0;
    for (; bufferIdx < val.length; bufferIdx++) {
      this.decodeAttribute(mask, val[bufferIdx], key);
    }
  }
};
/**
 * @param {!Object} nothing
 * @param {!Object} obj
 * @param {!Object} instance
 * @return {?}
 */
mxObjectCodec.prototype.isIgnoredAttribute = function(nothing, obj, instance) {
  return "as" == obj.nodeName || "id" == obj.nodeName;
};
/**
 * @param {!Object} name
 * @param {!Object} value
 * @param {!Object} node
 * @return {undefined}
 */
mxObjectCodec.prototype.decodeAttribute = function(name, value, node) {
  if (!this.isIgnoredAttribute(name, value, node)) {
    var k = value.nodeName;
    value = this.convertAttributeFromXml(name, value, node);
    var e = this.getFieldName(k);
    if (this.isReference(node, e, value, false)) {
      name = name.getObject(value);
      if (null == name) {
        mxLog.warn("mxObjectCodec.decode: No object for " + this.getName() + "." + k + "=" + value);
        return;
      }
      /** @type {!Object} */
      value = name;
    }
    if (!this.isExcluded(node, k, value, false)) {
      /** @type {!Object} */
      node[k] = value;
    }
  }
};
/**
 * @param {!Object} path
 * @param {!Object} child
 * @param {!Object} key
 * @return {undefined}
 */
mxObjectCodec.prototype.decodeChildren = function(path, child, key) {
  child = child.firstChild;
  for (; null != child;) {
    var moveTo = child.nextSibling;
    if (!(child.nodeType != mxConstants.NODETYPE_ELEMENT || this.processInclude(path, child, key))) {
      this.decodeChild(path, child, key);
    }
    child = moveTo;
  }
};
/**
 * @param {!Object} type
 * @param {!Object} node
 * @param {!Object} id
 * @return {undefined}
 */
mxObjectCodec.prototype.decodeChild = function(type, node, id) {
  var key = this.getFieldName(node.getAttribute("as"));
  if (null == key || !this.isExcluded(id, key, node, false)) {
    var value = this.getFieldTemplate(id, key, node);
    if ("add" == node.nodeName) {
      type = node.getAttribute("value");
      if (null == type && mxObjectCodec.allowEval) {
        type = mxUtils.eval(mxUtils.getTextContent(node));
      }
    } else {
      type = type.decode(node, value);
    }
    try {
      this.addObjectValue(id, key, type, value);
    } catch (controlFlowAction) {
      throw Error(controlFlowAction.message + " for " + node.nodeName);
    }
  }
};
/**
 * @param {!Object} i
 * @param {string} k
 * @param {!Object} options
 * @return {?}
 */
mxObjectCodec.prototype.getFieldTemplate = function(i, k, options) {
  i = i[k];
  if (i instanceof Array && 0 < i.length) {
    /** @type {null} */
    i = null;
  }
  return i;
};
/**
 * @param {!Object} s
 * @param {string} k
 * @param {!Object} c
 * @param {!Object} name
 * @return {undefined}
 */
mxObjectCodec.prototype.addObjectValue = function(s, k, c, name) {
  if (null != c && c != name) {
    if (null != k && 0 < k.length) {
      /** @type {!Object} */
      s[k] = c;
    } else {
      s.push(c);
    }
  }
};
/**
 * @param {!Object} c
 * @param {!Object} node
 * @param {!Object} value
 * @return {?}
 */
mxObjectCodec.prototype.processInclude = function(c, node, value) {
  if ("include" == node.nodeName) {
    node = node.getAttribute("name");
    if (null != node) {
      try {
        var d = mxUtils.load(node).getDocumentElement();
        if (null != d) {
          c.decode(d, value);
        }
      } catch (e) {
      }
    }
    return true;
  }
  return false;
};
/**
 * @param {!Object} before
 * @param {!Object} submenu
 * @param {?} eventArgs
 * @return {?}
 */
mxObjectCodec.prototype.beforeDecode = function(before, submenu, eventArgs) {
  return submenu;
};
/**
 * @param {!Object} before
 * @param {!Object} submenu
 * @param {?} eventArgs
 * @return {?}
 */
mxObjectCodec.prototype.afterDecode = function(before, submenu, eventArgs) {
  return eventArgs;
};
mxCodecRegistry.register(function() {
  var me = new mxObjectCodec(new mxCell, ["children", "edges", "overlays", "mxTransient"], ["parent", "source", "target"]);
  /**
   * @return {?}
   */
  me.isCellCodec = function() {
    return true;
  };
  /**
   * @param {!Object} b
   * @param {!Object} target
   * @param {!Object} variable
   * @return {?}
   */
  me.isNumericAttribute = function(b, target, variable) {
    return "value" !== target.nodeName && mxObjectCodec.prototype.isNumericAttribute.apply(this, arguments);
  };
  /**
   * @param {!Object} index
   * @param {string} path
   * @param {!Object} str
   * @param {boolean} value
   * @return {?}
   */
  me.isExcluded = function(index, path, str, value) {
    return mxObjectCodec.prototype.isExcluded.apply(this, arguments) || value && "value" == path && mxUtils.isNode(str);
  };
  /**
   * @param {!Object} node
   * @param {!Object} cell
   * @param {!Element} x
   * @return {?}
   */
  me.afterEncode = function(node, cell, x) {
    if (null != cell.value && mxUtils.isNode(cell.value)) {
      /** @type {!Element} */
      var e = x;
      x = mxUtils.importNode(node.document, cell.value, true);
      x.appendChild(e);
      node = e.getAttribute("id");
      x.setAttribute("id", node);
      e.removeAttribute("id");
    }
    return x;
  };
  /**
   * @param {!Object} obj
   * @param {string} node
   * @param {!Object} t
   * @return {?}
   */
  me.beforeDecode = function(obj, node, t) {
    var child = node.cloneNode(true);
    var name = this.getName();
    if (node.nodeName != name) {
      child = node.getElementsByTagName(name)[0];
      if (null != child && child.parentNode == node) {
        mxUtils.removeWhitespace(child, true);
        mxUtils.removeWhitespace(child, false);
        child.parentNode.removeChild(child);
      } else {
        /** @type {null} */
        child = null;
      }
      t.value = node.cloneNode(true);
      node = t.value.getAttribute("id");
      if (null != node) {
        t.setId(node);
        t.value.removeAttribute("id");
      }
    } else {
      t.setId(node.getAttribute("id"));
    }
    if (null != child) {
      /** @type {number} */
      node = 0;
      for (; node < this.idrefs.length; node++) {
        name = this.idrefs[node];
        var i = child.getAttribute(name);
        if (null != i) {
          child.removeAttribute(name);
          var val = obj.objects[i] || obj.lookup(i);
          if (null == val) {
            i = obj.getElementById(i);
            if (null != i) {
              val = (mxCodecRegistry.codecs[i.nodeName] || this).decode(obj, i);
            }
          }
          t[name] = val;
        }
      }
    }
    return child;
  };
  return me;
}());
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxGraphModel);
  /**
   * @param {!Object} options
   * @param {!Object} obj
   * @param {!Object} o
   * @return {undefined}
   */
  codec.encodeObject = function(options, obj, o) {
    var e = options.document.createElement("root");
    options.encodeCell(obj.getRoot(), e);
    o.appendChild(e);
  };
  /**
   * @param {!Object} obj
   * @param {!Object} root
   * @param {!Object} vNode
   * @return {undefined}
   */
  codec.decodeChild = function(obj, root, vNode) {
    if ("root" == root.nodeName) {
      this.decodeRoot(obj, root, vNode);
    } else {
      mxObjectCodec.prototype.decodeChild.apply(this, arguments);
    }
  };
  /**
   * @param {!Object} date
   * @param {!Object} n
   * @param {!Object} data
   * @return {undefined}
   */
  codec.decodeRoot = function(date, n, data) {
    /** @type {null} */
    var rootNode = null;
    n = n.firstChild;
    for (; null != n;) {
      var node = date.decodeCell(n);
      if (null != node && null == node.getParent()) {
        rootNode = node;
      }
      n = n.nextSibling;
    }
    if (null != rootNode) {
      data.setRoot(rootNode);
    }
  };
  return codec;
}());
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxRootChange, ["model", "previous", "root"]);
  /**
   * @param {!Object} t
   * @param {!Object} c
   * @param {!Object} d
   * @return {?}
   */
  codec.afterEncode = function(t, c, d) {
    t.encodeCell(c.root, d);
    return d;
  };
  /**
   * @param {!Object} ast
   * @param {!Object} item
   * @param {!Object} result
   * @return {?}
   */
  codec.beforeDecode = function(ast, item, result) {
    if (null != item.firstChild && item.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT) {
      item = item.cloneNode(true);
      var root = item.firstChild;
      result.root = ast.decodeCell(root, false);
      result = root.nextSibling;
      root.parentNode.removeChild(root);
      /** @type {!Object} */
      root = result;
      for (; null != root;) {
        result = root.nextSibling;
        ast.decodeCell(root);
        root.parentNode.removeChild(root);
        /** @type {!Object} */
        root = result;
      }
    }
    return item;
  };
  /**
   * @param {!Object} value
   * @param {!Object} term
   * @param {!Object} item
   * @return {?}
   */
  codec.afterDecode = function(value, term, item) {
    item.previous = item.root;
    return item;
  };
  return codec;
}());
mxCodecRegistry.register(function() {
  var util = new mxObjectCodec(new mxChildChange, ["model", "child", "previousIndex"], ["parent", "previous"]);
  /**
   * @param {!Object} node
   * @param {string} obj
   * @param {!Object} scope
   * @param {boolean} state
   * @return {?}
   */
  util.isReference = function(node, obj, scope, state) {
    return "child" != obj || state && !node.model.contains(node.previous) ? 0 <= mxUtils.indexOf(this.idrefs, obj) : true;
  };
  /**
   * @param {!Object} page
   * @param {string} name
   * @param {!Object} value
   * @param {string} field
   * @return {?}
   */
  util.isExcluded = function(page, name, value, field) {
    return mxObjectCodec.prototype.isExcluded.apply(this, arguments) || field && null != value && ("previous" == name || "parent" == name) && !page.model.contains(value);
  };
  /**
   * @param {!Object} t
   * @param {!Object} node
   * @param {!Object} d
   * @return {?}
   */
  util.afterEncode = function(t, node, d) {
    if (this.isReference(node, "child", node.child, true)) {
      d.setAttribute("child", t.getId(node.child));
    } else {
      t.encodeCell(node.child, d);
    }
    return d;
  };
  /**
   * @param {!Object} instance
   * @param {!Object} context
   * @param {!Object} result
   * @return {?}
   */
  util.beforeDecode = function(instance, context, result) {
    if (null != context.firstChild && context.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT) {
      context = context.cloneNode(true);
      var target = context.firstChild;
      result.child = instance.decodeCell(target, false);
      result = target.nextSibling;
      target.parentNode.removeChild(target);
      /** @type {!Object} */
      target = result;
      for (; null != target;) {
        result = target.nextSibling;
        if (target.nodeType == mxConstants.NODETYPE_ELEMENT) {
          var f = target.getAttribute("id");
          if (null == instance.lookup(f)) {
            instance.decodeCell(target);
          }
        }
        target.parentNode.removeChild(target);
        /** @type {!Object} */
        target = result;
      }
    } else {
      target = context.getAttribute("child");
      result.child = instance.getObject(target);
    }
    return context;
  };
  /**
   * @param {!Object} ast
   * @param {!Object} name
   * @param {!Object} scope
   * @return {?}
   */
  util.afterDecode = function(ast, name, scope) {
    if (null != scope.child) {
      if (null != scope.child.parent && null != scope.previous && scope.child.parent != scope.previous) {
        scope.previous = scope.child.parent;
      }
      scope.child.parent = scope.previous;
      scope.previous = scope.parent;
      scope.previousIndex = scope.index;
    }
    return scope;
  };
  return util;
}());
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxTerminalChange, ["model", "previous"], ["cell", "terminal"]);
  /**
   * @param {!Object} layer
   * @param {!Object} rect
   * @param {!Node} options
   * @return {?}
   */
  codec.afterDecode = function(layer, rect, options) {
    options.previous = options.terminal;
    return options;
  };
  return codec;
}());
/**
 * @param {!Object} counter
 * @param {string} value
 * @return {?}
 */
var mxGenericChangeCodec = function(counter, value) {
  counter = new mxObjectCodec(counter, ["model", "previous"], ["cell"]);
  /**
   * @param {!Object} ctx
   * @param {!Object} theta
   * @param {!Object} options
   * @return {?}
   */
  counter.afterDecode = function(ctx, theta, options) {
    if (mxUtils.isNode(options.cell)) {
      options.cell = ctx.decodeCell(options.cell, false);
    }
    options.previous = options[value];
    return options;
  };
  return counter;
};
mxCodecRegistry.register(mxGenericChangeCodec(new mxValueChange, "value"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxStyleChange, "style"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxGeometryChange, "geometry"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxCollapseChange, "collapsed"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxVisibleChange, "visible"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxCellAttributeChange, "value"));
mxCodecRegistry.register(function() {
  return new mxObjectCodec(new mxGraph, "graphListeners eventListeners view container cellRenderer editor selection".split(" "));
}());
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxGraphView);
  /**
   * @param {?} body
   * @param {!Object} context
   * @return {?}
   */
  codec.encode = function(body, context) {
    return this.encodeCell(body, context, context.graph.getModel().getRoot());
  };
  /**
   * @param {?} root
   * @param {!Object} data
   * @param {undefined} cell
   * @return {?}
   */
  codec.encodeCell = function(root, data, cell) {
    var model = data.graph.getModel();
    var o = data.getState(cell);
    var a = model.getParent(cell);
    if (null == a || null != o) {
      var max = model.getChildCount(cell);
      var prev = data.graph.getCellGeometry(cell);
      /** @type {null} */
      var type = null;
      if (a == model.getRoot()) {
        /** @type {string} */
        type = "layer";
      } else {
        if (null == a) {
          /** @type {string} */
          type = "graph";
        } else {
          if (model.isEdge(cell)) {
            /** @type {string} */
            type = "edge";
          } else {
            if (0 < max && null != prev) {
              /** @type {string} */
              type = "group";
            } else {
              if (model.isVertex(cell)) {
                /** @type {string} */
                type = "vertex";
              }
            }
          }
        }
      }
      if (null != type) {
        var self = root.document.createElement(type);
        if (null != data.graph.getLabel(cell)) {
          self.setAttribute("label", data.graph.getLabel(cell));
          if (data.graph.isHtmlLabel(cell)) {
            self.setAttribute("html", true);
          }
        }
        if (null == a) {
          var i = data.getGraphBounds();
          if (null != i) {
            self.setAttribute("x", Math.round(i.x));
            self.setAttribute("y", Math.round(i.y));
            self.setAttribute("width", Math.round(i.width));
            self.setAttribute("height", Math.round(i.height));
          }
          self.setAttribute("scale", data.scale);
        } else {
          if (null != o && null != prev) {
            for (i in o.style) {
              a = o.style[i];
              if ("function" == typeof a && "object" == typeof a) {
                a = mxStyleRegistry.getName(a);
              }
              if (null != a && "function" != typeof a && "object" != typeof a) {
                self.setAttribute(i, a);
              }
            }
            a = o.absolutePoints;
            if (null != a && 0 < a.length) {
              /** @type {string} */
              prev = Math.round(a[0].x) + "," + Math.round(a[0].y);
              /** @type {number} */
              i = 1;
              for (; i < a.length; i++) {
                /** @type {string} */
                prev = prev + (" " + Math.round(a[i].x) + "," + Math.round(a[i].y));
              }
              self.setAttribute("points", prev);
            } else {
              self.setAttribute("x", Math.round(o.x));
              self.setAttribute("y", Math.round(o.y));
              self.setAttribute("width", Math.round(o.width));
              self.setAttribute("height", Math.round(o.height));
            }
            i = o.absoluteOffset;
            if (null != i) {
              if (0 != i.x) {
                self.setAttribute("dx", Math.round(i.x));
              }
              if (0 != i.y) {
                self.setAttribute("dy", Math.round(i.y));
              }
            }
          }
        }
        /** @type {number} */
        i = 0;
        for (; i < max; i++) {
          o = this.encodeCell(root, data, model.getChildAt(cell, i));
          if (null != o) {
            self.appendChild(o);
          }
        }
      }
    }
    return self;
  };
  return codec;
}());
var mxStylesheetCodec = mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxStylesheet);
  /**
   * @param {!Object} n
   * @param {!Object} src
   * @return {?}
   */
  codec.encode = function(n, src) {
    var body = n.document.createElement(this.getName());
    var i;
    for (i in src.styles) {
      var oldo = src.styles[i];
      var script = n.document.createElement("add");
      if (null != i) {
        script.setAttribute("as", i);
        var j;
        for (j in oldo) {
          var transform = this.getStringValue(j, oldo[j]);
          if (null != transform) {
            var b = n.document.createElement("add");
            b.setAttribute("value", transform);
            b.setAttribute("as", j);
            script.appendChild(b);
          }
        }
        if (0 < script.childNodes.length) {
          body.appendChild(script);
        }
      }
    }
    return body;
  };
  /**
   * @param {string} type
   * @param {!Array} key
   * @return {?}
   */
  codec.getStringValue = function(type, key) {
    /** @type {string} */
    type = typeof key;
    if ("function" == type) {
      key = mxStyleRegistry.getName(key);
    } else {
      if ("object" == type) {
        /** @type {null} */
        key = null;
      }
    }
    return key;
  };
  /**
   * @param {!Object} d
   * @param {!Object} node
   * @param {!Object} obj
   * @return {?}
   */
  codec.decode = function(d, node, obj) {
    obj = obj || new this.template.constructor;
    var e = node.getAttribute("id");
    if (null != e) {
      /** @type {!Object} */
      d.objects[e] = obj;
    }
    node = node.firstChild;
    for (; null != node;) {
      if (!this.processInclude(d, node, obj) && "add" == node.nodeName && (e = node.getAttribute("as"), null != e)) {
        var i = node.getAttribute("extend");
        var g = null != i ? mxUtils.clone(obj.styles[i]) : null;
        if (null == g) {
          if (null != i) {
            mxLog.warn("mxStylesheetCodec.decode: stylesheet " + i + " not found to extend");
          }
          g = {};
        }
        i = node.firstChild;
        for (; null != i;) {
          if (i.nodeType == mxConstants.NODETYPE_ELEMENT) {
            var index = i.getAttribute("as");
            if ("add" == i.nodeName) {
              var value = mxUtils.getTextContent(i);
              if (null != value && 0 < value.length && mxStylesheetCodec.allowEval) {
                value = mxUtils.eval(value);
              } else {
                value = i.getAttribute("value");
                if (mxUtils.isNumeric(value)) {
                  /** @type {number} */
                  value = parseFloat(value);
                }
              }
              if (null != value) {
                g[index] = value;
              }
            } else {
              if ("remove" == i.nodeName) {
                delete g[index];
              }
            }
          }
          i = i.nextSibling;
        }
        obj.putCellStyle(e, g);
      }
      node = node.nextSibling;
    }
    return obj;
  };
  return codec;
}());
/** @type {boolean} */
mxStylesheetCodec.allowEval = false;
