'use strict';
var mxClient = {
  VERSION : "4.2.2",
  IS_IE : null != navigator.userAgent && 0 <= navigator.userAgent.indexOf("MSIE"),
  IS_IE6 : null != navigator.userAgent && 0 <= navigator.userAgent.indexOf("MSIE 6"),
  IS_IE11 : null != navigator.userAgent && !!navigator.userAgent.match(/Trident\/7\./),
  IS_EDGE : null != navigator.userAgent && !!navigator.userAgent.match(/Edge\//),
  IS_QUIRKS : null != navigator.userAgent && 0 <= navigator.userAgent.indexOf("MSIE") && (null == document.documentMode || 5 == document.documentMode),
  IS_EM : "spellcheck" in document.createElement("textarea") && 8 == document.documentMode,
  VML_PREFIX : "v",
  OFFICE_PREFIX : "o",
  IS_NS : null != navigator.userAgent && 0 <= navigator.userAgent.indexOf("Mozilla/") && 0 > navigator.userAgent.indexOf("MSIE") && 0 > navigator.userAgent.indexOf("Edge/"),
  IS_OP : null != navigator.userAgent && (0 <= navigator.userAgent.indexOf("Opera/") || 0 <= navigator.userAgent.indexOf("OPR/")),
  IS_OT : null != navigator.userAgent && 0 <= navigator.userAgent.indexOf("Presto/") && 0 > navigator.userAgent.indexOf("Presto/2.4.") && 0 > navigator.userAgent.indexOf("Presto/2.3.") && 0 > navigator.userAgent.indexOf("Presto/2.2.") && 0 > navigator.userAgent.indexOf("Presto/2.1.") && 0 > navigator.userAgent.indexOf("Presto/2.0.") && 0 > navigator.userAgent.indexOf("Presto/1."),
  IS_SF : /Apple Computer, Inc/.test(navigator.vendor),
  IS_ANDROID : 0 <= navigator.appVersion.indexOf("Android"),
  IS_IOS : /iP(hone|od|ad)/.test(navigator.platform),
  IS_GC : /Google Inc/.test(navigator.vendor),
  IS_CHROMEAPP : null != window.chrome && null != chrome.app && null != chrome.app.runtime,
  IS_FF : "undefined" !== typeof InstallTrigger,
  IS_MT : 0 <= navigator.userAgent.indexOf("Firefox/") && 0 > navigator.userAgent.indexOf("Firefox/1.") && 0 > navigator.userAgent.indexOf("Firefox/2.") || 0 <= navigator.userAgent.indexOf("Iceweasel/") && 0 > navigator.userAgent.indexOf("Iceweasel/1.") && 0 > navigator.userAgent.indexOf("Iceweasel/2.") || 0 <= navigator.userAgent.indexOf("SeaMonkey/") && 0 > navigator.userAgent.indexOf("SeaMonkey/1.") || 0 <= navigator.userAgent.indexOf("Iceape/") && 0 > navigator.userAgent.indexOf("Iceape/1."),
  IS_VML : "MICROSOFT INTERNET EXPLORER" == navigator.appName.toUpperCase(),
  IS_SVG : "MICROSOFT INTERNET EXPLORER" != navigator.appName.toUpperCase(),
  NO_FO : !document.createElementNS || "[object SVGForeignObjectElement]" != document.createElementNS("http://www.w3.org/2000/svg", "foreignObject") || 0 <= navigator.userAgent.indexOf("Opera/"),
  IS_WIN : 0 < navigator.appVersion.indexOf("Win"),
  IS_MAC : 0 < navigator.appVersion.indexOf("Mac"),
  IS_CHROMEOS : /\bCrOS\b/.test(navigator.appVersion),
  IS_TOUCH : "ontouchstart" in document.documentElement,
  IS_POINTER : null != window.PointerEvent && !(0 < navigator.appVersion.indexOf("Mac")),
  IS_LOCAL : 0 > document.location.href.indexOf("http://") && 0 > document.location.href.indexOf("https://"),
  defaultBundles : [],
  isBrowserSupported : function() {
    return mxClient.IS_VML || mxClient.IS_SVG;
  },
  link : function(value, name, context, x) {
    context = context || document;
    if (mxClient.IS_IE6) {
      context.write('<link rel="' + value + '" href="' + name + '" charset="UTF-8" type="text/css"/>');
    } else {
      var res = context.createElement("link");
      res.setAttribute("rel", value);
      res.setAttribute("href", name);
      res.setAttribute("charset", "UTF-8");
      res.setAttribute("type", "text/css");
      if (x) {
        res.setAttribute("id", x);
      }
      context.getElementsByTagName("head")[0].appendChild(res);
    }
  },
  loadResources : function(cb, data) {
    /**
     * @return {undefined}
     */
    function callback() {
      if (0 == --readersLength) {
        cb();
      }
    }
    var readersLength = mxClient.defaultBundles.length;
    /** @type {number} */
    var i = 0;
    for (; i < mxClient.defaultBundles.length; i++) {
      mxResources.add(mxClient.defaultBundles[i], data, callback);
    }
  },
  include : function(controlName) {
    document.write('<script src="' + controlName + '">\x3c/script>');
  }
};
if ("undefined" == typeof mxLoadResources) {
  /** @type {boolean} */
  mxLoadResources = true;
}
if ("undefined" == typeof mxForceIncludes) {
  /** @type {boolean} */
  mxForceIncludes = false;
}
if ("undefined" == typeof mxResourceExtension) {
  /** @type {string} */
  mxResourceExtension = ".txt";
}
if ("undefined" == typeof mxLoadStylesheets) {
  /** @type {boolean} */
  mxLoadStylesheets = true;
}
if ("undefined" != typeof mxBasePath && 0 < mxBasePath.length) {
  if ("/" == mxBasePath.substring(mxBasePath.length - 1)) {
    mxBasePath = mxBasePath.substring(0, mxBasePath.length - 1);
  }
  mxClient.basePath = mxBasePath;
} else {
  /** @type {string} */
  mxClient.basePath = ".";
}
if ("undefined" != typeof mxImageBasePath && 0 < mxImageBasePath.length) {
  if ("/" == mxImageBasePath.substring(mxImageBasePath.length - 1)) {
    mxImageBasePath = mxImageBasePath.substring(0, mxImageBasePath.length - 1);
  }
  mxClient.imageBasePath = mxImageBasePath;
} else {
  /** @type {string} */
  mxClient.imageBasePath = mxClient.basePath + "/images";
}
mxClient.language = "undefined" != typeof mxLanguage && null != mxLanguage ? mxLanguage : mxClient.IS_IE ? navigator.userLanguage : navigator.language;
mxClient.defaultLanguage = "undefined" != typeof mxDefaultLanguage && null != mxDefaultLanguage ? mxDefaultLanguage : "en";
if (mxLoadStylesheets) {
  mxClient.link("stylesheet", mxClient.basePath + "/css/common.css");
}
if ("undefined" != typeof mxLanguages && null != mxLanguages) {
  mxClient.languages = mxLanguages;
}
if (mxClient.IS_VML) {
  if (mxClient.IS_SVG) {
    /** @type {boolean} */
    mxClient.IS_VML = false;
  } else {
    if (null != document.namespaces) {
      if (8 == document.documentMode) {
        document.namespaces.add(mxClient.VML_PREFIX, "urn:schemas-microsoft-com:vml", "#default#VML");
        document.namespaces.add(mxClient.OFFICE_PREFIX, "urn:schemas-microsoft-com:office:office", "#default#VML");
      } else {
        document.namespaces.add(mxClient.VML_PREFIX, "urn:schemas-microsoft-com:vml");
        document.namespaces.add(mxClient.OFFICE_PREFIX, "urn:schemas-microsoft-com:office:office");
      }
    }
    if (mxClient.IS_QUIRKS && 30 <= document.styleSheets.length) {
      (function() {
        /** @type {!Element} */
        var styleTag = document.createElement("style");
        /** @type {string} */
        styleTag.type = "text/css";
        /** @type {string} */
        styleTag.styleSheet.cssText = mxClient.VML_PREFIX + "\\:*{behavior:url(#default#VML)}" + mxClient.OFFICE_PREFIX + "\\:*{behavior:url(#default#VML)}";
        document.getElementsByTagName("head")[0].appendChild(styleTag);
      })();
    } else {
      /** @type {string} */
      document.createStyleSheet().cssText = mxClient.VML_PREFIX + "\\:*{behavior:url(#default#VML)}" + mxClient.OFFICE_PREFIX + "\\:*{behavior:url(#default#VML)}";
    }
    if (mxLoadStylesheets) {
      mxClient.link("stylesheet", mxClient.basePath + "/css/explorer.css");
    }
  }
}
var mxLog = {
  consoleName : "Console",
  TRACE : false,
  DEBUG : true,
  WARN : true,
  buffer : "",
  init : function() {
    if (null == mxLog.window && null != document.body) {
      /** @type {string} */
      var render = mxLog.consoleName + " - mxGraph " + mxClient.VERSION;
      /** @type {!Element} */
      var inShadowTable = document.createElement("table");
      inShadowTable.setAttribute("width", "100%");
      inShadowTable.setAttribute("height", "100%");
      /** @type {!Element} */
      var w = document.createElement("tbody");
      /** @type {!Element} */
      var x = document.createElement("tr");
      /** @type {!Element} */
      var row = document.createElement("td");
      /** @type {string} */
      row.style.verticalAlign = "top";
      /** @type {!Element} */
      mxLog.textarea = document.createElement("textarea");
      mxLog.textarea.setAttribute("wrap", "off");
      mxLog.textarea.setAttribute("readOnly", "true");
      /** @type {string} */
      mxLog.textarea.style.height = "100%";
      /** @type {string} */
      mxLog.textarea.style.resize = "none";
      mxLog.textarea.value = mxLog.buffer;
      /** @type {string} */
      mxLog.textarea.style.width = mxClient.IS_NS && "BackCompat" != document.compatMode ? "99%" : "100%";
      row.appendChild(mxLog.textarea);
      x.appendChild(row);
      w.appendChild(x);
      /** @type {!Element} */
      x = document.createElement("tr");
      /** @type {!Element} */
      mxLog.td = document.createElement("td");
      /** @type {string} */
      mxLog.td.style.verticalAlign = "top";
      mxLog.td.setAttribute("height", "30px");
      x.appendChild(mxLog.td);
      w.appendChild(x);
      inShadowTable.appendChild(w);
      mxLog.addButton("Info", function(a) {
        mxLog.info();
      });
      mxLog.addButton("DOM", function(enrollments) {
        enrollments = mxUtils.getInnerHtml(document.body);
        mxLog.debug(enrollments);
      });
      mxLog.addButton("Trace", function(a) {
        /** @type {boolean} */
        mxLog.TRACE = !mxLog.TRACE;
        if (mxLog.TRACE) {
          mxLog.debug("Tracing enabled");
        } else {
          mxLog.debug("Tracing disabled");
        }
      });
      mxLog.addButton("Copy", function(a) {
        try {
          mxUtils.copy(mxLog.textarea.value);
        } catch (error) {
          mxUtils.alert(error);
        }
      });
      mxLog.addButton("Show", function(a) {
        try {
          mxUtils.popup(mxLog.textarea.value);
        } catch (error) {
          mxUtils.alert(error);
        }
      });
      mxLog.addButton("Clear", function(a) {
        /** @type {string} */
        mxLog.textarea.value = "";
      });
      /** @type {number} */
      x = w = 0;
      if ("number" === typeof window.innerWidth) {
        /** @type {number} */
        w = window.innerHeight;
        /** @type {number} */
        x = window.innerWidth;
      } else {
        /** @type {number} */
        w = document.documentElement.clientHeight || document.body.clientHeight;
        /** @type {number} */
        x = document.body.clientWidth;
      }
      mxLog.window = new mxWindow(render, inShadowTable, Math.max(0, x - 320), Math.max(0, w - 210), 300, 160);
      mxLog.window.setMaximizable(true);
      mxLog.window.setScrollable(false);
      mxLog.window.setResizable(true);
      mxLog.window.setClosable(true);
      /** @type {boolean} */
      mxLog.window.destroyOnClose = false;
      if ((mxClient.IS_NS || mxClient.IS_IE) && !mxClient.IS_GC && !mxClient.IS_SF && "BackCompat" != document.compatMode || 11 == document.documentMode) {
        var viewcontainer = mxLog.window.getElement();
        /**
         * @param {?} url
         * @param {?} callback
         * @return {undefined}
         */
        render = function(url, callback) {
          /** @type {string} */
          mxLog.textarea.style.height = Math.max(0, viewcontainer.offsetHeight - 70) + "px";
        };
        mxLog.window.addListener(mxEvent.RESIZE_END, render);
        mxLog.window.addListener(mxEvent.MAXIMIZE, render);
        mxLog.window.addListener(mxEvent.NORMALIZE, render);
        /** @type {string} */
        mxLog.textarea.style.height = "92px";
      }
    }
  },
  info : function() {
    mxLog.writeln(mxUtils.toString(navigator));
  },
  addButton : function(name, callback) {
    /** @type {!Element} */
    var elt = document.createElement("button");
    mxUtils.write(elt, name);
    mxEvent.addListener(elt, "click", callback);
    mxLog.td.appendChild(elt);
  },
  isVisible : function() {
    return null != mxLog.window ? mxLog.window.isVisible() : false;
  },
  show : function() {
    mxLog.setVisible(true);
  },
  setVisible : function(visible) {
    if (null == mxLog.window) {
      mxLog.init();
    }
    if (null != mxLog.window) {
      mxLog.window.setVisible(visible);
    }
  },
  enter : function(key) {
    if (mxLog.TRACE) {
      return mxLog.writeln("Entering " + key), (new Date).getTime();
    }
  },
  leave : function(config, ast) {
    if (mxLog.TRACE) {
      /** @type {string} */
      var template = 0 != ast ? " (" + ((new Date).getTime() - ast) + " ms)" : "";
      mxLog.writeln("Leaving " + config + template);
    }
  },
  debug : function() {
    if (mxLog.DEBUG) {
      mxLog.writeln.apply(this, arguments);
    }
  },
  warn : function() {
    if (mxLog.WARN) {
      mxLog.writeln.apply(this, arguments);
    }
  },
  write : function() {
    /** @type {string} */
    var str = "";
    /** @type {number} */
    var i = 0;
    for (; i < arguments.length; i++) {
      /** @type {string} */
      str = str + arguments[i];
      if (i < arguments.length - 1) {
        /** @type {string} */
        str = str + " ";
      }
    }
    if (null != mxLog.textarea) {
      mxLog.textarea.value += str;
      if (null != navigator.userAgent && 0 <= navigator.userAgent.indexOf("Presto/2.5")) {
        /** @type {string} */
        mxLog.textarea.style.visibility = "hidden";
        /** @type {string} */
        mxLog.textarea.style.visibility = "visible";
      }
      mxLog.textarea.scrollTop = mxLog.textarea.scrollHeight;
    } else {
      mxLog.buffer += str;
    }
  },
  writeln : function() {
    /** @type {string} */
    var msg = "";
    /** @type {number} */
    var i = 0;
    for (; i < arguments.length; i++) {
      /** @type {string} */
      msg = msg + arguments[i];
      if (i < arguments.length - 1) {
        /** @type {string} */
        msg = msg + " ";
      }
    }
    mxLog.write(msg + "\n");
  }
};
var mxObjectIdentity = {
  FIELD_NAME : "mxObjectId",
  counter : 0,
  get : function(obj) {
    if (null != obj) {
      if (null == obj[mxObjectIdentity.FIELD_NAME]) {
        if ("object" === typeof obj) {
          var uriPathPrefix = mxUtils.getFunctionName(obj.constructor);
          /** @type {string} */
          obj[mxObjectIdentity.FIELD_NAME] = uriPathPrefix + "#" + mxObjectIdentity.counter++;
        } else {
          if ("function" === typeof obj) {
            /** @type {string} */
            obj[mxObjectIdentity.FIELD_NAME] = "Function#" + mxObjectIdentity.counter++;
          }
        }
      }
      return obj[mxObjectIdentity.FIELD_NAME];
    }
    return null;
  },
  clear : function(object) {
    if (!("object" !== typeof object && "function" !== typeof object)) {
      delete object[mxObjectIdentity.FIELD_NAME];
    }
  }
};
/**
 * @return {undefined}
 */
function mxDictionary() {
  this.clear();
}
/** @type {null} */
mxDictionary.prototype.map = null;
/**
 * @return {undefined}
 */
mxDictionary.prototype.clear = function() {
  this.map = {};
};
/**
 * @param {!Object} val
 * @return {?}
 */
mxDictionary.prototype.get = function(val) {
  val = mxObjectIdentity.get(val);
  return this.map[val];
};
/**
 * @param {!Object} data
 * @param {string} val
 * @return {?}
 */
mxDictionary.prototype.put = function(data, val) {
  var i = mxObjectIdentity.get(data);
  var entry = this.map[i];
  /** @type {string} */
  this.map[i] = val;
  return entry;
};
/**
 * @param {!Object} prop
 * @return {?}
 */
mxDictionary.prototype.remove = function(prop) {
  prop = mxObjectIdentity.get(prop);
  var oldValue = this.map[prop];
  delete this.map[prop];
  return oldValue;
};
/**
 * @return {?}
 */
mxDictionary.prototype.getKeys = function() {
  /** @type {!Array} */
  var buffer = [];
  var id;
  for (id in this.map) {
    buffer.push(id);
  }
  return buffer;
};
/**
 * @return {?}
 */
mxDictionary.prototype.getValues = function() {
  /** @type {!Array} */
  var values = [];
  var i;
  for (i in this.map) {
    values.push(this.map[i]);
  }
  return values;
};
/**
 * @param {!Function} callback
 * @return {undefined}
 */
mxDictionary.prototype.visit = function(callback) {
  var i;
  for (i in this.map) {
    callback(i, this.map[i]);
  }
};
var mxResources = {
  resources : {},
  extension : mxResourceExtension,
  resourcesEncoded : false,
  loadDefaultBundle : true,
  loadSpecialBundle : true,
  isLanguageSupported : function(value) {
    return null != mxClient.languages ? 0 <= mxUtils.indexOf(mxClient.languages, value) : true;
  },
  getDefaultBundle : function(view, key) {
    return mxResources.loadDefaultBundle || !mxResources.isLanguageSupported(key) ? view + mxResources.extension : null;
  },
  getSpecialBundle : function(containerName, key) {
    if (null == mxClient.languages || !this.isLanguageSupported(key)) {
      var c = key.indexOf("-");
      if (0 < c) {
        key = key.substring(0, c);
      }
    }
    return mxResources.loadSpecialBundle && mxResources.isLanguageSupported(key) && key != mxClient.defaultLanguage ? containerName + "_" + key + mxResources.extension : null;
  },
  add : function(name, e, value) {
    e = null != e ? e : null != mxClient.language ? mxClient.language.toLowerCase() : mxConstants.NONE;
    if (e != mxConstants.NONE) {
      var link = mxResources.getDefaultBundle(name, e);
      var value = mxResources.getSpecialBundle(name, e);
      /**
       * @return {undefined}
       */
      var init = function() {
        if (null != value) {
          if (value) {
            mxUtils.get(value, function(status_tweet) {
              mxResources.parse(status_tweet.getText());
              value();
            }, function() {
              value();
            });
          } else {
            try {
              var indicator = mxUtils.load(value);
              if (indicator.isReady()) {
                mxResources.parse(indicator.getText());
              }
            } catch (l) {
            }
          }
        } else {
          if (null != value) {
            value();
          }
        }
      };
      if (null != link) {
        if (value) {
          mxUtils.get(link, function(status_tweet) {
            mxResources.parse(status_tweet.getText());
            init();
          }, function() {
            init();
          });
        } else {
          try {
            var debug = mxUtils.load(link);
            if (debug.isReady()) {
              mxResources.parse(debug.getText());
            }
            init();
          } catch (k) {
          }
        }
      } else {
        init();
      }
    }
  },
  parse : function(tokens) {
    if (null != tokens) {
      tokens = tokens.split("\n");
      /** @type {number} */
      var j = 0;
      for (; j < tokens.length; j++) {
        if ("#" != tokens[j].charAt(0)) {
          var index = tokens[j].indexOf("=");
          if (0 < index) {
            var i = tokens[j].substring(0, index);
            var length = tokens[j].length;
            if (13 == tokens[j].charCodeAt(length - 1)) {
              length--;
            }
            index = tokens[j].substring(index + 1, length);
            if (this.resourcesEncoded) {
              index = index.replace(/\\(?=u[a-fA-F\d]{4})/g, "%");
              /** @type {string} */
              mxResources.resources[i] = unescape(index);
            } else {
              mxResources.resources[i] = index;
            }
          }
        }
      }
    }
  },
  get : function(name, idx, _) {
    name = mxResources.resources[name];
    if (null == name) {
      /** @type {!Function} */
      name = _;
    }
    if (null != name && null != idx) {
      name = mxResources.replacePlaceholders(name, idx);
    }
    return name;
  },
  replacePlaceholders : function(index, text) {
    /** @type {!Array} */
    var newtext = [];
    /** @type {null} */
    var i = null;
    /** @type {number} */
    var x = 0;
    for (; x < index.length; x++) {
      var mil = index.charAt(x);
      if ("{" == mil) {
        /** @type {string} */
        i = "";
      } else {
        if (null != i && "}" == mil) {
          /** @type {number} */
          i = parseInt(i) - 1;
          if (0 <= i && i < text.length) {
            newtext.push(text[i]);
          }
          /** @type {null} */
          i = null;
        } else {
          if (null != i) {
            /** @type {string} */
            i = i + mil;
          } else {
            newtext.push(mil);
          }
        }
      }
    }
    return newtext.join("");
  },
  loadResources : function(callback) {
    mxResources.add(mxClient.basePath + "/resources/editor", null, function() {
      mxResources.add(mxClient.basePath + "/resources/graph", null, callback);
    });
  }
};
/**
 * @param {number} a
 * @param {number} b
 * @return {undefined}
 */
function mxPoint(a, b) {
  this.x = null != a ? a : 0;
  this.y = null != b ? b : 0;
}
/** @type {null} */
mxPoint.prototype.x = null;
/** @type {null} */
mxPoint.prototype.y = null;
/**
 * @param {!Object} current
 * @return {?}
 */
mxPoint.prototype.equals = function(current) {
  return null != current && current.x == this.x && current.y == this.y;
};
/**
 * @return {?}
 */
mxPoint.prototype.clone = function() {
  return mxUtils.clone(this);
};
/**
 * @param {?} callback
 * @param {?} lineNumber
 * @param {number} width
 * @param {number} height
 * @return {undefined}
 */
function mxRectangle(callback, lineNumber, width, height) {
  mxPoint.call(this, callback, lineNumber);
  this.width = null != width ? width : 0;
  this.height = null != height ? height : 0;
}
mxRectangle.prototype = new mxPoint;
/** @type {function(?, ?, number, number): undefined} */
mxRectangle.prototype.constructor = mxRectangle;
/** @type {null} */
mxRectangle.prototype.width = null;
/** @type {null} */
mxRectangle.prototype.height = null;
/**
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @return {undefined}
 */
mxRectangle.prototype.setRect = function(x, y, width, height) {
  /** @type {number} */
  this.x = x;
  /** @type {number} */
  this.y = y;
  /** @type {number} */
  this.width = width;
  /** @type {number} */
  this.height = height;
};
/**
 * @return {?}
 */
mxRectangle.prototype.getCenterX = function() {
  return this.x + this.width / 2;
};
/**
 * @return {?}
 */
mxRectangle.prototype.getCenterY = function() {
  return this.y + this.height / 2;
};
/**
 * @param {number} value
 * @return {undefined}
 */
mxRectangle.prototype.add = function(value) {
  if (null != value) {
    /** @type {number} */
    var x = Math.min(this.x, value.x);
    /** @type {number} */
    var y = Math.min(this.y, value.y);
    /** @type {number} */
    var w = Math.max(this.x + this.width, value.x + value.width);
    /** @type {number} */
    value = Math.max(this.y + this.height, value.y + value.height);
    /** @type {number} */
    this.x = x;
    /** @type {number} */
    this.y = y;
    /** @type {number} */
    this.width = w - x;
    /** @type {number} */
    this.height = value - y;
  }
};
/**
 * @param {!Object} other
 * @return {undefined}
 */
mxRectangle.prototype.intersect = function(other) {
  if (null != other) {
    var ax2 = this.x + this.width;
    var dtStep = other.x + other.width;
    var y = this.y + this.height;
    var imgNowHeight = other.y + other.height;
    /** @type {number} */
    this.x = Math.max(this.x, other.x);
    /** @type {number} */
    this.y = Math.max(this.y, other.y);
    /** @type {number} */
    this.width = Math.min(ax2, dtStep) - this.x;
    /** @type {number} */
    this.height = Math.min(y, imgNowHeight) - this.y;
  }
};
/**
 * @param {number} x
 * @return {?}
 */
mxRectangle.prototype.grow = function(x) {
  this.x -= x;
  this.y -= x;
  this.width += 2 * x;
  this.height += 2 * x;
  return this;
};
/**
 * @return {?}
 */
mxRectangle.prototype.getPoint = function() {
  return new mxPoint(this.x, this.y);
};
/**
 * @return {undefined}
 */
mxRectangle.prototype.rotate90 = function() {
  /** @type {number} */
  var x = (this.width - this.height) / 2;
  this.x += x;
  this.y -= x;
  x = this.width;
  this.width = this.height;
  this.height = x;
};
/**
 * @param {!Object} current
 * @return {?}
 */
mxRectangle.prototype.equals = function(current) {
  return null != current && current.x == this.x && current.y == this.y && current.width == this.width && current.height == this.height;
};
/**
 * @param {?} obj
 * @return {?}
 */
mxRectangle.fromRectangle = function(obj) {
  return new mxRectangle(obj.x, obj.y, obj.width, obj.height);
};
var mxEffects = {
  animateChanges : function(r, changes, done) {
    /** @type {number} */
    var squanchiness = 0;
    /**
     * @return {undefined}
     */
    var draw = function() {
      /** @type {boolean} */
      var hasCharacters = false;
      /** @type {number} */
      var i = 0;
      for (; i < changes.length; i++) {
        var change = changes[i];
        if (change instanceof mxGeometryChange || change instanceof mxTerminalChange || change instanceof mxValueChange || change instanceof mxChildChange || change instanceof mxStyleChange) {
          var node = r.getView().getState(change.cell || change.child, false);
          if (null != node) {
            if (hasCharacters = true, change.constructor != mxGeometryChange || r.model.isEdge(change.cell)) {
              mxUtils.setOpacity(node.shape.node, 100 * squanchiness / 10);
            } else {
              var s = r.getView().scale;
              /** @type {number} */
              var x = (change.geometry.x - change.previous.x) * s;
              /** @type {number} */
              var dy = (change.geometry.y - change.previous.y) * s;
              /** @type {number} */
              var w = (change.geometry.width - change.previous.width) * s;
              /** @type {number} */
              s = (change.geometry.height - change.previous.height) * s;
              if (0 == squanchiness) {
                node.x -= x;
                node.y -= dy;
                node.width -= w;
                node.height -= s;
              } else {
                node.x += x / 10;
                node.y += dy / 10;
                node.width += w / 10;
                node.height += s / 10;
              }
              r.cellRenderer.redraw(node);
              mxEffects.cascadeOpacity(r, change.cell, 100 * squanchiness / 10);
            }
          }
        }
      }
      if (10 > squanchiness && hasCharacters) {
        squanchiness++;
        window.setTimeout(draw, renewTokenIn);
      } else {
        if (null != done) {
          done();
        }
      }
    };
    /** @type {number} */
    var renewTokenIn = 30;
    draw();
  },
  cascadeOpacity : function(self, start, value) {
    var d = self.model.getChildCount(start);
    /** @type {number} */
    var i = 0;
    for (; i < d; i++) {
      var token = self.model.getChildAt(start, i);
      var message = self.getView().getState(token);
      if (null != message) {
        mxUtils.setOpacity(message.shape.node, value);
        mxEffects.cascadeOpacity(self, token, value);
      }
    }
    start = self.model.getEdges(start);
    if (null != start) {
      /** @type {number} */
      i = 0;
      for (; i < start.length; i++) {
        d = self.getView().getState(start[i]);
        if (null != d) {
          mxUtils.setOpacity(d.shape.node, value);
        }
      }
    }
  },
  fadeOut : function(node, color, name, val, duration, targetVol) {
    val = val || 40;
    duration = duration || 30;
    var value = color || 100;
    mxUtils.setOpacity(node, value);
    if (targetVol || null == targetVol) {
      /**
       * @return {undefined}
       */
      var tick = function() {
        /** @type {number} */
        value = Math.max(value - val, 0);
        mxUtils.setOpacity(node, value);
        if (0 < value) {
          window.setTimeout(tick, duration);
        } else {
          /** @type {string} */
          node.style.visibility = "hidden";
          if (name && node.parentNode) {
            node.parentNode.removeChild(node);
          }
        }
      };
      window.setTimeout(tick, duration);
    } else {
      /** @type {string} */
      node.style.visibility = "hidden";
      if (name && node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
  }
};
var mxUtils = {
  errorResource : "none" != mxClient.language ? "error" : "",
  closeResource : "none" != mxClient.language ? "close" : "",
  errorImage : mxClient.imageBasePath + "/error.gif",
  removeCursors : function(root) {
    if (null != root.style) {
      /** @type {string} */
      root.style.cursor = "";
    }
    root = root.childNodes;
    if (null != root) {
      var l = root.length;
      /** @type {number} */
      var i = 0;
      for (; i < l; i = i + 1) {
        mxUtils.removeCursors(root[i]);
      }
    }
  },
  getCurrentStyle : function() {
    return mxClient.IS_IE && (null == document.documentMode || 9 > document.documentMode) ? function(o) {
      return null != o ? o.currentStyle : null;
    } : function(DOMNode) {
      return null != DOMNode ? window.getComputedStyle(DOMNode, "") : null;
    };
  }(),
  parseCssNumber : function(a) {
    if ("thin" == a) {
      /** @type {string} */
      a = "2";
    } else {
      if ("medium" == a) {
        /** @type {string} */
        a = "4";
      } else {
        if ("thick" == a) {
          /** @type {string} */
          a = "6";
        }
      }
    }
    /** @type {number} */
    a = parseFloat(a);
    if (isNaN(a)) {
      /** @type {number} */
      a = 0;
    }
    return a;
  },
  setPrefixedStyle : function() {
    /** @type {null} */
    var vendorCssPrefixJS = null;
    if (mxClient.IS_OT) {
      /** @type {string} */
      vendorCssPrefixJS = "O";
    } else {
      if (mxClient.IS_SF || mxClient.IS_GC) {
        /** @type {string} */
        vendorCssPrefixJS = "Webkit";
      } else {
        if (mxClient.IS_MT) {
          /** @type {string} */
          vendorCssPrefixJS = "Moz";
        } else {
          if (mxClient.IS_IE && 9 <= document.documentMode && 10 > document.documentMode) {
            /** @type {string} */
            vendorCssPrefixJS = "ms";
          }
        }
      }
    }
    return function(colVisible, c, newVisible) {
      colVisible[c] = newVisible;
      if (null != vendorCssPrefixJS && 0 < c.length) {
        c = vendorCssPrefixJS + c.substring(0, 1).toUpperCase() + c.substring(1);
        colVisible[c] = newVisible;
      }
    };
  }(),
  hasScrollbars : function(settings) {
    settings = mxUtils.getCurrentStyle(settings);
    return null != settings && ("scroll" == settings.overflow || "auto" == settings.overflow);
  },
  bind : function(a, f) {
    return function() {
      return f.apply(a, arguments);
    };
  },
  eval : function(a$jscomp$57) {
    /** @type {null} */
    var b$jscomp$31 = null;
    if (0 <= a$jscomp$57.indexOf("function")) {
      try {
        eval("var _mxJavaScriptExpression=" + a$jscomp$57);
        b$jscomp$31 = _mxJavaScriptExpression;
        /** @type {null} */
        _mxJavaScriptExpression = null;
      } catch (controlFlowAction) {
        mxLog.warn(controlFlowAction.message + " while evaluating " + a$jscomp$57);
      }
    } else {
      try {
        /** @type {*} */
        b$jscomp$31 = eval(a$jscomp$57);
      } catch (controlFlowAction) {
        mxLog.warn(controlFlowAction.message + " while evaluating " + a$jscomp$57);
      }
    }
    return b$jscomp$31;
  },
  findNode : function(node, value, root) {
    if (node.nodeType == mxConstants.NODETYPE_ELEMENT) {
      var result = node.getAttribute(value);
      if (null != result && result == root) {
        return node;
      }
    }
    node = node.firstChild;
    for (; null != node;) {
      result = mxUtils.findNode(node, value, root);
      if (null != result) {
        return result;
      }
      node = node.nextSibling;
    }
    return null;
  },
  getFunctionName : function(v) {
    /** @type {null} */
    var ret = null;
    if (null != v) {
      if (null != v.name) {
        ret = v.name;
      } else {
        ret = mxUtils.trim(v.toString());
        if (/^function\s/.test(ret)) {
          ret = mxUtils.ltrim(ret.substring(9));
          v = ret.indexOf("(");
          if (0 < v) {
            ret = ret.substring(0, v);
          }
        }
      }
    }
    return ret;
  },
  indexOf : function(str, s) {
    if (null != str && null != s) {
      /** @type {number} */
      var i = 0;
      for (; i < str.length; i++) {
        if (str[i] == s) {
          return i;
        }
      }
    }
    return -1;
  },
  forEach : function(array, iteratee) {
    if (null != array && null != iteratee) {
      /** @type {number} */
      var i = 0;
      for (; i < array.length; i++) {
        iteratee(array[i]);
      }
    }
    return array;
  },
  remove : function(value, data) {
    /** @type {null} */
    var _file = null;
    if ("object" == typeof data) {
      var d = mxUtils.indexOf(data, value);
      for (; 0 <= d;) {
        data.splice(d, 1);
        /** @type {!Object} */
        _file = value;
        d = mxUtils.indexOf(data, value);
      }
    }
    var i;
    for (i in data) {
      if (data[i] == value) {
        delete data[i];
        /** @type {!Object} */
        _file = value;
      }
    }
    return _file;
  },
  isNode : function(value, type, element, index) {
    return null == value || isNaN(value.nodeType) || null != type && value.nodeName.toLowerCase() != type.toLowerCase() ? false : null == element || value.getAttribute(element) == index;
  },
  isAncestorNode : function(ancestor, node) {
    var n = node;
    for (; null != n;) {
      if (n == ancestor) {
        return true;
      }
      n = n.parentNode;
    }
    return false;
  },
  getChildNodes : function(parent, type) {
    type = type || mxConstants.NODETYPE_ELEMENT;
    /** @type {!Array} */
    var nodes = [];
    var node = parent.firstChild;
    for (; null != node;) {
      if (node.nodeType == type) {
        nodes.push(node);
      }
      node = node.nextSibling;
    }
    return nodes;
  },
  importNode : function(doc, node, importChildren) {
    return mxClient.IS_IE && (null == document.documentMode || 10 > document.documentMode) ? mxUtils.importNodeImplementation(doc, node, importChildren) : doc.importNode(node, importChildren);
  },
  importNodeImplementation : function(document, node, allChildren) {
    switch(node.nodeType) {
      case 1:
        var newNode = document.createElement(node.nodeName);
        if (node.attributes && 0 < node.attributes.length) {
          /** @type {number} */
          var i = 0;
          for (; i < node.attributes.length; i++) {
            newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i].nodeName));
          }
        }
        if (allChildren && node.childNodes && 0 < node.childNodes.length) {
          /** @type {number} */
          i = 0;
          for (; i < node.childNodes.length; i++) {
            newNode.appendChild(mxUtils.importNodeImplementation(document, node.childNodes[i], allChildren));
          }
        }
        return newNode;
      case 3:
      case 4:
      case 8:
        return document.createTextNode(null != node.nodeValue ? node.nodeValue : node.value);
    }
  },
  createXmlDocument : function() {
    /** @type {null} */
    var doc = null;
    if (document.implementation && document.implementation.createDocument) {
      /** @type {(Document|null)} */
      doc = document.implementation.createDocument("", "", null);
    } else {
      if ("ActiveXObject" in window) {
        doc = mxUtils.createMsXmlDocument();
      }
    }
    return doc;
  },
  createMsXmlDocument : function() {
    var doc = new ActiveXObject("Microsoft.XMLDOM");
    /** @type {boolean} */
    doc.async = false;
    /** @type {boolean} */
    doc.validateOnParse = false;
    /** @type {boolean} */
    doc.resolveExternals = false;
    return doc;
  },
  parseXml : function() {
    return window.DOMParser ? function(content_string) {
      return (new DOMParser).parseFromString(content_string, "text/xml");
    } : function(inputXML) {
      var XMLdoc = mxUtils.createMsXmlDocument();
      XMLdoc.loadXML(inputXML);
      return XMLdoc;
    };
  }(),
  clearSelection : function() {
    return document.selection ? function() {
      document.selection.empty();
    } : window.getSelection ? function() {
      if (window.getSelection().empty) {
        window.getSelection().empty();
      } else {
        if (window.getSelection().removeAllRanges) {
          window.getSelection().removeAllRanges();
        }
      }
    } : function() {
    };
  }(),
  removeWhitespace : function(el, left) {
    var node = left ? el.previousSibling : el.nextSibling;
    for (; null != node && node.nodeType == mxConstants.NODETYPE_TEXT;) {
      var x = left ? node.previousSibling : node.nextSibling;
      var style = mxUtils.getTextContent(node);
      if (0 == mxUtils.trim(style).length) {
        node.parentNode.removeChild(node);
      }
      node = x;
    }
  },
  htmlEntities : function(text, str) {
    /** @type {string} */
    text = String(text || "");
    /** @type {string} */
    text = text.replace(/&/g, "&amp;");
    /** @type {string} */
    text = text.replace(/"/g, "&quot;");
    /** @type {string} */
    text = text.replace(/'/g, "&#39;");
    /** @type {string} */
    text = text.replace(/</g, "&lt;");
    /** @type {string} */
    text = text.replace(/>/g, "&gt;");
    if (null == str || str) {
      /** @type {string} */
      text = text.replace(/\n/g, "&#xa;");
    }
    return text;
  },
  isVml : function(element) {
    return null != element && "urn:schemas-microsoft-com:vml" == element.tagUrn;
  },
  getXml : function(node, type) {
    /** @type {string} */
    var msg = "";
    if (mxClient.IS_IE || mxClient.IS_IE11) {
      msg = mxUtils.getPrettyXml(node, "", "", "");
    } else {
      if (null != window.XMLSerializer) {
        /** @type {string} */
        msg = (new XMLSerializer).serializeToString(node);
      } else {
        if (null != node.xml) {
          msg = node.xml.replace(/\r\n\t[\t]*/g, "").replace(/>\r\n/g, ">").replace(/\r\n/g, "\n");
        }
      }
    }
    return msg = msg.replace(/\n/g, type || "&#xa;");
  },
  getPrettyXml : function(node, e, i, obj, t) {
    /** @type {!Array} */
    var result = [];
    if (null != node) {
      if (e = null != e ? e : "  ", i = null != i ? i : "", obj = null != obj ? obj : "\n", null != node.namespaceURI && node.namespaceURI != t && (t = node.namespaceURI, null == node.getAttribute("xmlns") && node.setAttribute("xmlns", node.namespaceURI)), node.nodeType == mxConstants.NODETYPE_DOCUMENT) {
        result.push(mxUtils.getPrettyXml(node.documentElement, e, i, obj, t));
      } else {
        if (node.nodeType == mxConstants.NODETYPE_DOCUMENT_FRAGMENT) {
          var item = node.firstChild;
          if (null != item) {
            for (; null != item;) {
              result.push(mxUtils.getPrettyXml(item, e, i, obj, t));
              item = item.nextSibling;
            }
          }
        } else {
          if (node.nodeType == mxConstants.NODETYPE_COMMENT) {
            node = mxUtils.getTextContent(node);
            if (0 < node.length) {
              result.push(i + "\x3c!--" + node + "--\x3e" + obj);
            }
          } else {
            if (node.nodeType == mxConstants.NODETYPE_TEXT) {
              node = mxUtils.trim(mxUtils.getTextContent(node));
              if (0 < node.length) {
                result.push(i + mxUtils.htmlEntities(node, false) + obj);
              }
            } else {
              if (node.nodeType == mxConstants.NODETYPE_CDATA) {
                node = mxUtils.getTextContent(node);
                if (0 < node.length) {
                  result.push(i + "<![CDATA[" + node + "]]" + obj);
                }
              } else {
                result.push(i + "<" + node.nodeName);
                item = node.attributes;
                if (null != item) {
                  /** @type {number} */
                  var i = 0;
                  for (; i < item.length; i++) {
                    var l = mxUtils.htmlEntities(item[i].value);
                    result.push(" " + item[i].nodeName + '="' + l + '"');
                  }
                }
                item = node.firstChild;
                if (null != item) {
                  result.push(">" + obj);
                  for (; null != item;) {
                    result.push(mxUtils.getPrettyXml(item, e, i + e, obj, t));
                    item = item.nextSibling;
                  }
                  result.push(i + "</" + node.nodeName + ">" + obj);
                } else {
                  result.push(" />" + obj);
                }
              }
            }
          }
        }
      }
    }
    return result.join("");
  },
  extractTextWithWhitespace : function(text) {
    /**
     * @param {!Object} elems
     * @return {undefined}
     */
    function getText(elems) {
      if (1 != elems.length || "BR" != elems[0].nodeName && "\n" != elems[0].innerHTML) {
        /** @type {number} */
        var i = 0;
        for (; i < elems.length; i++) {
          var node = elems[i];
          if ("BR" == node.nodeName || "\n" == node.innerHTML || (1 == elems.length || 0 == i) && "DIV" == node.nodeName && "<br>" == node.innerHTML.toLowerCase()) {
            nodeValues.push("\n");
          } else {
            if (3 === node.nodeType || 4 === node.nodeType) {
              if (0 < node.nodeValue.length) {
                nodeValues.push(node.nodeValue);
              }
            } else {
              if (8 !== node.nodeType && 0 < node.childNodes.length) {
                getText(node.childNodes);
              }
            }
            if (i < elems.length - 1 && 0 <= mxUtils.indexOf(str, elems[i + 1].nodeName)) {
              nodeValues.push("\n");
            }
          }
        }
      }
    }
    /** @type {!Array<string>} */
    var str = "BLOCKQUOTE DIV H1 H2 H3 H4 H5 H6 OL P PRE TABLE UL".split(" ");
    /** @type {!Array} */
    var nodeValues = [];
    getText(text);
    return nodeValues.join("");
  },
  replaceTrailingNewlines : function(value, i) {
    /** @type {string} */
    var s = "";
    for (; 0 < value.length && "\n" == value.charAt(value.length - 1);) {
      value = value.substring(0, value.length - 1);
      /** @type {string} */
      s = s + i;
    }
    return value + s;
  },
  getTextContent : function(el) {
    return mxClient.IS_IE && void 0 !== el.innerText ? el.innerText : null != el ? el[void 0 === el.textContent ? "text" : "textContent"] : "";
  },
  setTextContent : function(node, value) {
    if (void 0 !== node.innerText) {
      /** @type {string} */
      node.innerText = value;
    } else {
      /** @type {string} */
      node[void 0 === node.textContent ? "text" : "textContent"] = value;
    }
  },
  getInnerHtml : function() {
    return mxClient.IS_IE ? function(result) {
      return null != result ? result.innerHTML : "";
    } : function(n) {
      return null != n ? (new XMLSerializer).serializeToString(n) : "";
    };
  }(),
  getOuterHtml : function() {
    return mxClient.IS_IE ? function(c) {
      if (null != c) {
        if (null != c.outerHTML) {
          return c.outerHTML;
        }
        /** @type {!Array} */
        var e = [];
        e.push("<" + c.nodeName);
        var n = c.attributes;
        if (null != n) {
          /** @type {number} */
          var i = 0;
          for (; i < n.length; i++) {
            var b = n[i].value;
            if (null != b && 0 < b.length) {
              e.push(" ");
              e.push(n[i].nodeName);
              e.push('="');
              e.push(b);
              e.push('"');
            }
          }
        }
        if (0 == c.innerHTML.length) {
          e.push("/>");
        } else {
          e.push(">");
          e.push(c.innerHTML);
          e.push("</" + c.nodeName + ">");
        }
        return e.join("");
      }
      return "";
    } : function(n) {
      return null != n ? (new XMLSerializer).serializeToString(n) : "";
    };
  }(),
  write : function(parent, val) {
    var newNode = parent.ownerDocument.createTextNode(val);
    if (null != parent) {
      parent.appendChild(newNode);
    }
    return newNode;
  },
  writeln : function(e, text) {
    var out = e.ownerDocument.createTextNode(text);
    if (null != e) {
      e.appendChild(out);
      e.appendChild(document.createElement("br"));
    }
    return out;
  },
  br : function(a, b) {
    b = b || 1;
    /** @type {null} */
    var entry = null;
    /** @type {number} */
    var a = 0;
    for (; a < b; a++) {
      if (null != a) {
        entry = a.ownerDocument.createElement("br");
        a.appendChild(entry);
      }
    }
    return entry;
  },
  button : function(value, action, node) {
    node = null != node ? node : document;
    node = node.createElement("button");
    mxUtils.write(node, value);
    mxEvent.addListener(node, "click", function(toggler) {
      action(toggler);
    });
    return node;
  },
  para : function(block, next) {
    /** @type {!Element} */
    var p = document.createElement("p");
    mxUtils.write(p, next);
    if (null != block) {
      block.appendChild(p);
    }
    return p;
  },
  addTransparentBackgroundFilter : function(o) {
    o.style.filter += "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + mxClient.imageBasePath + "/transparent.gif', sizingMethod='scale')";
  },
  linkAction : function(value, link, action, path, transform) {
    return mxUtils.link(value, link, function() {
      action.execute(path);
    }, transform);
  },
  linkInvoke : function(link, value, _, func, arr, ct) {
    return mxUtils.link(link, value, function() {
      _[func](arr);
    }, ct);
  },
  link : function(key, value, scope, x) {
    /** @type {!Element} */
    var node = document.createElement("span");
    /** @type {string} */
    node.style.color = "blue";
    /** @type {string} */
    node.style.textDecoration = "underline";
    /** @type {string} */
    node.style.cursor = "pointer";
    if (null != x) {
      /** @type {string} */
      node.style.paddingLeft = x + "px";
    }
    mxEvent.addListener(node, "click", scope);
    mxUtils.write(node, value);
    if (null != key) {
      key.appendChild(node);
    }
    return node;
  },
  getDocumentSize : function() {
    /** @type {!HTMLBodyElement} */
    var el = document.body;
    /** @type {!Element} */
    var doc = document.documentElement;
    try {
      return new mxRectangle(0, 0, el.clientWidth || doc.clientWidth, Math.max(el.clientHeight || 0, doc.clientHeight));
    } catch (c) {
      return new mxRectangle;
    }
  },
  fit : function(obj) {
    var b = mxUtils.getDocumentSize();
    /** @type {number} */
    var start = parseInt(obj.offsetLeft);
    /** @type {number} */
    var offset = parseInt(obj.offsetWidth);
    var t = mxUtils.getDocumentScrollOrigin(obj.ownerDocument);
    var a = t.x;
    t = t.y;
    var length = a + b.width;
    if (start + offset > length) {
      /** @type {string} */
      obj.style.left = Math.max(a, length - offset) + "px";
    }
    /** @type {number} */
    start = parseInt(obj.offsetTop);
    /** @type {number} */
    offset = parseInt(obj.offsetHeight);
    b = t + b.height;
    if (start + offset > b) {
      /** @type {string} */
      obj.style.top = Math.max(t, b - offset) + "px";
    }
  },
  load : function(value) {
    value = new mxXmlRequest(value, null, "GET", false);
    value.send();
    return value;
  },
  get : function(a, v, data, value, fn, message, headers) {
    a = new mxXmlRequest(a, null, "GET");
    /** @type {function(!Object, ?): undefined} */
    var k = a.setRequestHeaders;
    if (headers) {
      /**
       * @param {!Object} xhr
       * @param {?} request
       * @return {undefined}
       */
      a.setRequestHeaders = function(xhr, request) {
        k.apply(this, arguments);
        var i;
        for (i in headers) {
          xhr.setRequestHeader(i, headers[i]);
        }
      };
    }
    if (null != value) {
      a.setBinary(value);
    }
    a.send(v, data, fn, message);
    return a;
  },
  getAll : function(t, table, c) {
    var pal = t.length;
    /** @type {!Array} */
    var output = [];
    /** @type {number} */
    var buffer = 0;
    /**
     * @return {undefined}
     */
    var success = function() {
      if (0 == buffer && null != c) {
        c();
      }
      buffer++;
    };
    /** @type {number} */
    var j = 0;
    for (; j < t.length; j++) {
      (function(value, file) {
        mxUtils.get(value, function(p) {
          var f = p.getStatus();
          if (200 > f || 299 < f) {
            success();
          } else {
            /** @type {(Object|string)} */
            output[file] = p;
            pal--;
            if (0 == pal) {
              table(output);
            }
          }
        }, success);
      })(t[j], j);
    }
    if (0 == pal) {
      table(output);
    }
  },
  post : function(options, callback, e, path) {
    return (new mxXmlRequest(options, callback)).send(e, path);
  },
  submit : function(json, template, element, event) {
    return (new mxXmlRequest(json, template)).simulate(element, event);
  },
  loadInto : function(options, doc, fn) {
    if (mxClient.IS_IE) {
      /**
       * @return {undefined}
       */
      doc.onreadystatechange = function() {
        if (4 == doc.readyState) {
          fn();
        }
      };
    } else {
      doc.addEventListener("load", fn, false);
    }
    doc.load(options);
  },
  getValue : function(obj, item, id) {
    obj = null != obj ? obj[item] : null;
    if (null == obj) {
      /** @type {number} */
      obj = id;
    }
    return obj;
  },
  getNumber : function(string, i, n) {
    string = null != string ? string[i] : null;
    if (null == string) {
      string = n || 0;
    }
    return Number(string);
  },
  getColor : function(state, type, all) {
    state = null != state ? state[type] : null;
    if (null == state) {
      /** @type {string} */
      state = all;
    } else {
      if (state == mxConstants.NONE) {
        /** @type {null} */
        state = null;
      }
    }
    return state;
  },
  clone : function(array, result, parent) {
    parent = null != parent ? parent : false;
    /** @type {null} */
    var rrs = null;
    if (null != array && "function" == typeof array.constructor) {
      rrs = new array.constructor;
      var i;
      for (i in array) {
        if (i != mxObjectIdentity.FIELD_NAME && (null == result || 0 > mxUtils.indexOf(result, i))) {
          rrs[i] = parent || "object" != typeof array[i] ? array[i] : mxUtils.clone(array[i]);
        }
      }
    }
    return rrs;
  },
  equalPoints : function(a, b) {
    if (null == a && null != b || null != a && null == b || null != a && null != b && a.length != b.length) {
      return false;
    }
    if (null != a && null != b) {
      /** @type {number} */
      var i = 0;
      for (; i < a.length; i++) {
        if (null != a[i] && null == b[i] || null == a[i] && null != b[i] || null != a[i] && null != b[i] && (a[i].x != b[i].x || a[i].y != b[i].y)) {
          return false;
        }
      }
    }
    return true;
  },
  equalEntries : function(data, values) {
    /** @type {number} */
    var c = 0;
    if (null == data && null != values || null != data && null == values || null != data && null != values && data.length != values.length) {
      return false;
    }
    if (null != data && null != values) {
      var i;
      for (i in values) {
        c++;
      }
      for (i in data) {
        if (c--, !(mxUtils.isNaN(data[i]) && mxUtils.isNaN(values[i]) || data[i] == values[i])) {
          return false;
        }
      }
    }
    return 0 == c;
  },
  removeDuplicates : function(a) {
    var r = new mxDictionary;
    /** @type {!Array} */
    var result = [];
    /** @type {number} */
    var i = 0;
    for (; i < a.length; i++) {
      if (!r.get(a[i])) {
        result.push(a[i]);
        r.put(a[i], true);
      }
    }
    return result;
  },
  isNaN : function(value) {
    return "number" == typeof value && isNaN(value);
  },
  extend : function(ctor, target) {
    /**
     * @return {undefined}
     */
    var F = function() {
    };
    F.prototype = target.prototype;
    ctor.prototype = new F;
    /** @type {string} */
    ctor.prototype.constructor = ctor;
  },
  toString : function(obj) {
    /** @type {string} */
    var string = "";
    var prop;
    for (prop in obj) {
      try {
        if (null == obj[prop]) {
          /** @type {string} */
          string = string + (prop + " = [null]\n");
        } else {
          if ("function" == typeof obj[prop]) {
            /** @type {string} */
            string = string + (prop + " => [Function]\n");
          } else {
            if ("object" == typeof obj[prop]) {
              var subprop = mxUtils.getFunctionName(obj[prop].constructor);
              /** @type {string} */
              string = string + (prop + " => [" + subprop + "]\n");
            } else {
              /** @type {string} */
              string = string + (prop + " = " + obj[prop] + "\n");
            }
          }
        }
      } catch (e) {
        /** @type {string} */
        string = string + (prop + "=" + e.message);
      }
    }
    return string;
  },
  toRadians : function(value) {
    return Math.PI * value / 180;
  },
  toDegree : function(val) {
    return 180 * val / Math.PI;
  },
  arcToCurves : function(px, offset, b, r, i, s, max, width, ch) {
    /** @type {number} */
    width = width - px;
    /** @type {number} */
    ch = ch - offset;
    if (0 === b || 0 === r) {
      return a;
    }
    /** @type {number} */
    b = Math.abs(b);
    /** @type {number} */
    r = Math.abs(r);
    /** @type {number} */
    var d = -width / 2;
    /** @type {number} */
    var x = -ch / 2;
    /** @type {number} */
    var c = Math.cos(i * Math.PI / 180);
    /** @type {number} */
    var a = Math.sin(i * Math.PI / 180);
    /** @type {number} */
    i = c * d + a * x;
    /** @type {number} */
    d = -1 * a * d + c * x;
    /** @type {number} */
    x = i * i;
    /** @type {number} */
    var y = d * d;
    /** @type {number} */
    var t = b * b;
    /** @type {number} */
    var z = r * r;
    /** @type {number} */
    var num = x / t + y / z;
    if (1 < num) {
      /** @type {number} */
      b = b * Math.sqrt(num);
      /** @type {number} */
      r = r * Math.sqrt(num);
      /** @type {number} */
      s = 0;
    } else {
      /** @type {number} */
      num = 1;
      if (s === max) {
        /** @type {number} */
        num = -1;
      }
      /** @type {number} */
      s = num * Math.sqrt((t * z - t * y - z * x) / (t * y + z * x));
    }
    /** @type {number} */
    x = s * b * d / r;
    /** @type {number} */
    y = -1 * s * r * i / b;
    /** @type {number} */
    width = c * x - a * y + width / 2;
    /** @type {number} */
    ch = a * x + c * y + ch / 2;
    /** @type {number} */
    t = Math.atan2((d - y) / r, (i - x) / b) - Math.atan2(0, 1);
    /** @type {number} */
    s = 0 <= t ? t : 2 * Math.PI + t;
    /** @type {number} */
    t = Math.atan2((-d - y) / r, (-i - x) / b) - Math.atan2((d - y) / r, (i - x) / b);
    /** @type {number} */
    i = 0 <= t ? t : 2 * Math.PI + t;
    if (0 == max && 0 < i) {
      /** @type {number} */
      i = i - 2 * Math.PI;
    } else {
      if (0 != max && 0 > i) {
        /** @type {number} */
        i = i + 2 * Math.PI;
      }
    }
    /** @type {number} */
    max = 2 * i / Math.PI;
    /** @type {number} */
    max = Math.ceil(0 > max ? -1 * max : max);
    /** @type {number} */
    i = i / max;
    /** @type {number} */
    d = 8 / 3 * Math.sin(i / 4) * Math.sin(i / 4) / Math.sin(i / 2);
    /** @type {number} */
    x = c * b;
    /** @type {number} */
    c = c * r;
    /** @type {number} */
    b = b * a;
    /** @type {number} */
    r = r * a;
    /** @type {number} */
    var w = Math.cos(s);
    /** @type {number} */
    var h = Math.sin(s);
    /** @type {number} */
    y = -d * (x * h + r * w);
    /** @type {number} */
    t = -d * (b * h - c * w);
    /** @type {!Array} */
    a = [];
    /** @type {number} */
    var scale = 0;
    for (; scale < max; ++scale) {
      /** @type {number} */
      s = s + i;
      /** @type {number} */
      w = Math.cos(s);
      /** @type {number} */
      h = Math.sin(s);
      /** @type {number} */
      z = x * w - r * h + width;
      /** @type {number} */
      num = b * w + c * h + ch;
      /** @type {number} */
      var dy = -d * (x * h + r * w);
      /** @type {number} */
      w = -d * (b * h - c * w);
      /** @type {number} */
      h = 6 * scale;
      /** @type {number} */
      a[h] = Number(y + px);
      /** @type {number} */
      a[h + 1] = Number(t + offset);
      /** @type {number} */
      a[h + 2] = Number(z - dy + px);
      /** @type {number} */
      a[h + 3] = Number(num - w + offset);
      /** @type {number} */
      a[h + 4] = Number(z + px);
      /** @type {number} */
      a[h + 5] = Number(num + offset);
      /** @type {number} */
      y = z + dy;
      /** @type {number} */
      t = num + w;
    }
    return a;
  },
  getBoundingBox : function(value, o, data) {
    /** @type {null} */
    var y = null;
    if (null != value && null != o && 0 != o) {
      o = mxUtils.toRadians(o);
      /** @type {number} */
      y = Math.cos(o);
      /** @type {number} */
      var sin = Math.sin(o);
      data = null != data ? data : new mxPoint(value.x + value.width / 2, value.y + value.height / 2);
      var result = new mxPoint(value.x, value.y);
      o = new mxPoint(value.x + value.width, value.y);
      var pt = new mxPoint(o.x, value.y + value.height);
      value = new mxPoint(value.x, pt.y);
      result = mxUtils.getRotatedPoint(result, y, sin, data);
      o = mxUtils.getRotatedPoint(o, y, sin, data);
      pt = mxUtils.getRotatedPoint(pt, y, sin, data);
      value = mxUtils.getRotatedPoint(value, y, sin, data);
      y = new mxRectangle(result.x, result.y, 0, 0);
      y.add(new mxRectangle(o.x, o.y, 0, 0));
      y.add(new mxRectangle(pt.x, pt.y, 0, 0));
      y.add(new mxRectangle(value.x, value.y, 0, 0));
    }
    return y;
  },
  getRotatedPoint : function(a, x, y, b) {
    b = null != b ? b : new mxPoint;
    /** @type {number} */
    var c = a.x - b.x;
    /** @type {number} */
    a = a.y - b.y;
    return new mxPoint(c * x - a * y + b.x, a * x + c * y + b.y);
  },
  getPortConstraints : function(el, s, method, graph) {
    s = mxUtils.getValue(el.style, mxConstants.STYLE_PORT_CONSTRAINT, mxUtils.getValue(s.style, method ? mxConstants.STYLE_SOURCE_PORT_CONSTRAINT : mxConstants.STYLE_TARGET_PORT_CONSTRAINT, null));
    if (null == s) {
      return graph;
    }
    graph = s.toString();
    s = mxConstants.DIRECTION_MASK_NONE;
    /** @type {number} */
    method = 0;
    if (1 == mxUtils.getValue(el.style, mxConstants.STYLE_PORT_CONSTRAINT_ROTATION, 0)) {
      method = mxUtils.getValue(el.style, mxConstants.STYLE_ROTATION, 0);
    }
    /** @type {number} */
    el = 0;
    if (45 < method) {
      /** @type {number} */
      el = 1;
      if (135 <= method) {
        /** @type {number} */
        el = 2;
      }
    } else {
      if (-45 > method) {
        /** @type {number} */
        el = 3;
        if (-135 >= method) {
          /** @type {number} */
          el = 2;
        }
      }
    }
    if (0 <= graph.indexOf(mxConstants.DIRECTION_NORTH)) {
      switch(el) {
        case 0:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_NORTH;
          break;
        case 1:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_EAST;
          break;
        case 2:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_SOUTH;
          break;
        case 3:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_WEST;
      }
    }
    if (0 <= graph.indexOf(mxConstants.DIRECTION_WEST)) {
      switch(el) {
        case 0:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_WEST;
          break;
        case 1:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_NORTH;
          break;
        case 2:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_EAST;
          break;
        case 3:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_SOUTH;
      }
    }
    if (0 <= graph.indexOf(mxConstants.DIRECTION_SOUTH)) {
      switch(el) {
        case 0:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_SOUTH;
          break;
        case 1:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_WEST;
          break;
        case 2:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_NORTH;
          break;
        case 3:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_EAST;
      }
    }
    if (0 <= graph.indexOf(mxConstants.DIRECTION_EAST)) {
      switch(el) {
        case 0:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_EAST;
          break;
        case 1:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_SOUTH;
          break;
        case 2:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_WEST;
          break;
        case 3:
          /** @type {number} */
          s = s | mxConstants.DIRECTION_MASK_NORTH;
      }
    }
    return s;
  },
  reversePortConstraints : function(a) {
    var b;
    /** @type {number} */
    b = (a & mxConstants.DIRECTION_MASK_WEST) << 3;
    /** @type {number} */
    b = b | (a & mxConstants.DIRECTION_MASK_NORTH) << 1;
    /** @type {number} */
    b = b | (a & mxConstants.DIRECTION_MASK_SOUTH) >> 1;
    return b = b | (a & mxConstants.DIRECTION_MASK_EAST) >> 3;
  },
  findNearestSegment : function(component, soql, options) {
    /** @type {number} */
    var spliceTo = -1;
    if (0 < component.absolutePoints.length) {
      var from = component.absolutePoints[0];
      /** @type {null} */
      var to = null;
      /** @type {number} */
      var i = 1;
      for (; i < component.absolutePoints.length; i++) {
        var tmp = component.absolutePoints[i];
        from = mxUtils.ptSegDistSq(from.x, from.y, tmp.x, tmp.y, soql, options);
        if (null == to || from < to) {
          to = from;
          /** @type {number} */
          spliceTo = i - 1;
        }
        from = tmp;
      }
    }
    return spliceTo;
  },
  getDirectedBounds : function(offset, obj, value, options, parent) {
    var f = mxUtils.getValue(value, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
    options = null != options ? options : mxUtils.getValue(value, mxConstants.STYLE_FLIPH, false);
    parent = null != parent ? parent : mxUtils.getValue(value, mxConstants.STYLE_FLIPV, false);
    /** @type {number} */
    obj.x = Math.round(Math.max(0, Math.min(offset.width, obj.x)));
    /** @type {number} */
    obj.y = Math.round(Math.max(0, Math.min(offset.height, obj.y)));
    /** @type {number} */
    obj.width = Math.round(Math.max(0, Math.min(offset.width, obj.width)));
    /** @type {number} */
    obj.height = Math.round(Math.max(0, Math.min(offset.height, obj.height)));
    if (parent && (f == mxConstants.DIRECTION_SOUTH || f == mxConstants.DIRECTION_NORTH) || options && (f == mxConstants.DIRECTION_EAST || f == mxConstants.DIRECTION_WEST)) {
      /** @type {number} */
      value = obj.x;
      /** @type {number} */
      obj.x = obj.width;
      /** @type {number} */
      obj.width = value;
    }
    if (options && (f == mxConstants.DIRECTION_SOUTH || f == mxConstants.DIRECTION_NORTH) || parent && (f == mxConstants.DIRECTION_EAST || f == mxConstants.DIRECTION_WEST)) {
      /** @type {number} */
      value = obj.y;
      /** @type {number} */
      obj.y = obj.height;
      /** @type {number} */
      obj.height = value;
    }
    options = mxRectangle.fromRectangle(obj);
    if (f == mxConstants.DIRECTION_SOUTH) {
      /** @type {number} */
      options.y = obj.x;
      /** @type {number} */
      options.x = obj.height;
      /** @type {number} */
      options.width = obj.y;
      /** @type {number} */
      options.height = obj.width;
    } else {
      if (f == mxConstants.DIRECTION_WEST) {
        /** @type {number} */
        options.y = obj.height;
        /** @type {number} */
        options.x = obj.width;
        /** @type {number} */
        options.width = obj.x;
        /** @type {number} */
        options.height = obj.y;
      } else {
        if (f == mxConstants.DIRECTION_NORTH) {
          /** @type {number} */
          options.y = obj.width;
          /** @type {number} */
          options.x = obj.y;
          /** @type {number} */
          options.width = obj.height;
          /** @type {number} */
          options.height = obj.x;
        }
      }
    }
    return new mxRectangle(offset.x + options.x, offset.y + options.y, offset.width - options.width - options.x, offset.height - options.height - options.y);
  },
  getPerimeterPoint : function(pages, point, prev) {
    /** @type {null} */
    var second = null;
    /** @type {number} */
    var i = 0;
    for (; i < pages.length - 1; i++) {
      var first = mxUtils.intersection(pages[i].x, pages[i].y, pages[i + 1].x, pages[i + 1].y, point.x, point.y, prev.x, prev.y);
      if (null != first) {
        /** @type {number} */
        var lightJ = prev.x - first.x;
        /** @type {number} */
        var lightI = prev.y - first.y;
        first = {
          p : first,
          distSq : lightI * lightI + lightJ * lightJ
        };
        if (null != first && (null == second || second.distSq > first.distSq)) {
          second = first;
        }
      }
    }
    return null != second ? second.p : null;
  },
  rectangleIntersectsSegment : function(t, s, r) {
    var max = t.y;
    var i = t.x;
    var count = max + t.height;
    var c = i + t.width;
    t = s.x;
    var n = r.x;
    if (s.x > r.x) {
      t = r.x;
      n = s.x;
    }
    if (n > c) {
      n = c;
    }
    if (t < i) {
      t = i;
    }
    if (t > n) {
      return false;
    }
    i = s.y;
    c = r.y;
    /** @type {number} */
    var fc = r.x - s.x;
    if (1E-7 < Math.abs(fc)) {
      /** @type {number} */
      r = (r.y - s.y) / fc;
      /** @type {number} */
      s = s.y - r * s.x;
      /** @type {number} */
      i = r * t + s;
      /** @type {number} */
      c = r * n + s;
    }
    if (i > c) {
      s = c;
      c = i;
      /** @type {number} */
      i = s;
    }
    if (c > count) {
      c = count;
    }
    if (i < max) {
      i = max;
    }
    return i > c ? false : true;
  },
  contains : function(a, e, b) {
    return a.x <= e && a.x + a.width >= e && a.y <= b && a.y + a.height >= b;
  },
  intersects : function(obj, x) {
    var ret = obj.width;
    var y = obj.height;
    var i = x.width;
    var a = x.height;
    if (0 >= i || 0 >= a || 0 >= ret || 0 >= y) {
      return false;
    }
    var min = obj.x;
    var t = obj.y;
    var max = x.x;
    var b = x.y;
    i = i + max;
    a = a + b;
    ret = ret + min;
    y = y + t;
    return (i < max || i > min) && (a < b || a > t) && (ret < min || ret > max) && (y < t || y > b);
  },
  intersectsHotspot : function(s, x, y, w, v, e) {
    w = null != w ? w : 1;
    v = null != v ? v : 0;
    e = null != e ? e : 0;
    if (0 < w) {
      var b = s.getCenterX();
      var l = s.getCenterY();
      var d = s.width;
      var c = s.height;
      /** @type {number} */
      var a = mxUtils.getValue(s.style, mxConstants.STYLE_STARTSIZE) * s.view.scale;
      if (0 < a) {
        if (mxUtils.getValue(s.style, mxConstants.STYLE_HORIZONTAL, true)) {
          l = s.y + a / 2;
          /** @type {number} */
          c = a;
        } else {
          b = s.x + a / 2;
          /** @type {number} */
          d = a;
        }
      }
      /** @type {number} */
      d = Math.max(v, d * w);
      /** @type {number} */
      c = Math.max(v, c * w);
      if (0 < e) {
        /** @type {number} */
        d = Math.min(d, e);
        /** @type {number} */
        c = Math.min(c, e);
      }
      w = new mxRectangle(b - d / 2, l - c / 2, d, c);
      b = mxUtils.toRadians(mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION) || 0);
      if (0 != b) {
        /** @type {number} */
        v = Math.cos(-b);
        /** @type {number} */
        e = Math.sin(-b);
        b = new mxPoint(s.getCenterX(), s.getCenterY());
        s = mxUtils.getRotatedPoint(new mxPoint(x, y), v, e, b);
        x = s.x;
        y = s.y;
      }
      return mxUtils.contains(w, x, y);
    }
    return true;
  },
  getOffset : function(obj, prop) {
    /** @type {number} */
    var width = 0;
    /** @type {number} */
    var height = 0;
    /** @type {boolean} */
    var offsets = false;
    /** @type {!Object} */
    var elt = obj;
    /** @type {!HTMLBodyElement} */
    var element = document.body;
    /** @type {!Element} */
    var ddE = document.documentElement;
    for (; null != elt && elt != element && elt != ddE && !offsets;) {
      var geometry = mxUtils.getCurrentStyle(elt);
      if (null != geometry) {
        /** @type {boolean} */
        offsets = offsets || "fixed" == geometry.position;
      }
      elt = elt.parentNode;
    }
    if (!(prop || offsets)) {
      offsets = mxUtils.getDocumentScrollOrigin(obj.ownerDocument);
      width = width + offsets.x;
      height = height + offsets.y;
    }
    offsets = obj.getBoundingClientRect();
    if (null != offsets) {
      width = width + offsets.left;
      height = height + offsets.top;
    }
    return new mxPoint(width, height);
  },
  getDocumentScrollOrigin : function(doc) {
    if (mxClient.IS_QUIRKS) {
      return new mxPoint(doc.body.scrollLeft, doc.body.scrollTop);
    }
    doc = doc.defaultView || doc.parentWindow;
    return new mxPoint(null != doc && void 0 !== window.pageXOffset ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft, null != doc && void 0 !== window.pageYOffset ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop);
  },
  getScrollOrigin : function(e, name, max) {
    name = null != name ? name : false;
    max = null != max ? max : true;
    var node = null != e ? e.ownerDocument : document;
    var body = node.body;
    var root = node.documentElement;
    var pt = new mxPoint;
    /** @type {boolean} */
    var reverse = false;
    for (; null != e && e != body && e != root;) {
      if (!(isNaN(e.scrollLeft) || isNaN(e.scrollTop))) {
        pt.x += e.scrollLeft;
        pt.y += e.scrollTop;
      }
      var edgeLabel = mxUtils.getCurrentStyle(e);
      if (null != edgeLabel) {
        /** @type {boolean} */
        reverse = reverse || "fixed" == edgeLabel.position;
      }
      e = name ? e.parentNode : null;
    }
    if (!reverse && max) {
      e = mxUtils.getDocumentScrollOrigin(node);
      pt.x += e.x;
      pt.y += e.y;
    }
    return pt;
  },
  convertPoint : function(p, x, t) {
    var player = mxUtils.getScrollOrigin(p, false);
    p = mxUtils.getOffset(p);
    p.x -= player.x;
    p.y -= player.y;
    return new mxPoint(x - p.x, t - p.y);
  },
  ltrim : function(s, chars) {
    return null != s ? s.replace(new RegExp("^[" + (chars || "\\s") + "]+", "g"), "") : null;
  },
  rtrim : function(str, value) {
    return null != str ? str.replace(new RegExp("[" + (value || "\\s") + "]+$", "g"), "") : null;
  },
  trim : function(str, chars) {
    return mxUtils.ltrim(mxUtils.rtrim(str, chars), chars);
  },
  isNumeric : function(value) {
    return !isNaN(parseFloat(value)) && isFinite(value) && ("string" != typeof value || 0 > value.toLowerCase().indexOf("0x"));
  },
  isInteger : function(value) {
    return String(parseInt(value)) === String(value);
  },
  mod : function(x, n) {
    return (x % n + n) % n;
  },
  intersection : function(s, r, b, c, d, a, f, p) {
    /** @type {number} */
    var q = (p - a) * (b - s) - (f - d) * (c - r);
    /** @type {number} */
    f = ((f - d) * (r - a) - (p - a) * (s - d)) / q;
    /** @type {number} */
    d = ((b - s) * (r - a) - (c - r) * (s - d)) / q;
    return 0 <= f && 1 >= f && 0 <= d && 1 >= d ? new mxPoint(s + f * (b - s), r + f * (c - r)) : null;
  },
  ptSegDistSq : function(x, e, d, c, a, b) {
    /** @type {number} */
    d = d - x;
    /** @type {number} */
    c = c - e;
    /** @type {number} */
    a = a - x;
    /** @type {number} */
    b = b - e;
    if (0 >= a * d + b * c) {
      /** @type {number} */
      d = 0;
    } else {
      /** @type {number} */
      a = d - a;
      /** @type {number} */
      b = c - b;
      /** @type {number} */
      x = a * d + b * c;
      /** @type {number} */
      d = 0 >= x ? 0 : x * x / (d * d + c * c);
    }
    /** @type {number} */
    a = a * a + b * b - d;
    if (0 > a) {
      /** @type {number} */
      a = 0;
    }
    return a;
  },
  ptLineDist : function(d, g, b, r, a, c) {
    return Math.abs((r - g) * a - (b - d) * c + b * g - r * d) / Math.sqrt((r - g) * (r - g) + (b - d) * (b - d));
  },
  relativeCcw : function(d, a, f, i, b, c) {
    /** @type {number} */
    f = f - d;
    /** @type {number} */
    i = i - a;
    /** @type {number} */
    b = b - d;
    /** @type {number} */
    c = c - a;
    /** @type {number} */
    d = b * i - c * f;
    if (0 == d) {
      /** @type {number} */
      d = b * f + c * i;
      if (0 < d) {
        /** @type {number} */
        d = (b - f) * f + (c - i) * i;
        if (0 > d) {
          /** @type {number} */
          d = 0;
        }
      }
    }
    return 0 > d ? -1 : 0 < d ? 1 : 0;
  },
  animateChanges : function(a, b) {
    mxEffects.animateChanges.apply(this, arguments);
  },
  cascadeOpacity : function(a, val, reason) {
    mxEffects.cascadeOpacity.apply(this, arguments);
  },
  fadeOut : function(targetVol, startVol, stopAtEnd, val, force, elem) {
    mxEffects.fadeOut.apply(this, arguments);
  },
  setOpacity : function(node, opacity) {
    if (mxUtils.isVml(node)) {
      /** @type {string} */
      node.style.filter = 100 <= opacity ? "" : "alpha(opacity=" + opacity / 5 + ")";
    } else {
      if (mxClient.IS_IE && ("undefined" === typeof document.documentMode || 9 > document.documentMode)) {
        /** @type {string} */
        node.style.filter = 100 <= opacity ? "" : "alpha(opacity=" + opacity + ")";
      } else {
        /** @type {number} */
        node.style.opacity = opacity / 100;
      }
    }
  },
  createImage : function(position) {
    var img;
    if (mxClient.IS_IE6 && "CSS1Compat" != document.compatMode) {
      /** @type {!Element} */
      img = document.createElement(mxClient.VML_PREFIX + ":image");
      img.setAttribute("src", position);
      /** @type {string} */
      img.style.borderStyle = "none";
    } else {
      /** @type {!Element} */
      img = document.createElement("img");
      img.setAttribute("src", position);
      img.setAttribute("border", "0");
    }
    return img;
  },
  sortCells : function(q, v) {
    v = null != v ? v : true;
    var recentList = new mxDictionary;
    q.sort(function(a, d) {
      var c = recentList.get(a);
      if (null == c) {
        c = mxCellPath.create(a).split(mxCellPath.PATH_SEPARATOR);
        recentList.put(a, c);
      }
      var b = recentList.get(d);
      if (null == b) {
        b = mxCellPath.create(d).split(mxCellPath.PATH_SEPARATOR);
        recentList.put(d, b);
      }
      c = mxCellPath.compare(c, b);
      return 0 == c ? 0 : 0 < c == v ? 1 : -1;
    });
    return q;
  },
  getStylename : function(a) {
    return null != a && (a = a.split(";")[0], 0 > a.indexOf("=")) ? a : "";
  },
  getStylenames : function(classes) {
    /** @type {!Array} */
    var remainingClasses = [];
    if (null != classes) {
      classes = classes.split(";");
      /** @type {number} */
      var i = 0;
      for (; i < classes.length; i++) {
        if (0 > classes[i].indexOf("=")) {
          remainingClasses.push(classes[i]);
        }
      }
    }
    return remainingClasses;
  },
  indexOfStylename : function(a, b) {
    if (null != a && null != b) {
      var tokens = a.split(";");
      /** @type {number} */
      var next_tick_ts = 0;
      /** @type {number} */
      var i = 0;
      for (; i < tokens.length; i++) {
        if (tokens[i] == b) {
          return next_tick_ts;
        }
        next_tick_ts = next_tick_ts + (tokens[i].length + 1);
      }
    }
    return -1;
  },
  addStylename : function(result, value) {
    if (0 > mxUtils.indexOfStylename(result, value)) {
      if (null == result) {
        /** @type {string} */
        result = "";
      } else {
        if (0 < result.length && ";" != result.charAt(result.length - 1)) {
          /** @type {string} */
          result = result + ";";
        }
      }
      result = result + value;
    }
    return result;
  },
  removeStylename : function(hashString, direction) {
    /** @type {!Array} */
    var lines = [];
    if (null != hashString) {
      var arr = hashString.split(";");
      /** @type {number} */
      var e = 0;
      for (; e < arr.length; e++) {
        if (arr[e] != direction) {
          lines.push(arr[e]);
        }
      }
    }
    return lines.join(";");
  },
  removeAllStylenames : function(classes) {
    /** @type {!Array} */
    var remainingClasses = [];
    if (null != classes) {
      classes = classes.split(";");
      /** @type {number} */
      var i = 0;
      for (; i < classes.length; i++) {
        if (0 <= classes[i].indexOf("=")) {
          remainingClasses.push(classes[i]);
        }
      }
    }
    return remainingClasses.join(";");
  },
  setCellStyles : function(node, nodes, value, opacity) {
    if (null != nodes && 0 < nodes.length) {
      node.beginUpdate();
      try {
        /** @type {number} */
        var i = 0;
        for (; i < nodes.length; i++) {
          if (null != nodes[i]) {
            var index = mxUtils.setStyle(node.getStyle(nodes[i]), value, opacity);
            node.setStyle(nodes[i], index);
          }
        }
      } finally {
        node.endUpdate();
      }
    }
  },
  setStyle : function(element, index, value) {
    /** @type {boolean} */
    var suffix = null != value && ("undefined" == typeof value.length || 0 < value.length);
    if (null == element || 0 == element.length) {
      if (suffix) {
        /** @type {string} */
        element = index + "=" + value + ";";
      }
    } else {
      if (element.substring(0, index.length + 1) == index + "=") {
        var n = element.indexOf(";");
        element = suffix ? index + "=" + value + (0 > n ? ";" : element.substring(n)) : 0 > n || n == element.length - 1 ? "" : element.substring(n + 1);
      } else {
        var right = element.indexOf(";" + index + "=");
        if (0 > right) {
          if (suffix) {
            /** @type {string} */
            suffix = ";" == element.charAt(element.length - 1) ? "" : ";";
            /** @type {string} */
            element = element + suffix + index + "=" + value + ";";
          }
        } else {
          n = element.indexOf(";", right + 1);
          element = suffix ? element.substring(0, right + 1) + index + "=" + value + (0 > n ? ";" : element.substring(n)) : element.substring(0, right) + (0 > n ? ";" : element.substring(n));
        }
      }
    }
    return element;
  },
  setCellStyleFlags : function(me, list, value, opacity, position) {
    if (null != list && 0 < list.length) {
      me.beginUpdate();
      try {
        /** @type {number} */
        var i = 0;
        for (; i < list.length; i++) {
          if (null != list[i]) {
            var ret = mxUtils.setStyleFlag(me.getStyle(list[i]), value, opacity, position);
            me.setStyle(list[i], ret);
          }
        }
      } finally {
        me.endUpdate();
      }
    }
  },
  setStyleFlag : function(s, t, key, value) {
    if (null == s || 0 == s.length) {
      /** @type {string} */
      s = value || null == value ? t + "=" + key : t + "=0";
    } else {
      var e = s.indexOf(t + "=");
      if (0 > e) {
        /** @type {string} */
        e = ";" == s.charAt(s.length - 1) ? "" : ";";
        /** @type {string} */
        s = value || null == value ? s + e + t + "=" + key : s + e + t + "=0";
      } else {
        var position = s.indexOf(";", e);
        var i;
        i = 0 > position ? s.substring(e + t.length + 1) : s.substring(e + t.length + 1, position);
        /** @type {number} */
        i = null == value ? parseInt(i) ^ key : value ? parseInt(i) | key : parseInt(i) & ~key;
        s = s.substring(0, e) + t + "=" + i + (0 <= position ? s.substring(position) : "");
      }
    }
    return s;
  },
  getAlignmentAsPoint : function(align, valign) {
    /** @type {number} */
    var right = -.5;
    /** @type {number} */
    var bottom = -.5;
    if (align == mxConstants.ALIGN_LEFT) {
      /** @type {number} */
      right = 0;
    } else {
      if (align == mxConstants.ALIGN_RIGHT) {
        /** @type {number} */
        right = -1;
      }
    }
    if (valign == mxConstants.ALIGN_TOP) {
      /** @type {number} */
      bottom = 0;
    } else {
      if (valign == mxConstants.ALIGN_BOTTOM) {
        /** @type {number} */
        bottom = -1;
      }
    }
    return new mxPoint(right, bottom);
  },
  getSizeForString : function(text, val, name, d, lazyLayout) {
    val = null != val ? val : mxConstants.DEFAULT_FONTSIZE;
    name = null != name ? name : mxConstants.DEFAULT_FONTFAMILY;
    /** @type {!Element} */
    var el = document.createElement("div");
    /** @type {string} */
    el.style.fontFamily = name;
    /** @type {string} */
    el.style.fontSize = Math.round(val) + "px";
    /** @type {string} */
    el.style.lineHeight = Math.round(val * mxConstants.LINE_HEIGHT) + "px";
    if (null != lazyLayout) {
      if ((lazyLayout & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
        /** @type {string} */
        el.style.fontWeight = "bold";
      }
      if ((lazyLayout & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
        /** @type {string} */
        el.style.fontStyle = "italic";
      }
      /** @type {!Array} */
      val = [];
      if ((lazyLayout & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
        val.push("underline");
      }
      if ((lazyLayout & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
        val.push("line-through");
      }
      if (0 < val.length) {
        /** @type {string} */
        el.style.textDecoration = val.join(" ");
      }
    }
    /** @type {string} */
    el.style.position = "absolute";
    /** @type {string} */
    el.style.visibility = "hidden";
    /** @type {string} */
    el.style.display = mxClient.IS_QUIRKS ? "inline" : "inline-block";
    /** @type {string} */
    el.style.zoom = "1";
    if (null != d) {
      /** @type {string} */
      el.style.width = d + "px";
      /** @type {string} */
      el.style.whiteSpace = "normal";
    } else {
      /** @type {string} */
      el.style.whiteSpace = "nowrap";
    }
    /** @type {string} */
    el.innerHTML = text;
    document.body.appendChild(el);
    text = new mxRectangle(0, 0, el.offsetWidth, el.offsetHeight);
    document.body.removeChild(el);
    return text;
  },
  getViewXml : function(graph, result, coords, width, height) {
    width = null != width ? width : 0;
    height = null != height ? height : 0;
    result = null != result ? result : 1;
    if (null == coords) {
      /** @type {!Array} */
      coords = [graph.getModel().getRoot()];
    }
    var self = graph.getView();
    /** @type {null} */
    var g = null;
    var se = self.isEventsEnabled();
    self.setEventsEnabled(false);
    var boxInput = self.drawPane;
    var locked_balance_JSBigInt = self.overlayPane;
    if (graph.dialect == mxConstants.DIALECT_SVG) {
      /** @type {!Element} */
      self.drawPane = document.createElementNS(mxConstants.NS_SVG, "g");
      self.canvas.appendChild(self.drawPane);
      /** @type {!Element} */
      self.overlayPane = document.createElementNS(mxConstants.NS_SVG, "g");
    } else {
      self.drawPane = self.drawPane.cloneNode(false);
      self.canvas.appendChild(self.drawPane);
      self.overlayPane = self.overlayPane.cloneNode(false);
    }
    self.canvas.appendChild(self.overlayPane);
    var newValue = self.getTranslate();
    self.translate = new mxPoint(width, height);
    result = new mxTemporaryCellStates(graph.getView(), result, coords);
    try {
      g = (new mxCodec).encode(graph.getView());
    } finally {
      result.destroy();
      self.translate = newValue;
      self.canvas.removeChild(self.drawPane);
      self.canvas.removeChild(self.overlayPane);
      self.drawPane = boxInput;
      self.overlayPane = locked_balance_JSBigInt;
      self.setEventsEnabled(se);
    }
    return g;
  },
  getScaleForPageCount : function(max, count, h, scale) {
    if (1 > max) {
      return 1;
    }
    h = null != h ? h : mxConstants.PAGE_FORMAT_A4_PORTRAIT;
    scale = null != scale ? scale : 0;
    /** @type {number} */
    var w = h.width - 2 * scale;
    /** @type {number} */
    h = h.height - 2 * scale;
    scale = count.getGraphBounds().clone();
    count = count.getView().getScale();
    scale.width /= count;
    scale.height /= count;
    count = scale.width;
    /** @type {number} */
    var size = Math.sqrt(max);
    /** @type {number} */
    scale = Math.sqrt(count / scale.height / (w / h));
    /** @type {number} */
    h = size * scale;
    /** @type {number} */
    scale = size / scale;
    if (1 > h && scale > max) {
      /** @type {number} */
      var ratio = scale / max;
      /** @type {number} */
      scale = max;
      /** @type {number} */
      h = h / ratio;
    }
    if (1 > scale && h > max) {
      /** @type {number} */
      ratio = h / max;
      /** @type {number} */
      h = max;
      /** @type {number} */
      scale = scale / ratio;
    }
    /** @type {number} */
    ratio = Math.ceil(h) * Math.ceil(scale);
    /** @type {number} */
    size = 0;
    for (; ratio > max;) {
      /** @type {number} */
      ratio = Math.floor(h) / h;
      /** @type {number} */
      var left = Math.floor(scale) / scale;
      if (1 == ratio) {
        /** @type {number} */
        ratio = Math.floor(h - 1) / h;
      }
      if (1 == left) {
        /** @type {number} */
        left = Math.floor(scale - 1) / scale;
      }
      /** @type {number} */
      ratio = ratio > left ? ratio : left;
      /** @type {number} */
      h = h * ratio;
      /** @type {number} */
      scale = scale * ratio;
      /** @type {number} */
      ratio = Math.ceil(h) * Math.ceil(scale);
      size++;
      if (10 < size) {
        break;
      }
    }
    return w * h / count * .99999;
  },
  show : function(instance, self, i, e, n, c) {
    i = null != i ? i : 0;
    e = null != e ? e : 0;
    if (null == self) {
      self = window.open().document;
    } else {
      self.open();
    }
    if (9 == document.documentMode) {
      self.writeln('\x3c!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=9"><![endif]--\x3e');
    }
    var s = instance.getGraphBounds();
    /** @type {number} */
    var targetL = Math.ceil(i - s.x);
    /** @type {number} */
    var y_body_bottom = Math.ceil(e - s.y);
    if (null == n) {
      /** @type {number} */
      n = Math.ceil(s.width + i) + Math.ceil(Math.ceil(s.x) - s.x);
    }
    if (null == c) {
      /** @type {number} */
      c = Math.ceil(s.height + e) + Math.ceil(Math.ceil(s.y) - s.y);
    }
    if (mxClient.IS_IE || 11 == document.documentMode) {
      /** @type {string} */
      e = "<html><head>";
      /** @type {!NodeList<Element>} */
      s = document.getElementsByTagName("base");
      /** @type {number} */
      i = 0;
      for (; i < s.length; i++) {
        /** @type {string} */
        e = e + s[i].outerHTML;
      }
      /** @type {string} */
      e = e + "<style>";
      /** @type {number} */
      i = 0;
      for (; i < document.styleSheets.length; i++) {
        try {
          /** @type {string} */
          e = e + document.styleSheets[i].cssText;
        } catch (m) {
        }
      }
      /** @type {string} */
      e = e + '</style></head><body style="margin:0px;">' + ('<div style="position:absolute;overflow:hidden;width:' + n + "px;height:" + c + 'px;"><div style="position:relative;left:' + targetL + "px;top:" + y_body_bottom + 'px;">') + instance.container.innerHTML;
      self.writeln(e + "</div></div></body><html>");
      self.close();
    } else {
      self.writeln("<html><head>");
      /** @type {!NodeList<Element>} */
      s = document.getElementsByTagName("base");
      /** @type {number} */
      i = 0;
      for (; i < s.length; i++) {
        self.writeln(mxUtils.getOuterHtml(s[i]));
      }
      /** @type {!NodeList<Element>} */
      e = document.getElementsByTagName("link");
      /** @type {number} */
      i = 0;
      for (; i < e.length; i++) {
        self.writeln(mxUtils.getOuterHtml(e[i]));
      }
      /** @type {!NodeList<Element>} */
      e = document.getElementsByTagName("style");
      /** @type {number} */
      i = 0;
      for (; i < e.length; i++) {
        self.writeln(mxUtils.getOuterHtml(e[i]));
      }
      self.writeln('</head><body style="margin:0px;"></body></html>');
      self.close();
      i = self.createElement("div");
      /** @type {string} */
      i.position = "absolute";
      /** @type {string} */
      i.overflow = "hidden";
      /** @type {string} */
      i.style.width = n + "px";
      /** @type {string} */
      i.style.height = c + "px";
      n = self.createElement("div");
      /** @type {string} */
      n.style.position = "absolute";
      /** @type {string} */
      n.style.left = targetL + "px";
      /** @type {string} */
      n.style.top = y_body_bottom + "px";
      c = instance.container.firstChild;
      /** @type {null} */
      e = null;
      for (; null != c;) {
        s = c.cloneNode(true);
        if (c == instance.view.drawPane.ownerSVGElement) {
          i.appendChild(s);
          e = s;
        } else {
          n.appendChild(s);
        }
        c = c.nextSibling;
      }
      self.body.appendChild(i);
      if (null != n.firstChild) {
        self.body.appendChild(n);
      }
      if (null != e) {
        /** @type {string} */
        e.style.minWidth = "";
        /** @type {string} */
        e.style.minHeight = "";
        e.firstChild.setAttribute("transform", "translate(" + targetL + "," + y_body_bottom + ")");
      }
    }
    mxUtils.removeCursors(self.body);
    return self;
  },
  printScreen : function(error) {
    /** @type {(Window|null)} */
    var node = window.open();
    error.getGraphBounds();
    mxUtils.show(error, node.document);
    /**
     * @return {undefined}
     */
    error = function() {
      node.focus();
      node.print();
      node.close();
    };
    if (mxClient.IS_GC) {
      node.setTimeout(error, 500);
    } else {
      error();
    }
  },
  popup : function(text, hashTags) {
    if (hashTags) {
      /** @type {!Element} */
      var c = document.createElement("div");
      /** @type {string} */
      c.style.overflow = "scroll";
      /** @type {string} */
      c.style.width = "636px";
      /** @type {string} */
      c.style.height = "460px";
      /** @type {!Element} */
      var button = document.createElement("pre");
      button.innerHTML = mxUtils.htmlEntities(text, false).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;");
      c.appendChild(button);
      c = new mxWindow("Popup Window", c, document.body.clientWidth / 2 - 320, Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight) / 2 - 240, 640, 480, false, true);
      c.setClosable(true);
      c.setVisible(true);
    } else {
      if (mxClient.IS_NS) {
        /** @type {(Window|null)} */
        c = window.open();
        c.document.writeln("<pre>" + mxUtils.htmlEntities(text) + "</pre");
        c.document.close();
      } else {
        /** @type {(Window|null)} */
        c = window.open();
        button = c.document.createElement("pre");
        button.innerHTML = mxUtils.htmlEntities(text, false).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;");
        c.document.body.appendChild(button);
      }
    }
  },
  alert : function(data) {
    alert(data);
  },
  prompt : function(message, url) {
    return prompt(message, null != url ? url : "");
  },
  confirm : function(question) {
    return confirm(question);
  },
  error : function(x, r, link, value) {
    /** @type {!Element} */
    var node = document.createElement("div");
    /** @type {string} */
    node.style.padding = "20px";
    /** @type {!Element} */
    var element = document.createElement("img");
    element.setAttribute("src", value || mxUtils.errorImage);
    element.setAttribute("valign", "bottom");
    /** @type {string} */
    element.style.verticalAlign = "middle";
    node.appendChild(element);
    node.appendChild(document.createTextNode("\u00a0"));
    node.appendChild(document.createTextNode("\u00a0"));
    node.appendChild(document.createTextNode("\u00a0"));
    mxUtils.write(node, x);
    /** @type {number} */
    x = document.body.clientWidth;
    /** @type {number} */
    value = document.body.clientHeight || document.documentElement.clientHeight;
    var self = new mxWindow(mxResources.get(mxUtils.errorResource) || mxUtils.errorResource, node, (x - r) / 2, value / 4, r, null, false, true);
    if (link) {
      mxUtils.br(node);
      /** @type {!Element} */
      r = document.createElement("p");
      /** @type {!Element} */
      link = document.createElement("button");
      if (mxClient.IS_IE) {
        /** @type {string} */
        link.style.cssText = "float:right";
      } else {
        link.setAttribute("style", "float:right");
      }
      mxEvent.addListener(link, "click", function(a) {
        self.destroy();
      });
      mxUtils.write(link, mxResources.get(mxUtils.closeResource) || mxUtils.closeResource);
      r.appendChild(link);
      node.appendChild(r);
      mxUtils.br(node);
      self.setClosable(true);
    }
    self.setVisible(true);
    return self;
  },
  makeDraggable : function(obj, callback, opts, el, position, name, params, options, element, collection) {
    obj = new mxDragSource(obj, opts);
    obj.dragOffset = new mxPoint(null != position ? position : 0, null != name ? name : mxConstants.TOOLTIP_VERTICAL_OFFSET);
    /** @type {string} */
    obj.autoscroll = params;
    obj.setGuidesEnabled(false);
    if (null != element) {
      /** @type {!Object} */
      obj.highlightDropTargets = element;
    }
    if (null != collection) {
      /** @type {string} */
      obj.getDropTarget = collection;
    }
    /**
     * @param {!Object} e
     * @return {?}
     */
    obj.getGraphForEvent = function(e) {
      return "function" == typeof callback ? callback(e) : callback;
    };
    if (null != el) {
      /**
       * @return {?}
       */
      obj.createDragElement = function() {
        return el.cloneNode(true);
      };
      if (options) {
        /**
         * @param {!Object} g
         * @return {?}
         */
        obj.createPreviewElement = function(g) {
          var listcontentPage = el.cloneNode(true);
          /** @type {number} */
          var v2 = parseInt(listcontentPage.style.width);
          /** @type {number} */
          var oy = parseInt(listcontentPage.style.height);
          /** @type {string} */
          listcontentPage.style.width = Math.round(v2 * g.view.scale) + "px";
          /** @type {string} */
          listcontentPage.style.height = Math.round(oy * g.view.scale) + "px";
          return listcontentPage;
        };
      }
    }
    return obj;
  }
};
var mxConstants = {
  DEFAULT_HOTSPOT : .3,
  MIN_HOTSPOT_SIZE : 8,
  MAX_HOTSPOT_SIZE : 0,
  RENDERING_HINT_EXACT : "exact",
  RENDERING_HINT_FASTER : "faster",
  RENDERING_HINT_FASTEST : "fastest",
  DIALECT_SVG : "svg",
  DIALECT_VML : "vml",
  DIALECT_MIXEDHTML : "mixedHtml",
  DIALECT_PREFERHTML : "preferHtml",
  DIALECT_STRICTHTML : "strictHtml",
  NS_SVG : "http://www.w3.org/2000/svg",
  NS_XHTML : "http://www.w3.org/1999/xhtml",
  NS_XLINK : "http://www.w3.org/1999/xlink",
  SHADOWCOLOR : "gray",
  VML_SHADOWCOLOR : "gray",
  SHADOW_OFFSET_X : 2,
  SHADOW_OFFSET_Y : 3,
  SHADOW_OPACITY : 1,
  NODETYPE_ELEMENT : 1,
  NODETYPE_ATTRIBUTE : 2,
  NODETYPE_TEXT : 3,
  NODETYPE_CDATA : 4,
  NODETYPE_ENTITY_REFERENCE : 5,
  NODETYPE_ENTITY : 6,
  NODETYPE_PROCESSING_INSTRUCTION : 7,
  NODETYPE_COMMENT : 8,
  NODETYPE_DOCUMENT : 9,
  NODETYPE_DOCUMENTTYPE : 10,
  NODETYPE_DOCUMENT_FRAGMENT : 11,
  NODETYPE_NOTATION : 12,
  TOOLTIP_VERTICAL_OFFSET : 16,
  DEFAULT_VALID_COLOR : "#00FF00",
  DEFAULT_INVALID_COLOR : "#FF0000",
  OUTLINE_HIGHLIGHT_COLOR : "#00FF00",
  OUTLINE_HIGHLIGHT_STROKEWIDTH : 5,
  HIGHLIGHT_STROKEWIDTH : 3,
  HIGHLIGHT_SIZE : 2,
  HIGHLIGHT_OPACITY : 100,
  CURSOR_MOVABLE_VERTEX : "move",
  CURSOR_MOVABLE_EDGE : "move",
  CURSOR_LABEL_HANDLE : "default",
  CURSOR_TERMINAL_HANDLE : "pointer",
  CURSOR_BEND_HANDLE : "crosshair",
  CURSOR_VIRTUAL_BEND_HANDLE : "crosshair",
  CURSOR_CONNECT : "pointer",
  HIGHLIGHT_COLOR : "#00FF00",
  CONNECT_TARGET_COLOR : "#0000FF",
  INVALID_CONNECT_TARGET_COLOR : "#FF0000",
  DROP_TARGET_COLOR : "#0000FF",
  VALID_COLOR : "#00FF00",
  INVALID_COLOR : "#FF0000",
  EDGE_SELECTION_COLOR : "#00FF00",
  VERTEX_SELECTION_COLOR : "#00FF00",
  VERTEX_SELECTION_STROKEWIDTH : 1,
  EDGE_SELECTION_STROKEWIDTH : 1,
  VERTEX_SELECTION_DASHED : true,
  EDGE_SELECTION_DASHED : true,
  GUIDE_COLOR : "#FF0000",
  GUIDE_STROKEWIDTH : 1,
  OUTLINE_COLOR : "#0099FF",
  OUTLINE_STROKEWIDTH : mxClient.IS_IE ? 2 : 3,
  HANDLE_SIZE : 6,
  LABEL_HANDLE_SIZE : 4,
  HANDLE_FILLCOLOR : "#00FF00",
  HANDLE_STROKECOLOR : "black",
  LABEL_HANDLE_FILLCOLOR : "yellow",
  CONNECT_HANDLE_FILLCOLOR : "#0000FF",
  LOCKED_HANDLE_FILLCOLOR : "#FF0000",
  OUTLINE_HANDLE_FILLCOLOR : "#00FFFF",
  OUTLINE_HANDLE_STROKECOLOR : "#0033FF",
  DEFAULT_FONTFAMILY : "Arial,Helvetica",
  DEFAULT_FONTSIZE : 11,
  DEFAULT_TEXT_DIRECTION : "",
  LINE_HEIGHT : 1.2,
  WORD_WRAP : "normal",
  ABSOLUTE_LINE_HEIGHT : false,
  DEFAULT_FONTSTYLE : 0,
  DEFAULT_STARTSIZE : 40,
  DEFAULT_MARKERSIZE : 6,
  DEFAULT_IMAGESIZE : 24,
  ENTITY_SEGMENT : 30,
  RECTANGLE_ROUNDING_FACTOR : .15,
  LINE_ARCSIZE : 20,
  ARROW_SPACING : 0,
  ARROW_WIDTH : 30,
  ARROW_SIZE : 30,
  PAGE_FORMAT_A4_PORTRAIT : new mxRectangle(0, 0, 827, 1169),
  PAGE_FORMAT_A4_LANDSCAPE : new mxRectangle(0, 0, 1169, 827),
  PAGE_FORMAT_LETTER_PORTRAIT : new mxRectangle(0, 0, 850, 1100),
  PAGE_FORMAT_LETTER_LANDSCAPE : new mxRectangle(0, 0, 1100, 850),
  NONE : "none",
  STYLE_PERIMETER : "perimeter",
  STYLE_SOURCE_PORT : "sourcePort",
  STYLE_TARGET_PORT : "targetPort",
  STYLE_PORT_CONSTRAINT : "portConstraint",
  STYLE_PORT_CONSTRAINT_ROTATION : "portConstraintRotation",
  STYLE_SOURCE_PORT_CONSTRAINT : "sourcePortConstraint",
  STYLE_TARGET_PORT_CONSTRAINT : "targetPortConstraint",
  STYLE_OPACITY : "opacity",
  STYLE_FILL_OPACITY : "fillOpacity",
  STYLE_STROKE_OPACITY : "strokeOpacity",
  STYLE_TEXT_OPACITY : "textOpacity",
  STYLE_TEXT_DIRECTION : "textDirection",
  STYLE_OVERFLOW : "overflow",
  STYLE_ORTHOGONAL : "orthogonal",
  STYLE_EXIT_X : "exitX",
  STYLE_EXIT_Y : "exitY",
  STYLE_EXIT_DX : "exitDx",
  STYLE_EXIT_DY : "exitDy",
  STYLE_EXIT_PERIMETER : "exitPerimeter",
  STYLE_ENTRY_X : "entryX",
  STYLE_ENTRY_Y : "entryY",
  STYLE_ENTRY_DX : "entryDx",
  STYLE_ENTRY_DY : "entryDy",
  STYLE_ENTRY_PERIMETER : "entryPerimeter",
  STYLE_WHITE_SPACE : "whiteSpace",
  STYLE_ROTATION : "rotation",
  STYLE_FILLCOLOR : "fillColor",
  STYLE_POINTER_EVENTS : "pointerEvents",
  STYLE_SWIMLANE_FILLCOLOR : "swimlaneFillColor",
  STYLE_MARGIN : "margin",
  STYLE_GRADIENTCOLOR : "gradientColor",
  STYLE_GRADIENT_DIRECTION : "gradientDirection",
  STYLE_STROKECOLOR : "strokeColor",
  STYLE_SEPARATORCOLOR : "separatorColor",
  STYLE_STROKEWIDTH : "strokeWidth",
  STYLE_ALIGN : "align",
  STYLE_VERTICAL_ALIGN : "verticalAlign",
  STYLE_LABEL_WIDTH : "labelWidth",
  STYLE_LABEL_POSITION : "labelPosition",
  STYLE_VERTICAL_LABEL_POSITION : "verticalLabelPosition",
  STYLE_IMAGE_ASPECT : "imageAspect",
  STYLE_IMAGE_ALIGN : "imageAlign",
  STYLE_IMAGE_VERTICAL_ALIGN : "imageVerticalAlign",
  STYLE_GLASS : "glass",
  STYLE_IMAGE : "image",
  STYLE_IMAGE_WIDTH : "imageWidth",
  STYLE_IMAGE_HEIGHT : "imageHeight",
  STYLE_IMAGE_BACKGROUND : "imageBackground",
  STYLE_IMAGE_BORDER : "imageBorder",
  STYLE_FLIPH : "flipH",
  STYLE_FLIPV : "flipV",
  STYLE_NOLABEL : "noLabel",
  STYLE_NOEDGESTYLE : "noEdgeStyle",
  STYLE_LABEL_BACKGROUNDCOLOR : "labelBackgroundColor",
  STYLE_LABEL_BORDERCOLOR : "labelBorderColor",
  STYLE_LABEL_PADDING : "labelPadding",
  STYLE_INDICATOR_SHAPE : "indicatorShape",
  STYLE_INDICATOR_IMAGE : "indicatorImage",
  STYLE_INDICATOR_COLOR : "indicatorColor",
  STYLE_INDICATOR_STROKECOLOR : "indicatorStrokeColor",
  STYLE_INDICATOR_GRADIENTCOLOR : "indicatorGradientColor",
  STYLE_INDICATOR_SPACING : "indicatorSpacing",
  STYLE_INDICATOR_WIDTH : "indicatorWidth",
  STYLE_INDICATOR_HEIGHT : "indicatorHeight",
  STYLE_INDICATOR_DIRECTION : "indicatorDirection",
  STYLE_SHADOW : "shadow",
  STYLE_SEGMENT : "segment",
  STYLE_ENDARROW : "endArrow",
  STYLE_STARTARROW : "startArrow",
  STYLE_ENDSIZE : "endSize",
  STYLE_STARTSIZE : "startSize",
  STYLE_SWIMLANE_LINE : "swimlaneLine",
  STYLE_ENDFILL : "endFill",
  STYLE_STARTFILL : "startFill",
  STYLE_DASHED : "dashed",
  STYLE_DASH_PATTERN : "dashPattern",
  STYLE_FIX_DASH : "fixDash",
  STYLE_ROUNDED : "rounded",
  STYLE_CURVED : "curved",
  STYLE_ARCSIZE : "arcSize",
  STYLE_ABSOLUTE_ARCSIZE : "absoluteArcSize",
  STYLE_SOURCE_PERIMETER_SPACING : "sourcePerimeterSpacing",
  STYLE_TARGET_PERIMETER_SPACING : "targetPerimeterSpacing",
  STYLE_PERIMETER_SPACING : "perimeterSpacing",
  STYLE_SPACING : "spacing",
  STYLE_SPACING_TOP : "spacingTop",
  STYLE_SPACING_LEFT : "spacingLeft",
  STYLE_SPACING_BOTTOM : "spacingBottom",
  STYLE_SPACING_RIGHT : "spacingRight",
  STYLE_HORIZONTAL : "horizontal",
  STYLE_DIRECTION : "direction",
  STYLE_ANCHOR_POINT_DIRECTION : "anchorPointDirection",
  STYLE_ELBOW : "elbow",
  STYLE_FONTCOLOR : "fontColor",
  STYLE_FONTFAMILY : "fontFamily",
  STYLE_FONTSIZE : "fontSize",
  STYLE_FONTSTYLE : "fontStyle",
  STYLE_ASPECT : "aspect",
  STYLE_AUTOSIZE : "autosize",
  STYLE_FOLDABLE : "foldable",
  STYLE_EDITABLE : "editable",
  STYLE_BACKGROUND_OUTLINE : "backgroundOutline",
  STYLE_BENDABLE : "bendable",
  STYLE_MOVABLE : "movable",
  STYLE_RESIZABLE : "resizable",
  STYLE_RESIZE_WIDTH : "resizeWidth",
  STYLE_RESIZE_HEIGHT : "resizeHeight",
  STYLE_ROTATABLE : "rotatable",
  STYLE_CLONEABLE : "cloneable",
  STYLE_DELETABLE : "deletable",
  STYLE_SHAPE : "shape",
  STYLE_EDGE : "edgeStyle",
  STYLE_JETTY_SIZE : "jettySize",
  STYLE_SOURCE_JETTY_SIZE : "sourceJettySize",
  STYLE_TARGET_JETTY_SIZE : "targetJettySize",
  STYLE_LOOP : "loopStyle",
  STYLE_ORTHOGONAL_LOOP : "orthogonalLoop",
  STYLE_ROUTING_CENTER_X : "routingCenterX",
  STYLE_ROUTING_CENTER_Y : "routingCenterY",
  FONT_BOLD : 1,
  FONT_ITALIC : 2,
  FONT_UNDERLINE : 4,
  FONT_STRIKETHROUGH : 8,
  SHAPE_RECTANGLE : "rectangle",
  SHAPE_ELLIPSE : "ellipse",
  SHAPE_DOUBLE_ELLIPSE : "doubleEllipse",
  SHAPE_RHOMBUS : "rhombus",
  SHAPE_LINE : "line",
  SHAPE_IMAGE : "image",
  SHAPE_ARROW : "arrow",
  SHAPE_ARROW_CONNECTOR : "arrowConnector",
  SHAPE_LABEL : "label",
  SHAPE_CYLINDER : "cylinder",
  SHAPE_SWIMLANE : "swimlane",
  SHAPE_CONNECTOR : "connector",
  SHAPE_ACTOR : "actor",
  SHAPE_CLOUD : "cloud",
  SHAPE_TRIANGLE : "triangle",
  SHAPE_HEXAGON : "hexagon",
  ARROW_CLASSIC : "classic",
  ARROW_CLASSIC_THIN : "classicThin",
  ARROW_BLOCK : "block",
  ARROW_BLOCK_THIN : "blockThin",
  ARROW_OPEN : "open",
  ARROW_OPEN_THIN : "openThin",
  ARROW_OVAL : "oval",
  ARROW_DIAMOND : "diamond",
  ARROW_DIAMOND_THIN : "diamondThin",
  ALIGN_LEFT : "left",
  ALIGN_CENTER : "center",
  ALIGN_RIGHT : "right",
  ALIGN_TOP : "top",
  ALIGN_MIDDLE : "middle",
  ALIGN_BOTTOM : "bottom",
  DIRECTION_NORTH : "north",
  DIRECTION_SOUTH : "south",
  DIRECTION_EAST : "east",
  DIRECTION_WEST : "west",
  TEXT_DIRECTION_DEFAULT : "",
  TEXT_DIRECTION_AUTO : "auto",
  TEXT_DIRECTION_LTR : "ltr",
  TEXT_DIRECTION_RTL : "rtl",
  DIRECTION_MASK_NONE : 0,
  DIRECTION_MASK_WEST : 1,
  DIRECTION_MASK_NORTH : 2,
  DIRECTION_MASK_SOUTH : 4,
  DIRECTION_MASK_EAST : 8,
  DIRECTION_MASK_ALL : 15,
  ELBOW_VERTICAL : "vertical",
  ELBOW_HORIZONTAL : "horizontal",
  EDGESTYLE_ELBOW : "elbowEdgeStyle",
  EDGESTYLE_ENTITY_RELATION : "entityRelationEdgeStyle",
  EDGESTYLE_LOOP : "loopEdgeStyle",
  EDGESTYLE_SIDETOSIDE : "sideToSideEdgeStyle",
  EDGESTYLE_TOPTOBOTTOM : "topToBottomEdgeStyle",
  EDGESTYLE_ORTHOGONAL : "orthogonalEdgeStyle",
  EDGESTYLE_SEGMENT : "segmentEdgeStyle",
  PERIMETER_ELLIPSE : "ellipsePerimeter",
  PERIMETER_RECTANGLE : "rectanglePerimeter",
  PERIMETER_RHOMBUS : "rhombusPerimeter",
  PERIMETER_HEXAGON : "hexagonPerimeter",
  PERIMETER_TRIANGLE : "trianglePerimeter"
};
/**
 * @param {string} name
 * @return {undefined}
 */
function mxEventObject(name) {
  /** @type {string} */
  this.name = name;
  /** @type {!Array} */
  this.properties = [];
  /** @type {number} */
  var i = 1;
  for (; i < arguments.length; i = i + 2) {
    if (null != arguments[i + 1]) {
      this.properties[arguments[i]] = arguments[i + 1];
    }
  }
}
/** @type {null} */
mxEventObject.prototype.name = null;
/** @type {null} */
mxEventObject.prototype.properties = null;
/** @type {boolean} */
mxEventObject.prototype.consumed = false;
/**
 * @return {?}
 */
mxEventObject.prototype.getName = function() {
  return this.name;
};
/**
 * @return {?}
 */
mxEventObject.prototype.getProperties = function() {
  return this.properties;
};
/**
 * @param {string} name
 * @return {?}
 */
mxEventObject.prototype.getProperty = function(name) {
  return this.properties[name];
};
/**
 * @return {?}
 */
mxEventObject.prototype.isConsumed = function() {
  return this.consumed;
};
/**
 * @return {undefined}
 */
mxEventObject.prototype.consume = function() {
  /** @type {boolean} */
  this.consumed = true;
};
/**
 * @param {!Event} evt
 * @param {!Object} val
 * @return {undefined}
 */
function mxMouseEvent(evt, val) {
  /** @type {!Event} */
  this.evt = evt;
  this.sourceState = this.state = val;
}
/** @type {boolean} */
mxMouseEvent.prototype.consumed = false;
/** @type {null} */
mxMouseEvent.prototype.evt = null;
/** @type {null} */
mxMouseEvent.prototype.graphX = null;
/** @type {null} */
mxMouseEvent.prototype.graphY = null;
/** @type {null} */
mxMouseEvent.prototype.state = null;
/** @type {null} */
mxMouseEvent.prototype.sourceState = null;
/**
 * @return {?}
 */
mxMouseEvent.prototype.getEvent = function() {
  return this.evt;
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.getSource = function() {
  return mxEvent.getSource(this.evt);
};
/**
 * @param {!Object} s
 * @return {?}
 */
mxMouseEvent.prototype.isSource = function(s) {
  return null != s ? mxUtils.isAncestorNode(s.node, this.getSource()) : false;
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.getX = function() {
  return mxEvent.getClientX(this.getEvent());
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.getY = function() {
  return mxEvent.getClientY(this.getEvent());
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.getGraphX = function() {
  return this.graphX;
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.getGraphY = function() {
  return this.graphY;
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.getState = function() {
  return this.state;
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.getCell = function() {
  var state = this.getState();
  return null != state ? state.cell : null;
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.isPopupTrigger = function() {
  return mxEvent.isPopupTrigger(this.getEvent());
};
/**
 * @return {?}
 */
mxMouseEvent.prototype.isConsumed = function() {
  return this.consumed;
};
/**
 * @param {string} e
 * @return {undefined}
 */
mxMouseEvent.prototype.consume = function(e) {
  if ((e = null != e ? e : null != this.evt.touches || mxEvent.isMouseEvent(this.evt)) && this.evt.preventDefault) {
    this.evt.preventDefault();
  }
  if (mxClient.IS_IE) {
    /** @type {boolean} */
    this.evt.returnValue = true;
  }
  /** @type {boolean} */
  this.consumed = true;
};
/**
 * @param {string} primaryTxHex
 * @return {undefined}
 */
function mxEventSource(primaryTxHex) {
  this.setEventSource(primaryTxHex);
}
/** @type {null} */
mxEventSource.prototype.eventListeners = null;
/** @type {boolean} */
mxEventSource.prototype.eventsEnabled = true;
/** @type {null} */
mxEventSource.prototype.eventSource = null;
/**
 * @return {?}
 */
mxEventSource.prototype.isEventsEnabled = function() {
  return this.eventsEnabled;
};
/**
 * @param {boolean} enabled
 * @return {undefined}
 */
mxEventSource.prototype.setEventsEnabled = function(enabled) {
  /** @type {boolean} */
  this.eventsEnabled = enabled;
};
/**
 * @return {?}
 */
mxEventSource.prototype.getEventSource = function() {
  return this.eventSource;
};
/**
 * @param {string} newEventSource
 * @return {undefined}
 */
mxEventSource.prototype.setEventSource = function(newEventSource) {
  /** @type {string} */
  this.eventSource = newEventSource;
};
/**
 * @param {!Object} obj
 * @param {string} name
 * @return {undefined}
 */
mxEventSource.prototype.addListener = function(obj, name) {
  if (null == this.eventListeners) {
    /** @type {!Array} */
    this.eventListeners = [];
  }
  this.eventListeners.push(obj);
  this.eventListeners.push(name);
};
/**
 * @param {!Object} event
 * @return {undefined}
 */
mxEventSource.prototype.removeListener = function(event) {
  if (null != this.eventListeners) {
    /** @type {number} */
    var i = 0;
    for (; i < this.eventListeners.length;) {
      if (this.eventListeners[i + 1] == event) {
        this.eventListeners.splice(i, 2);
      } else {
        /** @type {number} */
        i = i + 2;
      }
    }
  }
};
/**
 * @param {string} value
 * @param {!Object} type
 * @return {undefined}
 */
mxEventSource.prototype.fireEvent = function(value, type) {
  if (null != this.eventListeners && this.isEventsEnabled()) {
    if (null == value) {
      value = new mxEventObject;
    }
    if (null == type) {
      type = this.getEventSource();
    }
    if (null == type) {
      type = this;
    }
    /** @type {!Array} */
    var args = [type, value];
    /** @type {number} */
    var i = 0;
    for (; i < this.eventListeners.length; i = i + 2) {
      var e = this.eventListeners[i];
      if (!(null != e && e != value.getName())) {
        this.eventListeners[i + 1].apply(this, args);
      }
    }
  }
};
var mxEvent = {
  addListener : function() {
    return window.addEventListener ? function(a, b, c) {
      a.addEventListener(b, c, false);
      if (null == a.mxListenerList) {
        /** @type {!Array} */
        a.mxListenerList = [];
      }
      a.mxListenerList.push({
        name : b,
        f : c
      });
    } : function(target, event, functionref) {
      target.attachEvent("on" + event, functionref);
      if (null == target.mxListenerList) {
        /** @type {!Array} */
        target.mxListenerList = [];
      }
      target.mxListenerList.push({
        name : event,
        f : functionref
      });
    };
  }(),
  removeListener : function() {
    /**
     * @param {!Node} obj
     * @param {number} index
     * @param {?} fn
     * @return {undefined}
     */
    var test = function(obj, index, fn) {
      if (null != obj.mxListenerList) {
        index = obj.mxListenerList.length;
        /** @type {number} */
        var i = 0;
        for (; i < index; i++) {
          if (obj.mxListenerList[i].f == fn) {
            obj.mxListenerList.splice(i, 1);
            break;
          }
        }
        if (0 == obj.mxListenerList.length) {
          /** @type {null} */
          obj.mxListenerList = null;
        }
      }
    };
    return window.removeEventListener ? function(d, h, e) {
      d.removeEventListener(h, e, false);
      test(d, h, e);
    } : function(element, name, d) {
      element.detachEvent("on" + name, d);
      test(element, name, d);
    };
  }(),
  removeAllListeners : function(e) {
    var video = e.mxListenerList;
    if (null != video) {
      for (; 0 < video.length;) {
        var v = video[0];
        mxEvent.removeListener(e, v.name, v.f);
      }
    }
  },
  addGestureListeners : function(input, name, update, fn) {
    if (null != name) {
      mxEvent.addListener(input, mxClient.IS_POINTER ? "pointerdown" : "mousedown", name);
    }
    if (null != update) {
      mxEvent.addListener(input, mxClient.IS_POINTER ? "pointermove" : "mousemove", update);
    }
    if (null != fn) {
      mxEvent.addListener(input, mxClient.IS_POINTER ? "pointerup" : "mouseup", fn);
    }
    if (!mxClient.IS_POINTER && mxClient.IS_TOUCH) {
      if (null != name) {
        mxEvent.addListener(input, "touchstart", name);
      }
      if (null != update) {
        mxEvent.addListener(input, "touchmove", update);
      }
      if (null != fn) {
        mxEvent.addListener(input, "touchend", fn);
      }
    }
  },
  removeGestureListeners : function(input, type, name, handler) {
    if (null != type) {
      mxEvent.removeListener(input, mxClient.IS_POINTER ? "pointerdown" : "mousedown", type);
    }
    if (null != name) {
      mxEvent.removeListener(input, mxClient.IS_POINTER ? "pointermove" : "mousemove", name);
    }
    if (null != handler) {
      mxEvent.removeListener(input, mxClient.IS_POINTER ? "pointerup" : "mouseup", handler);
    }
    if (!mxClient.IS_POINTER && mxClient.IS_TOUCH) {
      if (null != type) {
        mxEvent.removeListener(input, "touchstart", type);
      }
      if (null != name) {
        mxEvent.removeListener(input, "touchmove", name);
      }
      if (null != handler) {
        mxEvent.removeListener(input, "touchend", handler);
      }
    }
  },
  redirectMouseEvents : function(node, graph, callback, next, progress, resolve, reject) {
    /**
     * @param {string} e
     * @return {?}
     */
    var next = function(e) {
      return "function" == typeof callback ? callback(e) : callback;
    };
    mxEvent.addGestureListeners(node, function(evt) {
      if (null != next) {
        next(evt);
      } else {
        if (!mxEvent.isConsumed(evt)) {
          graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, next(evt)));
        }
      }
    }, function(evt) {
      if (null != progress) {
        progress(evt);
      } else {
        if (!mxEvent.isConsumed(evt)) {
          graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, next(evt)));
        }
      }
    }, function(evt) {
      if (null != resolve) {
        resolve(evt);
      } else {
        if (!mxEvent.isConsumed(evt)) {
          graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, next(evt)));
        }
      }
    });
    mxEvent.addListener(node, "dblclick", function(e) {
      if (null != reject) {
        reject(e);
      } else {
        if (!mxEvent.isConsumed(e)) {
          var result = next(e);
          graph.dblClick(e, null != result ? result.cell : null);
        }
      }
    });
  },
  release : function(e) {
    try {
      if (null != e) {
        mxEvent.removeAllListeners(e);
        var n = e.childNodes;
        if (null != n) {
          var el = n.length;
          /** @type {number} */
          e = 0;
          for (; e < el; e = e + 1) {
            mxEvent.release(n[e]);
          }
        }
      }
    } catch (d) {
    }
  },
  addMouseWheelListener : function(callback, e) {
    if (null != callback) {
      e = null != e ? e : window;
      if (mxClient.IS_SF && !mxClient.IS_TOUCH) {
        /** @type {number} */
        var firstPressMoveY = 1;
        mxEvent.addListener(e, "gesturestart", function(e) {
          mxEvent.consume(e);
          /** @type {number} */
          firstPressMoveY = 1;
        });
        mxEvent.addListener(e, "gesturechange", function(evt) {
          mxEvent.consume(evt);
          /** @type {number} */
          var utcDayCalib = firstPressMoveY - evt.scale;
          if (.2 < Math.abs(utcDayCalib)) {
            callback(evt, 0 > utcDayCalib, true);
            firstPressMoveY = evt.scale;
          }
        });
        mxEvent.addListener(e, "gestureend", function(e) {
          mxEvent.consume(e);
        });
      } else {
        /** @type {!Array} */
        var touches = [];
        /** @type {number} */
        var m = 0;
        /** @type {number} */
        var x = 0;
        mxEvent.addGestureListeners(e, mxUtils.bind(this, function(e) {
          if (!(mxEvent.isMouseEvent(e) || null == e.pointerId)) {
            touches.push(e);
          }
        }), mxUtils.bind(this, function(e) {
          if (!mxEvent.isMouseEvent(e) && 2 == touches.length) {
            /** @type {number} */
            var i = 0;
            for (; i < touches.length; i++) {
              if (e.pointerId == touches[i].pointerId) {
                /** @type {!Object} */
                touches[i] = e;
                break;
              }
            }
            /** @type {number} */
            e = Math.abs(touches[0].clientX - touches[1].clientX);
            /** @type {number} */
            i = Math.abs(touches[0].clientY - touches[1].clientY);
            /** @type {number} */
            var deltaHoriz = Math.abs(e - m);
            /** @type {number} */
            var deltaVert = Math.abs(i - x);
            if (deltaHoriz > mxEvent.PINCH_THRESHOLD || deltaVert > mxEvent.PINCH_THRESHOLD) {
              callback(touches[0], deltaHoriz > deltaVert ? e > m : i > x, true, touches[0].clientX + (touches[1].clientX - touches[0].clientX) / 2, touches[0].clientY + (touches[1].clientY - touches[0].clientY) / 2);
              /** @type {!Object} */
              m = e;
              /** @type {number} */
              x = i;
            }
          }
        }), mxUtils.bind(this, function(a) {
          /** @type {!Array} */
          touches = [];
          /** @type {number} */
          x = m = 0;
        }));
      }
      mxEvent.addListener(e, "wheel", function(event) {
        if (null == event) {
          event = window.event;
        }
        if (event.ctrlKey) {
          event.preventDefault();
        }
        if (.5 < Math.abs(event.deltaX) || .5 < Math.abs(event.deltaY)) {
          callback(event, 0 == event.deltaY ? 0 < -event.deltaX : 0 < -event.deltaY);
        }
      });
    }
  },
  disableContextMenu : function(e) {
    mxEvent.addListener(e, "contextmenu", function(event) {
      if (event.preventDefault) {
        event.preventDefault();
      }
      return false;
    });
  },
  getSource : function(e) {
    return null != e.srcElement ? e.srcElement : e.target;
  },
  isConsumed : function(evt) {
    return null != evt.isConsumed && evt.isConsumed;
  },
  isTouchEvent : function(event) {
    return null != event.pointerType ? "touch" == event.pointerType || event.pointerType === event.MSPOINTER_TYPE_TOUCH : null != event.mozInputSource ? 5 == event.mozInputSource : 0 == event.type.indexOf("touch");
  },
  isPenEvent : function(event) {
    return null != event.pointerType ? "pen" == event.pointerType || event.pointerType === event.MSPOINTER_TYPE_PEN : null != event.mozInputSource ? 2 == event.mozInputSource : 0 == event.type.indexOf("pen");
  },
  isMultiTouchEvent : function(e) {
    return null != e.type && 0 == e.type.indexOf("touch") && null != e.touches && 1 < e.touches.length;
  },
  isMouseEvent : function(e) {
    return null != e.pointerType ? "mouse" == e.pointerType || e.pointerType === e.MSPOINTER_TYPE_MOUSE : null != e.mozInputSource ? 1 == e.mozInputSource : 0 == e.type.indexOf("mouse");
  },
  isLeftMouseButton : function(e) {
    return "buttons" in e && ("mousedown" == e.type || "mousemove" == e.type) ? 1 == e.buttons : "which" in e ? 1 === e.which : 1 === e.button;
  },
  isMiddleMouseButton : function(event) {
    return "which" in event ? 2 === event.which : 4 === event.button;
  },
  isRightMouseButton : function(e) {
    return "which" in e ? 3 === e.which : 2 === e.button;
  },
  isPopupTrigger : function(evt) {
    return mxEvent.isRightMouseButton(evt) || mxClient.IS_MAC && mxEvent.isControlDown(evt) && !mxEvent.isShiftDown(evt) && !mxEvent.isMetaDown(evt) && !mxEvent.isAltDown(evt);
  },
  isShiftDown : function(o) {
    return null != o ? o.shiftKey : false;
  },
  isAltDown : function(o) {
    return null != o ? o.altKey : false;
  },
  isControlDown : function(evt) {
    return null != evt ? evt.ctrlKey : false;
  },
  isMetaDown : function(o) {
    return null != o ? o.metaKey : false;
  },
  getMainEvent : function(event) {
    if ("touchstart" != event.type && "touchmove" != event.type || null == event.touches || null == event.touches[0]) {
      if ("touchend" == event.type && null != event.changedTouches && null != event.changedTouches[0]) {
        event = event.changedTouches[0];
      }
    } else {
      event = event.touches[0];
    }
    return event;
  },
  getClientX : function(e) {
    return mxEvent.getMainEvent(e).clientX;
  },
  getClientY : function(event) {
    return mxEvent.getMainEvent(event).clientY;
  },
  consume : function(e, count, limit) {
    limit = null != limit ? limit : true;
    if (null != count ? count : 1) {
      if (e.preventDefault) {
        if (limit) {
          e.stopPropagation();
        }
        e.preventDefault();
      } else {
        if (limit) {
          /** @type {boolean} */
          e.cancelBubble = true;
        }
      }
    }
    /** @type {boolean} */
    e.isConsumed = true;
    if (!e.preventDefault) {
      /** @type {boolean} */
      e.returnValue = false;
    }
  },
  LABEL_HANDLE : -1,
  ROTATION_HANDLE : -2,
  CUSTOM_HANDLE : -100,
  VIRTUAL_HANDLE : -1E5,
  MOUSE_DOWN : "mouseDown",
  MOUSE_MOVE : "mouseMove",
  MOUSE_UP : "mouseUp",
  ACTIVATE : "activate",
  RESIZE_START : "resizeStart",
  RESIZE : "resize",
  RESIZE_END : "resizeEnd",
  MOVE_START : "moveStart",
  MOVE : "move",
  MOVE_END : "moveEnd",
  PAN_START : "panStart",
  PAN : "pan",
  PAN_END : "panEnd",
  MINIMIZE : "minimize",
  NORMALIZE : "normalize",
  MAXIMIZE : "maximize",
  HIDE : "hide",
  SHOW : "show",
  CLOSE : "close",
  DESTROY : "destroy",
  REFRESH : "refresh",
  SIZE : "size",
  SELECT : "select",
  FIRED : "fired",
  FIRE_MOUSE_EVENT : "fireMouseEvent",
  GESTURE : "gesture",
  TAP_AND_HOLD : "tapAndHold",
  GET : "get",
  RECEIVE : "receive",
  CONNECT : "connect",
  DISCONNECT : "disconnect",
  SUSPEND : "suspend",
  RESUME : "resume",
  MARK : "mark",
  ROOT : "root",
  POST : "post",
  OPEN : "open",
  SAVE : "save",
  BEFORE_ADD_VERTEX : "beforeAddVertex",
  ADD_VERTEX : "addVertex",
  AFTER_ADD_VERTEX : "afterAddVertex",
  DONE : "done",
  EXECUTE : "execute",
  EXECUTED : "executed",
  BEGIN_UPDATE : "beginUpdate",
  START_EDIT : "startEdit",
  END_UPDATE : "endUpdate",
  END_EDIT : "endEdit",
  BEFORE_UNDO : "beforeUndo",
  UNDO : "undo",
  REDO : "redo",
  CHANGE : "change",
  NOTIFY : "notify",
  LAYOUT_CELLS : "layoutCells",
  CLICK : "click",
  SCALE : "scale",
  TRANSLATE : "translate",
  SCALE_AND_TRANSLATE : "scaleAndTranslate",
  UP : "up",
  DOWN : "down",
  ADD : "add",
  REMOVE : "remove",
  CLEAR : "clear",
  ADD_CELLS : "addCells",
  CELLS_ADDED : "cellsAdded",
  MOVE_CELLS : "moveCells",
  CELLS_MOVED : "cellsMoved",
  RESIZE_CELLS : "resizeCells",
  CELLS_RESIZED : "cellsResized",
  TOGGLE_CELLS : "toggleCells",
  CELLS_TOGGLED : "cellsToggled",
  ORDER_CELLS : "orderCells",
  CELLS_ORDERED : "cellsOrdered",
  REMOVE_CELLS : "removeCells",
  CELLS_REMOVED : "cellsRemoved",
  GROUP_CELLS : "groupCells",
  UNGROUP_CELLS : "ungroupCells",
  REMOVE_CELLS_FROM_PARENT : "removeCellsFromParent",
  FOLD_CELLS : "foldCells",
  CELLS_FOLDED : "cellsFolded",
  ALIGN_CELLS : "alignCells",
  LABEL_CHANGED : "labelChanged",
  CONNECT_CELL : "connectCell",
  CELL_CONNECTED : "cellConnected",
  SPLIT_EDGE : "splitEdge",
  FLIP_EDGE : "flipEdge",
  START_EDITING : "startEditing",
  EDITING_STARTED : "editingStarted",
  EDITING_STOPPED : "editingStopped",
  ADD_OVERLAY : "addOverlay",
  REMOVE_OVERLAY : "removeOverlay",
  UPDATE_CELL_SIZE : "updateCellSize",
  ESCAPE : "escape",
  DOUBLE_CLICK : "doubleClick",
  START : "start",
  RESET : "reset",
  PINCH_THRESHOLD : 10
};
/**
 * @param {string} url
 * @param {!Object} data
 * @param {string} method
 * @param {?} async
 * @param {string} username
 * @param {string} password
 * @return {undefined}
 */
function mxXmlRequest(url, data, method, async, username, password) {
  /** @type {string} */
  this.url = url;
  /** @type {!Object} */
  this.params = data;
  this.method = method || "POST";
  this.async = null != async ? async : true;
  /** @type {string} */
  this.username = username;
  /** @type {string} */
  this.password = password;
}
/** @type {null} */
mxXmlRequest.prototype.url = null;
/** @type {null} */
mxXmlRequest.prototype.params = null;
/** @type {null} */
mxXmlRequest.prototype.method = null;
/** @type {null} */
mxXmlRequest.prototype.async = null;
/** @type {boolean} */
mxXmlRequest.prototype.binary = false;
/** @type {boolean} */
mxXmlRequest.prototype.withCredentials = false;
/** @type {null} */
mxXmlRequest.prototype.username = null;
/** @type {null} */
mxXmlRequest.prototype.password = null;
/** @type {null} */
mxXmlRequest.prototype.request = null;
/** @type {boolean} */
mxXmlRequest.prototype.decodeSimulateValues = false;
/**
 * @return {?}
 */
mxXmlRequest.prototype.isBinary = function() {
  return this.binary;
};
/**
 * @param {string} binary
 * @return {undefined}
 */
mxXmlRequest.prototype.setBinary = function(binary) {
  /** @type {string} */
  this.binary = binary;
};
/**
 * @return {?}
 */
mxXmlRequest.prototype.getText = function() {
  return this.request.responseText;
};
/**
 * @return {?}
 */
mxXmlRequest.prototype.isReady = function() {
  return 4 == this.request.readyState;
};
/**
 * @return {?}
 */
mxXmlRequest.prototype.getDocumentElement = function() {
  var xml = this.getXml();
  return null != xml ? xml.documentElement : null;
};
/**
 * @return {?}
 */
mxXmlRequest.prototype.getXml = function() {
  var xml = this.request.responseXML;
  if (9 <= document.documentMode || null == xml || null == xml.documentElement) {
    xml = mxUtils.parseXml(this.request.responseText);
  }
  return xml;
};
/**
 * @return {?}
 */
mxXmlRequest.prototype.getStatus = function() {
  return null != this.request ? this.request.status : null;
};
mxXmlRequest.prototype.create = function() {
  if (window.XMLHttpRequest) {
    return function() {
      /** @type {!XMLHttpRequest} */
      var xhr = new XMLHttpRequest;
      if (this.isBinary() && xhr.overrideMimeType) {
        xhr.overrideMimeType("text/plain; charset=x-user-defined");
      }
      return xhr;
    };
  }
  if ("undefined" != typeof ActiveXObject) {
    return function() {
      return new ActiveXObject("Microsoft.XMLHTTP");
    };
  }
}();
/**
 * @param {string} t
 * @param {!Function} dir
 * @param {number} value
 * @param {?} error
 * @return {undefined}
 */
mxXmlRequest.prototype.send = function(t, dir, value, error) {
  this.request = this.create();
  if (null != this.request) {
    if (null != t) {
      this.request.onreadystatechange = mxUtils.bind(this, function() {
        if (this.isReady()) {
          t(this);
          /** @type {null} */
          this.request.onreadystatechange = null;
        }
      });
    }
    this.request.open(this.method, this.url, this.async, this.username, this.password);
    this.setRequestHeaders(this.request, this.params);
    if (window.XMLHttpRequest && this.withCredentials) {
      /** @type {string} */
      this.request.withCredentials = "true";
    }
    if (!mxClient.IS_QUIRKS && (null == document.documentMode || 9 < document.documentMode) && window.XMLHttpRequest && null != value && null != error) {
      /** @type {number} */
      this.request.timeout = value;
      this.request.ontimeout = error;
    }
    this.request.send(this.params);
  }
};
/**
 * @param {!Object} xhr
 * @param {?} url
 * @return {undefined}
 */
mxXmlRequest.prototype.setRequestHeaders = function(xhr, url) {
  if (null != url) {
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
  }
};
/**
 * @param {!Object} target
 * @param {string} type
 * @return {undefined}
 */
mxXmlRequest.prototype.simulate = function(target, type) {
  target = target || document;
  /** @type {null} */
  var jujuConfig = null;
  if (target == document) {
    /** @type {(function((Event|null)): ?|null)} */
    jujuConfig = window.onbeforeunload;
    /** @type {null} */
    window.onbeforeunload = null;
  }
  var form = target.createElement("form");
  form.setAttribute("method", this.method);
  form.setAttribute("action", this.url);
  if (null != type) {
    form.setAttribute("target", type);
  }
  /** @type {string} */
  form.style.display = "none";
  /** @type {string} */
  form.style.visibility = "hidden";
  var cooks = 0 < this.params.indexOf("&") ? this.params.split("&") : this.params.split();
  /** @type {number} */
  var i = 0;
  for (; i < cooks.length; i++) {
    var a = cooks[i].indexOf("=");
    if (0 < a) {
      var nodeType = cooks[i].substring(0, a);
      a = cooks[i].substring(a + 1);
      if (this.decodeSimulateValues) {
        /** @type {string} */
        a = decodeURIComponent(a);
      }
      var node = target.createElement("textarea");
      node.setAttribute("wrap", "off");
      node.setAttribute("name", nodeType);
      mxUtils.write(node, a);
      form.appendChild(node);
    }
  }
  target.body.appendChild(form);
  form.submit();
  if (null != form.parentNode) {
    form.parentNode.removeChild(form);
  }
  if (null != jujuConfig) {
    window.onbeforeunload = jujuConfig;
  }
};
var mxClipboard = {
  STEPSIZE : 10,
  insertCount : 1,
  cells : null,
  setCells : function(cells) {
    /** @type {number} */
    mxClipboard.cells = cells;
  },
  getCells : function() {
    return mxClipboard.cells;
  },
  isEmpty : function() {
    return null == mxClipboard.getCells();
  },
  cut : function(from, data) {
    data = mxClipboard.copy(from, data);
    /** @type {number} */
    mxClipboard.insertCount = 0;
    mxClipboard.removeCells(from, data);
    return data;
  },
  removeCells : function(position, id) {
    position.removeCells(id);
  },
  copy : function(graph, parent) {
    parent = parent || graph.getSelectionCells();
    var cells = graph.getExportableCells(graph.model.getTopmostCells(parent));
    /** @type {number} */
    mxClipboard.insertCount = 1;
    mxClipboard.setCells(graph.cloneCells(cells));
    return cells;
  },
  paste : function(graph) {
    /** @type {null} */
    var cells = null;
    if (!mxClipboard.isEmpty()) {
      cells = graph.getImportableCells(mxClipboard.getCells());
      /** @type {number} */
      var y = mxClipboard.insertCount * mxClipboard.STEPSIZE;
      var target = graph.getDefaultParent();
      cells = graph.importCells(cells, y, y, target);
      mxClipboard.insertCount++;
      graph.setSelectionCells(cells);
    }
    return cells;
  }
};
/**
 * @param {string} text
 * @param {string} img
 * @param {undefined} canvas
 * @param {!Object} filter
 * @param {string} args
 * @param {string} color
 * @param {?} v
 * @param {string} minlist
 * @param {!Object} n
 * @param {string} type
 * @return {undefined}
 */
function mxWindow(text, img, canvas, filter, args, color, v, minlist, n, type) {
  if (null != img) {
    v = null != v ? v : true;
    /** @type {string} */
    this.content = img;
    this.init(canvas, filter, args, color, type);
    this.installMaximizeHandler();
    this.installMinimizeHandler();
    this.installCloseHandler();
    this.setMinimizable(v);
    this.setTitle(text);
    if (null == minlist || minlist) {
      this.installMoveHandler();
    }
    if (null != n && null != n.parentNode) {
      n.parentNode.replaceChild(this.div, n);
    } else {
      document.body.appendChild(this.div);
    }
  }
}
mxWindow.prototype = new mxEventSource;
/** @type {function(string, string, undefined, !Object, string, string, ?, string, !Object, string): undefined} */
mxWindow.prototype.constructor = mxWindow;
/** @type {string} */
mxWindow.prototype.closeImage = mxClient.imageBasePath + "/close.gif";
/** @type {string} */
mxWindow.prototype.minimizeImage = mxClient.imageBasePath + "/minimize.gif";
/** @type {string} */
mxWindow.prototype.normalizeImage = mxClient.imageBasePath + "/normalize.gif";
/** @type {string} */
mxWindow.prototype.maximizeImage = mxClient.imageBasePath + "/maximize.gif";
/** @type {string} */
mxWindow.prototype.resizeImage = mxClient.imageBasePath + "/resize.gif";
/** @type {boolean} */
mxWindow.prototype.visible = false;
mxWindow.prototype.minimumSize = new mxRectangle(0, 0, 50, 40);
/** @type {boolean} */
mxWindow.prototype.destroyOnClose = true;
/** @type {number} */
mxWindow.prototype.contentHeightCorrection = 8 == document.documentMode || 7 == document.documentMode ? 6 : 2;
/** @type {null} */
mxWindow.prototype.title = null;
/** @type {null} */
mxWindow.prototype.content = null;
/**
 * @param {!Object} node
 * @param {!Object} s
 * @param {string} c
 * @param {string} n
 * @param {string} type
 * @return {undefined}
 */
mxWindow.prototype.init = function(node, s, c, n, type) {
  type = null != type ? type : "mxWindow";
  /** @type {!Element} */
  this.div = document.createElement("div");
  /** @type {string} */
  this.div.className = type;
  /** @type {string} */
  this.div.style.left = node + "px";
  /** @type {string} */
  this.div.style.top = s + "px";
  /** @type {!Element} */
  this.table = document.createElement("table");
  /** @type {string} */
  this.table.className = type;
  if (mxClient.IS_POINTER) {
    /** @type {string} */
    this.div.style.touchAction = "none";
  }
  if (null != c) {
    if (!mxClient.IS_QUIRKS) {
      /** @type {string} */
      this.div.style.width = c + "px";
    }
    /** @type {string} */
    this.table.style.width = c + "px";
  }
  if (null != n) {
    if (!mxClient.IS_QUIRKS) {
      /** @type {string} */
      this.div.style.height = n + "px";
    }
    /** @type {string} */
    this.table.style.height = n + "px";
  }
  /** @type {!Element} */
  node = document.createElement("tbody");
  /** @type {!Element} */
  s = document.createElement("tr");
  /** @type {!Element} */
  this.title = document.createElement("td");
  /** @type {string} */
  this.title.className = type + "Title";
  /** @type {!Element} */
  this.buttons = document.createElement("div");
  /** @type {string} */
  this.buttons.style.position = "absolute";
  /** @type {string} */
  this.buttons.style.display = "inline-block";
  /** @type {string} */
  this.buttons.style.right = "4px";
  /** @type {string} */
  this.buttons.style.top = "5px";
  this.title.appendChild(this.buttons);
  s.appendChild(this.title);
  node.appendChild(s);
  /** @type {!Element} */
  s = document.createElement("tr");
  /** @type {!Element} */
  this.td = document.createElement("td");
  /** @type {string} */
  this.td.className = type + "Pane";
  if (7 == document.documentMode) {
    /** @type {string} */
    this.td.style.height = "100%";
  }
  /** @type {!Element} */
  this.contentWrapper = document.createElement("div");
  /** @type {string} */
  this.contentWrapper.className = type + "Pane";
  /** @type {string} */
  this.contentWrapper.style.width = "100%";
  this.contentWrapper.appendChild(this.content);
  if (mxClient.IS_QUIRKS || "DIV" != this.content.nodeName.toUpperCase()) {
    /** @type {string} */
    this.contentWrapper.style.height = "100%";
  }
  this.td.appendChild(this.contentWrapper);
  s.appendChild(this.td);
  node.appendChild(s);
  this.table.appendChild(node);
  this.div.appendChild(this.table);
  type = mxUtils.bind(this, function(a) {
    this.activate();
  });
  mxEvent.addGestureListeners(this.title, type);
  mxEvent.addGestureListeners(this.table, type);
  this.hide();
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxWindow.prototype.setTitle = function(value) {
  var shape = this.title.firstChild;
  for (; null != shape;) {
    var node = shape.nextSibling;
    if (shape.nodeType == mxConstants.NODETYPE_TEXT) {
      shape.parentNode.removeChild(shape);
    }
    shape = node;
  }
  mxUtils.write(this.title, value || "");
  this.title.appendChild(this.buttons);
};
/**
 * @param {boolean} state
 * @return {undefined}
 */
mxWindow.prototype.setScrollable = function(state) {
  if (null == navigator.userAgent || 0 > navigator.userAgent.indexOf("Presto/2.5")) {
    /** @type {string} */
    this.contentWrapper.style.overflow = state ? "auto" : "hidden";
  }
};
/**
 * @return {undefined}
 */
mxWindow.prototype.activate = function() {
  if (mxWindow.activeWindow != this) {
    var val = mxUtils.getCurrentStyle(this.getElement());
    val = null != val ? val.zIndex : 3;
    if (mxWindow.activeWindow) {
      var win = mxWindow.activeWindow.getElement();
      if (null != win && null != win.style) {
        win.style.zIndex = val;
      }
    }
    win = mxWindow.activeWindow;
    /** @type {number} */
    this.getElement().style.zIndex = parseInt(val) + 1;
    mxWindow.activeWindow = this;
    this.fireEvent(new mxEventObject(mxEvent.ACTIVATE, "previousWindow", win));
  }
};
/**
 * @return {?}
 */
mxWindow.prototype.getElement = function() {
  return this.div;
};
/**
 * @return {undefined}
 */
mxWindow.prototype.fit = function() {
  mxUtils.fit(this.div);
};
/**
 * @return {?}
 */
mxWindow.prototype.isResizable = function() {
  return null != this.resize ? "none" != this.resize.style.display : false;
};
/**
 * @param {string} resizable
 * @return {undefined}
 */
mxWindow.prototype.setResizable = function(resizable) {
  if (resizable) {
    if (null == this.resize) {
      /** @type {!Element} */
      this.resize = document.createElement("img");
      /** @type {string} */
      this.resize.style.position = "absolute";
      /** @type {string} */
      this.resize.style.bottom = "2px";
      /** @type {string} */
      this.resize.style.right = "2px";
      this.resize.setAttribute("src", this.resizeImage);
      /** @type {string} */
      this.resize.style.cursor = "nw-resize";
      /** @type {null} */
      var msgW = null;
      /** @type {null} */
      var morphWithHalos = null;
      /** @type {null} */
      var dw = null;
      /** @type {null} */
      var dHeight = null;
      resizable = mxUtils.bind(this, function(evt) {
        this.activate();
        msgW = mxEvent.getClientX(evt);
        morphWithHalos = mxEvent.getClientY(evt);
        dw = this.div.offsetWidth;
        dHeight = this.div.offsetHeight;
        mxEvent.addGestureListeners(document, null, update, handleMoveOrResize);
        this.fireEvent(new mxEventObject(mxEvent.RESIZE_START, "event", evt));
        mxEvent.consume(evt);
      });
      var update = mxUtils.bind(this, function(e) {
        if (null != msgW && null != morphWithHalos) {
          /** @type {number} */
          var deltaW = mxEvent.getClientX(e) - msgW;
          /** @type {number} */
          var deltaH = mxEvent.getClientY(e) - morphWithHalos;
          this.setSize(dw + deltaW, dHeight + deltaH);
          this.fireEvent(new mxEventObject(mxEvent.RESIZE, "event", e));
          mxEvent.consume(e);
        }
      });
      var handleMoveOrResize = mxUtils.bind(this, function(e) {
        if (null != msgW && null != morphWithHalos) {
          /** @type {null} */
          morphWithHalos = msgW = null;
          mxEvent.removeGestureListeners(document, null, update, handleMoveOrResize);
          this.fireEvent(new mxEventObject(mxEvent.RESIZE_END, "event", e));
          mxEvent.consume(e);
        }
      });
      mxEvent.addGestureListeners(this.resize, resizable, update, handleMoveOrResize);
      this.div.appendChild(this.resize);
    } else {
      /** @type {string} */
      this.resize.style.display = "inline";
    }
  } else {
    if (null != this.resize) {
      /** @type {string} */
      this.resize.style.display = "none";
    }
  }
};
/**
 * @param {number} size
 * @param {number} offset
 * @return {undefined}
 */
mxWindow.prototype.setSize = function(size, offset) {
  /** @type {number} */
  size = Math.max(this.minimumSize.width, size);
  /** @type {number} */
  offset = Math.max(this.minimumSize.height, offset);
  if (!mxClient.IS_QUIRKS) {
    /** @type {string} */
    this.div.style.width = size + "px";
    /** @type {string} */
    this.div.style.height = offset + "px";
  }
  /** @type {string} */
  this.table.style.width = size + "px";
  /** @type {string} */
  this.table.style.height = offset + "px";
  if (!mxClient.IS_QUIRKS) {
    /** @type {string} */
    this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
  }
};
/**
 * @param {boolean} show
 * @return {undefined}
 */
mxWindow.prototype.setMinimizable = function(show) {
  /** @type {string} */
  this.minimize.style.display = show ? "" : "none";
};
/**
 * @return {?}
 */
mxWindow.prototype.getMinimumSize = function() {
  return new mxRectangle(0, 0, 0, this.title.offsetHeight);
};
/**
 * @return {undefined}
 */
mxWindow.prototype.installMinimizeHandler = function() {
  /** @type {!Element} */
  this.minimize = document.createElement("img");
  this.minimize.setAttribute("src", this.minimizeImage);
  this.minimize.setAttribute("title", "Minimize");
  /** @type {string} */
  this.minimize.style.cursor = "pointer";
  /** @type {string} */
  this.minimize.style.marginLeft = "2px";
  /** @type {string} */
  this.minimize.style.display = "none";
  this.buttons.appendChild(this.minimize);
  /** @type {boolean} */
  var a = false;
  /** @type {null} */
  var display = null;
  /** @type {null} */
  var _viewPortH = null;
  var mm = mxUtils.bind(this, function(e) {
    this.activate();
    if (a) {
      /** @type {boolean} */
      a = false;
      this.minimize.setAttribute("src", this.minimizeImage);
      this.minimize.setAttribute("title", "Minimize");
      /** @type {string} */
      this.contentWrapper.style.display = "";
      this.maximize.style.display = display;
      if (!mxClient.IS_QUIRKS) {
        this.div.style.height = _viewPortH;
      }
      this.table.style.height = _viewPortH;
      if (null != this.resize) {
        /** @type {string} */
        this.resize.style.visibility = "";
      }
      this.fireEvent(new mxEventObject(mxEvent.NORMALIZE, "event", e));
    } else {
      /** @type {boolean} */
      a = true;
      this.minimize.setAttribute("src", this.normalizeImage);
      this.minimize.setAttribute("title", "Normalize");
      /** @type {string} */
      this.contentWrapper.style.display = "none";
      display = this.maximize.style.display;
      /** @type {string} */
      this.maximize.style.display = "none";
      _viewPortH = this.table.style.height;
      var svRect = this.getMinimumSize();
      if (0 < svRect.height) {
        if (!mxClient.IS_QUIRKS) {
          /** @type {string} */
          this.div.style.height = svRect.height + "px";
        }
        /** @type {string} */
        this.table.style.height = svRect.height + "px";
      }
      if (0 < svRect.width) {
        if (!mxClient.IS_QUIRKS) {
          /** @type {string} */
          this.div.style.width = svRect.width + "px";
        }
        /** @type {string} */
        this.table.style.width = svRect.width + "px";
      }
      if (null != this.resize) {
        /** @type {string} */
        this.resize.style.visibility = "hidden";
      }
      this.fireEvent(new mxEventObject(mxEvent.MINIMIZE, "event", e));
    }
    mxEvent.consume(e);
  });
  mxEvent.addGestureListeners(this.minimize, mm);
};
/**
 * @param {boolean} doShowDetailsSection
 * @return {undefined}
 */
mxWindow.prototype.setMaximizable = function(doShowDetailsSection) {
  /** @type {string} */
  this.maximize.style.display = doShowDetailsSection ? "" : "none";
};
/**
 * @return {undefined}
 */
mxWindow.prototype.installMaximizeHandler = function() {
  /** @type {!Element} */
  this.maximize = document.createElement("img");
  this.maximize.setAttribute("src", this.maximizeImage);
  this.maximize.setAttribute("title", "Maximize");
  /** @type {string} */
  this.maximize.style.cursor = "default";
  /** @type {string} */
  this.maximize.style.marginLeft = "2px";
  /** @type {string} */
  this.maximize.style.cursor = "pointer";
  /** @type {string} */
  this.maximize.style.display = "none";
  this.buttons.appendChild(this.maximize);
  /** @type {boolean} */
  var a = false;
  /** @type {null} */
  var imagePosLeft = null;
  /** @type {null} */
  var topValue = null;
  /** @type {null} */
  var _viewPortH = null;
  /** @type {null} */
  var runtimeWidth = null;
  /** @type {null} */
  var display = null;
  var update = mxUtils.bind(this, function(e) {
    this.activate();
    if ("none" != this.maximize.style.display) {
      if (a) {
        /** @type {boolean} */
        a = false;
        this.maximize.setAttribute("src", this.maximizeImage);
        this.maximize.setAttribute("title", "Maximize");
        /** @type {string} */
        this.contentWrapper.style.display = "";
        this.minimize.style.display = display;
        this.div.style.left = imagePosLeft + "px";
        this.div.style.top = topValue + "px";
        if (!(mxClient.IS_QUIRKS || (this.div.style.height = _viewPortH, this.div.style.width = runtimeWidth, y = mxUtils.getCurrentStyle(this.contentWrapper), "auto" != y.overflow && null == this.resize))) {
          /** @type {string} */
          this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
        }
        this.table.style.height = _viewPortH;
        this.table.style.width = runtimeWidth;
        if (null != this.resize) {
          /** @type {string} */
          this.resize.style.visibility = "";
        }
        this.fireEvent(new mxEventObject(mxEvent.NORMALIZE, "event", e));
      } else {
        /** @type {boolean} */
        a = true;
        this.maximize.setAttribute("src", this.normalizeImage);
        this.maximize.setAttribute("title", "Normalize");
        /** @type {string} */
        this.contentWrapper.style.display = "";
        display = this.minimize.style.display;
        /** @type {string} */
        this.minimize.style.display = "none";
        /** @type {number} */
        imagePosLeft = parseInt(this.div.style.left);
        /** @type {number} */
        topValue = parseInt(this.div.style.top);
        _viewPortH = this.table.style.height;
        runtimeWidth = this.table.style.width;
        /** @type {string} */
        this.div.style.left = "0px";
        /** @type {string} */
        this.div.style.top = "0px";
        /** @type {number} */
        y = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight || 0);
        if (!mxClient.IS_QUIRKS) {
          /** @type {string} */
          this.div.style.width = document.body.clientWidth - 2 + "px";
          /** @type {string} */
          this.div.style.height = y - 2 + "px";
        }
        /** @type {string} */
        this.table.style.width = document.body.clientWidth - 2 + "px";
        /** @type {string} */
        this.table.style.height = y - 2 + "px";
        if (null != this.resize) {
          /** @type {string} */
          this.resize.style.visibility = "hidden";
        }
        if (!mxClient.IS_QUIRKS) {
          var y = mxUtils.getCurrentStyle(this.contentWrapper);
          if ("auto" == y.overflow || null != this.resize) {
            /** @type {string} */
            this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
          }
        }
        this.fireEvent(new mxEventObject(mxEvent.MAXIMIZE, "event", e));
      }
      mxEvent.consume(e);
    }
  });
  mxEvent.addGestureListeners(this.maximize, update);
  mxEvent.addListener(this.title, "dblclick", update);
};
/**
 * @return {undefined}
 */
mxWindow.prototype.installMoveHandler = function() {
  /** @type {string} */
  this.title.style.cursor = "move";
  mxEvent.addGestureListeners(this.title, mxUtils.bind(this, function(evt) {
    var _getClientCoordinates = mxEvent.getClientX(evt);
    var offset = mxEvent.getClientY(evt);
    var x = this.getX();
    var left = this.getY();
    var update = mxUtils.bind(this, function(e) {
      /** @type {number} */
      var EPSILSON = mxEvent.getClientX(e) - _getClientCoordinates;
      /** @type {number} */
      var n = mxEvent.getClientY(e) - offset;
      this.setLocation(x + EPSILSON, left + n);
      this.fireEvent(new mxEventObject(mxEvent.MOVE, "event", e));
      mxEvent.consume(e);
    });
    var handleMoveOrResize = mxUtils.bind(this, function(e) {
      mxEvent.removeGestureListeners(document, null, update, handleMoveOrResize);
      this.fireEvent(new mxEventObject(mxEvent.MOVE_END, "event", e));
      mxEvent.consume(e);
    });
    mxEvent.addGestureListeners(document, null, update, handleMoveOrResize);
    this.fireEvent(new mxEventObject(mxEvent.MOVE_START, "event", evt));
    mxEvent.consume(evt);
  }));
  if (mxClient.IS_POINTER) {
    /** @type {string} */
    this.title.style.touchAction = "none";
  }
};
/**
 * @param {number} left
 * @param {number} top
 * @return {undefined}
 */
mxWindow.prototype.setLocation = function(left, top) {
  /** @type {string} */
  this.div.style.left = left + "px";
  /** @type {string} */
  this.div.style.top = top + "px";
};
/**
 * @return {?}
 */
mxWindow.prototype.getX = function() {
  return parseInt(this.div.style.left);
};
/**
 * @return {?}
 */
mxWindow.prototype.getY = function() {
  return parseInt(this.div.style.top);
};
/**
 * @return {undefined}
 */
mxWindow.prototype.installCloseHandler = function() {
  /** @type {!Element} */
  this.closeImg = document.createElement("img");
  this.closeImg.setAttribute("src", this.closeImage);
  this.closeImg.setAttribute("title", "Close");
  /** @type {string} */
  this.closeImg.style.marginLeft = "2px";
  /** @type {string} */
  this.closeImg.style.cursor = "pointer";
  /** @type {string} */
  this.closeImg.style.display = "none";
  this.buttons.appendChild(this.closeImg);
  mxEvent.addGestureListeners(this.closeImg, mxUtils.bind(this, function(e) {
    this.fireEvent(new mxEventObject(mxEvent.CLOSE, "event", e));
    if (this.destroyOnClose) {
      this.destroy();
    } else {
      this.setVisible(false);
    }
    mxEvent.consume(e);
  }));
};
/**
 * @param {string} source
 * @return {undefined}
 */
mxWindow.prototype.setImage = function(source) {
  /** @type {!Element} */
  this.image = document.createElement("img");
  this.image.setAttribute("src", source);
  this.image.setAttribute("align", "left");
  /** @type {string} */
  this.image.style.marginRight = "4px";
  /** @type {string} */
  this.image.style.marginLeft = "0px";
  /** @type {string} */
  this.image.style.marginTop = "-2px";
  this.title.insertBefore(this.image, this.title.firstChild);
};
/**
 * @param {boolean} doShowDetailsSection
 * @return {undefined}
 */
mxWindow.prototype.setClosable = function(doShowDetailsSection) {
  /** @type {string} */
  this.closeImg.style.display = doShowDetailsSection ? "" : "none";
};
/**
 * @return {?}
 */
mxWindow.prototype.isVisible = function() {
  return null != this.div ? "none" != this.div.style.display : false;
};
/**
 * @param {boolean} isVisible
 * @return {undefined}
 */
mxWindow.prototype.setVisible = function(isVisible) {
  if (null != this.div && this.isVisible() != isVisible) {
    if (isVisible) {
      this.show();
    } else {
      this.hide();
    }
  }
};
/**
 * @return {undefined}
 */
mxWindow.prototype.show = function() {
  /** @type {string} */
  this.div.style.display = "";
  this.activate();
  var css_options = mxUtils.getCurrentStyle(this.contentWrapper);
  if (!(mxClient.IS_QUIRKS || "auto" != css_options.overflow && null == this.resize || "none" == this.contentWrapper.style.display)) {
    /** @type {string} */
    this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
  }
  this.fireEvent(new mxEventObject(mxEvent.SHOW));
};
/**
 * @return {undefined}
 */
mxWindow.prototype.hide = function() {
  /** @type {string} */
  this.div.style.display = "none";
  this.fireEvent(new mxEventObject(mxEvent.HIDE));
};
/**
 * @return {undefined}
 */
mxWindow.prototype.destroy = function() {
  this.fireEvent(new mxEventObject(mxEvent.DESTROY));
  if (null != this.div) {
    mxEvent.release(this.div);
    this.div.parentNode.removeChild(this.div);
    /** @type {null} */
    this.div = null;
  }
  /** @type {null} */
  this.contentWrapper = this.content = this.title = null;
};
/**
 * @param {string} iconclass
 * @return {undefined}
 */
function mxForm(iconclass) {
  /** @type {!Element} */
  this.table = document.createElement("table");
  /** @type {string} */
  this.table.className = iconclass;
  /** @type {!Element} */
  this.body = document.createElement("tbody");
  this.table.appendChild(this.body);
}
/** @type {null} */
mxForm.prototype.table = null;
/** @type {boolean} */
mxForm.prototype.body = false;
/**
 * @return {?}
 */
mxForm.prototype.getTable = function() {
  return this.table;
};
/**
 * @param {?} element
 * @param {?} test
 * @return {undefined}
 */
mxForm.prototype.addButtons = function(element, test) {
  /** @type {!Element} */
  var trComments = document.createElement("tr");
  /** @type {!Element} */
  var commentsCell = document.createElement("td");
  trComments.appendChild(commentsCell);
  /** @type {!Element} */
  commentsCell = document.createElement("td");
  /** @type {!Element} */
  var div = document.createElement("button");
  mxUtils.write(div, mxResources.get("ok") || "OK");
  commentsCell.appendChild(div);
  mxEvent.addListener(div, "click", function() {
    element();
  });
  /** @type {!Element} */
  div = document.createElement("button");
  mxUtils.write(div, mxResources.get("cancel") || "Cancel");
  commentsCell.appendChild(div);
  mxEvent.addListener(div, "click", function() {
    test();
  });
  trComments.appendChild(commentsCell);
  this.body.appendChild(trComments);
};
/**
 * @param {string} name
 * @param {!Object} text
 * @param {string} type
 * @return {?}
 */
mxForm.prototype.addText = function(name, text, type) {
  /** @type {!Element} */
  var input = document.createElement("input");
  input.setAttribute("type", type || "text");
  /** @type {!Object} */
  input.value = text;
  return this.addField(name, input);
};
/**
 * @param {string} name
 * @param {?} state
 * @return {?}
 */
mxForm.prototype.addCheckbox = function(name, state) {
  /** @type {!Element} */
  var checkbox = document.createElement("input");
  checkbox.setAttribute("type", "checkbox");
  this.addField(name, checkbox);
  if (state) {
    /** @type {boolean} */
    checkbox.checked = true;
  }
  return checkbox;
};
/**
 * @param {string} key
 * @param {!Object} value
 * @param {number} id
 * @return {?}
 */
mxForm.prototype.addTextarea = function(key, value, id) {
  /** @type {!Element} */
  var node = document.createElement("textarea");
  if (mxClient.IS_NS) {
    id--;
  }
  node.setAttribute("rows", id || 2);
  /** @type {!Object} */
  node.value = value;
  return this.addField(key, node);
};
/**
 * @param {string} data
 * @param {?} selector
 * @param {string} callback
 * @return {?}
 */
mxForm.prototype.addCombo = function(data, selector, callback) {
  /** @type {!Element} */
  var node = document.createElement("select");
  if (null != callback) {
    node.setAttribute("size", callback);
  }
  if (selector) {
    node.setAttribute("multiple", "true");
  }
  return this.addField(data, node);
};
/**
 * @param {!Element} fn
 * @param {string} value
 * @param {string} name
 * @param {string} val
 * @return {undefined}
 */
mxForm.prototype.addOption = function(fn, value, name, val) {
  /** @type {!Element} */
  var e = document.createElement("option");
  mxUtils.writeln(e, value);
  e.setAttribute("value", name);
  if (val) {
    e.setAttribute("selected", val);
  }
  fn.appendChild(e);
};
/**
 * @param {string} value
 * @param {(Node|Window)} input
 * @return {?}
 */
mxForm.prototype.addField = function(value, input) {
  /** @type {!Element} */
  var ref = document.createElement("tr");
  /** @type {!Element} */
  var node = document.createElement("td");
  mxUtils.write(node, value);
  ref.appendChild(node);
  /** @type {!Element} */
  node = document.createElement("td");
  node.appendChild(input);
  ref.appendChild(node);
  this.body.appendChild(ref);
  return input;
};
/**
 * @param {string} src
 * @param {number} width
 * @param {number} height
 * @return {undefined}
 */
function mxImage(src, width, height) {
  /** @type {string} */
  this.src = src;
  /** @type {number} */
  this.width = width;
  /** @type {number} */
  this.height = height;
}
/** @type {null} */
mxImage.prototype.src = null;
/** @type {null} */
mxImage.prototype.width = null;
/** @type {null} */
mxImage.prototype.height = null;
/**
 * @param {string} e
 * @param {!Object} link
 * @return {undefined}
 */
function mxDivResizer(e, link) {
  if ("div" == e.nodeName.toLowerCase()) {
    if (null == link) {
      /** @type {!Window} */
      link = window;
    }
    /** @type {string} */
    this.div = e;
    var settings = mxUtils.getCurrentStyle(e);
    if (null != settings) {
      /** @type {boolean} */
      this.resizeWidth = "auto" == settings.width;
      /** @type {boolean} */
      this.resizeHeight = "auto" == settings.height;
    }
    mxEvent.addListener(link, "resize", mxUtils.bind(this, function(a) {
      if (!this.handlingResize) {
        /** @type {boolean} */
        this.handlingResize = true;
        this.resize();
        /** @type {boolean} */
        this.handlingResize = false;
      }
    }));
    this.resize();
  }
}
/** @type {boolean} */
mxDivResizer.prototype.resizeWidth = true;
/** @type {boolean} */
mxDivResizer.prototype.resizeHeight = true;
/** @type {boolean} */
mxDivResizer.prototype.handlingResize = false;
/**
 * @return {undefined}
 */
mxDivResizer.prototype.resize = function() {
  var h = this.getDocumentWidth();
  var b = this.getDocumentHeight();
  /** @type {number} */
  var g = parseInt(this.div.style.left);
  /** @type {number} */
  var w = parseInt(this.div.style.right);
  /** @type {number} */
  var t = parseInt(this.div.style.top);
  /** @type {number} */
  var a = parseInt(this.div.style.bottom);
  if (this.resizeWidth && !isNaN(g) && !isNaN(w) && 0 <= g && 0 <= w && 0 < h - w - g) {
    /** @type {string} */
    this.div.style.width = h - w - g + "px";
  }
  if (this.resizeHeight && !isNaN(t) && !isNaN(a) && 0 <= t && 0 <= a && 0 < b - t - a) {
    /** @type {string} */
    this.div.style.height = b - t - a + "px";
  }
};
/**
 * @return {?}
 */
mxDivResizer.prototype.getDocumentWidth = function() {
  return document.body.clientWidth;
};
/**
 * @return {?}
 */
mxDivResizer.prototype.getDocumentHeight = function() {
  return document.body.clientHeight;
};
/**
 * @param {!Object} img
 * @param {string} notNew
 * @return {undefined}
 */
function mxDragSource(img, notNew) {
  /** @type {!Object} */
  this.element = img;
  /** @type {string} */
  this.dropHandler = notNew;
  mxEvent.addGestureListeners(img, mxUtils.bind(this, function(e) {
    this.mouseDown(e);
  }));
  mxEvent.addListener(img, "dragstart", function(e) {
    mxEvent.consume(e);
  });
  /**
   * @param {?} index
   * @param {!Object} item
   * @return {undefined}
   */
  this.eventConsumer = function(index, item) {
    var eventSubs = item.getProperty("eventName");
    var event = item.getProperty("event");
    if (eventSubs != mxEvent.MOUSE_DOWN) {
      event.consume();
    }
  };
}
/** @type {null} */
mxDragSource.prototype.element = null;
/** @type {null} */
mxDragSource.prototype.dropHandler = null;
/** @type {null} */
mxDragSource.prototype.dragOffset = null;
/** @type {null} */
mxDragSource.prototype.dragElement = null;
/** @type {null} */
mxDragSource.prototype.previewElement = null;
/** @type {null} */
mxDragSource.prototype.previewOffset = null;
/** @type {boolean} */
mxDragSource.prototype.enabled = true;
/** @type {null} */
mxDragSource.prototype.currentGraph = null;
/** @type {null} */
mxDragSource.prototype.currentDropTarget = null;
/** @type {null} */
mxDragSource.prototype.currentPoint = null;
/** @type {null} */
mxDragSource.prototype.currentGuide = null;
/** @type {null} */
mxDragSource.prototype.currentHighlight = null;
/** @type {boolean} */
mxDragSource.prototype.autoscroll = true;
/** @type {boolean} */
mxDragSource.prototype.guidesEnabled = true;
/** @type {boolean} */
mxDragSource.prototype.gridEnabled = true;
/** @type {boolean} */
mxDragSource.prototype.highlightDropTargets = true;
/** @type {number} */
mxDragSource.prototype.dragElementZIndex = 100;
/** @type {number} */
mxDragSource.prototype.dragElementOpacity = 70;
/** @type {boolean} */
mxDragSource.prototype.checkEventSource = true;
/**
 * @return {?}
 */
mxDragSource.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxDragSource.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxDragSource.prototype.isGuidesEnabled = function() {
  return this.guidesEnabled;
};
/**
 * @param {boolean} addedRenderer
 * @return {undefined}
 */
mxDragSource.prototype.setGuidesEnabled = function(addedRenderer) {
  /** @type {boolean} */
  this.guidesEnabled = addedRenderer;
};
/**
 * @return {?}
 */
mxDragSource.prototype.isGridEnabled = function() {
  return this.gridEnabled;
};
/**
 * @param {number} a
 * @return {undefined}
 */
mxDragSource.prototype.setGridEnabled = function(a) {
  /** @type {number} */
  this.gridEnabled = a;
};
/**
 * @param {!Object} a22
 * @return {?}
 */
mxDragSource.prototype.getGraphForEvent = function(a22) {
  return null;
};
/**
 * @param {!Object} graph
 * @param {?} x
 * @param {?} y
 * @param {(Object|string)} event
 * @return {?}
 */
mxDragSource.prototype.getDropTarget = function(graph, x, y, event) {
  return graph.getCellAt(x, y);
};
/**
 * @param {!Object} element
 * @return {?}
 */
mxDragSource.prototype.createDragElement = function(element) {
  return this.element.cloneNode(true);
};
/**
 * @param {string} sourceGraph
 * @return {?}
 */
mxDragSource.prototype.createPreviewElement = function(sourceGraph) {
  return null;
};
/**
 * @return {?}
 */
mxDragSource.prototype.isActive = function() {
  return null != this.mouseMoveHandler;
};
/**
 * @return {undefined}
 */
mxDragSource.prototype.reset = function() {
  if (null != this.currentGraph) {
    this.dragExit(this.currentGraph);
    /** @type {null} */
    this.currentGraph = null;
  }
  this.removeDragElement();
  this.removeListeners();
  this.stopDrag();
};
/**
 * @param {undefined} e
 * @return {undefined}
 */
mxDragSource.prototype.mouseDown = function(e) {
  if (this.enabled && !mxEvent.isConsumed(e) && null == this.mouseMoveHandler) {
    this.startDrag(e);
    this.mouseMoveHandler = mxUtils.bind(this, this.mouseMove);
    this.mouseUpHandler = mxUtils.bind(this, this.mouseUp);
    mxEvent.addGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);
    if (mxClient.IS_TOUCH && !mxEvent.isMouseEvent(e)) {
      this.eventSource = mxEvent.getSource(e);
      mxEvent.addGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);
    }
  }
};
/**
 * @param {!Object} e
 * @return {undefined}
 */
mxDragSource.prototype.startDrag = function(e) {
  this.dragElement = this.createDragElement(e);
  /** @type {string} */
  this.dragElement.style.position = "absolute";
  this.dragElement.style.zIndex = this.dragElementZIndex;
  mxUtils.setOpacity(this.dragElement, this.dragElementOpacity);
  if (this.checkEventSource && mxClient.IS_SVG) {
    /** @type {string} */
    this.dragElement.style.pointerEvents = "none";
  }
};
/**
 * @return {undefined}
 */
mxDragSource.prototype.stopDrag = function() {
  this.removeDragElement();
};
/**
 * @return {undefined}
 */
mxDragSource.prototype.removeDragElement = function() {
  if (null != this.dragElement) {
    if (null != this.dragElement.parentNode) {
      this.dragElement.parentNode.removeChild(this.dragElement);
    }
    /** @type {null} */
    this.dragElement = null;
  }
};
/**
 * @param {undefined} e
 * @return {?}
 */
mxDragSource.prototype.getElementForEvent = function(e) {
  return mxEvent.isTouchEvent(e) || mxEvent.isPenEvent(e) ? document.elementFromPoint(mxEvent.getClientX(e), mxEvent.getClientY(e)) : mxEvent.getSource(e);
};
/**
 * @param {!Object} state
 * @param {undefined} evt
 * @return {?}
 */
mxDragSource.prototype.graphContainsEvent = function(state, evt) {
  var _getClientCoordinates = mxEvent.getClientX(evt);
  var _getClientCoordinates2 = mxEvent.getClientY(evt);
  var dialogGeometry = mxUtils.getOffset(state.container);
  var containerGeometry = mxUtils.getScrollOrigin();
  var e = this.getElementForEvent(evt);
  if (this.checkEventSource) {
    for (; null != e && e != state.container;) {
      e = e.parentNode;
    }
  }
  return null != e && _getClientCoordinates >= dialogGeometry.x - containerGeometry.x && _getClientCoordinates2 >= dialogGeometry.y - containerGeometry.y && _getClientCoordinates <= dialogGeometry.x - containerGeometry.x + state.container.offsetWidth && _getClientCoordinates2 <= dialogGeometry.y - containerGeometry.y + state.container.offsetHeight;
};
/**
 * @param {undefined} e
 * @return {undefined}
 */
mxDragSource.prototype.mouseMove = function(e) {
  var id = this.getGraphForEvent(e);
  if (!(null == id || this.graphContainsEvent(id, e))) {
    /** @type {null} */
    id = null;
  }
  if (id != this.currentGraph) {
    if (null != this.currentGraph) {
      this.dragExit(this.currentGraph, e);
    }
    this.currentGraph = id;
    if (null != this.currentGraph) {
      this.dragEnter(this.currentGraph, e);
    }
  }
  if (null != this.currentGraph) {
    this.dragOver(this.currentGraph, e);
  }
  if (null == this.dragElement || null != this.previewElement && "visible" == this.previewElement.style.visibility) {
    if (null != this.dragElement) {
      /** @type {string} */
      this.dragElement.style.visibility = "hidden";
    }
  } else {
    id = mxEvent.getClientX(e);
    var y = mxEvent.getClientY(e);
    if (null == this.dragElement.parentNode) {
      document.body.appendChild(this.dragElement);
    }
    /** @type {string} */
    this.dragElement.style.visibility = "visible";
    if (null != this.dragOffset) {
      id = id + this.dragOffset.x;
      y = y + this.dragOffset.y;
    }
    var options = mxUtils.getDocumentScrollOrigin(document);
    /** @type {string} */
    this.dragElement.style.left = id + options.x + "px";
    /** @type {string} */
    this.dragElement.style.top = y + options.y + "px";
  }
  mxEvent.consume(e);
};
/**
 * @param {undefined} e
 * @return {undefined}
 */
mxDragSource.prototype.mouseUp = function(e) {
  if (null != this.currentGraph) {
    if (null != this.currentPoint && (null == this.previewElement || "hidden" != this.previewElement.style.visibility)) {
      var scale = this.currentGraph.view.scale;
      var geo = this.currentGraph.view.translate;
      this.drop(this.currentGraph, e, this.currentDropTarget, this.currentPoint.x / scale - geo.x, this.currentPoint.y / scale - geo.y);
    }
    this.dragExit(this.currentGraph);
    /** @type {null} */
    this.currentGraph = null;
  }
  this.stopDrag();
  this.removeListeners();
  mxEvent.consume(e);
};
/**
 * @return {undefined}
 */
mxDragSource.prototype.removeListeners = function() {
  if (null != this.eventSource) {
    mxEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);
    /** @type {null} */
    this.eventSource = null;
  }
  mxEvent.removeGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);
  /** @type {null} */
  this.mouseUpHandler = this.mouseMoveHandler = null;
};
/**
 * @param {string} graph
 * @param {!PointerEvent} evt
 * @return {undefined}
 */
mxDragSource.prototype.dragEnter = function(graph, evt) {
  /** @type {boolean} */
  graph.isMouseDown = true;
  graph.isMouseTrigger = mxEvent.isMouseEvent(evt);
  this.previewElement = this.createPreviewElement(graph);
  if (null != this.previewElement && this.checkEventSource && mxClient.IS_SVG) {
    /** @type {string} */
    this.previewElement.style.pointerEvents = "none";
  }
  if (this.isGuidesEnabled() && null != this.previewElement) {
    this.currentGuide = new mxGuide(graph, graph.graphHandler.getGuideStates());
  }
  if (this.highlightDropTargets) {
    this.currentHighlight = new mxCellHighlight(graph, mxConstants.DROP_TARGET_COLOR);
  }
  graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.eventConsumer);
};
/**
 * @param {!Object} self
 * @param {!Object} event
 * @return {undefined}
 */
mxDragSource.prototype.dragExit = function(self, event) {
  /** @type {null} */
  this.currentPoint = this.currentDropTarget = null;
  /** @type {boolean} */
  self.isMouseDown = false;
  self.removeListener(this.eventConsumer);
  if (null != this.previewElement) {
    if (null != this.previewElement.parentNode) {
      this.previewElement.parentNode.removeChild(this.previewElement);
    }
    /** @type {null} */
    this.previewElement = null;
  }
  if (null != this.currentGuide) {
    this.currentGuide.destroy();
    /** @type {null} */
    this.currentGuide = null;
  }
  if (null != this.currentHighlight) {
    this.currentHighlight.destroy();
    /** @type {null} */
    this.currentHighlight = null;
  }
};
/**
 * @param {!Object} self
 * @param {(Object|string)} e
 * @return {undefined}
 */
mxDragSource.prototype.dragOver = function(self, e) {
  var value = mxUtils.getOffset(self.container);
  var scale = mxUtils.getScrollOrigin(self.container);
  /** @type {number} */
  var x = mxEvent.getClientX(e) - value.x + scale.x - self.panDx;
  /** @type {number} */
  value = mxEvent.getClientY(e) - value.y + scale.y - self.panDy;
  if (self.autoScroll && (null == this.autoscroll || this.autoscroll)) {
    self.scrollPointToVisible(x, value, self.autoExtend);
  }
  if (null != this.currentHighlight && self.isDropEnabled()) {
    this.currentDropTarget = this.getDropTarget(self, x, value, e);
    scale = self.getView().getState(this.currentDropTarget);
    this.currentHighlight.highlight(scale);
  }
  if (null != this.previewElement) {
    if (null == this.previewElement.parentNode) {
      self.container.appendChild(this.previewElement);
      /** @type {string} */
      this.previewElement.style.zIndex = "3";
      /** @type {string} */
      this.previewElement.style.position = "absolute";
    }
    scale = this.isGridEnabled() && self.isGridEnabledEvent(e);
    /** @type {boolean} */
    var command = true;
    if (null != this.currentGuide && this.currentGuide.isEnabledForEvent(e)) {
      /** @type {number} */
      command = parseInt(this.previewElement.style.width);
      /** @type {number} */
      var pos = parseInt(this.previewElement.style.height);
      command = new mxRectangle(0, 0, command, pos);
      value = new mxPoint(x, value);
      value = this.currentGuide.move(command, value, scale, true);
      /** @type {boolean} */
      command = false;
      x = value.x;
      value = value.y;
    } else {
      if (scale) {
        scale = self.view.scale;
        pos = self.view.translate;
        /** @type {number} */
        var start = self.gridSize / 2;
        /** @type {number} */
        x = (self.snap(x / scale - pos.x - start) + pos.x) * scale;
        /** @type {number} */
        value = (self.snap(value / scale - pos.y - start) + pos.y) * scale;
      }
    }
    if (null != this.currentGuide && command) {
      this.currentGuide.hide();
    }
    if (null != this.previewOffset) {
      x = x + this.previewOffset.x;
      value = value + this.previewOffset.y;
    }
    /** @type {string} */
    this.previewElement.style.left = Math.round(x) + "px";
    /** @type {string} */
    this.previewElement.style.top = Math.round(value) + "px";
    /** @type {string} */
    this.previewElement.style.visibility = "visible";
  }
  this.currentPoint = new mxPoint(x, value);
};
/**
 * @param {!Object} x
 * @param {!Object} key
 * @param {?} aEvent
 * @param {number} aDragDropObserver
 * @param {number} mouseOverItem
 * @return {undefined}
 */
mxDragSource.prototype.drop = function(x, key, aEvent, aDragDropObserver, mouseOverItem) {
  this.dropHandler.apply(this, arguments);
  if ("hidden" != x.container.style.visibility) {
    x.container.focus();
  }
};
/**
 * @param {!Node} dom
 * @return {undefined}
 */
function mxToolbar(dom) {
  /** @type {!Node} */
  this.container = dom;
}
mxToolbar.prototype = new mxEventSource;
/** @type {function(!Node): undefined} */
mxToolbar.prototype.constructor = mxToolbar;
/** @type {null} */
mxToolbar.prototype.container = null;
/** @type {boolean} */
mxToolbar.prototype.enabled = true;
/** @type {boolean} */
mxToolbar.prototype.noReset = false;
/** @type {boolean} */
mxToolbar.prototype.updateDefaultMode = true;
/**
 * @param {string} value
 * @param {string} type
 * @param {string} test
 * @param {string} id
 * @param {string} el
 * @param {?} text
 * @return {?}
 */
mxToolbar.prototype.addItem = function(value, type, test, id, el, text) {
  /** @type {!Element} */
  var node = document.createElement(null != type ? "img" : "button");
  var id = el || (null != text ? "mxToolbarMode" : "mxToolbarItem");
  node.className = id;
  node.setAttribute("src", type);
  if (null != value) {
    if (null != type) {
      node.setAttribute("title", value);
    } else {
      mxUtils.write(node, value);
    }
  }
  this.container.appendChild(node);
  if (null != test) {
    mxEvent.addListener(node, "click", test);
    if (mxClient.IS_TOUCH) {
      mxEvent.addListener(node, "touchend", test);
    }
  }
  value = mxUtils.bind(this, function(a) {
    if (null != id) {
      node.setAttribute("src", type);
    } else {
      /** @type {string} */
      node.style.backgroundColor = "";
    }
  });
  mxEvent.addGestureListeners(node, mxUtils.bind(this, function(title) {
    if (null != id) {
      node.setAttribute("src", id);
    } else {
      /** @type {string} */
      node.style.backgroundColor = "gray";
    }
    if (null != text) {
      if (null == this.menu) {
        this.menu = new mxPopupMenu;
        this.menu.init();
      }
      var e = this.currentImg;
      if (this.menu.isMenuShowing()) {
        this.menu.hideMenu();
      }
      if (e != node) {
        /** @type {!Element} */
        this.currentImg = node;
        this.menu.factoryMethod = text;
        e = new mxPoint(node.offsetLeft, node.offsetTop + node.offsetHeight);
        this.menu.popup(e.x, e.y, null, title);
        if (this.menu.isMenuShowing()) {
          /** @type {string} */
          node.className = id + "Selected";
          /**
           * @return {undefined}
           */
          this.menu.hideMenu = function() {
            mxPopupMenu.prototype.hideMenu.apply(this);
            node.className = id;
            /** @type {null} */
            this.currentImg = null;
          };
        }
      }
    }
  }), null, value);
  mxEvent.addListener(node, "mouseout", value);
  return node;
};
/**
 * @param {string} customStyle
 * @return {?}
 */
mxToolbar.prototype.addCombo = function(customStyle) {
  /** @type {!Element} */
  var scroller = document.createElement("div");
  /** @type {string} */
  scroller.style.display = "inline";
  /** @type {string} */
  scroller.className = "mxToolbarComboContainer";
  /** @type {!Element} */
  var el = document.createElement("select");
  el.className = customStyle || "mxToolbarCombo";
  scroller.appendChild(el);
  this.container.appendChild(scroller);
  return el;
};
/**
 * @param {string} value
 * @param {string} className
 * @return {?}
 */
mxToolbar.prototype.addActionCombo = function(value, className) {
  /** @type {!Element} */
  var e = document.createElement("select");
  e.className = className || "mxToolbarCombo";
  this.addOption(e, value, null);
  mxEvent.addListener(e, "change", function(attribute_or_func) {
    var a = e.options[e.selectedIndex];
    /** @type {number} */
    e.selectedIndex = 0;
    if (null != a.funct) {
      a.funct(attribute_or_func);
    }
  });
  this.container.appendChild(e);
  return e;
};
/**
 * @param {!Element} e
 * @param {string} value
 * @param {!Function} type
 * @return {?}
 */
mxToolbar.prototype.addOption = function(e, value, type) {
  /** @type {!Element} */
  var option = document.createElement("option");
  mxUtils.writeln(option, value);
  if ("function" == typeof type) {
    /** @type {!Function} */
    option.funct = type;
  } else {
    option.setAttribute("value", type);
  }
  e.appendChild(option);
  return option;
};
/**
 * @param {string} type
 * @param {string} position
 * @param {?} c
 * @param {!Array} kind
 * @param {string} data
 * @return {?}
 */
mxToolbar.prototype.addSwitchMode = function(type, position, c, kind, data) {
  /** @type {!Element} */
  var item = document.createElement("img");
  item.initialClassName = data || "mxToolbarMode";
  item.className = item.initialClassName;
  item.setAttribute("src", position);
  /** @type {!Array} */
  item.altIcon = kind;
  if (null != type) {
    item.setAttribute("title", type);
  }
  mxEvent.addListener(item, "click", mxUtils.bind(this, function(a) {
    a = this.selectedMode.altIcon;
    if (null != a) {
      this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
      this.selectedMode.setAttribute("src", a);
    } else {
      this.selectedMode.className = this.selectedMode.initialClassName;
    }
    if (this.updateDefaultMode) {
      /** @type {!Element} */
      this.defaultMode = item;
    }
    /** @type {!Element} */
    this.selectedMode = item;
    a = item.altIcon;
    if (null != a) {
      /** @type {string} */
      item.altIcon = item.getAttribute("src");
      item.setAttribute("src", a);
    } else {
      /** @type {string} */
      item.className = item.initialClassName + "Selected";
    }
    this.fireEvent(new mxEventObject(mxEvent.SELECT));
    c();
  }));
  this.container.appendChild(item);
  if (null == this.defaultMode) {
    /** @type {!Element} */
    this.defaultMode = item;
    this.selectMode(item);
    c();
  }
  return item;
};
/**
 * @param {string} title
 * @param {string} id
 * @param {!Function} params
 * @param {!Array} filter
 * @param {string} name
 * @param {!Object} object
 * @return {?}
 */
mxToolbar.prototype.addMode = function(title, id, params, filter, name, object) {
  object = null != object ? object : true;
  /** @type {!Element} */
  var e = document.createElement(null != id ? "img" : "button");
  e.initialClassName = name || "mxToolbarMode";
  e.className = e.initialClassName;
  e.setAttribute("src", id);
  /** @type {!Array} */
  e.altIcon = filter;
  if (null != title) {
    e.setAttribute("title", title);
  }
  if (this.enabled && object) {
    mxEvent.addListener(e, "click", mxUtils.bind(this, function(a) {
      this.selectMode(e, params);
      /** @type {boolean} */
      this.noReset = false;
    }));
    mxEvent.addListener(e, "dblclick", mxUtils.bind(this, function(a) {
      this.selectMode(e, params);
      /** @type {boolean} */
      this.noReset = true;
    }));
    if (null == this.defaultMode) {
      /** @type {!Element} */
      this.defaultMode = e;
      /** @type {!Function} */
      this.defaultFunction = params;
      this.selectMode(e, params);
    }
  }
  this.container.appendChild(e);
  return e;
};
/**
 * @param {string} entity
 * @param {!Function} mode
 * @return {undefined}
 */
mxToolbar.prototype.selectMode = function(entity, mode) {
  if (this.selectedMode != entity) {
    if (null != this.selectedMode) {
      var TEXT_SIZE_CONTAINER_ID = this.selectedMode.altIcon;
      if (null != TEXT_SIZE_CONTAINER_ID) {
        this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
        this.selectedMode.setAttribute("src", TEXT_SIZE_CONTAINER_ID);
      } else {
        this.selectedMode.className = this.selectedMode.initialClassName;
      }
    }
    /** @type {string} */
    this.selectedMode = entity;
    TEXT_SIZE_CONTAINER_ID = this.selectedMode.altIcon;
    if (null != TEXT_SIZE_CONTAINER_ID) {
      this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
      this.selectedMode.setAttribute("src", TEXT_SIZE_CONTAINER_ID);
    } else {
      /** @type {string} */
      this.selectedMode.className = this.selectedMode.initialClassName + "Selected";
    }
    this.fireEvent(new mxEventObject(mxEvent.SELECT, "function", mode));
  }
};
/**
 * @param {boolean} params
 * @return {undefined}
 */
mxToolbar.prototype.resetMode = function(params) {
  if (!(!params && this.noReset || this.selectedMode == this.defaultMode)) {
    this.selectMode(this.defaultMode, this.defaultFunction);
  }
};
/**
 * @param {boolean} value
 * @return {?}
 */
mxToolbar.prototype.addSeparator = function(value) {
  return this.addItem(null, value, null);
};
/**
 * @return {undefined}
 */
mxToolbar.prototype.addBreak = function() {
  mxUtils.br(this.container);
};
/**
 * @return {undefined}
 */
mxToolbar.prototype.addLine = function() {
  /** @type {!Element} */
  var elem = document.createElement("hr");
  /** @type {string} */
  elem.style.marginRight = "6px";
  elem.setAttribute("size", "1");
  this.container.appendChild(elem);
};
/**
 * @return {undefined}
 */
mxToolbar.prototype.destroy = function() {
  mxEvent.release(this.container);
  /** @type {null} */
  this.selectedMode = this.defaultFunction = this.defaultMode = this.container = null;
  if (null != this.menu) {
    this.menu.destroy();
  }
};
/**
 * @param {string} data
 * @param {?} linkedEntities
 * @return {undefined}
 */
function mxUndoableEdit(data, linkedEntities) {
  /** @type {string} */
  this.source = data;
  /** @type {!Array} */
  this.changes = [];
  this.significant = null != linkedEntities ? linkedEntities : true;
}
/** @type {null} */
mxUndoableEdit.prototype.source = null;
/** @type {null} */
mxUndoableEdit.prototype.changes = null;
/** @type {null} */
mxUndoableEdit.prototype.significant = null;
/** @type {boolean} */
mxUndoableEdit.prototype.undone = false;
/** @type {boolean} */
mxUndoableEdit.prototype.redone = false;
/**
 * @return {?}
 */
mxUndoableEdit.prototype.isEmpty = function() {
  return 0 == this.changes.length;
};
/**
 * @return {?}
 */
mxUndoableEdit.prototype.isSignificant = function() {
  return this.significant;
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxUndoableEdit.prototype.add = function(value) {
  this.changes.push(value);
};
/**
 * @return {undefined}
 */
mxUndoableEdit.prototype.notify = function() {
};
/**
 * @return {undefined}
 */
mxUndoableEdit.prototype.die = function() {
};
/**
 * @return {undefined}
 */
mxUndoableEdit.prototype.undo = function() {
  if (!this.undone) {
    this.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));
    /** @type {number} */
    var i = this.changes.length - 1;
    for (; 0 <= i; i--) {
      var change = this.changes[i];
      if (null != change.execute) {
        change.execute();
      } else {
        if (null != change.undo) {
          change.undo();
        }
      }
      this.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", change));
    }
    /** @type {boolean} */
    this.undone = true;
    /** @type {boolean} */
    this.redone = false;
    this.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));
  }
  this.notify();
};
/**
 * @return {undefined}
 */
mxUndoableEdit.prototype.redo = function() {
  if (!this.redone) {
    this.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));
    var length = this.changes.length;
    /** @type {number} */
    var i = 0;
    for (; i < length; i++) {
      var change = this.changes[i];
      if (null != change.execute) {
        change.execute();
      } else {
        if (null != change.redo) {
          change.redo();
        }
      }
      this.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", change));
    }
    /** @type {boolean} */
    this.undone = false;
    /** @type {boolean} */
    this.redone = true;
    this.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));
  }
  this.notify();
};
/**
 * @param {number} size
 * @return {undefined}
 */
function mxUndoManager(size) {
  this.size = null != size ? size : 100;
  this.clear();
}
mxUndoManager.prototype = new mxEventSource;
/** @type {function(number): undefined} */
mxUndoManager.prototype.constructor = mxUndoManager;
/** @type {null} */
mxUndoManager.prototype.size = null;
/** @type {null} */
mxUndoManager.prototype.history = null;
/** @type {number} */
mxUndoManager.prototype.indexOfNextAdd = 0;
/**
 * @return {?}
 */
mxUndoManager.prototype.isEmpty = function() {
  return 0 == this.history.length;
};
/**
 * @return {undefined}
 */
mxUndoManager.prototype.clear = function() {
  /** @type {!Array} */
  this.history = [];
  /** @type {number} */
  this.indexOfNextAdd = 0;
  this.fireEvent(new mxEventObject(mxEvent.CLEAR));
};
/**
 * @return {?}
 */
mxUndoManager.prototype.canUndo = function() {
  return 0 < this.indexOfNextAdd;
};
/**
 * @return {undefined}
 */
mxUndoManager.prototype.undo = function() {
  for (; 0 < this.indexOfNextAdd;) {
    var history = this.history[--this.indexOfNextAdd];
    history.undo();
    if (history.isSignificant()) {
      this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", history));
      break;
    }
  }
};
/**
 * @return {?}
 */
mxUndoManager.prototype.canRedo = function() {
  return this.indexOfNextAdd < this.history.length;
};
/**
 * @return {undefined}
 */
mxUndoManager.prototype.redo = function() {
  var l = this.history.length;
  for (; this.indexOfNextAdd < l;) {
    var history = this.history[this.indexOfNextAdd++];
    history.redo();
    if (history.isSignificant()) {
      this.fireEvent(new mxEventObject(mxEvent.REDO, "edit", history));
      break;
    }
  }
};
/**
 * @param {!Function} edit
 * @return {undefined}
 */
mxUndoManager.prototype.undoableEditHappened = function(edit) {
  this.trim();
  if (0 < this.size && this.size == this.history.length) {
    this.history.shift();
  }
  this.history.push(edit);
  this.indexOfNextAdd = this.history.length;
  this.fireEvent(new mxEventObject(mxEvent.ADD, "edit", edit));
};
/**
 * @return {undefined}
 */
mxUndoManager.prototype.trim = function() {
  if (this.history.length > this.indexOfNextAdd) {
    var views_to_remove = this.history.splice(this.indexOfNextAdd, this.history.length - this.indexOfNextAdd);
    /** @type {number} */
    var i = 0;
    for (; i < views_to_remove.length; i++) {
      views_to_remove[i].die();
    }
  }
};
/**
 * @return {undefined}
 */
var mxUrlConverter = function() {
};
/** @type {boolean} */
mxUrlConverter.prototype.enabled = true;
/** @type {null} */
mxUrlConverter.prototype.baseUrl = null;
/** @type {null} */
mxUrlConverter.prototype.baseDomain = null;
/**
 * @return {undefined}
 */
mxUrlConverter.prototype.updateBaseUrl = function() {
  /** @type {string} */
  this.baseDomain = location.protocol + "//" + location.host;
  /** @type {string} */
  this.baseUrl = this.baseDomain + location.pathname;
  /** @type {number} */
  var folderPathIndex = this.baseUrl.lastIndexOf("/");
  if (0 < folderPathIndex) {
    /** @type {string} */
    this.baseUrl = this.baseUrl.substring(0, folderPathIndex + 1);
  }
};
/**
 * @return {?}
 */
mxUrlConverter.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxUrlConverter.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxUrlConverter.prototype.getBaseUrl = function() {
  return this.baseUrl;
};
/**
 * @param {string} url
 * @return {undefined}
 */
mxUrlConverter.prototype.setBaseUrl = function(url) {
  /** @type {string} */
  this.baseUrl = url;
};
/**
 * @return {?}
 */
mxUrlConverter.prototype.getBaseDomain = function() {
  return this.baseDomain;
};
/**
 * @param {string} a
 * @return {undefined}
 */
mxUrlConverter.prototype.setBaseDomain = function(a) {
  /** @type {string} */
  this.baseDomain = a;
};
/**
 * @param {string} url
 * @return {?}
 */
mxUrlConverter.prototype.isRelativeUrl = function(url) {
  return null != url && "//" != url.substring(0, 2) && "http://" != url.substring(0, 7) && "https://" != url.substring(0, 8) && "data:image" != url.substring(0, 10) && "file://" != url.substring(0, 7);
};
/**
 * @param {string} s
 * @return {?}
 */
mxUrlConverter.prototype.convert = function(s) {
  if (this.isEnabled() && this.isRelativeUrl(s)) {
    if (null == this.getBaseUrl()) {
      this.updateBaseUrl();
    }
    s = "/" == s.charAt(0) ? this.getBaseDomain() + s : this.getBaseUrl() + s;
  }
  return s;
};
/**
 * @param {!Object} self
 * @return {undefined}
 */
function mxPanningManager(self) {
  /** @type {null} */
  this.thread = null;
  /** @type {boolean} */
  this.active = false;
  /** @type {number} */
  this.dy = this.dx = this.t0y = this.t0x = this.tdy = this.tdx = 0;
  /** @type {boolean} */
  this.scrollbars = false;
  /** @type {number} */
  this.scrollTop = this.scrollLeft = 0;
  this.mouseListener = {
    mouseDown : function(e, editor) {
    },
    mouseMove : function(element, new_yaw) {
    },
    mouseUp : mxUtils.bind(this, function(a, b) {
      if (this.active) {
        this.stop();
      }
    })
  };
  self.addMouseListener(this.mouseListener);
  this.mouseUpListener = mxUtils.bind(this, function() {
    if (this.active) {
      this.stop();
    }
  });
  mxEvent.addListener(document, "mouseup", this.mouseUpListener);
  var animate = mxUtils.bind(this, function() {
    this.scrollbars = mxUtils.hasScrollbars(self.container);
    this.scrollLeft = self.container.scrollLeft;
    this.scrollTop = self.container.scrollTop;
    return window.setInterval(mxUtils.bind(this, function() {
      this.tdx -= this.dx;
      this.tdy -= this.dy;
      if (this.scrollbars) {
        self.panGraph(-self.container.scrollLeft - Math.ceil(this.dx), -self.container.scrollTop - Math.ceil(this.dy));
        /** @type {number} */
        self.panDx = this.scrollLeft - self.container.scrollLeft;
        /** @type {number} */
        self.panDy = this.scrollTop - self.container.scrollTop;
        self.fireEvent(new mxEventObject(mxEvent.PAN));
      } else {
        self.panGraph(this.getDx(), this.getDy());
      }
    }), this.delay);
  });
  /**
   * @return {?}
   */
  this.isActive = function() {
    return active;
  };
  /**
   * @return {?}
   */
  this.getDx = function() {
    return Math.round(this.tdx);
  };
  /**
   * @return {?}
   */
  this.getDy = function() {
    return Math.round(this.tdy);
  };
  /**
   * @return {undefined}
   */
  this.start = function() {
    this.t0x = self.view.translate.x;
    this.t0y = self.view.translate.y;
    /** @type {boolean} */
    this.active = true;
  };
  /**
   * @param {number} x
   * @param {number} y
   * @param {number} count
   * @param {number} width
   * @return {undefined}
   */
  this.panTo = function(x, y, count, width) {
    if (!this.active) {
      this.start();
    }
    this.scrollLeft = self.container.scrollLeft;
    this.scrollTop = self.container.scrollTop;
    var box = self.container;
    /** @type {number} */
    this.dx = x + (null != count ? count : 0) - box.scrollLeft - box.clientWidth;
    this.dx = 0 > this.dx && Math.abs(this.dx) < this.border ? this.border + this.dx : this.handleMouseOut ? Math.max(this.dx, 0) : 0;
    if (0 == this.dx) {
      /** @type {number} */
      this.dx = x - box.scrollLeft;
      /** @type {number} */
      this.dx = 0 < this.dx && this.dx < this.border ? this.dx - this.border : this.handleMouseOut ? Math.min(0, this.dx) : 0;
    }
    /** @type {number} */
    this.dy = y + (null != width ? width : 0) - box.scrollTop - box.clientHeight;
    this.dy = 0 > this.dy && Math.abs(this.dy) < this.border ? this.border + this.dy : this.handleMouseOut ? Math.max(this.dy, 0) : 0;
    if (0 == this.dy) {
      /** @type {number} */
      this.dy = y - box.scrollTop;
      /** @type {number} */
      this.dy = 0 < this.dy && this.dy < this.border ? this.dy - this.border : this.handleMouseOut ? Math.min(0, this.dy) : 0;
    }
    if (0 != this.dx || 0 != this.dy) {
      this.dx *= this.damper;
      this.dy *= this.damper;
      if (null == this.thread) {
        this.thread = animate();
      }
    } else {
      if (null != this.thread) {
        window.clearInterval(this.thread);
        /** @type {null} */
        this.thread = null;
      }
    }
  };
  /**
   * @return {undefined}
   */
  this.stop = function() {
    if (this.active) {
      if (this.active = false, null != this.thread && (window.clearInterval(this.thread), this.thread = null), this.tdy = this.tdx = 0, this.scrollbars) {
        /** @type {number} */
        self.panDx = 0;
        /** @type {number} */
        self.panDy = 0;
        self.fireEvent(new mxEventObject(mxEvent.PAN));
      } else {
        var scale = self.panDx;
        var em = self.panDy;
        if (0 != scale || 0 != em) {
          self.panGraph(0, 0);
          self.view.setTranslate(this.t0x + scale / self.view.scale, this.t0y + em / self.view.scale);
        }
      }
    }
  };
  /**
   * @return {undefined}
   */
  this.destroy = function() {
    self.removeMouseListener(this.mouseListener);
    mxEvent.removeListener(document, "mouseup", this.mouseUpListener);
  };
}
/** @type {number} */
mxPanningManager.prototype.damper = 1 / 6;
/** @type {number} */
mxPanningManager.prototype.delay = 10;
/** @type {boolean} */
mxPanningManager.prototype.handleMouseOut = true;
/** @type {number} */
mxPanningManager.prototype.border = 0;
/**
 * @param {?} a
 * @return {undefined}
 */
function mxPopupMenu(a) {
  this.factoryMethod = a;
  if (null != a) {
    this.init();
  }
}
mxPopupMenu.prototype = new mxEventSource;
/** @type {function(?): undefined} */
mxPopupMenu.prototype.constructor = mxPopupMenu;
/** @type {string} */
mxPopupMenu.prototype.submenuImage = mxClient.imageBasePath + "/submenu.gif";
/** @type {number} */
mxPopupMenu.prototype.zIndex = 10006;
/** @type {null} */
mxPopupMenu.prototype.factoryMethod = null;
/** @type {boolean} */
mxPopupMenu.prototype.useLeftButtonForPopup = false;
/** @type {boolean} */
mxPopupMenu.prototype.enabled = true;
/** @type {number} */
mxPopupMenu.prototype.itemCount = 0;
/** @type {boolean} */
mxPopupMenu.prototype.autoExpand = false;
/** @type {boolean} */
mxPopupMenu.prototype.smartSeparators = false;
/** @type {boolean} */
mxPopupMenu.prototype.labels = true;
/**
 * @return {undefined}
 */
mxPopupMenu.prototype.init = function() {
  /** @type {!Element} */
  this.table = document.createElement("table");
  /** @type {string} */
  this.table.className = "mxPopupMenu";
  /** @type {!Element} */
  this.tbody = document.createElement("tbody");
  this.table.appendChild(this.tbody);
  /** @type {!Element} */
  this.div = document.createElement("div");
  /** @type {string} */
  this.div.className = "mxPopupMenu";
  /** @type {string} */
  this.div.style.display = "inline";
  this.div.style.zIndex = this.zIndex;
  this.div.appendChild(this.table);
  mxEvent.disableContextMenu(this.div);
};
/**
 * @return {?}
 */
mxPopupMenu.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxPopupMenu.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @param {!Event} child
 * @return {?}
 */
mxPopupMenu.prototype.isPopupTrigger = function(child) {
  return child.isPopupTrigger() || this.useLeftButtonForPopup && mxEvent.isLeftMouseButton(child.getEvent());
};
/**
 * @param {!Object} node
 * @param {string} data
 * @param {string} parent
 * @param {!Object} obj
 * @param {string} c
 * @param {string} error
 * @param {number} description
 * @param {?} isVegetarian
 * @return {?}
 */
mxPopupMenu.prototype.addItem = function(node, data, parent, obj, c, error, description, isVegetarian) {
  obj = obj || this;
  this.itemCount++;
  if (obj.willAddSeparator) {
    if (obj.containsItems) {
      this.addSeparator(obj, true);
    }
    /** @type {boolean} */
    obj.willAddSeparator = false;
  }
  /** @type {boolean} */
  obj.containsItems = true;
  /** @type {!Element} */
  var result = document.createElement("tr");
  /** @type {string} */
  result.className = "mxPopupMenuItem";
  /** @type {!Element} */
  var e = document.createElement("td");
  /** @type {string} */
  e.className = "mxPopupMenuIcon";
  if (null != data) {
    /** @type {!Element} */
    c = document.createElement("img");
    /** @type {string} */
    c.src = data;
    e.appendChild(c);
  } else {
    if (null != c) {
      /** @type {!Element} */
      data = document.createElement("div");
      /** @type {string} */
      data.className = c;
      e.appendChild(data);
    }
  }
  result.appendChild(e);
  if (this.labels) {
    /** @type {!Element} */
    e = document.createElement("td");
    /** @type {string} */
    e.className = "mxPopupMenuItem" + (null == error || error ? "" : " mxDisabled");
    mxUtils.write(e, node);
    /** @type {string} */
    e.align = "left";
    result.appendChild(e);
    /** @type {!Element} */
    node = document.createElement("td");
    /** @type {string} */
    node.className = "mxPopupMenuItem" + (null == error || error ? "" : " mxDisabled");
    /** @type {string} */
    node.style.paddingRight = "6px";
    /** @type {string} */
    node.style.textAlign = "right";
    result.appendChild(node);
    if (null == obj.div) {
      this.createSubmenu(obj);
    }
  }
  obj.tbody.appendChild(result);
  if (0 != description && 0 != error) {
    /** @type {null} */
    var logoRef = null;
    mxEvent.addGestureListeners(result, mxUtils.bind(this, function(e) {
      /** @type {!Element} */
      this.eventReceiver = result;
      if (obj.activeRow != result && obj.activeRow != obj) {
        if (null != obj.activeRow && null != obj.activeRow.div.parentNode) {
          this.hideSubmenu(obj);
        }
        if (null != result.div) {
          this.showSubmenu(obj, result);
          /** @type {!Element} */
          obj.activeRow = result;
        }
      }
      if (!(null == document.selection || !mxClient.IS_QUIRKS && 8 != document.documentMode)) {
        /** @type {(ControlRange|TextRange|null)} */
        logoRef = document.selection.createRange();
      }
      mxEvent.consume(e);
    }), mxUtils.bind(this, function(a) {
      if (obj.activeRow != result && obj.activeRow != obj) {
        if (null != obj.activeRow && null != obj.activeRow.div.parentNode) {
          this.hideSubmenu(obj);
        }
        if (this.autoExpand && null != result.div) {
          this.showSubmenu(obj, result);
          /** @type {!Element} */
          obj.activeRow = result;
        }
      }
      if (!isVegetarian) {
        /** @type {string} */
        result.className = "mxPopupMenuItemHover";
      }
    }), mxUtils.bind(this, function(e) {
      if (this.eventReceiver == result) {
        if (obj.activeRow != result) {
          this.hideMenu();
        }
        if (null != logoRef) {
          try {
            logoRef.select();
          } catch (q) {
          }
          /** @type {null} */
          logoRef = null;
        }
        if (null != parent) {
          parent(e);
        }
      }
      /** @type {null} */
      this.eventReceiver = null;
      mxEvent.consume(e);
    }));
    if (!isVegetarian) {
      mxEvent.addListener(result, "mouseout", mxUtils.bind(this, function(a) {
        /** @type {string} */
        result.className = "mxPopupMenuItem";
      }));
    }
  }
  return result;
};
/**
 * @param {!Node} item
 * @param {string} changeMeta
 * @return {undefined}
 */
mxPopupMenu.prototype.addCheckmark = function(item, changeMeta) {
  var a = item.firstChild.nextSibling;
  /** @type {string} */
  a.style.backgroundImage = "url('" + changeMeta + "')";
  /** @type {string} */
  a.style.backgroundRepeat = "no-repeat";
  /** @type {string} */
  a.style.backgroundPosition = "2px 50%";
};
/**
 * @param {!Object} self
 * @return {undefined}
 */
mxPopupMenu.prototype.createSubmenu = function(self) {
  /** @type {!Element} */
  self.table = document.createElement("table");
  /** @type {string} */
  self.table.className = "mxPopupMenu";
  /** @type {!Element} */
  self.tbody = document.createElement("tbody");
  self.table.appendChild(self.tbody);
  /** @type {!Element} */
  self.div = document.createElement("div");
  /** @type {string} */
  self.div.className = "mxPopupMenu";
  /** @type {string} */
  self.div.style.position = "absolute";
  /** @type {string} */
  self.div.style.display = "inline";
  self.div.style.zIndex = this.zIndex;
  self.div.appendChild(self.table);
  /** @type {!Element} */
  var b = document.createElement("img");
  b.setAttribute("src", this.submenuImage);
  td = self.firstChild.nextSibling.nextSibling;
  td.appendChild(b);
};
/**
 * @param {!Object} a
 * @param {!Object} obj
 * @return {undefined}
 */
mxPopupMenu.prototype.showSubmenu = function(a, obj) {
  if (null != obj.div) {
    /** @type {string} */
    obj.div.style.left = a.div.offsetLeft + obj.offsetLeft + obj.offsetWidth - 1 + "px";
    /** @type {string} */
    obj.div.style.top = a.div.offsetTop + obj.offsetTop + "px";
    document.body.appendChild(obj.div);
    /** @type {number} */
    var index = parseInt(obj.div.offsetLeft);
    /** @type {number} */
    var centerOffset = parseInt(obj.div.offsetWidth);
    var doc = mxUtils.getDocumentScrollOrigin(document);
    /** @type {!Element} */
    var docElem = document.documentElement;
    if (index + centerOffset > doc.x + (document.body.clientWidth || docElem.clientWidth)) {
      /** @type {string} */
      obj.div.style.left = Math.max(0, a.div.offsetLeft - centerOffset + (mxClient.IS_IE ? 6 : -6)) + "px";
    }
    mxUtils.fit(obj.div);
  }
};
/**
 * @param {!Object} options
 * @param {boolean} target
 * @return {undefined}
 */
mxPopupMenu.prototype.addSeparator = function(options, target) {
  options = options || this;
  if (this.smartSeparators && !target) {
    /** @type {boolean} */
    options.willAddSeparator = true;
  } else {
    if (null != options.tbody) {
      /** @type {boolean} */
      options.willAddSeparator = false;
      /** @type {!Element} */
      var row = document.createElement("tr");
      /** @type {!Element} */
      var cell = document.createElement("td");
      /** @type {string} */
      cell.className = "mxPopupMenuIcon";
      /** @type {string} */
      cell.style.padding = "0 0 0 0px";
      row.appendChild(cell);
      /** @type {!Element} */
      cell = document.createElement("td");
      /** @type {string} */
      cell.style.padding = "0 0 0 0px";
      cell.setAttribute("colSpan", "2");
      /** @type {!Element} */
      var node = document.createElement("hr");
      node.setAttribute("size", "1");
      cell.appendChild(node);
      row.appendChild(cell);
      options.tbody.appendChild(row);
    }
  }
};
/**
 * @param {number} width
 * @param {number} height
 * @param {!Object} mode
 * @param {?} title
 * @return {undefined}
 */
mxPopupMenu.prototype.popup = function(width, height, mode, title) {
  if (null != this.div && null != this.tbody && null != this.factoryMethod) {
    /** @type {string} */
    this.div.style.left = width + "px";
    /** @type {string} */
    this.div.style.top = height + "px";
    for (; null != this.tbody.firstChild;) {
      mxEvent.release(this.tbody.firstChild);
      this.tbody.removeChild(this.tbody.firstChild);
    }
    /** @type {number} */
    this.itemCount = 0;
    this.factoryMethod(this, mode, title);
    if (0 < this.itemCount) {
      this.showMenu();
      this.fireEvent(new mxEventObject(mxEvent.SHOW));
    }
  }
};
/**
 * @return {?}
 */
mxPopupMenu.prototype.isMenuShowing = function() {
  return null != this.div && this.div.parentNode == document.body;
};
/**
 * @return {undefined}
 */
mxPopupMenu.prototype.showMenu = function() {
  if (9 <= document.documentMode) {
    /** @type {string} */
    this.div.style.filter = "none";
  }
  document.body.appendChild(this.div);
  mxUtils.fit(this.div);
};
/**
 * @return {undefined}
 */
mxPopupMenu.prototype.hideMenu = function() {
  if (null != this.div) {
    if (null != this.div.parentNode) {
      this.div.parentNode.removeChild(this.div);
    }
    this.hideSubmenu(this);
    /** @type {boolean} */
    this.containsItems = false;
    this.fireEvent(new mxEventObject(mxEvent.HIDE));
  }
};
/**
 * @param {!Object} $scope
 * @return {undefined}
 */
mxPopupMenu.prototype.hideSubmenu = function($scope) {
  if (null != $scope.activeRow) {
    this.hideSubmenu($scope.activeRow);
    if (null != $scope.activeRow.div.parentNode) {
      $scope.activeRow.div.parentNode.removeChild($scope.activeRow.div);
    }
    /** @type {null} */
    $scope.activeRow = null;
  }
};
/**
 * @return {undefined}
 */
mxPopupMenu.prototype.destroy = function() {
  if (null != this.div) {
    mxEvent.release(this.div);
    if (null != this.div.parentNode) {
      this.div.parentNode.removeChild(this.div);
    }
    /** @type {null} */
    this.div = null;
  }
};
/**
 * @param {!Object} vScale
 * @return {undefined}
 */
function mxAutoSaveManager(vScale) {
  this.changeHandler = mxUtils.bind(this, function(a, link) {
    if (this.isEnabled()) {
      this.graphModelChanged(link.getProperty("edit").changes);
    }
  });
  this.setGraph(vScale);
}
mxAutoSaveManager.prototype = new mxEventSource;
/** @type {function(!Object): undefined} */
mxAutoSaveManager.prototype.constructor = mxAutoSaveManager;
/** @type {null} */
mxAutoSaveManager.prototype.graph = null;
/** @type {number} */
mxAutoSaveManager.prototype.autoSaveDelay = 10;
/** @type {number} */
mxAutoSaveManager.prototype.autoSaveThrottle = 2;
/** @type {number} */
mxAutoSaveManager.prototype.autoSaveThreshold = 5;
/** @type {number} */
mxAutoSaveManager.prototype.ignoredChanges = 0;
/** @type {number} */
mxAutoSaveManager.prototype.lastSnapshot = 0;
/** @type {boolean} */
mxAutoSaveManager.prototype.enabled = true;
/** @type {null} */
mxAutoSaveManager.prototype.changeHandler = null;
/**
 * @return {?}
 */
mxAutoSaveManager.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxAutoSaveManager.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @param {!Object} gf
 * @return {undefined}
 */
mxAutoSaveManager.prototype.setGraph = function(gf) {
  if (null != this.graph) {
    this.graph.getModel().removeListener(this.changeHandler);
  }
  /** @type {!Object} */
  this.graph = gf;
  if (null != this.graph) {
    this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
  }
};
/**
 * @return {undefined}
 */
mxAutoSaveManager.prototype.save = function() {
};
/**
 * @param {number} a
 * @return {undefined}
 */
mxAutoSaveManager.prototype.graphModelChanged = function(a) {
  /** @type {number} */
  a = ((new Date).getTime() - this.lastSnapshot) / 1E3;
  if (a > this.autoSaveDelay || this.ignoredChanges >= this.autoSaveThreshold && a > this.autoSaveThrottle) {
    this.save();
    this.reset();
  } else {
    this.ignoredChanges++;
  }
};
/**
 * @return {undefined}
 */
mxAutoSaveManager.prototype.reset = function() {
  /** @type {number} */
  this.lastSnapshot = (new Date).getTime();
  /** @type {number} */
  this.ignoredChanges = 0;
};
/**
 * @return {undefined}
 */
mxAutoSaveManager.prototype.destroy = function() {
  this.setGraph(null);
};
/**
 * @param {number} delay
 * @return {undefined}
 */
function mxAnimation(delay) {
  this.delay = null != delay ? delay : 20;
}
mxAnimation.prototype = new mxEventSource;
/** @type {function(number): undefined} */
mxAnimation.prototype.constructor = mxAnimation;
/** @type {null} */
mxAnimation.prototype.delay = null;
/** @type {null} */
mxAnimation.prototype.thread = null;
/**
 * @return {?}
 */
mxAnimation.prototype.isRunning = function() {
  return null != this.thread;
};
/**
 * @return {undefined}
 */
mxAnimation.prototype.startAnimation = function() {
  if (null == this.thread) {
    this.thread = window.setInterval(mxUtils.bind(this, this.updateAnimation), this.delay);
  }
};
/**
 * @return {undefined}
 */
mxAnimation.prototype.updateAnimation = function() {
  this.fireEvent(new mxEventObject(mxEvent.EXECUTE));
};
/**
 * @return {undefined}
 */
mxAnimation.prototype.stopAnimation = function() {
  if (null != this.thread) {
    window.clearInterval(this.thread);
    /** @type {null} */
    this.thread = null;
    this.fireEvent(new mxEventObject(mxEvent.DONE));
  }
};
/**
 * @param {!Object} src
 * @param {number} name
 * @param {string} max
 * @param {?} excludes
 * @return {undefined}
 */
function mxMorphing(src, name, max, excludes) {
  mxAnimation.call(this, excludes);
  /** @type {!Object} */
  this.graph = src;
  this.steps = null != name ? name : 6;
  this.ease = null != max ? max : 1.5;
}
mxMorphing.prototype = new mxAnimation;
/** @type {function(!Object, number, string, ?): undefined} */
mxMorphing.prototype.constructor = mxMorphing;
/** @type {null} */
mxMorphing.prototype.graph = null;
/** @type {null} */
mxMorphing.prototype.steps = null;
/** @type {number} */
mxMorphing.prototype.step = 0;
/** @type {null} */
mxMorphing.prototype.ease = null;
/** @type {null} */
mxMorphing.prototype.cells = null;
/**
 * @return {undefined}
 */
mxMorphing.prototype.updateAnimation = function() {
  mxAnimation.prototype.updateAnimation.apply(this, arguments);
  var a = new mxCellStatePreview(this.graph);
  if (null != this.cells) {
    /** @type {number} */
    var i = 0;
    for (; i < this.cells.length; i++) {
      this.animateCell(this.cells[i], a, false);
    }
  } else {
    this.animateCell(this.graph.getModel().getRoot(), a, true);
  }
  this.show(a);
  if (a.isEmpty() || this.step++ >= this.steps) {
    this.stopAnimation();
  }
};
/**
 * @param {!Object} flag
 * @return {undefined}
 */
mxMorphing.prototype.show = function(flag) {
  flag.show();
};
/**
 * @param {undefined} cell
 * @param {?} pos
 * @param {boolean} removeCount
 * @return {undefined}
 */
mxMorphing.prototype.animateCell = function(cell, pos, removeCount) {
  var index = this.graph.getView().getState(cell);
  /** @type {null} */
  var i = null;
  if (null != index && (i = this.getDelta(index), this.graph.getModel().isVertex(cell) && (0 != i.x || 0 != i.y))) {
    var signalCoords = this.graph.view.getTranslate();
    var factor = this.graph.view.getScale();
    i.x += signalCoords.x * factor;
    i.y += signalCoords.y * factor;
    pos.moveState(index, -i.x / this.ease, -i.y / this.ease);
  }
  if (removeCount && !this.stopRecursion(index, i)) {
    index = this.graph.getModel().getChildCount(cell);
    /** @type {number} */
    i = 0;
    for (; i < index; i++) {
      this.animateCell(this.graph.getModel().getChildAt(cell, i), pos, removeCount);
    }
  }
};
/**
 * @param {?} m
 * @param {!Object} b
 * @return {?}
 */
mxMorphing.prototype.stopRecursion = function(m, b) {
  return null != b && (0 != b.x || 0 != b.y);
};
/**
 * @param {!Object} o
 * @return {?}
 */
mxMorphing.prototype.getDelta = function(o) {
  var b = this.getOriginForCell(o.cell);
  var geo = this.graph.getView().getTranslate();
  var scale = this.graph.getView().getScale();
  return new mxPoint((b.x - (o.x / scale - geo.x)) * scale, (b.y - (o.y / scale - geo.y)) * scale);
};
/**
 * @param {!Object} target
 * @return {?}
 */
mxMorphing.prototype.getOriginForCell = function(target) {
  /** @type {null} */
  var start = null;
  if (null != target) {
    var element = this.graph.getModel().getParent(target);
    target = this.graph.getCellGeometry(target);
    start = this.getOriginForCell(element);
    if (null != target) {
      if (target.relative) {
        element = this.graph.getCellGeometry(element);
        if (null != element) {
          start.x += target.x * element.width;
          start.y += target.y * element.height;
        }
      } else {
        start.x += target.x;
        start.y += target.y;
      }
    }
  }
  if (null == start) {
    start = this.graph.view.getTranslate();
    start = new mxPoint(-start.x, -start.y);
  }
  return start;
};
/**
 * @param {string} a
 * @return {undefined}
 */
function mxImageBundle(a) {
  /** @type {!Array} */
  this.images = [];
  this.alt = null != a ? a : false;
}
/** @type {null} */
mxImageBundle.prototype.images = null;
/** @type {null} */
mxImageBundle.prototype.alt = null;
/**
 * @param {?} key
 * @param {!Object} img
 * @param {(HTMLCanvasElement|HTMLImageElement|string)} data
 * @return {undefined}
 */
mxImageBundle.prototype.putImage = function(key, img, data) {
  this.images[key] = {
    value : img,
    fallback : data
  };
};
/**
 * @param {!Object} image
 * @return {?}
 */
mxImageBundle.prototype.getImage = function(image) {
  /** @type {null} */
  var template = null;
  if (null != image) {
    image = this.images[image];
    if (null != image) {
      template = this.alt ? image.fallback : image.value;
    }
  }
  return template;
};
/**
 * @return {undefined}
 */
function mxImageExport() {
}
/** @type {boolean} */
mxImageExport.prototype.includeOverlays = false;
/**
 * @param {!Object} context
 * @param {?} client
 * @return {undefined}
 */
mxImageExport.prototype.drawState = function(context, client) {
  if (null != context) {
    this.visitStatesRecursive(context, client, mxUtils.bind(this, function() {
      this.drawCellState.apply(this, arguments);
    }));
    if (this.includeOverlays) {
      this.visitStatesRecursive(context, client, mxUtils.bind(this, function() {
        this.drawOverlays.apply(this, arguments);
      }));
    }
  }
};
/**
 * @param {!Object} e
 * @param {?} t
 * @param {?} c
 * @return {undefined}
 */
mxImageExport.prototype.visitStatesRecursive = function(e, t, c) {
  if (null != e) {
    c(e, t);
    var self = e.view.graph;
    var cell_amount = self.model.getChildCount(e.cell);
    /** @type {number} */
    var i = 0;
    for (; i < cell_amount; i++) {
      var uboard = self.view.getState(self.model.getChildAt(e.cell, i));
      this.visitStatesRecursive(uboard, t, c);
    }
  }
};
/**
 * @param {!Object} m
 * @param {!Object} b
 * @return {?}
 */
mxImageExport.prototype.getLinkForCellState = function(m, b) {
  return null;
};
/**
 * @param {!Object} name
 * @param {!Object} node
 * @return {undefined}
 */
mxImageExport.prototype.drawCellState = function(name, node) {
  var href = this.getLinkForCellState(name, node);
  if (null != href) {
    node.setLink(href);
  }
  this.drawShape(name, node);
  this.drawText(name, node);
  if (null != href) {
    node.setLink(null);
  }
};
/**
 * @param {!Object} options
 * @param {!Object} ctx
 * @return {undefined}
 */
mxImageExport.prototype.drawShape = function(options, ctx) {
  if (options.shape instanceof mxShape && options.shape.checkBounds()) {
    ctx.save();
    options.shape.beforePaint(ctx);
    options.shape.paint(ctx);
    options.shape.afterPaint(ctx);
    ctx.restore();
  }
};
/**
 * @param {!Object} item
 * @param {!Object} ctx
 * @return {undefined}
 */
mxImageExport.prototype.drawText = function(item, ctx) {
  if (null != item.text && item.text.checkBounds()) {
    ctx.save();
    item.text.beforePaint(ctx);
    item.text.paint(ctx);
    item.text.afterPaint(ctx);
    ctx.restore();
  }
};
/**
 * @param {!Object} params
 * @param {!Object} context
 * @return {undefined}
 */
mxImageExport.prototype.drawOverlays = function(params, context) {
  if (null != params.overlays) {
    params.overlays.visit(function(a, leftWin) {
      if (leftWin instanceof mxShape) {
        leftWin.paint(context);
      }
    });
  }
};
/**
 * @return {undefined}
 */
function mxAbstractCanvas2D() {
  this.converter = this.createUrlConverter();
  this.reset();
}
/** @type {null} */
mxAbstractCanvas2D.prototype.state = null;
/** @type {null} */
mxAbstractCanvas2D.prototype.states = null;
/** @type {null} */
mxAbstractCanvas2D.prototype.path = null;
/** @type {boolean} */
mxAbstractCanvas2D.prototype.rotateHtml = true;
/** @type {number} */
mxAbstractCanvas2D.prototype.lastX = 0;
/** @type {number} */
mxAbstractCanvas2D.prototype.lastY = 0;
/** @type {string} */
mxAbstractCanvas2D.prototype.moveOp = "M";
/** @type {string} */
mxAbstractCanvas2D.prototype.lineOp = "L";
/** @type {string} */
mxAbstractCanvas2D.prototype.quadOp = "Q";
/** @type {string} */
mxAbstractCanvas2D.prototype.curveOp = "C";
/** @type {string} */
mxAbstractCanvas2D.prototype.closeOp = "Z";
/** @type {boolean} */
mxAbstractCanvas2D.prototype.pointerEvents = false;
/**
 * @return {?}
 */
mxAbstractCanvas2D.prototype.createUrlConverter = function() {
  return new mxUrlConverter;
};
/**
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.reset = function() {
  this.state = this.createState();
  /** @type {!Array} */
  this.states = [];
};
/**
 * @return {?}
 */
mxAbstractCanvas2D.prototype.createState = function() {
  return {
    dx : 0,
    dy : 0,
    scale : 1,
    alpha : 1,
    fillAlpha : 1,
    strokeAlpha : 1,
    fillColor : null,
    gradientFillAlpha : 1,
    gradientColor : null,
    gradientAlpha : 1,
    gradientDirection : null,
    strokeColor : null,
    strokeWidth : 1,
    dashed : false,
    dashPattern : "3 3",
    fixDash : false,
    lineCap : "flat",
    lineJoin : "miter",
    miterLimit : 10,
    fontColor : "#000000",
    fontBackgroundColor : null,
    fontBorderColor : null,
    fontSize : mxConstants.DEFAULT_FONTSIZE,
    fontFamily : mxConstants.DEFAULT_FONTFAMILY,
    fontStyle : 0,
    shadow : false,
    shadowColor : mxConstants.SHADOWCOLOR,
    shadowAlpha : mxConstants.SHADOW_OPACITY,
    shadowDx : mxConstants.SHADOW_OFFSET_X,
    shadowDy : mxConstants.SHADOW_OFFSET_Y,
    rotation : 0,
    rotationCx : 0,
    rotationCy : 0
  };
};
/**
 * @param {number} str
 * @return {?}
 */
mxAbstractCanvas2D.prototype.format = function(str) {
  return Math.round(parseFloat(str));
};
/**
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.addOp = function() {
  if (null != this.path && (this.path.push(arguments[0]), 2 < arguments.length)) {
    var state = this.state;
    /** @type {number} */
    var i = 2;
    for (; i < arguments.length; i = i + 2) {
      this.lastX = arguments[i - 1];
      this.lastY = arguments[i];
      this.path.push(this.format((this.lastX + state.dx) * state.scale));
      this.path.push(this.format((this.lastY + state.dy) * state.scale));
    }
  }
};
/**
 * @param {number} x
 * @param {number} y
 * @param {number} alpha
 * @param {?} width
 * @param {boolean} height
 * @return {?}
 */
mxAbstractCanvas2D.prototype.rotatePoint = function(x, y, alpha, width, height) {
  /** @type {number} */
  alpha = alpha * (Math.PI / 180);
  return mxUtils.getRotatedPoint(new mxPoint(x, y), Math.cos(alpha), Math.sin(alpha), new mxPoint(width, height));
};
/**
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.save = function() {
  this.states.push(this.state);
  this.state = mxUtils.clone(this.state);
};
/**
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.restore = function() {
  if (0 < this.states.length) {
    this.state = this.states.pop();
  }
};
/**
 * @param {!Object} url
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setLink = function(url) {
};
/**
 * @param {number} scale
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.scale = function(scale) {
  this.state.scale *= scale;
  this.state.strokeWidth *= scale;
};
/**
 * @param {number} size
 * @param {number} data
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.translate = function(size, data) {
  this.state.dx += size;
  this.state.dy += data;
};
/**
 * @param {number} a
 * @param {?} b
 * @param {?} status
 * @param {?} err
 * @param {?} _0
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.rotate = function(a, b, status, err, _0) {
};
/**
 * @param {number} val
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setAlpha = function(val) {
  /** @type {number} */
  this.state.alpha = val;
};
/**
 * @param {number} v
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFillAlpha = function(v) {
  /** @type {number} */
  this.state.fillAlpha = v;
};
/**
 * @param {number} name
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setStrokeAlpha = function(name) {
  /** @type {number} */
  this.state.strokeAlpha = name;
};
/**
 * @param {string} color
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFillColor = function(color) {
  if (color == mxConstants.NONE) {
    /** @type {null} */
    color = null;
  }
  /** @type {string} */
  this.state.fillColor = color;
  /** @type {null} */
  this.state.gradientColor = null;
};
/**
 * @param {string} value
 * @param {string} color
 * @param {!Object} o
 * @param {number} element
 * @param {number} percent
 * @param {number} options
 * @param {string} d
 * @param {number} l
 * @param {number} a
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setGradient = function(value, color, o, element, percent, options, d, l, a) {
  o = this.state;
  /** @type {string} */
  o.fillColor = value;
  o.gradientFillAlpha = null != l ? l : 1;
  /** @type {string} */
  o.gradientColor = color;
  o.gradientAlpha = null != a ? a : 1;
  /** @type {string} */
  o.gradientDirection = d;
};
/**
 * @param {string} color
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setStrokeColor = function(color) {
  if (color == mxConstants.NONE) {
    /** @type {null} */
    color = null;
  }
  /** @type {string} */
  this.state.strokeColor = color;
};
/**
 * @param {number} width
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setStrokeWidth = function(width) {
  /** @type {number} */
  this.state.strokeWidth = width;
};
/**
 * @param {string} dashed
 * @param {boolean} dash
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setDashed = function(dashed, dash) {
  /** @type {string} */
  this.state.dashed = dashed;
  /** @type {boolean} */
  this.state.fixDash = dash;
};
/**
 * @param {!Object} str
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setDashPattern = function(str) {
  /** @type {!Object} */
  this.state.dashPattern = str;
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setLineCap = function(value) {
  /** @type {string} */
  this.state.lineCap = value;
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setLineJoin = function(value) {
  /** @type {string} */
  this.state.lineJoin = value;
};
/**
 * @param {number} limit
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setMiterLimit = function(limit) {
  /** @type {number} */
  this.state.miterLimit = limit;
};
/**
 * @param {string} color
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFontColor = function(color) {
  if (color == mxConstants.NONE) {
    /** @type {null} */
    color = null;
  }
  /** @type {string} */
  this.state.fontColor = color;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFontBackgroundColor = function(state) {
  if (state == mxConstants.NONE) {
    /** @type {null} */
    state = null;
  }
  /** @type {string} */
  this.state.fontBackgroundColor = state;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFontBorderColor = function(state) {
  if (state == mxConstants.NONE) {
    /** @type {null} */
    state = null;
  }
  /** @type {string} */
  this.state.fontBorderColor = state;
};
/**
 * @param {number} fontSize
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFontSize = function(fontSize) {
  /** @type {number} */
  this.state.fontSize = parseFloat(fontSize);
};
/**
 * @param {string} fontFamily
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFontFamily = function(fontFamily) {
  /** @type {string} */
  this.state.fontFamily = fontFamily;
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setFontStyle = function(value) {
  if (null == value) {
    /** @type {number} */
    value = 0;
  }
  /** @type {string} */
  this.state.fontStyle = value;
};
/**
 * @param {boolean} value
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setShadow = function(value) {
  /** @type {boolean} */
  this.state.shadow = value;
};
/**
 * @param {string} color
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setShadowColor = function(color) {
  if (color == mxConstants.NONE) {
    /** @type {null} */
    color = null;
  }
  /** @type {string} */
  this.state.shadowColor = color;
};
/**
 * @param {?} name
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setShadowAlpha = function(name) {
  this.state.shadowAlpha = name;
};
/**
 * @param {?} tpl
 * @param {?} name
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.setShadowOffset = function(tpl, name) {
  this.state.shadowDx = tpl;
  this.state.shadowDy = name;
};
/**
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.begin = function() {
  /** @type {number} */
  this.lastY = this.lastX = 0;
  /** @type {!Array} */
  this.path = [];
};
/**
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.moveTo = function(x, y) {
  this.addOp(this.moveOp, x, y);
};
/**
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.lineTo = function(x, y) {
  this.addOp(this.lineOp, x, y);
};
/**
 * @param {number} id
 * @param {number} hex
 * @param {number} a
 * @param {number} v
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.quadTo = function(id, hex, a, v) {
  this.addOp(this.quadOp, id, hex, a, v);
};
/**
 * @param {number} e
 * @param {number} d
 * @param {number} a
 * @param {number} c
 * @param {number} f
 * @param {number} x
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.curveTo = function(e, d, a, c, f, x) {
  this.addOp(this.curveOp, e, d, a, c, f, x);
};
/**
 * @param {number} o
 * @param {number} n
 * @param {number} x1
 * @param {number} y1
 * @param {number} duration
 * @param {undefined} x
 * @param {undefined} y
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.arcTo = function(o, n, x1, y1, duration, x, y) {
  o = mxUtils.arcToCurves(this.lastX, this.lastY, o, n, x1, y1, duration, x, y);
  if (null != o) {
    /** @type {number} */
    n = 0;
    for (; n < o.length; n = n + 6) {
      this.curveTo(o[n], o[n + 1], o[n + 2], o[n + 3], o[n + 4], o[n + 5]);
    }
  }
};
/**
 * @param {?} a
 * @param {?} f
 * @param {?} duration
 * @param {?} fast
 * @param {?} callback
 * @param {?} isClose
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.close = function(a, f, duration, fast, callback, isClose) {
  this.addOp(this.closeOp);
};
/**
 * @return {undefined}
 */
mxAbstractCanvas2D.prototype.end = function() {
};
/**
 * @param {string} p
 * @return {undefined}
 */
function mxXmlCanvas2D(p) {
  mxAbstractCanvas2D.call(this);
  /** @type {string} */
  this.root = p;
  this.writeDefaults();
}
mxUtils.extend(mxXmlCanvas2D, mxAbstractCanvas2D);
/** @type {boolean} */
mxXmlCanvas2D.prototype.textEnabled = true;
/** @type {boolean} */
mxXmlCanvas2D.prototype.compressed = true;
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.writeDefaults = function() {
  var node;
  node = this.createElement("fontfamily");
  node.setAttribute("family", mxConstants.DEFAULT_FONTFAMILY);
  this.root.appendChild(node);
  node = this.createElement("fontsize");
  node.setAttribute("size", mxConstants.DEFAULT_FONTSIZE);
  this.root.appendChild(node);
  node = this.createElement("shadowcolor");
  node.setAttribute("color", mxConstants.SHADOWCOLOR);
  this.root.appendChild(node);
  node = this.createElement("shadowalpha");
  node.setAttribute("alpha", mxConstants.SHADOW_OPACITY);
  this.root.appendChild(node);
  node = this.createElement("shadowoffset");
  node.setAttribute("dx", mxConstants.SHADOW_OFFSET_X);
  node.setAttribute("dy", mxConstants.SHADOW_OFFSET_Y);
  this.root.appendChild(node);
};
/**
 * @param {number} str
 * @return {?}
 */
mxXmlCanvas2D.prototype.format = function(str) {
  return parseFloat(parseFloat(str).toFixed(2));
};
/**
 * @param {string} name
 * @return {?}
 */
mxXmlCanvas2D.prototype.createElement = function(name) {
  return this.root.ownerDocument.createElement(name);
};
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.save = function() {
  if (this.compressed) {
    mxAbstractCanvas2D.prototype.save.apply(this, arguments);
  }
  this.root.appendChild(this.createElement("save"));
};
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.restore = function() {
  if (this.compressed) {
    mxAbstractCanvas2D.prototype.restore.apply(this, arguments);
  }
  this.root.appendChild(this.createElement("restore"));
};
/**
 * @param {?} x
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.scale = function(x) {
  var elem = this.createElement("scale");
  elem.setAttribute("scale", x);
  this.root.appendChild(elem);
};
/**
 * @param {number} val
 * @param {number} data
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.translate = function(val, data) {
  var el = this.createElement("translate");
  el.setAttribute("dx", this.format(val));
  el.setAttribute("dy", this.format(data));
  this.root.appendChild(el);
};
/**
 * @param {number} data
 * @param {boolean} val
 * @param {string} state
 * @param {undefined} value
 * @param {undefined} i
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.rotate = function(data, val, state, value, i) {
  var el = this.createElement("rotate");
  if (0 != data || val || state) {
    el.setAttribute("theta", this.format(data));
    el.setAttribute("flipH", val ? "1" : "0");
    el.setAttribute("flipV", state ? "1" : "0");
    el.setAttribute("cx", this.format(value));
    el.setAttribute("cy", this.format(i));
    this.root.appendChild(el);
  }
};
/**
 * @param {number} val
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setAlpha = function(val) {
  if (this.compressed) {
    if (this.state.alpha == val) {
      return;
    }
    mxAbstractCanvas2D.prototype.setAlpha.apply(this, arguments);
  }
  var el = this.createElement("alpha");
  el.setAttribute("alpha", this.format(val));
  this.root.appendChild(el);
};
/**
 * @param {number} val
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFillAlpha = function(val) {
  if (this.compressed) {
    if (this.state.fillAlpha == val) {
      return;
    }
    mxAbstractCanvas2D.prototype.setFillAlpha.apply(this, arguments);
  }
  var el = this.createElement("fillalpha");
  el.setAttribute("alpha", this.format(val));
  this.root.appendChild(el);
};
/**
 * @param {number} val
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setStrokeAlpha = function(val) {
  if (this.compressed) {
    if (this.state.strokeAlpha == val) {
      return;
    }
    mxAbstractCanvas2D.prototype.setStrokeAlpha.apply(this, arguments);
  }
  var el = this.createElement("strokealpha");
  el.setAttribute("alpha", this.format(val));
  this.root.appendChild(el);
};
/**
 * @param {string} name
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFillColor = function(name) {
  if (name == mxConstants.NONE) {
    /** @type {null} */
    name = null;
  }
  if (this.compressed) {
    if (this.state.fillColor == name) {
      return;
    }
    mxAbstractCanvas2D.prototype.setFillColor.apply(this, arguments);
  }
  var element = this.createElement("fillcolor");
  element.setAttribute("color", null != name ? name : mxConstants.NONE);
  this.root.appendChild(element);
};
/**
 * @param {string} value
 * @param {string} color
 * @param {number} data
 * @param {number} text
 * @param {number} val
 * @param {number} label
 * @param {string} key
 * @param {string} index
 * @param {string} percent
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setGradient = function(value, color, data, text, val, label, key, index, percent) {
  if (null != value && null != color) {
    mxAbstractCanvas2D.prototype.setGradient.apply(this, arguments);
    var el = this.createElement("gradient");
    el.setAttribute("c1", value);
    el.setAttribute("c2", color);
    el.setAttribute("x", this.format(data));
    el.setAttribute("y", this.format(text));
    el.setAttribute("w", this.format(val));
    el.setAttribute("h", this.format(label));
    if (null != key) {
      el.setAttribute("direction", key);
    }
    if (null != index) {
      el.setAttribute("alpha1", index);
    }
    if (null != percent) {
      el.setAttribute("alpha2", percent);
    }
    this.root.appendChild(el);
  }
};
/**
 * @param {string} name
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setStrokeColor = function(name) {
  if (name == mxConstants.NONE) {
    /** @type {null} */
    name = null;
  }
  if (this.compressed) {
    if (this.state.strokeColor == name) {
      return;
    }
    mxAbstractCanvas2D.prototype.setStrokeColor.apply(this, arguments);
  }
  var element = this.createElement("strokecolor");
  element.setAttribute("color", null != name ? name : mxConstants.NONE);
  this.root.appendChild(element);
};
/**
 * @param {number} value
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setStrokeWidth = function(value) {
  if (this.compressed) {
    if (this.state.strokeWidth == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setStrokeWidth.apply(this, arguments);
  }
  var el = this.createElement("strokewidth");
  el.setAttribute("width", this.format(value));
  this.root.appendChild(el);
};
/**
 * @param {string} state
 * @param {string} text
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setDashed = function(state, text) {
  if (this.compressed) {
    if (this.state.dashed == state) {
      return;
    }
    mxAbstractCanvas2D.prototype.setDashed.apply(this, arguments);
  }
  var el = this.createElement("dashed");
  el.setAttribute("dashed", state ? "1" : "0");
  if (null != text) {
    el.setAttribute("fixDash", text ? "1" : "0");
  }
  this.root.appendChild(el);
};
/**
 * @param {string} x
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setDashPattern = function(x) {
  if (this.compressed) {
    if (this.state.dashPattern == x) {
      return;
    }
    mxAbstractCanvas2D.prototype.setDashPattern.apply(this, arguments);
  }
  var elem = this.createElement("dashpattern");
  elem.setAttribute("pattern", x);
  this.root.appendChild(elem);
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setLineCap = function(value) {
  if (this.compressed) {
    if (this.state.lineCap == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setLineCap.apply(this, arguments);
  }
  var group = this.createElement("linecap");
  group.setAttribute("cap", value);
  this.root.appendChild(group);
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setLineJoin = function(value) {
  if (this.compressed) {
    if (this.state.lineJoin == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setLineJoin.apply(this, arguments);
  }
  var group = this.createElement("linejoin");
  group.setAttribute("join", value);
  this.root.appendChild(group);
};
/**
 * @param {number} id
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setMiterLimit = function(id) {
  if (this.compressed) {
    if (this.state.miterLimit == id) {
      return;
    }
    mxAbstractCanvas2D.prototype.setMiterLimit.apply(this, arguments);
  }
  var elem = this.createElement("miterlimit");
  elem.setAttribute("limit", id);
  this.root.appendChild(elem);
};
/**
 * @param {string} name
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFontColor = function(name) {
  if (this.textEnabled) {
    if (name == mxConstants.NONE) {
      /** @type {null} */
      name = null;
    }
    if (this.compressed) {
      if (this.state.fontColor == name) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontColor.apply(this, arguments);
    }
    var element = this.createElement("fontcolor");
    element.setAttribute("color", null != name ? name : mxConstants.NONE);
    this.root.appendChild(element);
  }
};
/**
 * @param {string} name
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFontBackgroundColor = function(name) {
  if (this.textEnabled) {
    if (name == mxConstants.NONE) {
      /** @type {null} */
      name = null;
    }
    if (this.compressed) {
      if (this.state.fontBackgroundColor == name) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontBackgroundColor.apply(this, arguments);
    }
    var element = this.createElement("fontbackgroundcolor");
    element.setAttribute("color", null != name ? name : mxConstants.NONE);
    this.root.appendChild(element);
  }
};
/**
 * @param {string} name
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFontBorderColor = function(name) {
  if (this.textEnabled) {
    if (name == mxConstants.NONE) {
      /** @type {null} */
      name = null;
    }
    if (this.compressed) {
      if (this.state.fontBorderColor == name) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontBorderColor.apply(this, arguments);
    }
    var element = this.createElement("fontbordercolor");
    element.setAttribute("color", null != name ? name : mxConstants.NONE);
    this.root.appendChild(element);
  }
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFontSize = function(value) {
  if (this.textEnabled) {
    if (this.compressed) {
      if (this.state.fontSize == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontSize.apply(this, arguments);
    }
    var style = this.createElement("fontsize");
    style.setAttribute("size", value);
    this.root.appendChild(style);
  }
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFontFamily = function(value) {
  if (this.textEnabled) {
    if (this.compressed) {
      if (this.state.fontFamily == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontFamily.apply(this, arguments);
    }
    var el = this.createElement("fontfamily");
    el.setAttribute("family", value);
    this.root.appendChild(el);
  }
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setFontStyle = function(value) {
  if (this.textEnabled) {
    if (null == value) {
      /** @type {number} */
      value = 0;
    }
    if (this.compressed) {
      if (this.state.fontStyle == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontStyle.apply(this, arguments);
    }
    var elem = this.createElement("fontstyle");
    elem.setAttribute("style", value);
    this.root.appendChild(elem);
  }
};
/**
 * @param {string} x
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setShadow = function(x) {
  if (this.compressed) {
    if (this.state.shadow == x) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadow.apply(this, arguments);
  }
  var btn = this.createElement("shadow");
  btn.setAttribute("enabled", x ? "1" : "0");
  this.root.appendChild(btn);
};
/**
 * @param {string} name
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setShadowColor = function(name) {
  if (this.compressed) {
    if (name == mxConstants.NONE) {
      /** @type {null} */
      name = null;
    }
    if (this.state.shadowColor == name) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadowColor.apply(this, arguments);
  }
  var element = this.createElement("shadowcolor");
  element.setAttribute("color", null != name ? name : mxConstants.NONE);
  this.root.appendChild(element);
};
/**
 * @param {string} mode
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setShadowAlpha = function(mode) {
  if (this.compressed) {
    if (this.state.shadowAlpha == mode) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadowAlpha.apply(this, arguments);
  }
  var node = this.createElement("shadowalpha");
  node.setAttribute("alpha", mode);
  this.root.appendChild(node);
};
/**
 * @param {string} x
 * @param {string} y
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.setShadowOffset = function(x, y) {
  if (this.compressed) {
    if (this.state.shadowDx == x && this.state.shadowDy == y) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadowOffset.apply(this, arguments);
  }
  var text = this.createElement("shadowoffset");
  text.setAttribute("dx", x);
  text.setAttribute("dy", y);
  this.root.appendChild(text);
};
/**
 * @param {number} value
 * @param {number} label
 * @param {number} key
 * @param {number} val
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.rect = function(value, label, key, val) {
  var el = this.createElement("rect");
  el.setAttribute("x", this.format(value));
  el.setAttribute("y", this.format(label));
  el.setAttribute("w", this.format(key));
  el.setAttribute("h", this.format(val));
  this.root.appendChild(el);
};
/**
 * @param {number} y
 * @param {number} d
 * @param {number} e
 * @param {number} node
 * @param {boolean} x
 * @param {boolean} val
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.roundrect = function(y, d, e, node, x, val) {
  var t = this.createElement("roundrect");
  t.setAttribute("x", this.format(y));
  t.setAttribute("y", this.format(d));
  t.setAttribute("w", this.format(e));
  t.setAttribute("h", this.format(node));
  t.setAttribute("dx", this.format(x));
  t.setAttribute("dy", this.format(val));
  this.root.appendChild(t);
};
/**
 * @param {number} args
 * @param {number} val
 * @param {number} e
 * @param {number} d
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.ellipse = function(args, val, e, d) {
  var path = this.createElement("ellipse");
  path.setAttribute("x", this.format(args));
  path.setAttribute("y", this.format(val));
  path.setAttribute("w", this.format(e));
  path.setAttribute("h", this.format(d));
  this.root.appendChild(path);
};
/**
 * @param {number} data
 * @param {number} val
 * @param {number} key
 * @param {number} label
 * @param {boolean} value
 * @param {string} state
 * @param {string} show
 * @param {string} text
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.image = function(data, val, key, label, value, state, show, text) {
  value = this.converter.convert(value);
  var el = this.createElement("image");
  el.setAttribute("x", this.format(data));
  el.setAttribute("y", this.format(val));
  el.setAttribute("w", this.format(key));
  el.setAttribute("h", this.format(label));
  el.setAttribute("src", value);
  el.setAttribute("aspect", state ? "1" : "0");
  el.setAttribute("flipH", show ? "1" : "0");
  el.setAttribute("flipV", text ? "1" : "0");
  this.root.appendChild(el);
};
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.begin = function() {
  this.root.appendChild(this.createElement("begin"));
  /** @type {number} */
  this.lastY = this.lastX = 0;
};
/**
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.moveTo = function(x, y) {
  var el = this.createElement("move");
  el.setAttribute("x", this.format(x));
  el.setAttribute("y", this.format(y));
  this.root.appendChild(el);
  /** @type {number} */
  this.lastX = x;
  /** @type {number} */
  this.lastY = y;
};
/**
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.lineTo = function(x, y) {
  var info = this.createElement("line");
  info.setAttribute("x", this.format(x));
  info.setAttribute("y", this.format(y));
  this.root.appendChild(info);
  /** @type {number} */
  this.lastX = x;
  /** @type {number} */
  this.lastY = y;
};
/**
 * @param {number} i
 * @param {number} data
 * @param {number} val
 * @param {number} key
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.quadTo = function(i, data, val, key) {
  var el = this.createElement("quad");
  el.setAttribute("x1", this.format(i));
  el.setAttribute("y1", this.format(data));
  el.setAttribute("x2", this.format(val));
  el.setAttribute("y2", this.format(key));
  this.root.appendChild(el);
  /** @type {number} */
  this.lastX = val;
  /** @type {number} */
  this.lastY = key;
};
/**
 * @param {number} e
 * @param {number} end
 * @param {number} d
 * @param {number} i
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.curveTo = function(e, end, d, i, x, y) {
  var assert = this.createElement("curve");
  assert.setAttribute("x1", this.format(e));
  assert.setAttribute("y1", this.format(end));
  assert.setAttribute("x2", this.format(d));
  assert.setAttribute("y2", this.format(i));
  assert.setAttribute("x3", this.format(x));
  assert.setAttribute("y3", this.format(y));
  this.root.appendChild(assert);
  /** @type {number} */
  this.lastX = x;
  /** @type {number} */
  this.lastY = y;
};
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.close = function() {
  this.root.appendChild(this.createElement("close"));
};
/**
 * @param {number} val
 * @param {number} data
 * @param {number} i
 * @param {number} value
 * @param {string} node
 * @param {string} a
 * @param {string} x
 * @param {string} text
 * @param {string} dir
 * @param {string} color
 * @param {string} state
 * @param {string} name
 * @param {string} uuid
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.text = function(val, data, i, value, node, a, x, text, dir, color, state, name, uuid) {
  if (this.textEnabled && null != node) {
    if (mxUtils.isNode(node)) {
      node = mxUtils.getOuterHtml(node);
    }
    var el = this.createElement("text");
    el.setAttribute("x", this.format(val));
    el.setAttribute("y", this.format(data));
    el.setAttribute("w", this.format(i));
    el.setAttribute("h", this.format(value));
    el.setAttribute("str", node);
    if (null != a) {
      el.setAttribute("align", a);
    }
    if (null != x) {
      el.setAttribute("valign", x);
    }
    el.setAttribute("wrap", text ? "1" : "0");
    if (null == dir) {
      /** @type {string} */
      dir = "";
    }
    el.setAttribute("format", dir);
    if (null != color) {
      el.setAttribute("overflow", color);
    }
    if (null != state) {
      el.setAttribute("clip", state ? "1" : "0");
    }
    if (null != name) {
      el.setAttribute("rotation", name);
    }
    if (null != uuid) {
      el.setAttribute("dir", uuid);
    }
    this.root.appendChild(el);
  }
};
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.stroke = function() {
  this.root.appendChild(this.createElement("stroke"));
};
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.fill = function() {
  this.root.appendChild(this.createElement("fill"));
};
/**
 * @return {undefined}
 */
mxXmlCanvas2D.prototype.fillAndStroke = function() {
  this.root.appendChild(this.createElement("fillstroke"));
};
/**
 * @param {!Object} child
 * @param {string} min
 * @return {undefined}
 */
function mxSvgCanvas2D(child, min) {
  mxAbstractCanvas2D.call(this);
  /** @type {!Object} */
  this.root = child;
  /** @type {!Array} */
  this.gradients = [];
  /** @type {null} */
  this.defs = null;
  this.styleEnabled = null != min ? min : false;
  /** @type {null} */
  var elem = null;
  if (child.ownerDocument != document) {
    /** @type {!Object} */
    elem = child;
    for (; null != elem && "svg" != elem.nodeName;) {
      elem = elem.parentNode;
    }
  }
  if (null != elem) {
    if (0 < elem.getElementsByTagName("defs").length) {
      this.defs = elem.getElementsByTagName("defs")[0];
    }
    if (null == this.defs) {
      this.defs = this.createElement("defs");
      if (null != elem.firstChild) {
        elem.insertBefore(this.defs, elem.firstChild);
      } else {
        elem.appendChild(this.defs);
      }
    }
    if (this.styleEnabled) {
      this.defs.appendChild(this.createStyle());
    }
  }
}
mxUtils.extend(mxSvgCanvas2D, mxAbstractCanvas2D);
(function() {
  /** @type {boolean} */
  mxSvgCanvas2D.prototype.useDomParser = !mxClient.IS_IE && "function" === typeof DOMParser && "function" === typeof XMLSerializer;
  if (mxSvgCanvas2D.prototype.useDomParser) {
    try {
      /** @type {(Document|null)} */
      var doc = (new DOMParser).parseFromString("test text", "text/html");
      /** @type {boolean} */
      mxSvgCanvas2D.prototype.useDomParser = null != doc;
    } catch (b) {
      /** @type {boolean} */
      mxSvgCanvas2D.prototype.useDomParser = false;
    }
  }
  /** @type {boolean} */
  mxSvgCanvas2D.prototype.useAbsoluteIds = !mxClient.IS_CHROMEAPP && !mxClient.IS_IE && !mxClient.IS_IE11 && !mxClient.IS_EDGE && 0 < document.getElementsByTagName("base").length;
})();
/** @type {null} */
mxSvgCanvas2D.prototype.node = null;
/** @type {boolean} */
mxSvgCanvas2D.prototype.matchHtmlAlignment = true;
/** @type {boolean} */
mxSvgCanvas2D.prototype.textEnabled = true;
/** @type {boolean} */
mxSvgCanvas2D.prototype.foEnabled = true;
/** @type {string} */
mxSvgCanvas2D.prototype.foAltText = "[Object]";
/** @type {number} */
mxSvgCanvas2D.prototype.foOffset = 0;
/** @type {number} */
mxSvgCanvas2D.prototype.textOffset = 0;
/** @type {number} */
mxSvgCanvas2D.prototype.imageOffset = 0;
/** @type {number} */
mxSvgCanvas2D.prototype.strokeTolerance = 0;
/** @type {number} */
mxSvgCanvas2D.prototype.minStrokeWidth = 1;
/** @type {number} */
mxSvgCanvas2D.prototype.refCount = 0;
/** @type {number} */
mxSvgCanvas2D.prototype.lineHeightCorrection = 1;
/** @type {string} */
mxSvgCanvas2D.prototype.pointerEventsValue = "all";
/** @type {number} */
mxSvgCanvas2D.prototype.fontMetricsPadding = 10;
/** @type {boolean} */
mxSvgCanvas2D.prototype.cacheOffsetSize = true;
/**
 * @param {number} str
 * @return {?}
 */
mxSvgCanvas2D.prototype.format = function(str) {
  return parseFloat(parseFloat(str).toFixed(2));
};
/**
 * @return {?}
 */
mxSvgCanvas2D.prototype.getBaseUrl = function() {
  /** @type {string} */
  var baseUrl = window.location.href;
  /** @type {number} */
  var index = baseUrl.lastIndexOf("#");
  if (0 < index) {
    /** @type {string} */
    baseUrl = baseUrl.substring(0, index);
  }
  return baseUrl;
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.reset = function() {
  mxAbstractCanvas2D.prototype.reset.apply(this, arguments);
  /** @type {!Array} */
  this.gradients = [];
};
/**
 * @param {!Object} style
 * @return {?}
 */
mxSvgCanvas2D.prototype.createStyle = function(style) {
  style = this.createElement("style");
  style.setAttribute("type", "text/css");
  mxUtils.write(style, "svg{font-family:" + mxConstants.DEFAULT_FONTFAMILY + ";font-size:" + mxConstants.DEFAULT_FONTSIZE + ";fill:none;stroke-miterlimit:10}");
  return style;
};
/**
 * @param {string} name
 * @param {string} props
 * @return {?}
 */
mxSvgCanvas2D.prototype.createElement = function(name, props) {
  if (null != this.root.ownerDocument.createElementNS) {
    return this.root.ownerDocument.createElementNS(props || mxConstants.NS_SVG, name);
  }
  var item = this.root.ownerDocument.createElement(name);
  if (null != props) {
    item.setAttribute("xmlns", props);
  }
  return item;
};
/**
 * @param {?} a22
 * @param {string} Px
 * @param {number} Py
 * @param {!Object} Model
 * @param {string} type
 * @param {string} i
 * @param {!Object} p
 * @param {number} p2
 * @param {!Array} res
 * @param {string} order
 * @param {string} n
 * @param {?} elem
 * @param {number} array
 * @return {?}
 */
mxSvgCanvas2D.prototype.getAlternateText = function(a22, Px, Py, Model, type, i, p, p2, res, order, n, elem, array) {
  return null != i ? this.foAltText : null;
};
/**
 * @param {?} e
 * @param {string} x
 * @param {number} y
 * @param {!Object} options
 * @param {string} end
 * @param {string} f
 * @param {!Object} el
 * @param {number} index
 * @param {!Array} name
 * @param {string} o
 * @param {string} constructor
 * @param {?} key
 * @param {number} mode
 * @return {?}
 */
mxSvgCanvas2D.prototype.createAlternateContent = function(e, x, y, options, end, f, el, index, name, o, constructor, key, mode) {
  e = this.getAlternateText(e, x, y, options, end, f, el, index, name, o, constructor, key, mode);
  options = this.state;
  return null != e && 0 < options.fontSize ? (index = index == mxConstants.ALIGN_TOP ? 1 : index == mxConstants.ALIGN_BOTTOM ? 0 : .3, end = el == mxConstants.ALIGN_RIGHT ? "end" : el == mxConstants.ALIGN_LEFT ? "start" : "middle", el = this.createElement("text"), el.setAttribute("x", Math.round(x + options.dx)), el.setAttribute("y", Math.round(y + options.dy + index * options.fontSize)), el.setAttribute("fill", options.fontColor || "black"), el.setAttribute("font-family", options.fontFamily), el.setAttribute("font-size", 
  Math.round(options.fontSize) + "px"), "start" != end && el.setAttribute("text-anchor", end), (options.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && el.setAttribute("font-weight", "bold"), (options.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && el.setAttribute("font-style", "italic"), x = [], (options.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE && x.push("underline"), (options.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH && 
  x.push("line-through"), 0 < x.length && el.setAttribute("text-decoration", x.join(" ")), mxUtils.write(el, e), el) : null;
};
/**
 * @param {string} n
 * @param {string} c
 * @param {string} m
 * @param {string} d
 * @param {string} type
 * @return {?}
 */
mxSvgCanvas2D.prototype.createGradientId = function(n, c, m, d, type) {
  if ("#" == n.charAt(0)) {
    n = n.substring(1);
  }
  if ("#" == c.charAt(0)) {
    c = c.substring(1);
  }
  n = n.toLowerCase() + "-" + m;
  c = c.toLowerCase() + "-" + d;
  /** @type {null} */
  m = null;
  if (null == type || type == mxConstants.DIRECTION_SOUTH) {
    /** @type {string} */
    m = "s";
  } else {
    if (type == mxConstants.DIRECTION_EAST) {
      /** @type {string} */
      m = "e";
    } else {
      /** @type {string} */
      d = n;
      /** @type {string} */
      n = c;
      /** @type {string} */
      c = d;
      if (type == mxConstants.DIRECTION_NORTH) {
        /** @type {string} */
        m = "s";
      } else {
        if (type == mxConstants.DIRECTION_WEST) {
          /** @type {string} */
          m = "e";
        }
      }
    }
  }
  return "mx-gradient-" + n + "-" + c + "-" + m;
};
/**
 * @param {string} index
 * @param {string} type
 * @param {undefined} doc
 * @param {undefined} duration
 * @param {undefined} url
 * @return {?}
 */
mxSvgCanvas2D.prototype.getSvgGradient = function(index, type, doc, duration, url) {
  var i = this.createGradientId(index, type, doc, duration, url);
  var el = this.gradients[i];
  if (null == el) {
    var w = this.root.ownerSVGElement;
    /** @type {number} */
    var key = 0;
    /** @type {string} */
    var id = i + "-" + key;
    if (null != w) {
      el = w.ownerDocument.getElementById(id);
      for (; null != el && el.ownerSVGElement != w;) {
        /** @type {string} */
        id = i + "-" + key++;
        el = w.ownerDocument.getElementById(id);
      }
    } else {
      /** @type {string} */
      id = "id" + ++this.refCount;
    }
    if (null == el) {
      el = this.createSvgGradient(index, type, doc, duration, url);
      el.setAttribute("id", id);
      if (null != this.defs) {
        this.defs.appendChild(el);
      } else {
        w.appendChild(el);
      }
    }
    this.gradients[i] = el;
  }
  return el.getAttribute("id");
};
/**
 * @param {string} start
 * @param {string} data
 * @param {number} i
 * @param {number} n
 * @param {!Object} node
 * @return {?}
 */
mxSvgCanvas2D.prototype.createSvgGradient = function(start, data, i, n, node) {
  var element = this.createElement("linearGradient");
  element.setAttribute("x1", "0%");
  element.setAttribute("y1", "0%");
  element.setAttribute("x2", "0%");
  element.setAttribute("y2", "0%");
  if (null == node || node == mxConstants.DIRECTION_SOUTH) {
    element.setAttribute("y2", "100%");
  } else {
    if (node == mxConstants.DIRECTION_EAST) {
      element.setAttribute("x2", "100%");
    } else {
      if (node == mxConstants.DIRECTION_NORTH) {
        element.setAttribute("y1", "100%");
      } else {
        if (node == mxConstants.DIRECTION_WEST) {
          element.setAttribute("x1", "100%");
        }
      }
    }
  }
  /** @type {string} */
  i = 1 > i ? ";stop-opacity:" + i : "";
  node = this.createElement("stop");
  node.setAttribute("offset", "0%");
  node.setAttribute("style", "stop-color:" + start + i);
  element.appendChild(node);
  /** @type {string} */
  i = 1 > n ? ";stop-opacity:" + n : "";
  node = this.createElement("stop");
  node.setAttribute("offset", "100%");
  node.setAttribute("style", "stop-color:" + data + i);
  element.appendChild(node);
  return element;
};
/**
 * @param {boolean} data
 * @param {boolean} delta
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.addNode = function(data, delta) {
  var elem = this.node;
  var obj = this.state;
  if (null != elem) {
    if ("path" == elem.nodeName) {
      if (null != this.path && 0 < this.path.length) {
        elem.setAttribute("d", this.path.join(" "));
      } else {
        return;
      }
    }
    if (data && null != obj.fillColor) {
      this.updateFill();
    } else {
      if (!this.styleEnabled) {
        if ("ellipse" == elem.nodeName && mxClient.IS_FF) {
          elem.setAttribute("fill", "transparent");
        } else {
          elem.setAttribute("fill", "none");
        }
        /** @type {boolean} */
        data = false;
      }
    }
    if (delta && null != obj.strokeColor) {
      this.updateStroke();
    } else {
      if (!this.styleEnabled) {
        elem.setAttribute("stroke", "none");
      }
    }
    if (null != obj.transform && 0 < obj.transform.length) {
      elem.setAttribute("transform", obj.transform);
    }
    if (obj.shadow) {
      this.root.appendChild(this.createShadow(elem));
    }
    if (0 < this.strokeTolerance && !data) {
      this.root.appendChild(this.createTolerance(elem));
    }
    if (this.pointerEvents) {
      elem.setAttribute("pointer-events", this.pointerEventsValue);
    } else {
      if (!(this.pointerEvents || null != this.originalRoot)) {
        elem.setAttribute("pointer-events", "none");
      }
    }
    if ("rect" != elem.nodeName && "path" != elem.nodeName && "ellipse" != elem.nodeName || "none" != elem.getAttribute("fill") && "transparent" != elem.getAttribute("fill") || "none" != elem.getAttribute("stroke") || "none" != elem.getAttribute("pointer-events")) {
      this.root.appendChild(elem);
    }
    /** @type {null} */
    this.node = null;
  }
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.updateFill = function() {
  var parent = this.state;
  if (1 > parent.alpha || 1 > parent.fillAlpha) {
    this.node.setAttribute("fill-opacity", parent.alpha * parent.fillAlpha);
  }
  if (null != parent.fillColor) {
    if (null != parent.gradientColor) {
      if (parent = this.getSvgGradient(String(parent.fillColor), String(parent.gradientColor), parent.gradientFillAlpha, parent.gradientAlpha, parent.gradientDirection), this.root.ownerDocument == document && this.useAbsoluteIds) {
        var _ddoc = this.getBaseUrl().replace(/([\(\)])/g, "\\$1");
        this.node.setAttribute("fill", "url(" + _ddoc + "#" + parent + ")");
      } else {
        this.node.setAttribute("fill", "url(#" + parent + ")");
      }
    } else {
      this.node.setAttribute("fill", String(parent.fillColor).toLowerCase());
    }
  }
};
/**
 * @return {?}
 */
mxSvgCanvas2D.prototype.getCurrentStrokeWidth = function() {
  return Math.max(this.minStrokeWidth, Math.max(.01, this.format(this.state.strokeWidth * this.state.scale)));
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.updateStroke = function() {
  var options = this.state;
  this.node.setAttribute("stroke", String(options.strokeColor).toLowerCase());
  if (1 > options.alpha || 1 > options.strokeAlpha) {
    this.node.setAttribute("stroke-opacity", options.alpha * options.strokeAlpha);
  }
  var value = this.getCurrentStrokeWidth();
  if (1 != value) {
    this.node.setAttribute("stroke-width", value);
  }
  if ("path" == this.node.nodeName) {
    this.updateStrokeAttributes();
  }
  if (options.dashed) {
    this.node.setAttribute("stroke-dasharray", this.createDashPattern((options.fixDash ? 1 : options.strokeWidth) * options.scale));
  }
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.updateStrokeAttributes = function() {
  var options = this.state;
  if (null != options.lineJoin && "miter" != options.lineJoin) {
    this.node.setAttribute("stroke-linejoin", options.lineJoin);
  }
  if (null != options.lineCap) {
    var value = options.lineCap;
    if ("flat" == value) {
      /** @type {string} */
      value = "butt";
    }
    if ("butt" != value) {
      this.node.setAttribute("stroke-linecap", value);
    }
  }
  if (!(null == options.miterLimit || this.styleEnabled && 10 == options.miterLimit)) {
    this.node.setAttribute("stroke-miterlimit", options.miterLimit);
  }
};
/**
 * @param {number} multiplier
 * @return {?}
 */
mxSvgCanvas2D.prototype.createDashPattern = function(multiplier) {
  /** @type {!Array} */
  var outputBuffer = [];
  if ("string" === typeof this.state.dashPattern) {
    /** @type {!Array<string>} */
    var SMPTE = this.state.dashPattern.split(" ");
    if (0 < SMPTE.length) {
      /** @type {number} */
      var i = 0;
      for (; i < SMPTE.length; i++) {
        /** @type {number} */
        outputBuffer[i] = Number(SMPTE[i]) * multiplier;
      }
    }
  }
  return outputBuffer.join(" ");
};
/**
 * @param {!Node} el
 * @return {?}
 */
mxSvgCanvas2D.prototype.createTolerance = function(el) {
  el = el.cloneNode(true);
  var styleElId = parseFloat(el.getAttribute("stroke-width") || 1) + this.strokeTolerance;
  el.setAttribute("pointer-events", "stroke");
  el.setAttribute("visibility", "hidden");
  el.removeAttribute("stroke-dasharray");
  el.setAttribute("stroke-width", styleElId);
  el.setAttribute("fill", "none");
  el.setAttribute("stroke", mxClient.IS_OT ? "none" : "white");
  return el;
};
/**
 * @param {!Node} e
 * @return {?}
 */
mxSvgCanvas2D.prototype.createShadow = function(e) {
  e = e.cloneNode(true);
  var style = this.state;
  if (!("none" == e.getAttribute("fill") || mxClient.IS_FF && "transparent" == e.getAttribute("fill"))) {
    e.setAttribute("fill", style.shadowColor);
  }
  if ("none" != e.getAttribute("stroke")) {
    e.setAttribute("stroke", style.shadowColor);
  }
  e.setAttribute("transform", "translate(" + this.format(style.shadowDx * style.scale) + "," + this.format(style.shadowDy * style.scale) + ")" + (style.transform || ""));
  e.setAttribute("opacity", style.shadowAlpha);
  return e;
};
/**
 * @param {string} url
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.setLink = function(url) {
  if (null == url) {
    this.root = this.originalRoot;
  } else {
    this.originalRoot = this.root;
    var el = this.createElement("a");
    if (null == el.setAttributeNS || this.root.ownerDocument != document && null == document.documentMode) {
      el.setAttribute("xlink:href", url);
    } else {
      el.setAttributeNS(mxConstants.NS_XLINK, "xlink:href", url);
    }
    this.root.appendChild(el);
    this.root = el;
  }
};
/**
 * @param {number} d
 * @param {boolean} b
 * @param {boolean} a
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.rotate = function(d, b, a, x, y) {
  if (0 != d || b || a) {
    var s = this.state;
    x = x + s.dx;
    y = y + s.dy;
    /** @type {number} */
    x = x * s.scale;
    /** @type {number} */
    y = y * s.scale;
    s.transform = s.transform || "";
    if (b && a) {
      d = d + 180;
    } else {
      if (b != a) {
        var data = b ? x : 0;
        /** @type {number} */
        var name = b ? -1 : 1;
        var d = a ? y : 0;
        /** @type {number} */
        var start = a ? -1 : 1;
        s.transform += "translate(" + this.format(data) + "," + this.format(d) + ")scale(" + this.format(name) + "," + this.format(start) + ")translate(" + this.format(-data) + "," + this.format(-d) + ")";
      }
    }
    if (b ? !a : a) {
      /** @type {number} */
      d = d * -1;
    }
    if (0 != d) {
      s.transform += "rotate(" + this.format(d) + "," + this.format(x) + "," + this.format(y) + ")";
    }
    s.rotation += d;
    /** @type {number} */
    s.rotationCx = x;
    /** @type {number} */
    s.rotationCy = y;
  }
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.begin = function() {
  mxAbstractCanvas2D.prototype.begin.apply(this, arguments);
  this.node = this.createElement("path");
};
/**
 * @param {number} x
 * @param {number} y
 * @param {number} i
 * @param {number} val
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.rect = function(x, y, i, val) {
  var s = this.state;
  var el = this.createElement("rect");
  el.setAttribute("x", this.format((x + s.dx) * s.scale));
  el.setAttribute("y", this.format((y + s.dy) * s.scale));
  el.setAttribute("width", this.format(i * s.scale));
  el.setAttribute("height", this.format(val * s.scale));
  this.node = el;
};
/**
 * @param {number} x
 * @param {number} s
 * @param {number} g
 * @param {number} h
 * @param {number} y
 * @param {number} value
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.roundrect = function(x, s, g, h, y, value) {
  this.rect(x, s, g, h);
  if (0 < y) {
    this.node.setAttribute("rx", this.format(y * this.state.scale));
  }
  if (0 < value) {
    this.node.setAttribute("ry", this.format(value * this.state.scale));
  }
};
/**
 * @param {number} a
 * @param {number} id
 * @param {number} b
 * @param {number} t
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.ellipse = function(a, id, b, t) {
  var state = this.state;
  var el = this.createElement("ellipse");
  el.setAttribute("cx", this.format((a + b / 2 + state.dx) * state.scale));
  el.setAttribute("cy", this.format((id + t / 2 + state.dy) * state.scale));
  el.setAttribute("rx", b / 2 * state.scale);
  el.setAttribute("ry", t / 2 * state.scale);
  this.node = el;
};
/**
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} index
 * @param {string} value
 * @param {?} name
 * @param {string} v
 * @param {string} h
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.image = function(x, y, width, index, value, name, v, h) {
  value = this.converter.convert(value);
  name = null != name ? name : true;
  v = null != v ? v : false;
  h = null != h ? h : false;
  var me = this.state;
  x = x + me.dx;
  y = y + me.dy;
  var el = this.createElement("image");
  el.setAttribute("x", this.format(x * me.scale) + this.imageOffset);
  el.setAttribute("y", this.format(y * me.scale) + this.imageOffset);
  el.setAttribute("width", this.format(width * me.scale));
  el.setAttribute("height", this.format(index * me.scale));
  if (null == el.setAttributeNS) {
    el.setAttribute("xlink:href", value);
  } else {
    el.setAttributeNS(mxConstants.NS_XLINK, "xlink:href", value);
  }
  if (!name) {
    el.setAttribute("preserveAspectRatio", "none");
  }
  if (1 > me.alpha || 1 > me.fillAlpha) {
    el.setAttribute("opacity", me.alpha * me.fillAlpha);
  }
  value = this.state.transform || "";
  if (v || h) {
    /** @type {number} */
    var prefix = name = 1;
    /** @type {number} */
    var offset = 0;
    /** @type {number} */
    var cx = 0;
    if (v) {
      /** @type {number} */
      name = -1;
      /** @type {number} */
      offset = -width - 2 * x;
    }
    if (h) {
      /** @type {number} */
      prefix = -1;
      /** @type {number} */
      cx = -index - 2 * y;
    }
    /** @type {string} */
    value = value + ("scale(" + name + "," + prefix + ")translate(" + offset * me.scale + "," + cx * me.scale + ")");
  }
  if (0 < value.length) {
    el.setAttribute("transform", value);
  }
  if (!this.pointerEvents) {
    el.setAttribute("pointer-events", "none");
  }
  this.root.appendChild(el);
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxSvgCanvas2D.prototype.convertHtml = function(e) {
  if (this.useDomParser) {
    /** @type {(Document|null)} */
    var result = (new DOMParser).parseFromString(e, "text/html");
    if (null != result) {
      /** @type {string} */
      e = (new XMLSerializer).serializeToString(result.body);
      if ("<body" == e.substring(0, 5)) {
        /** @type {string} */
        e = e.substring(e.indexOf(">", 5) + 1);
      }
      if ("</body>" == e.substring(e.length - 7, e.length)) {
        /** @type {string} */
        e = e.substring(0, e.length - 7);
      }
    }
  } else {
    if (null != document.implementation && null != document.implementation.createDocument) {
      /** @type {(Document|null)} */
      result = document.implementation.createDocument("http://www.w3.org/1999/xhtml", "html", null);
      /** @type {!Element} */
      var b = result.createElement("body");
      result.documentElement.appendChild(b);
      /** @type {!Element} */
      var t = document.createElement("div");
      /** @type {!Object} */
      t.innerHTML = e;
      /** @type {(Node|null)} */
      e = t.firstChild;
      for (; null != e;) {
        /** @type {(Node|null)} */
        t = e.nextSibling;
        b.appendChild(result.adoptNode(e));
        /** @type {(Node|null)} */
        e = t;
      }
      return b.innerHTML;
    }
    /** @type {!Element} */
    result = document.createElement("textarea");
    result.innerHTML = e.replace(/&amp;/g, "&amp;amp;").replace(/&#60;/g, "&amp;lt;").replace(/&#62;/g, "&amp;gt;").replace(/&lt;/g, "&amp;lt;").replace(/&gt;/g, "&amp;gt;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    e = result.value.replace(/&/g, "&amp;").replace(/&amp;lt;/g, "&lt;").replace(/&amp;gt;/g, "&gt;").replace(/&amp;amp;/g, "&amp;").replace(/<br>/g, "<br />").replace(/<hr>/g, "<hr />").replace(/(<img[^>]+)>/gm, "$1 />");
  }
  return e;
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxSvgCanvas2D.prototype.createDiv = function(value) {
  if (!mxUtils.isNode(value)) {
    /** @type {string} */
    value = "<div><div>" + this.convertHtml(value) + "</div></div>";
  }
  if (mxClient.IS_IE || mxClient.IS_IE11 || !document.createElementNS) {
    return mxUtils.isNode(value) && (value = "<div><div>" + mxUtils.getXml(value) + "</div></div>"), mxUtils.parseXml('<div xmlns="http://www.w3.org/1999/xhtml">' + value + "</div>").documentElement;
  }
  /** @type {!Element} */
  var div = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
  if (mxUtils.isNode(value)) {
    /** @type {!Element} */
    var c = document.createElement("div");
    /** @type {!Element} */
    var d = c.cloneNode(false);
    if (this.root.ownerDocument != document) {
      c.appendChild(value.cloneNode(true));
    } else {
      c.appendChild(value);
    }
    d.appendChild(c);
    div.appendChild(d);
  } else {
    /** @type {!Object} */
    div.innerHTML = value;
  }
  return div;
};
/**
 * @param {number} target
 * @param {!Function} position
 * @param {number} text
 * @param {!Array} id
 * @param {string} html
 * @param {string} key
 * @param {boolean} url
 * @param {string} parent
 * @param {boolean} newPath
 * @param {undefined} type
 * @param {!Object} body
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.updateText = function(target, position, text, id, html, key, url, parent, newPath, type, body) {
  if (null != body && null != body.firstChild && null != body.firstChild.firstChild) {
    this.updateTextNodes(target, position, text, id, html, key, url, parent, newPath, type, body.firstChild);
  }
};
/**
 * @param {number} x
 * @param {!Object} y
 * @param {number} width
 * @param {?} t
 * @param {boolean} str
 * @param {string} align
 * @param {boolean} valign
 * @param {?} wrap
 * @param {string} format
 * @param {string} model
 * @param {?} clip
 * @param {number} state
 * @param {!Object} base
 * @param {!Object} element
 * @param {!Object} h
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.addForeignObject = function(x, y, width, t, str, align, valign, wrap, format, model, clip, state, base, element, h) {
  base = this.createElement("g");
  var node = this.createElement("foreignObject");
  node.setAttribute("style", "overflow: visible; text-align: left;");
  node.setAttribute("pointer-events", "none");
  if (element.ownerDocument != document) {
    element = mxUtils.importNodeImplementation(node.ownerDocument, element, true);
  }
  node.appendChild(element);
  base.appendChild(node);
  this.updateTextNodes(x, y, width, t, align, valign, wrap, model, clip, state, base);
  if (this.root.ownerDocument != document) {
    x = this.createAlternateContent(node, x, y, width, t, str, align, valign, wrap, format, model, clip, state);
    if (null != x) {
      node.setAttribute("requiredFeatures", "http://www.w3.org/TR/SVG11/feature#Extensibility");
      y = this.createElement("switch");
      y.appendChild(node);
      y.appendChild(x);
      base.appendChild(y);
    }
  }
  h.appendChild(base);
};
/**
 * @param {number} x
 * @param {string} y
 * @param {number} val
 * @param {!Array} label
 * @param {string} align
 * @param {string} valign
 * @param {boolean} callback
 * @param {string} path
 * @param {boolean} name
 * @param {number} data
 * @param {!Object} target
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.updateTextNodes = function(x, y, val, label, align, valign, callback, path, name, data, target) {
  var v = this.state.scale;
  mxSvgCanvas2D.createCss(val + 2, label, align, valign, callback, path, name, null != this.state.fontBackgroundColor ? this.state.fontBackgroundColor : null, null != this.state.fontBorderColor ? this.state.fontBorderColor : null, "display: flex; align-items: unsafe " + (valign == mxConstants.ALIGN_TOP ? "flex-start" : valign == mxConstants.ALIGN_BOTTOM ? "flex-end" : "center") + "; justify-content: unsafe " + (align == mxConstants.ALIGN_LEFT ? "flex-start" : align == mxConstants.ALIGN_RIGHT ? "flex-end" : 
  "center") + "; ", this.getTextCss(), v, mxUtils.bind(this, function(ix, size, s, value, $iconFilePath) {
    x = x + this.state.dx;
    y = y + this.state.dy;
    var panel = target.firstChild;
    var doc = panel.firstChild;
    var body = doc.firstChild;
    var where = (this.rotateHtml ? this.state.rotation : 0) + (null != data ? data : 0);
    /** @type {string} */
    var val = (0 != this.foOffset ? "translate(" + this.foOffset + " " + this.foOffset + ")" : "") + (1 != v ? "scale(" + v + ")" : "");
    body.firstChild.setAttribute("style", $iconFilePath);
    body.setAttribute("style", value);
    panel.setAttribute("width", Math.ceil(1 / Math.min(1, v) * 100) + "%");
    panel.setAttribute("height", Math.ceil(1 / Math.min(1, v) * 100) + "%");
    /** @type {number} */
    size = Math.round(y + size);
    if (0 > size) {
      panel.setAttribute("y", size);
    } else {
      panel.removeAttribute("y");
      /** @type {string} */
      s = s + ("padding-top: " + size + "px; ");
    }
    doc.setAttribute("style", s + "margin-left: " + Math.round(x + ix) + "px;");
    /** @type {string} */
    val = val + (0 != where ? "rotate(" + where + " " + x + " " + y + ")" : "");
    if ("" != val) {
      target.setAttribute("transform", val);
    } else {
      target.removeAttribute("transform");
    }
    if (1 != this.state.alpha) {
      target.setAttribute("opacity", this.state.alpha);
    } else {
      target.removeAttribute("opacity");
    }
  }));
};
/**
 * @param {number} height
 * @param {number} width
 * @param {string} value
 * @param {string} x
 * @param {boolean} method
 * @param {string} undefined
 * @param {boolean} call
 * @param {?} rule
 * @param {?} rules
 * @param {string} name
 * @param {string} pos
 * @param {string} i
 * @param {?} callback
 * @return {undefined}
 */
mxSvgCanvas2D.createCss = function(height, width, value, x, method, undefined, call, rule, rules, name, pos, i, callback) {
  /** @type {string} */
  i = "box-sizing: border-box; font-size: 0; text-align: " + (value == mxConstants.ALIGN_LEFT ? "left" : value == mxConstants.ALIGN_RIGHT ? "right" : "center") + "; ";
  var d = mxUtils.getAlignmentAsPoint(value, x);
  /** @type {string} */
  value = "overflow: hidden; ";
  /** @type {string} */
  x = "width: 1px; ";
  /** @type {string} */
  var n = "height: 1px; ";
  /** @type {number} */
  var rows = d.x * height;
  /** @type {number} */
  d = d.y * width;
  if (call) {
    /** @type {string} */
    x = "width: " + Math.round(height) + "px; ";
    /** @type {string} */
    i = i + ("max-height: " + Math.round(width) + "px; ");
    /** @type {number} */
    d = 0;
  } else {
    if ("fill" == undefined) {
      /** @type {string} */
      x = "width: " + Math.round(height) + "px; ";
      /** @type {string} */
      n = "height: " + Math.round(width) + "px; ";
      /** @type {string} */
      pos = pos + "width: 100%; height: 100%; ";
      /** @type {string} */
      i = i + (x + n);
    } else {
      if ("width" == undefined) {
        /** @type {string} */
        x = "width: " + Math.round(height) + "px; ";
        /** @type {string} */
        pos = pos + "width: 100%; ";
        /** @type {string} */
        i = i + x;
        /** @type {number} */
        d = 0;
        if (0 < width) {
          /** @type {string} */
          i = i + ("max-height: " + Math.round(width) + "px; ");
        }
      } else {
        /** @type {string} */
        value = "";
        /** @type {number} */
        d = 0;
      }
    }
  }
  /** @type {string} */
  width = "";
  if (null != rule) {
    /** @type {string} */
    width = width + ("background-color: " + rule + "; ");
  }
  if (null != rules) {
    /** @type {string} */
    width = width + ("border: 1px solid " + rules + "; ");
  }
  if ("" == value || call) {
    /** @type {string} */
    pos = pos + width;
  } else {
    /** @type {string} */
    i = i + width;
  }
  if (method && 0 < height) {
    /** @type {string} */
    pos = pos + ("white-space: normal; word-wrap: " + mxConstants.WORD_WRAP + "; ");
    /** @type {string} */
    x = "width: " + Math.round(height) + "px; ";
    if ("" != value && "fill" != undefined) {
      /** @type {number} */
      d = 0;
    }
  } else {
    /** @type {string} */
    pos = pos + "white-space: nowrap; ";
    if ("" == value) {
      /** @type {number} */
      rows = 0;
    }
  }
  callback(rows, d, name + x + n, i + value, pos, value);
};
/**
 * @return {?}
 */
mxSvgCanvas2D.prototype.getTextCss = function() {
  var obj = this.state;
  /** @type {string} */
  var encrypted = "display: inline-block; font-size: " + obj.fontSize + "px; font-family: " + obj.fontFamily + "; color: " + obj.fontColor + "; line-height: " + (mxConstants.ABSOLUTE_LINE_HEIGHT ? obj.fontSize * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT * this.lineHeightCorrection) + "; pointer-events: " + (this.pointerEvents ? this.pointerEventsValue : "none") + "; ";
  if ((obj.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
    /** @type {string} */
    encrypted = encrypted + "font-weight: bold; ";
  }
  if ((obj.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
    /** @type {string} */
    encrypted = encrypted + "font-style: italic; ";
  }
  /** @type {!Array} */
  var textDecorations = [];
  if ((obj.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    textDecorations.push("underline");
  }
  if ((obj.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
    textDecorations.push("line-through");
  }
  if (0 < textDecorations.length) {
    /** @type {string} */
    encrypted = encrypted + ("text-decoration: " + textDecorations.join(" ") + "; ");
  }
  return encrypted;
};
/**
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @param {?} str
 * @param {undefined} align
 * @param {undefined} valign
 * @param {?} wrap
 * @param {string} value
 * @param {string} group
 * @param {?} data
 * @param {number} name
 * @param {number} dir
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.text = function(x, y, w, h, str, align, valign, wrap, value, group, data, name, dir) {
  if (this.textEnabled && null != str) {
    if (name = null != name ? name : 0, this.foEnabled && "html" == value) {
      var div = this.createDiv(str);
      if (null != div) {
        if (null != dir) {
          div.setAttribute("dir", dir);
        }
        this.addForeignObject(x, y, w, h, str, align, valign, wrap, value, group, data, name, dir, div, this.root);
      }
    } else {
      this.plainText(x + this.state.dx, y + this.state.dy, w, h, str, align, valign, wrap, group, data, name, dir);
    }
  }
};
/**
 * @param {string} b
 * @param {string} a
 * @param {string} d
 * @param {string} v
 * @return {?}
 */
mxSvgCanvas2D.prototype.createClip = function(b, a, d, v) {
  /** @type {number} */
  b = Math.round(b);
  /** @type {number} */
  a = Math.round(a);
  /** @type {number} */
  d = Math.round(d);
  /** @type {number} */
  v = Math.round(v);
  /** @type {string} */
  var s = "mx-clip-" + b + "-" + a + "-" + d + "-" + v;
  /** @type {number} */
  var i = 0;
  /** @type {string} */
  var text = s + "-" + i;
  for (; null != document.getElementById(text);) {
    /** @type {string} */
    text = s + "-" + ++i;
  }
  clip = this.createElement("clipPath");
  clip.setAttribute("id", text);
  s = this.createElement("rect");
  s.setAttribute("x", b);
  s.setAttribute("y", a);
  s.setAttribute("width", d);
  s.setAttribute("height", v);
  clip.appendChild(s);
  return clip;
};
/**
 * @param {number} value
 * @param {string} h
 * @param {number} y
 * @param {number} w
 * @param {!Object} text
 * @param {(Object|string)} align
 * @param {number} valign
 * @param {!Object} options
 * @param {string} string
 * @param {number} j
 * @param {string} i
 * @param {number} x
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.plainText = function(value, h, y, w, text, align, valign, options, string, j, i, x) {
  i = null != i ? i : 0;
  options = this.state;
  var p = options.fontSize;
  var node = this.createElement("g");
  var params = options.transform || "";
  this.updateFont(node);
  if (!(this.pointerEvents || null != this.originalRoot)) {
    node.setAttribute("pointer-events", "none");
  }
  if (0 != i) {
    /** @type {string} */
    params = params + ("rotate(" + i + "," + this.format(value * options.scale) + "," + this.format(h * options.scale) + ")");
  }
  if (null != x) {
    node.setAttribute("direction", x);
  }
  if (j && 0 < y && 0 < w) {
    /** @type {number} */
    x = value;
    /** @type {string} */
    i = h;
    if (align == mxConstants.ALIGN_CENTER) {
      /** @type {number} */
      x = x - y / 2;
    } else {
      if (align == mxConstants.ALIGN_RIGHT) {
        /** @type {number} */
        x = x - y;
      }
    }
    if ("fill" != string) {
      if (valign == mxConstants.ALIGN_MIDDLE) {
        /** @type {number} */
        i = i - w / 2;
      } else {
        if (valign == mxConstants.ALIGN_BOTTOM) {
          /** @type {number} */
          i = i - w;
        }
      }
    }
    i = this.createClip(x * options.scale - 2, i * options.scale - 2, y * options.scale + 4, w * options.scale + 4);
    if (null != this.defs) {
      this.defs.appendChild(i);
    } else {
      this.root.appendChild(i);
    }
    if (mxClient.IS_CHROMEAPP || mxClient.IS_IE || mxClient.IS_IE11 || mxClient.IS_EDGE || this.root.ownerDocument != document) {
      node.setAttribute("clip-path", "url(#" + i.getAttribute("id") + ")");
    } else {
      x = this.getBaseUrl().replace(/([\(\)])/g, "\\$1");
      node.setAttribute("clip-path", "url(" + x + "#" + i.getAttribute("id") + ")");
    }
  }
  /** @type {string} */
  i = align == mxConstants.ALIGN_RIGHT ? "end" : align == mxConstants.ALIGN_CENTER ? "middle" : "start";
  if ("start" != i) {
    node.setAttribute("text-anchor", i);
  }
  if (!(this.styleEnabled && p == mxConstants.DEFAULT_FONTSIZE)) {
    node.setAttribute("font-size", p * options.scale + "px");
  }
  if (0 < params.length) {
    node.setAttribute("transform", params);
  }
  if (1 > options.alpha) {
    node.setAttribute("opacity", options.alpha);
  }
  params = text.split("\n");
  /** @type {number} */
  x = Math.round(p * mxConstants.LINE_HEIGHT);
  var l = p + (params.length - 1) * x;
  /** @type {number} */
  i = h + p - 1;
  if (valign == mxConstants.ALIGN_MIDDLE) {
    if ("fill" == string) {
      /** @type {number} */
      i = i - w / 2;
    } else {
      /** @type {number} */
      j = (this.matchHtmlAlignment && j && 0 < w ? Math.min(l, w) : l) / 2;
      /** @type {number} */
      i = i - j;
    }
  } else {
    if (valign == mxConstants.ALIGN_BOTTOM) {
      if ("fill" == string) {
        /** @type {number} */
        i = i - w;
      } else {
        j = this.matchHtmlAlignment && j && 0 < w ? Math.min(l, w) : l;
        /** @type {number} */
        i = i - (j + 1);
      }
    }
  }
  /** @type {number} */
  j = 0;
  for (; j < params.length; j++) {
    if (0 < params[j].length && 0 < mxUtils.trim(params[j]).length) {
      p = this.createElement("text");
      p.setAttribute("x", this.format(value * options.scale) + this.textOffset);
      p.setAttribute("y", this.format(i * options.scale) + this.textOffset);
      mxUtils.write(p, params[j]);
      node.appendChild(p);
    }
    /** @type {number} */
    i = i + x;
  }
  this.root.appendChild(node);
  this.addTextBackground(node, text, value, h, y, "fill" == string ? w : l, align, valign, string);
};
/**
 * @param {!Element} t
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.updateFont = function(t) {
  var obj = this.state;
  t.setAttribute("fill", obj.fontColor);
  if (!(this.styleEnabled && obj.fontFamily == mxConstants.DEFAULT_FONTFAMILY)) {
    t.setAttribute("font-family", obj.fontFamily);
  }
  if ((obj.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
    t.setAttribute("font-weight", "bold");
  }
  if ((obj.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
    t.setAttribute("font-style", "italic");
  }
  /** @type {!Array} */
  var textDecorations = [];
  if ((obj.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    textDecorations.push("underline");
  }
  if ((obj.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
    textDecorations.push("line-through");
  }
  if (0 < textDecorations.length) {
    t.setAttribute("text-decoration", textDecorations.join(" "));
  }
};
/**
 * @param {!Element} item
 * @param {!Object} element
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @param {(Object|string)} align
 * @param {number} valign
 * @param {string} undefined
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.addTextBackground = function(item, element, x, y, w, h, align, valign, undefined) {
  var s = this.state;
  if (null != s.fontBackgroundColor || null != s.fontBorderColor) {
    /** @type {null} */
    var el = null;
    if ("fill" == undefined || "width" == undefined) {
      if (align == mxConstants.ALIGN_CENTER) {
        /** @type {number} */
        x = x - w / 2;
      } else {
        if (align == mxConstants.ALIGN_RIGHT) {
          /** @type {number} */
          x = x - w;
        }
      }
      if (valign == mxConstants.ALIGN_MIDDLE) {
        /** @type {number} */
        y = y - h / 2;
      } else {
        if (valign == mxConstants.ALIGN_BOTTOM) {
          /** @type {number} */
          y = y - h;
        }
      }
      el = new mxRectangle((x + 1) * s.scale, y * s.scale, (w - 2) * s.scale, (h + 2) * s.scale);
    } else {
      if (null != item.getBBox && this.root.ownerDocument == document) {
        try {
          el = item.getBBox();
          var rotate = mxClient.IS_IE && mxClient.IS_SVG;
          el = new mxRectangle(el.x, el.y + (rotate ? 0 : 1), el.width, el.height + (rotate ? 1 : 0));
        } catch (q) {
        }
      }
    }
    if (null == el || 0 == el.width || 0 == el.height) {
      /** @type {!Element} */
      el = document.createElement("div");
      el.style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? s.fontSize * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT;
      /** @type {string} */
      el.style.fontSize = s.fontSize + "px";
      el.style.fontFamily = s.fontFamily;
      /** @type {string} */
      el.style.whiteSpace = "nowrap";
      /** @type {string} */
      el.style.position = "absolute";
      /** @type {string} */
      el.style.visibility = "hidden";
      /** @type {string} */
      el.style.display = mxClient.IS_QUIRKS ? "inline" : "inline-block";
      /** @type {string} */
      el.style.zoom = "1";
      if ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
        /** @type {string} */
        el.style.fontWeight = "bold";
      }
      if ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
        /** @type {string} */
        el.style.fontStyle = "italic";
      }
      element = mxUtils.htmlEntities(element, false);
      el.innerHTML = element.replace(/\n/g, "<br/>");
      document.body.appendChild(el);
      w = el.offsetWidth;
      h = el.offsetHeight;
      el.parentNode.removeChild(el);
      if (align == mxConstants.ALIGN_CENTER) {
        /** @type {number} */
        x = x - w / 2;
      } else {
        if (align == mxConstants.ALIGN_RIGHT) {
          /** @type {number} */
          x = x - w;
        }
      }
      if (valign == mxConstants.ALIGN_MIDDLE) {
        /** @type {number} */
        y = y - h / 2;
      } else {
        if (valign == mxConstants.ALIGN_BOTTOM) {
          /** @type {number} */
          y = y - h;
        }
      }
      el = new mxRectangle((x + 1) * s.scale, (y + 2) * s.scale, w * s.scale, (h + 1) * s.scale);
    }
    if (null != el) {
      element = this.createElement("rect");
      element.setAttribute("fill", s.fontBackgroundColor || "none");
      element.setAttribute("stroke", s.fontBorderColor || "none");
      element.setAttribute("x", Math.floor(el.x - 1));
      element.setAttribute("y", Math.floor(el.y - 1));
      element.setAttribute("width", Math.ceil(el.width + 2));
      element.setAttribute("height", Math.ceil(el.height));
      /** @type {number} */
      s = null != s.fontBorderColor ? Math.max(1, this.format(s.scale)) : 0;
      element.setAttribute("stroke-width", s);
      if (this.root.ownerDocument == document && 1 == mxUtils.mod(s, 2)) {
        element.setAttribute("transform", "translate(0.5, 0.5)");
      }
      item.insertBefore(element, item.firstChild);
    }
  }
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.stroke = function() {
  this.addNode(false, true);
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.fill = function() {
  this.addNode(true, false);
};
/**
 * @return {undefined}
 */
mxSvgCanvas2D.prototype.fillAndStroke = function() {
  this.addNode(true, true);
};
/**
 * @param {string} p
 * @return {undefined}
 */
var mxVmlCanvas2D = function(p) {
  mxAbstractCanvas2D.call(this);
  /** @type {string} */
  this.root = p;
};
mxUtils.extend(mxVmlCanvas2D, mxAbstractCanvas2D);
/** @type {null} */
mxVmlCanvas2D.prototype.node = null;
/** @type {boolean} */
mxVmlCanvas2D.prototype.textEnabled = true;
/** @type {string} */
mxVmlCanvas2D.prototype.moveOp = "m";
/** @type {string} */
mxVmlCanvas2D.prototype.lineOp = "l";
/** @type {string} */
mxVmlCanvas2D.prototype.curveOp = "c";
/** @type {string} */
mxVmlCanvas2D.prototype.closeOp = "x";
/** @type {string} */
mxVmlCanvas2D.prototype.rotatedHtmlBackground = "";
/** @type {number} */
mxVmlCanvas2D.prototype.vmlScale = 1;
/**
 * @param {string} name
 * @return {?}
 */
mxVmlCanvas2D.prototype.createElement = function(name) {
  return document.createElement(name);
};
/**
 * @param {string} tagName
 * @return {?}
 */
mxVmlCanvas2D.prototype.createVmlElement = function(tagName) {
  return this.createElement(mxClient.VML_PREFIX + ":" + tagName);
};
/**
 * @param {boolean} data
 * @param {boolean} delta
 * @return {undefined}
 */
mxVmlCanvas2D.prototype.addNode = function(data, delta) {
  var node = this.node;
  var style = this.state;
  if (null != node) {
    if ("shape" == node.nodeName) {
      if (null != this.path && 0 < this.path.length) {
        node.path = this.path.join(" ") + " e";
        node.style.width = this.root.style.width;
        node.style.height = this.root.style.height;
        /** @type {string} */
        node.coordsize = parseInt(node.style.width) + " " + parseInt(node.style.height);
      } else {
        return;
      }
    }
    node.strokeweight = this.format(Math.max(1, style.strokeWidth * style.scale / this.vmlScale)) + "px";
    if (style.shadow) {
      this.root.appendChild(this.createShadow(node, data && null != style.fillColor, delta && null != style.strokeColor));
    }
    if (delta && null != style.strokeColor) {
      /** @type {string} */
      node.stroked = "true";
      node.strokecolor = style.strokeColor;
    } else {
      /** @type {string} */
      node.stroked = "false";
    }
    node.appendChild(this.createStroke());
    if (data && null != style.fillColor) {
      node.appendChild(this.createFill());
    } else {
      if (!this.pointerEvents || "shape" == node.nodeName && this.path[this.path.length - 1] != this.closeOp) {
        /** @type {string} */
        node.filled = "false";
      } else {
        node.appendChild(this.createTransparentFill());
      }
    }
    this.root.appendChild(node);
  }
};
/**
 * @return {?}
 */
mxVmlCanvas2D.prototype.createTransparentFill = function() {
  var fill = this.createVmlElement("fill");
  /** @type {string} */
  fill.src = mxClient.imageBasePath + "/transparent.gif";
  /** @type {string} */
  fill.type = "tile";
  return fill;
};
/**
 * @return {?}
 */
mxVmlCanvas2D.prototype.createFill = function() {
  var params = this.state;
  var fill = this.createVmlElement("fill");
  fill.color = params.fillColor;
  if (null != params.gradientColor) {
    /** @type {string} */
    fill.type = "gradient";
    /** @type {string} */
    fill.method = "none";
    fill.color2 = params.gradientColor;
    /** @type {number} */
    var value = 180 - params.rotation;
    /** @type {number} */
    value = params.gradientDirection == mxConstants.DIRECTION_WEST ? value - (90 + ("x" == this.root.style.flip ? 180 : 0)) : params.gradientDirection == mxConstants.DIRECTION_EAST ? value + (90 + ("x" == this.root.style.flip ? 180 : 0)) : params.gradientDirection == mxConstants.DIRECTION_NORTH ? value - (180 + ("y" == this.root.style.flip ? -180 : 0)) : value + ("y" == this.root.style.flip ? -180 : 0);
    if ("x" == this.root.style.flip || "y" == this.root.style.flip) {
      /** @type {number} */
      value = value * -1;
    }
    fill.angle = mxUtils.mod(value, 360);
    /** @type {string} */
    fill.opacity = params.alpha * params.gradientFillAlpha * 100 + "%";
    fill.setAttribute(mxClient.OFFICE_PREFIX + ":opacity2", params.alpha * params.gradientAlpha * 100 + "%");
  } else {
    if (1 > params.alpha || 1 > params.fillAlpha) {
      /** @type {string} */
      fill.opacity = params.alpha * params.fillAlpha * 100 + "%";
    }
  }
  return fill;
};
/**
 * @return {?}
 */
mxVmlCanvas2D.prototype.createStroke = function() {
  var style = this.state;
  var stroke = this.createVmlElement("stroke");
  stroke.endcap = style.lineCap || "flat";
  stroke.joinstyle = style.lineJoin || "miter";
  stroke.miterlimit = style.miterLimit || "10";
  if (1 > style.alpha || 1 > style.strokeAlpha) {
    /** @type {string} */
    stroke.opacity = style.alpha * style.strokeAlpha * 100 + "%";
  }
  if (style.dashed) {
    stroke.dashstyle = this.getVmlDashStyle();
  }
  return stroke;
};
/**
 * @return {?}
 */
mxVmlCanvas2D.prototype.getVmlDashStyle = function() {
  /** @type {string} */
  var new_tx_chain = "dash";
  if ("string" === typeof this.state.dashPattern) {
    /** @type {!Array<string>} */
    var expRecords = this.state.dashPattern.split(" ");
    if (0 < expRecords.length && 1 == expRecords[0]) {
      /** @type {string} */
      new_tx_chain = "0 2";
    }
  }
  return new_tx_chain;
};
/**
 * @param {!Node} p
 * @param {?} type
 * @param {?} direction
 * @return {?}
 */
mxVmlCanvas2D.prototype.createShadow = function(p, type, direction) {
  var style = this.state;
  /** @type {number} */
  var y = Math.PI / 180 * -style.rotation;
  /** @type {number} */
  var z = Math.cos(y);
  /** @type {number} */
  y = Math.sin(y);
  /** @type {number} */
  var tx = style.shadowDx * style.scale;
  /** @type {number} */
  var s = style.shadowDy * style.scale;
  if ("x" == this.root.style.flip) {
    /** @type {number} */
    tx = tx * -1;
  } else {
    if ("y" == this.root.style.flip) {
      /** @type {number} */
      s = s * -1;
    }
  }
  var node = p.cloneNode(true);
  /** @type {string} */
  node.style.marginLeft = Math.round(tx * z - s * y) + "px";
  /** @type {string} */
  node.style.marginTop = Math.round(tx * y + s * z) + "px";
  if (8 == document.documentMode) {
    node.strokeweight = p.strokeweight;
    if ("shape" == p.nodeName) {
      node.path = this.path.join(" ") + " e";
      node.style.width = this.root.style.width;
      node.style.height = this.root.style.height;
      /** @type {string} */
      node.coordsize = parseInt(p.style.width) + " " + parseInt(p.style.height);
    }
  }
  if (direction) {
    node.strokecolor = style.shadowColor;
    node.appendChild(this.createShadowStroke());
  } else {
    /** @type {string} */
    node.stroked = "false";
  }
  if (type) {
    node.appendChild(this.createShadowFill());
  } else {
    /** @type {string} */
    node.filled = "false";
  }
  return node;
};
/**
 * @return {?}
 */
mxVmlCanvas2D.prototype.createShadowFill = function() {
  var layer = this.createVmlElement("fill");
  layer.color = this.state.shadowColor;
  /** @type {string} */
  layer.opacity = this.state.alpha * this.state.shadowAlpha * 100 + "%";
  return layer;
};
/**
 * @return {?}
 */
mxVmlCanvas2D.prototype.createShadowStroke = function() {
  var stroke = this.createStroke();
  /** @type {string} */
  stroke.opacity = this.state.alpha * this.state.shadowAlpha * 100 + "%";
  return stroke;
};
/**
 * @param {number} delta
 * @param {boolean} b
 * @param {boolean} a
 * @param {number} cb
 * @param {number} err
 * @return {undefined}
 */
mxVmlCanvas2D.prototype.rotate = function(delta, b, a, cb, err) {
  if (b && a) {
    delta = delta + 180;
  } else {
    if (b) {
      /** @type {string} */
      this.root.style.flip = "x";
    } else {
      if (a) {
        /** @type {string} */
        this.root.style.flip = "y";
      }
    }
  }
  if (b ? !a : a) {
    /** @type {number} */
    delta = delta * -1;
  }
  /** @type {number} */
  this.root.style.rotation = delta;
  this.state.rotation += delta;
  /** @type {number} */
  this.state.rotationCx = cb;
  /** @type {number} */
  this.state.rotationCy = err;
};
/**
 * @return {undefined}
 */
mxVmlCanvas2D.prototype.begin = function() {
  mxAbstractCanvas2D.prototype.begin.apply(this, arguments);
  this.node = this.createVmlElement("shape");
  /** @type {string} */
  this.node.style.position = "absolute";
};
/**
 * @param {number} i
 * @param {number} v
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxVmlCanvas2D.prototype.quadTo = function(i, v, x, y) {
  var self = this.state;
  /** @type {number} */
  var currentLineStartIndex = (this.lastX + self.dx) * self.scale;
  /** @type {number} */
  var d = (this.lastY + self.dy) * self.scale;
  /** @type {number} */
  i = (i + self.dx) * self.scale;
  /** @type {number} */
  v = (v + self.dy) * self.scale;
  /** @type {number} */
  x = (x + self.dx) * self.scale;
  /** @type {number} */
  y = (y + self.dy) * self.scale;
  /** @type {number} */
  d = d + 2 / 3 * (v - d);
  /** @type {number} */
  var val = x + 2 / 3 * (i - x);
  /** @type {number} */
  v = y + 2 / 3 * (v - y);
  this.path.push("c " + this.format(currentLineStartIndex + 2 / 3 * (i - currentLineStartIndex)) + " " + this.format(d) + " " + this.format(val) + " " + this.format(v) + " " + this.format(x) + " " + this.format(y));
  /** @type {number} */
  this.lastX = x / self.scale - self.dx;
  /** @type {number} */
  this.lastY = y / self.scale - self.dy;
};
/**
 * @param {!Object} rect
 * @param {!Object} x
 * @param {!Object} y
 * @param {number} w
 * @param {number} h
 * @return {?}
 */
mxVmlCanvas2D.prototype.createRect = function(rect, x, y, w, h) {
  var s = this.state;
  rect = this.createVmlElement(rect);
  /** @type {string} */
  rect.style.position = "absolute";
  rect.style.left = this.format((x + s.dx) * s.scale) + "px";
  rect.style.top = this.format((y + s.dy) * s.scale) + "px";
  rect.style.width = this.format(w * s.scale) + "px";
  rect.style.height = this.format(h * s.scale) + "px";
  return rect;
};
/**
 * @param {number} y
 * @param {number} x
 * @param {number} c
 * @param {number} r
 * @return {undefined}
 */
mxVmlCanvas2D.prototype.rect = function(y, x, c, r) {
  this.node = this.createRect("rect", y, x, c, r);
};
/**
 * @param {?} x
 * @param {?} y
 * @param {number} a
 * @param {number} n
 * @param {number} g
 * @param {number} i
 * @return {undefined}
 */
mxVmlCanvas2D.prototype.roundrect = function(x, y, a, n, g, i) {
  this.node = this.createRect("roundrect", x, y, a, n);
  this.node.setAttribute("arcsize", Math.max(100 * g / a, 100 * i / n) + "%");
};
/**
 * @param {number} s
 * @param {number} width
 * @param {number} color
 * @param {number} x
 * @return {undefined}
 */
mxVmlCanvas2D.prototype.ellipse = function(s, width, color, x) {
  this.node = this.createRect("oval", s, width, color, x);
};
/**
 * @param {!Object} result
 * @param {!Object} data
 * @param {number} width
 * @param {number} height
 * @param {string} source
 * @param {string} name
 * @param {boolean} url
 * @param {boolean} type
 * @return {undefined}
 */
mxVmlCanvas2D.prototype.image = function(result, data, width, height, source, name, url, type) {
  if (name) {
    result = this.createRect("rect", result, data, width, height);
    /** @type {string} */
    result.stroked = "false";
    data = this.createVmlElement("fill");
    /** @type {string} */
    data.aspect = name ? "atmost" : "ignore";
    /** @type {string} */
    data.rotate = "true";
    /** @type {string} */
    data.type = "frame";
    /** @type {string} */
    data.src = source;
    result.appendChild(data);
  } else {
    result = this.createRect("image", result, data, width, height);
    /** @type {string} */
    result.src = source;
  }
  if (url && type) {
    /** @type {string} */
    result.style.rotation = "180";
  } else {
    if (url) {
      /** @type {string} */
      result.style.flip = "x";
    } else {
      if (type) {
        /** @type {string} */
        result.style.flip = "y";
      }
    }
  }
  if (1 > this.state.alpha || 1 > this.state.fillAlpha) {
    result.style.filter += "alpha(opacity=" + this.state.alpha * this.state.fillAlpha * 100 + ")";
  }
  this.root.appendChild(result);
};
/**
 * @param {!Object} style
 * @param {string} value
 * @param {!Object} node
 * @param {string} el
 * @return {?}
 */
mxVmlCanvas2D.prototype.createDiv = function(style, value, node, el) {
  node = this.createElement("div");
  var obj = this.state;
  /** @type {string} */
  var cssTextCollection = "";
  if (null != obj.fontBackgroundColor) {
    /** @type {string} */
    cssTextCollection = cssTextCollection + ("background-color:" + mxUtils.htmlEntities(obj.fontBackgroundColor) + ";");
  }
  if (null != obj.fontBorderColor) {
    /** @type {string} */
    cssTextCollection = cssTextCollection + ("border:1px solid " + mxUtils.htmlEntities(obj.fontBorderColor) + ";");
  }
  if (mxUtils.isNode(style)) {
    node.appendChild(style);
  } else {
    if ("fill" != el && "width" != el) {
      el = this.createElement("div");
      /** @type {string} */
      el.style.cssText = cssTextCollection;
      /** @type {string} */
      el.style.display = mxClient.IS_QUIRKS ? "inline" : "inline-block";
      /** @type {string} */
      el.style.zoom = "1";
      /** @type {string} */
      el.style.textDecoration = "inherit";
      /** @type {!Object} */
      el.innerHTML = style;
      node.appendChild(el);
    } else {
      /** @type {string} */
      node.style.cssText = cssTextCollection;
      /** @type {!Object} */
      node.innerHTML = style;
    }
  }
  style = node.style;
  /** @type {string} */
  style.fontSize = obj.fontSize / this.vmlScale + "px";
  style.fontFamily = obj.fontFamily;
  style.color = obj.fontColor;
  /** @type {string} */
  style.verticalAlign = "top";
  style.textAlign = value || "left";
  style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? obj.fontSize * mxConstants.LINE_HEIGHT / this.vmlScale + "px" : mxConstants.LINE_HEIGHT;
  if ((obj.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
    /** @type {string} */
    style.fontWeight = "bold";
  }
  if ((obj.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
    /** @type {string} */
    style.fontStyle = "italic";
  }
  if ((obj.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    /** @type {string} */
    style.textDecoration = "underline";
  }
  return node;
};
/**
 * @param {number} x
 * @param {number} y
 * @param {number} h
 * @param {number} w
 * @param {!Object} e
 * @param {!Object} node
 * @param {number} i
 * @param {number} p
 * @param {string} item
 * @param {string} parent
 * @param {string} val
 * @param {number} f
 * @param {number} r
 * @return {undefined}
 */
mxVmlCanvas2D.prototype.text = function(x, y, h, w, e, node, i, p, item, parent, val, f, r) {
  if (this.textEnabled && null != e) {
    var s = this.state;
    if ("html" == item) {
      if (null != s.rotation) {
        y = this.rotatePoint(x, y, s.rotation, s.rotationCx, s.rotationCy);
        x = y.x;
        y = y.y;
      }
      if (8 != document.documentMode || mxClient.IS_EM) {
        /** @type {number} */
        x = x * s.scale;
        /** @type {number} */
        y = y * s.scale;
      } else {
        x = x + s.dx;
        y = y + s.dy;
        if ("fill" != parent && i == mxConstants.ALIGN_TOP) {
          --y;
        }
      }
      item = 8 != document.documentMode || mxClient.IS_EM ? this.createElement("div") : this.createVmlElement("group");
      /** @type {string} */
      item.style.position = "absolute";
      /** @type {string} */
      item.style.display = "inline";
      item.style.left = this.format(x) + "px";
      item.style.top = this.format(y) + "px";
      item.style.zoom = s.scale;
      var t = this.createElement("div");
      /** @type {string} */
      t.style.position = "relative";
      /** @type {string} */
      t.style.display = "inline";
      var c = mxUtils.getAlignmentAsPoint(node, i);
      var width = c.x;
      c = c.y;
      e = this.createDiv(e, node, i, parent);
      node = this.createElement("div");
      if (null != r) {
        e.setAttribute("dir", r);
      }
      if (p && 0 < h) {
        if (val || (e.style.width = Math.round(h) + "px"), e.style.wordWrap = mxConstants.WORD_WRAP, e.style.whiteSpace = "normal", "break-word" == e.style.wordWrap) {
          /** @type {!Object} */
          var a = e;
          if (null != a.firstChild && "DIV" == a.firstChild.nodeName) {
            /** @type {string} */
            a.firstChild.style.width = "100%";
          }
        }
      } else {
        /** @type {string} */
        e.style.whiteSpace = "nowrap";
      }
      f = s.rotation + (f || 0);
      if (this.rotateHtml && 0 != f) {
        /** @type {string} */
        node.style.display = "inline";
        /** @type {string} */
        node.style.zoom = "1";
        node.appendChild(e);
        if (8 != document.documentMode || mxClient.IS_EM || "DIV" == this.root.nodeName) {
          item.appendChild(node);
        } else {
          t.appendChild(node);
          item.appendChild(t);
        }
      } else {
        if (8 != document.documentMode || mxClient.IS_EM) {
          /** @type {string} */
          e.style.display = "inline";
          item.appendChild(e);
        } else {
          t.appendChild(e);
          item.appendChild(t);
        }
      }
      if ("DIV" != this.root.nodeName) {
        r = this.createVmlElement("rect");
        /** @type {string} */
        r.stroked = "false";
        /** @type {string} */
        r.filled = "false";
        r.appendChild(item);
        this.root.appendChild(r);
      } else {
        this.root.appendChild(item);
      }
      if (val) {
        /** @type {string} */
        e.style.overflow = "hidden";
        /** @type {string} */
        e.style.width = Math.round(h) + "px";
        if (!mxClient.IS_QUIRKS) {
          /** @type {string} */
          e.style.maxHeight = Math.round(w) + "px";
        }
      } else {
        if ("fill" == parent) {
          /** @type {string} */
          e.style.overflow = "hidden";
          /** @type {string} */
          e.style.width = Math.max(0, h) + 1 + "px";
          /** @type {string} */
          e.style.height = Math.max(0, w) + 1 + "px";
        } else {
          if ("width" == parent) {
            /** @type {string} */
            e.style.overflow = "hidden";
            /** @type {string} */
            e.style.width = Math.max(0, h) + 1 + "px";
            /** @type {string} */
            e.style.maxHeight = Math.max(0, w) + 1 + "px";
          }
        }
      }
      if (this.rotateHtml && 0 != f) {
        /** @type {number} */
        a = Math.PI / 180 * f;
        /** @type {number} */
        f = parseFloat(parseFloat(Math.cos(a)).toFixed(8));
        /** @type {number} */
        r = parseFloat(parseFloat(Math.sin(-a)).toFixed(8));
        /** @type {number} */
        a = a % (2 * Math.PI);
        if (0 > a) {
          /** @type {number} */
          a = a + 2 * Math.PI;
        }
        /** @type {number} */
        a = a % Math.PI;
        if (a > Math.PI / 2) {
          /** @type {number} */
          a = Math.PI - a;
        }
        /** @type {number} */
        i = Math.cos(a);
        /** @type {number} */
        var sine = Math.sin(a);
        if (!(8 != document.documentMode || mxClient.IS_EM)) {
          /** @type {string} */
          e.style.display = "inline-block";
          /** @type {string} */
          node.style.display = "inline-block";
          /** @type {string} */
          t.style.display = "inline-block";
        }
        /** @type {string} */
        e.style.visibility = "hidden";
        /** @type {string} */
        e.style.position = "absolute";
        document.body.appendChild(e);
        /** @type {!Object} */
        t = e;
        if (null != t.firstChild && "DIV" == t.firstChild.nodeName) {
          t = t.firstChild;
        }
        a = t.offsetWidth + 3;
        t = t.offsetHeight;
        if (val) {
          /** @type {number} */
          h = Math.min(h, a);
          /** @type {number} */
          t = Math.min(t, w);
        } else {
          h = a;
        }
        if (p) {
          /** @type {string} */
          e.style.width = h + "px";
        }
        if (mxClient.IS_QUIRKS && (val || "width" == parent) && t > w) {
          /** @type {number} */
          t = w;
          /** @type {string} */
          e.style.height = t + "px";
        }
        w = t;
        /** @type {number} */
        val = (w - w * i + h * -sine) / 2 - r * h * (width + .5) + f * w * (c + .5);
        /** @type {number} */
        p = (h - h * i + w * -sine) / 2 + f * h * (width + .5) + r * w * (c + .5);
        if ("group" == item.nodeName && "DIV" == this.root.nodeName) {
          parent = this.createElement("div");
          /** @type {string} */
          parent.style.display = "inline-block";
          /** @type {string} */
          parent.style.position = "absolute";
          parent.style.left = this.format(x + (p - h / 2) * s.scale) + "px";
          parent.style.top = this.format(y + (val - w / 2) * s.scale) + "px";
          item.parentNode.appendChild(parent);
          parent.appendChild(item);
        } else {
          s = 8 != document.documentMode || mxClient.IS_EM ? s.scale : 1;
          item.style.left = this.format(x + (p - h / 2) * s) + "px";
          item.style.top = this.format(y + (val - w / 2) * s) + "px";
        }
        /** @type {string} */
        node.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11=" + f + ", M12=" + r + ", M21=" + -r + ", M22=" + f + ", sizingMethod='auto expand')";
        node.style.backgroundColor = this.rotatedHtmlBackground;
        if (1 > this.state.alpha) {
          node.style.filter += "alpha(opacity=" + 100 * this.state.alpha + ")";
        }
        node.appendChild(e);
        /** @type {string} */
        e.style.position = "";
        /** @type {string} */
        e.style.visibility = "";
      } else {
        if (8 != document.documentMode || mxClient.IS_EM) {
          /** @type {string} */
          e.style.verticalAlign = "top";
          if (1 > this.state.alpha) {
            /** @type {string} */
            item.style.filter = "alpha(opacity=" + 100 * this.state.alpha + ")";
          }
          s = e.parentNode;
          /** @type {string} */
          e.style.visibility = "hidden";
          document.body.appendChild(e);
          h = e.offsetWidth;
          t = e.offsetHeight;
          if (mxClient.IS_QUIRKS && val && t > w) {
            /** @type {number} */
            t = w;
            /** @type {string} */
            e.style.height = t + "px";
          }
          w = t;
          /** @type {string} */
          e.style.visibility = "";
          s.appendChild(e);
          item.style.left = this.format(x + h * width * this.state.scale) + "px";
          item.style.top = this.format(y + w * c * this.state.scale) + "px";
        } else {
          if (1 > this.state.alpha) {
            /** @type {string} */
            e.style.filter = "alpha(opacity=" + 100 * this.state.alpha + ")";
          }
          /** @type {string} */
          t.style.left = 100 * width + "%";
          /** @type {string} */
          t.style.top = 100 * c + "%";
        }
      }
    } else {
      this.plainText(x, y, h, w, mxUtils.htmlEntities(e, false), node, i, p, item, parent, val, f, r);
    }
  }
};
/**
 * @param {number} x
 * @param {number} y
 * @param {!Object} node
 * @param {!Object} element
 * @param {number} text
 * @param {number} value
 * @param {number} o
 * @param {!Object} options
 * @param {string} user
 * @param {!Object} content
 * @param {!Object} el
 * @param {number} v
 * @param {number} s
 * @return {undefined}
 */
mxVmlCanvas2D.prototype.plainText = function(x, y, node, element, text, value, o, options, user, content, el, v, s) {
  options = this.state;
  /** @type {number} */
  x = (x + options.dx) * options.scale;
  /** @type {number} */
  y = (y + options.dy) * options.scale;
  node = this.createVmlElement("shape");
  /** @type {string} */
  node.style.width = "1px";
  /** @type {string} */
  node.style.height = "1px";
  /** @type {string} */
  node.stroked = "false";
  element = this.createVmlElement("fill");
  element.color = options.fontColor;
  /** @type {string} */
  element.opacity = 100 * options.alpha + "%";
  node.appendChild(element);
  element = this.createVmlElement("path");
  /** @type {string} */
  element.textpathok = "true";
  element.v = "m " + this.format(0) + " " + this.format(0) + " l " + this.format(1) + " " + this.format(0);
  node.appendChild(element);
  element = this.createVmlElement("textpath");
  /** @type {string} */
  element.style.cssText = "v-text-align:" + value;
  /** @type {number} */
  element.style.align = value;
  element.style.fontFamily = options.fontFamily;
  /** @type {number} */
  element.string = text;
  /** @type {string} */
  element.on = "true";
  /** @type {number} */
  value = options.fontSize * options.scale / this.vmlScale;
  /** @type {string} */
  element.style.fontSize = value + "px";
  if ((options.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
    /** @type {string} */
    element.style.fontWeight = "bold";
  }
  if ((options.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
    /** @type {string} */
    element.style.fontStyle = "italic";
  }
  if ((options.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    /** @type {string} */
    element.style.textDecoration = "underline";
  }
  text = text.split("\n");
  /** @type {number} */
  options = value + (text.length - 1) * value * mxConstants.LINE_HEIGHT;
  /** @type {number} */
  value = text = 0;
  if (o == mxConstants.ALIGN_BOTTOM) {
    /** @type {number} */
    value = -options / 2;
  } else {
    if (o != mxConstants.ALIGN_MIDDLE) {
      /** @type {number} */
      value = options / 2;
    }
  }
  if (null != v) {
    /** @type {number} */
    node.style.rotation = v;
    /** @type {number} */
    o = Math.PI / 180 * v;
    /** @type {number} */
    text = Math.sin(o) * value;
    /** @type {number} */
    value = value * Math.cos(o);
  }
  node.appendChild(element);
  node.style.left = this.format(x - text) + "px";
  node.style.top = this.format(y + value) + "px";
  this.root.appendChild(node);
};
/**
 * @return {undefined}
 */
mxVmlCanvas2D.prototype.stroke = function() {
  this.addNode(false, true);
};
/**
 * @return {undefined}
 */
mxVmlCanvas2D.prototype.fill = function() {
  this.addNode(true, false);
};
/**
 * @return {undefined}
 */
mxVmlCanvas2D.prototype.fillAndStroke = function() {
  this.addNode(true, true);
};
/**
 * @param {!Object} src
 * @param {!Object} out
 * @return {undefined}
 */
function mxGuide(src, out) {
  /** @type {!Object} */
  this.graph = src;
  this.setStates(out);
}
/** @type {null} */
mxGuide.prototype.graph = null;
/** @type {null} */
mxGuide.prototype.states = null;
/** @type {boolean} */
mxGuide.prototype.horizontal = true;
/** @type {boolean} */
mxGuide.prototype.vertical = true;
/** @type {null} */
mxGuide.prototype.guideX = null;
/** @type {null} */
mxGuide.prototype.guideY = null;
/** @type {boolean} */
mxGuide.prototype.rounded = false;
/** @type {number} */
mxGuide.prototype.tolerance = 2;
/**
 * @param {!Object} states
 * @return {undefined}
 */
mxGuide.prototype.setStates = function(states) {
  /** @type {!Object} */
  this.states = states;
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxGuide.prototype.isEnabledForEvent = function(evt) {
  return true;
};
/**
 * @param {number} n22
 * @return {?}
 */
mxGuide.prototype.getGuideTolerance = function(n22) {
  return n22 && this.graph.gridEnabled ? this.graph.gridSize / 2 : this.tolerance;
};
/**
 * @param {string} isIron
 * @return {?}
 */
mxGuide.prototype.createGuideShape = function(isIron) {
  isIron = new mxPolyline([], mxConstants.GUIDE_COLOR, mxConstants.GUIDE_STROKEWIDTH);
  /** @type {boolean} */
  isIron.isDashed = true;
  return isIron;
};
/**
 * @param {!Object} tag
 * @return {?}
 */
mxGuide.prototype.isStateIgnored = function(tag) {
  return false;
};
/**
 * @param {?} s
 * @param {!Object} data
 * @param {!Object} c
 * @param {!Object} next
 * @return {?}
 */
mxGuide.prototype.move = function(s, data, c, next) {
  if (null != this.states && (this.horizontal || this.vertical) && null != s && null != data) {
    /**
     * @param {number} y
     * @param {!Object} delay
     * @param {boolean} retry
     * @return {undefined}
     */
    next = function(y, delay, retry) {
      /** @type {boolean} */
      var localModuleProblems = false;
      if (retry && Math.abs(y - heightVal) < deltaScale) {
        /** @type {number} */
        data.y = y - s.getCenterY();
        /** @type {number} */
        deltaScale = Math.abs(y - heightVal);
        /** @type {boolean} */
        localModuleProblems = true;
      } else {
        if (!retry) {
          if (Math.abs(y - yZero) < deltaScale) {
            /** @type {number} */
            data.y = y - s.y;
            /** @type {number} */
            deltaScale = Math.abs(y - yZero);
            /** @type {boolean} */
            localModuleProblems = true;
          } else {
            if (Math.abs(y - yR) < deltaScale) {
              /** @type {number} */
              data.y = y - s.y - s.height;
              /** @type {number} */
              deltaScale = Math.abs(y - yR);
              /** @type {boolean} */
              localModuleProblems = true;
            }
          }
        }
      }
      if (localModuleProblems) {
        /** @type {!Object} */
        d = delay;
        /** @type {number} */
        bottom = y;
        if (null == this.guideY) {
          this.guideY = this.createGuideShape(false);
          this.guideY.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
          /** @type {boolean} */
          this.guideY.pointerEvents = false;
          this.guideY.init(this.graph.getView().getOverlayPane());
        }
      }
      localProblems = localProblems || localModuleProblems;
    };
    /**
     * @param {number} x
     * @param {!Object} type
     * @param {boolean} extraAttr
     * @return {undefined}
     */
    var init = function(x, type, extraAttr) {
      /** @type {boolean} */
      var nullFunc = false;
      if (extraAttr && Math.abs(x - sleft) < prevScale) {
        /** @type {number} */
        data.x = x - s.getCenterX();
        /** @type {number} */
        prevScale = Math.abs(x - sleft);
        /** @type {boolean} */
        nullFunc = true;
      } else {
        if (!extraAttr) {
          if (Math.abs(x - intX) < prevScale) {
            /** @type {number} */
            data.x = x - s.x;
            /** @type {number} */
            prevScale = Math.abs(x - intX);
            /** @type {boolean} */
            nullFunc = true;
          } else {
            if (Math.abs(x - oriX) < prevScale) {
              /** @type {number} */
              data.x = x - s.x - s.width;
              /** @type {number} */
              prevScale = Math.abs(x - oriX);
              /** @type {boolean} */
              nullFunc = true;
            }
          }
        }
      }
      if (nullFunc) {
        /** @type {!Object} */
        config = type;
        /** @type {number} */
        right = x;
        if (null == this.guideX) {
          this.guideX = this.createGuideShape(true);
          this.guideX.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
          /** @type {boolean} */
          this.guideX.pointerEvents = false;
          this.guideX.init(this.graph.getView().getOverlayPane());
        }
      }
      callback = callback || nullFunc;
    };
    var scale = this.graph.getView().scale;
    /** @type {number} */
    scale = this.getGuideTolerance(c) * scale;
    var self = s.clone();
    self.x += data.x;
    self.y += data.y;
    /** @type {boolean} */
    var callback = false;
    /** @type {null} */
    var config = null;
    /** @type {null} */
    var right = null;
    /** @type {boolean} */
    var localProblems = false;
    /** @type {null} */
    var d = null;
    /** @type {null} */
    var bottom = null;
    /** @type {number} */
    var prevScale = scale;
    /** @type {number} */
    var deltaScale = scale;
    var intX = self.x;
    var oriX = self.x + self.width;
    var sleft = self.getCenterX();
    var yZero = self.y;
    var yR = self.y + self.height;
    var heightVal = self.getCenterY();
    /** @type {number} */
    scale = 0;
    for (; scale < this.states.length; scale++) {
      self = this.states[scale];
      if (!(null == self || this.isStateIgnored(self))) {
        if (this.horizontal) {
          init.call(this, self.getCenterX(), self, true);
          init.call(this, self.x, self, false);
          init.call(this, self.x + self.width, self, false);
          if (null == self.cell) {
            init.call(this, self.getCenterX(), self, false);
          }
        }
        if (this.vertical) {
          next.call(this, self.getCenterY(), self, true);
          next.call(this, self.y, self, false);
          next.call(this, self.y + self.height, self, false);
          if (null == self.cell) {
            next.call(this, self.getCenterY(), self, false);
          }
        }
      }
    }
    this.graph.snapDelta(data, s, !c, callback, localProblems);
    data = this.getDelta(s, config, data.x, d, data.y);
    c = this.graph.container;
    if (callback || null == this.guideX) {
      if (null != this.guideX) {
        /** @type {null} */
        init = next = null;
        if (null != config && null != s) {
          /** @type {number} */
          next = Math.min(s.y + data.y - this.graph.panDy, config.y);
          /** @type {number} */
          init = Math.max(s.y + s.height + data.y - this.graph.panDy, config.y + config.height);
        }
        /** @type {!Array} */
        this.guideX.points = null != next && null != init ? [new mxPoint(right, next), new mxPoint(right, init)] : [new mxPoint(right, -this.graph.panDy), new mxPoint(right, c.scrollHeight - 3 - this.graph.panDy)];
        this.guideX.stroke = this.getGuideColor(config, true);
        /** @type {string} */
        this.guideX.node.style.visibility = "visible";
        this.guideX.redraw();
      }
    } else {
      /** @type {string} */
      this.guideX.node.style.visibility = "hidden";
    }
    if (localProblems || null == this.guideY) {
      if (null != this.guideY) {
        /** @type {null} */
        init = next = null;
        if (null != d && null != s) {
          /** @type {number} */
          next = Math.min(s.x + data.x - this.graph.panDx, d.x);
          /** @type {number} */
          init = Math.max(s.x + s.width + data.x - this.graph.panDx, d.x + d.width);
        }
        /** @type {!Array} */
        this.guideY.points = null != next && null != init ? [new mxPoint(next, bottom), new mxPoint(init, bottom)] : [new mxPoint(-this.graph.panDx, bottom), new mxPoint(c.scrollWidth - 3 - this.graph.panDx, bottom)];
        this.guideY.stroke = this.getGuideColor(d, false);
        /** @type {string} */
        this.guideY.node.style.visibility = "visible";
        this.guideY.redraw();
      }
    } else {
      /** @type {string} */
      this.guideY.node.style.visibility = "hidden";
    }
  }
  return data;
};
/**
 * @param {!Object} path
 * @param {?} o
 * @param {number} n
 * @param {?} event
 * @param {number} diff
 * @return {?}
 */
mxGuide.prototype.getDelta = function(path, o, n, event, diff) {
  var ratio = this.graph.view.scale;
  if (this.rounded || null != o && null == o.cell) {
    /** @type {number} */
    n = Math.round((path.x + n) / ratio) * ratio - path.x;
  }
  if (this.rounded || null != event && null == event.cell) {
    /** @type {number} */
    diff = Math.round((path.y + diff) / ratio) * ratio - path.y;
  }
  return new mxPoint(n, diff);
};
/**
 * @param {?} a
 * @param {boolean} be
 * @return {?}
 */
mxGuide.prototype.getGuideColor = function(a, be) {
  return mxConstants.GUIDE_COLOR;
};
/**
 * @return {undefined}
 */
mxGuide.prototype.hide = function() {
  this.setVisible(false);
};
/**
 * @param {boolean} visible
 * @return {undefined}
 */
mxGuide.prototype.setVisible = function(visible) {
  if (null != this.guideX) {
    /** @type {string} */
    this.guideX.node.style.visibility = visible ? "visible" : "hidden";
  }
  if (null != this.guideY) {
    /** @type {string} */
    this.guideY.node.style.visibility = visible ? "visible" : "hidden";
  }
};
/**
 * @return {undefined}
 */
mxGuide.prototype.destroy = function() {
  if (null != this.guideX) {
    this.guideX.destroy();
    /** @type {null} */
    this.guideX = null;
  }
  if (null != this.guideY) {
    this.guideY.destroy();
    /** @type {null} */
    this.guideY = null;
  }
};
/**
 * @param {!Object} enable
 * @return {undefined}
 */
function mxShape(enable) {
  /** @type {!Object} */
  this.stencil = enable;
  this.initStyles();
}
/** @type {null} */
mxShape.prototype.dialect = null;
/** @type {number} */
mxShape.prototype.scale = 1;
/** @type {boolean} */
mxShape.prototype.antiAlias = true;
/** @type {number} */
mxShape.prototype.minSvgStrokeWidth = 1;
/** @type {null} */
mxShape.prototype.bounds = null;
/** @type {null} */
mxShape.prototype.points = null;
/** @type {null} */
mxShape.prototype.node = null;
/** @type {null} */
mxShape.prototype.state = null;
/** @type {null} */
mxShape.prototype.style = null;
/** @type {null} */
mxShape.prototype.boundingBox = null;
/** @type {null} */
mxShape.prototype.stencil = null;
/** @type {number} */
mxShape.prototype.svgStrokeTolerance = 8;
/** @type {boolean} */
mxShape.prototype.pointerEvents = true;
/** @type {string} */
mxShape.prototype.svgPointerEvents = "all";
/** @type {boolean} */
mxShape.prototype.shapePointerEvents = false;
/** @type {boolean} */
mxShape.prototype.stencilPointerEvents = false;
/** @type {number} */
mxShape.prototype.vmlScale = 1;
/** @type {boolean} */
mxShape.prototype.outline = false;
/** @type {boolean} */
mxShape.prototype.visible = true;
/** @type {boolean} */
mxShape.prototype.useSvgBoundingBox = false;
/**
 * @param {!Object} target
 * @return {undefined}
 */
mxShape.prototype.init = function(target) {
  if (null == this.node) {
    this.node = this.create(target);
    if (null != target) {
      target.appendChild(this.node);
    }
  }
};
/**
 * @param {?} value
 * @return {undefined}
 */
mxShape.prototype.initStyles = function(value) {
  /** @type {number} */
  this.strokewidth = 1;
  /** @type {number} */
  this.rotation = 0;
  /** @type {number} */
  this.strokeOpacity = this.fillOpacity = this.opacity = 100;
  /** @type {boolean} */
  this.flipV = this.flipH = false;
};
/**
 * @return {?}
 */
mxShape.prototype.isParseVml = function() {
  return true;
};
/**
 * @return {?}
 */
mxShape.prototype.isHtmlAllowed = function() {
  return false;
};
/**
 * @return {?}
 */
mxShape.prototype.getSvgScreenOffset = function() {
  return 1 == mxUtils.mod(Math.max(1, Math.round((this.stencil && "inherit" != this.stencil.strokewidth ? Number(this.stencil.strokewidth) : this.strokewidth) * this.scale)), 2) ? .5 : 0;
};
/**
 * @param {!Object} obj
 * @return {?}
 */
mxShape.prototype.create = function(obj) {
  return null != obj && null != obj.ownerSVGElement ? this.createSvg(obj) : 8 == document.documentMode || !mxClient.IS_VML || this.dialect != mxConstants.DIALECT_VML && this.isHtmlAllowed() ? this.createHtml(obj) : this.createVml(obj);
};
/**
 * @return {?}
 */
mxShape.prototype.createSvg = function() {
  return document.createElementNS(mxConstants.NS_SVG, "g");
};
/**
 * @return {?}
 */
mxShape.prototype.createVml = function() {
  /** @type {!Element} */
  var node = document.createElement(mxClient.VML_PREFIX + ":group");
  /** @type {string} */
  node.style.position = "absolute";
  return node;
};
/**
 * @return {?}
 */
mxShape.prototype.createHtml = function() {
  /** @type {!Element} */
  var b = document.createElement("div");
  /** @type {string} */
  b.style.position = "absolute";
  return b;
};
/**
 * @return {undefined}
 */
mxShape.prototype.reconfigure = function() {
  this.redraw();
};
/**
 * @return {undefined}
 */
mxShape.prototype.redraw = function() {
  this.updateBoundsFromPoints();
  if (this.visible && this.checkBounds()) {
    /** @type {string} */
    this.node.style.visibility = "visible";
    this.clear();
    if ("DIV" != this.node.nodeName || !this.isHtmlAllowed() && mxClient.IS_VML) {
      this.redrawShape();
    } else {
      this.redrawHtmlShape();
    }
    this.updateBoundingBox();
  } else {
    /** @type {string} */
    this.node.style.visibility = "hidden";
    /** @type {null} */
    this.boundingBox = null;
  }
};
/**
 * @return {undefined}
 */
mxShape.prototype.clear = function() {
  if (null != this.node.ownerSVGElement) {
    for (; null != this.node.lastChild;) {
      this.node.removeChild(this.node.lastChild);
    }
  } else {
    /** @type {string} */
    this.node.style.cssText = "position:absolute;" + (null != this.cursor ? "cursor:" + this.cursor + ";" : "");
    /** @type {string} */
    this.node.innerHTML = "";
  }
};
/**
 * @return {undefined}
 */
mxShape.prototype.updateBoundsFromPoints = function() {
  var points = this.points;
  if (null != points && 0 < points.length && null != points[0]) {
    this.bounds = new mxRectangle(Number(points[0].x), Number(points[0].y), 1, 1);
    /** @type {number} */
    var i = 1;
    for (; i < this.points.length; i++) {
      if (null != points[i]) {
        this.bounds.add(new mxRectangle(Number(points[i].x), Number(points[i].y), 1, 1));
      }
    }
  }
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxShape.prototype.getLabelBounds = function(value) {
  var r = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
  /** @type {!Object} */
  var c = value;
  if (r != mxConstants.DIRECTION_SOUTH && r != mxConstants.DIRECTION_NORTH && null != this.state && null != this.state.text && this.state.text.isPaintBoundsInverted()) {
    c = c.clone();
    r = c.width;
    c.width = c.height;
    c.height = r;
  }
  c = this.getLabelMargins(c);
  if (null != c) {
    /** @type {boolean} */
    var root = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, false);
    /** @type {boolean} */
    var rootNode = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, false);
    if (null != this.state && null != this.state.text && this.state.text.isPaintBoundsInverted()) {
      r = c.x;
      c.x = c.height;
      c.height = c.width;
      c.width = c.y;
      c.y = r;
      /** @type {boolean} */
      r = root;
      /** @type {boolean} */
      root = rootNode;
      /** @type {boolean} */
      rootNode = r;
    }
    return mxUtils.getDirectedBounds(value, c, this.style, root, rootNode);
  }
  return value;
};
/**
 * @param {?} n22
 * @return {?}
 */
mxShape.prototype.getLabelMargins = function(n22) {
  return null;
};
/**
 * @return {?}
 */
mxShape.prototype.checkBounds = function() {
  return !isNaN(this.scale) && isFinite(this.scale) && 0 < this.scale && null != this.bounds && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height) && 0 < this.bounds.width && 0 < this.bounds.height;
};
/**
 * @return {?}
 */
mxShape.prototype.createVmlGroup = function() {
  /** @type {!Element} */
  var dataTick = document.createElement(mxClient.VML_PREFIX + ":group");
  /** @type {string} */
  dataTick.style.position = "absolute";
  dataTick.style.width = this.node.style.width;
  dataTick.style.height = this.node.style.height;
  return dataTick;
};
/**
 * @return {undefined}
 */
mxShape.prototype.redrawShape = function() {
  var data = this.createCanvas();
  if (null != data) {
    data.pointerEvents = this.pointerEvents;
    this.beforePaint(data);
    this.paint(data);
    this.afterPaint(data);
    if (this.node != data.root) {
      this.node.insertAdjacentHTML("beforeend", data.root.outerHTML);
    }
    if ("DIV" == this.node.nodeName && 8 == document.documentMode) {
      /** @type {string} */
      this.node.style.filter = "";
      mxUtils.addTransparentBackgroundFilter(this.node);
    }
    this.destroyCanvas(data);
  }
};
/**
 * @return {?}
 */
mxShape.prototype.createCanvas = function() {
  /** @type {null} */
  var ctx = null;
  if (null != this.node.ownerSVGElement) {
    ctx = this.createSvgCanvas();
  } else {
    if (mxClient.IS_VML) {
      this.updateVmlContainer();
      ctx = this.createVmlCanvas();
    }
  }
  if (null != ctx && this.outline) {
    ctx.setStrokeWidth(this.strokewidth);
    ctx.setStrokeColor(this.stroke);
    if (null != this.isDashed) {
      ctx.setDashed(this.isDashed);
    }
    /**
     * @return {undefined}
     */
    ctx.setStrokeWidth = function() {
    };
    /**
     * @return {undefined}
     */
    ctx.setStrokeColor = function() {
    };
    /**
     * @return {undefined}
     */
    ctx.setFillColor = function() {
    };
    /**
     * @return {undefined}
     */
    ctx.setGradient = function() {
    };
    /**
     * @return {undefined}
     */
    ctx.setDashed = function() {
    };
    /**
     * @return {undefined}
     */
    ctx.text = function() {
    };
  }
  return ctx;
};
/**
 * @return {?}
 */
mxShape.prototype.createSvgCanvas = function() {
  var utils = new mxSvgCanvas2D(this.node, false);
  utils.strokeTolerance = this.pointerEvents ? this.svgStrokeTolerance : 0;
  utils.pointerEventsValue = this.svgPointerEvents;
  var b = this.getSvgScreenOffset();
  if (0 != b) {
    this.node.setAttribute("transform", "translate(" + b + "," + b + ")");
  } else {
    this.node.removeAttribute("transform");
  }
  utils.minStrokeWidth = this.minSvgStrokeWidth;
  if (!this.antiAlias) {
    /**
     * @param {number} str
     * @return {?}
     */
    utils.format = function(str) {
      return Math.round(parseFloat(str));
    };
  }
  return utils;
};
/**
 * @return {?}
 */
mxShape.prototype.createVmlCanvas = function() {
  var scale = 8 == document.documentMode && this.isParseVml() ? this.createVmlGroup() : this.node;
  var transform = new mxVmlCanvas2D(scale, false);
  if ("" != scale.tagUrn) {
    /** @type {string} */
    scale.coordsize = Math.max(1, Math.round(this.bounds.width)) * this.vmlScale + "," + Math.max(1, Math.round(this.bounds.height)) * this.vmlScale;
    transform.scale(this.vmlScale);
    transform.vmlScale = this.vmlScale;
  }
  scale = this.scale;
  transform.translate(-Math.round(this.bounds.x / scale), -Math.round(this.bounds.y / scale));
  return transform;
};
/**
 * @return {undefined}
 */
mxShape.prototype.updateVmlContainer = function() {
  /** @type {string} */
  this.node.style.left = Math.round(this.bounds.x) + "px";
  /** @type {string} */
  this.node.style.top = Math.round(this.bounds.y) + "px";
  /** @type {number} */
  var bg_h = Math.max(1, Math.round(this.bounds.height));
  /** @type {string} */
  this.node.style.width = Math.max(1, Math.round(this.bounds.width)) + "px";
  /** @type {string} */
  this.node.style.height = bg_h + "px";
  /** @type {string} */
  this.node.style.overflow = "visible";
};
/**
 * @return {undefined}
 */
mxShape.prototype.redrawHtmlShape = function() {
  this.updateHtmlBounds(this.node);
  this.updateHtmlFilters(this.node);
  this.updateHtmlColors(this.node);
};
/**
 * @param {!Element} a
 * @return {undefined}
 */
mxShape.prototype.updateHtmlFilters = function(a) {
  /** @type {string} */
  var style = "";
  if (100 > this.opacity) {
    /** @type {string} */
    style = style + ("alpha(opacity=" + this.opacity + ")");
  }
  if (this.isShadow) {
    /** @type {string} */
    style = style + ("progid:DXImageTransform.Microsoft.dropShadow (OffX='" + Math.round(mxConstants.SHADOW_OFFSET_X * this.scale) + "', OffY='" + Math.round(mxConstants.SHADOW_OFFSET_Y * this.scale) + "', Color='" + mxConstants.VML_SHADOWCOLOR + "')");
  }
  if (null != this.fill && this.fill != mxConstants.NONE && this.gradient && this.gradient != mxConstants.NONE) {
    var Infinity = this.fill;
    var gradient = this.gradient;
    /** @type {string} */
    var e = "0";
    var bounds = {
      east : 0,
      south : 1,
      west : 2,
      north : 3
    };
    var minX = null != this.direction ? bounds[this.direction] : 0;
    if (null != this.gradientDirection) {
      minX = mxUtils.mod(minX + bounds[this.gradientDirection] - 1, 4);
    }
    if (1 == minX) {
      /** @type {string} */
      e = "1";
      bounds = Infinity;
      Infinity = gradient;
      gradient = bounds;
    } else {
      if (2 == minX) {
        bounds = Infinity;
        Infinity = gradient;
        gradient = bounds;
      } else {
        if (3 == minX) {
          /** @type {string} */
          e = "1";
        }
      }
    }
    /** @type {string} */
    style = style + ("progid:DXImageTransform.Microsoft.gradient(startColorStr='" + Infinity + "', endColorStr='" + gradient + "', gradientType='" + e + "')");
  }
  /** @type {string} */
  a.style.filter = style;
};
/**
 * @param {!Element} e
 * @return {undefined}
 */
mxShape.prototype.updateHtmlColors = function(e) {
  var value = this.stroke;
  if (null != value && value != mxConstants.NONE) {
    e.style.borderColor = value;
    if (this.isDashed) {
      /** @type {string} */
      e.style.borderStyle = "dashed";
    } else {
      if (0 < this.strokewidth) {
        /** @type {string} */
        e.style.borderStyle = "solid";
      }
    }
    /** @type {string} */
    e.style.borderWidth = Math.max(1, Math.ceil(this.strokewidth * this.scale)) + "px";
  } else {
    /** @type {string} */
    e.style.borderWidth = "0px";
  }
  value = this.outline ? null : this.fill;
  if (null != value && value != mxConstants.NONE) {
    e.style.backgroundColor = value;
    /** @type {string} */
    e.style.backgroundImage = "none";
  } else {
    if (this.pointerEvents) {
      /** @type {string} */
      e.style.backgroundColor = "transparent";
    } else {
      if (8 == document.documentMode) {
        mxUtils.addTransparentBackgroundFilter(e);
      } else {
        this.setTransparentBackgroundImage(e);
      }
    }
  }
};
/**
 * @param {!Element} div
 * @return {undefined}
 */
mxShape.prototype.updateHtmlBounds = function(div) {
  /** @type {number} */
  var radius = 9 <= document.documentMode ? 0 : Math.ceil(this.strokewidth * this.scale);
  /** @type {string} */
  div.style.borderWidth = Math.max(1, radius) + "px";
  /** @type {string} */
  div.style.overflow = "hidden";
  /** @type {string} */
  div.style.left = Math.round(this.bounds.x - radius / 2) + "px";
  /** @type {string} */
  div.style.top = Math.round(this.bounds.y - radius / 2) + "px";
  if ("CSS1Compat" == document.compatMode) {
    /** @type {number} */
    radius = -radius;
  }
  /** @type {string} */
  div.style.width = Math.round(Math.max(0, this.bounds.width + radius)) + "px";
  /** @type {string} */
  div.style.height = Math.round(Math.max(0, this.bounds.height + radius)) + "px";
};
/**
 * @param {!AudioNode} data
 * @return {undefined}
 */
mxShape.prototype.destroyCanvas = function(data) {
  if (data instanceof mxSvgCanvas2D) {
    var i;
    for (i in data.gradients) {
      var beforeTab = data.gradients[i];
      if (null != beforeTab) {
        beforeTab.mxRefCount = (beforeTab.mxRefCount || 0) + 1;
      }
    }
    this.releaseSvgGradients(this.oldGradients);
    this.oldGradients = data.gradients;
  }
};
/**
 * @param {!Object} s
 * @return {undefined}
 */
mxShape.prototype.beforePaint = function(s) {
};
/**
 * @param {!Object} s
 * @return {undefined}
 */
mxShape.prototype.afterPaint = function(s) {
};
/**
 * @param {!Object} ctx
 * @return {undefined}
 */
mxShape.prototype.paint = function(ctx) {
  /** @type {boolean} */
  var i = false;
  if (null != ctx && this.outline) {
    var renderer = ctx.stroke;
    /**
     * @return {undefined}
     */
    ctx.stroke = function() {
      /** @type {boolean} */
      i = true;
      renderer.apply(this, arguments);
    };
    var parent = ctx.fillAndStroke;
    /**
     * @return {undefined}
     */
    ctx.fillAndStroke = function() {
      /** @type {boolean} */
      i = true;
      parent.apply(this, arguments);
    };
  }
  var scale = this.scale;
  /** @type {number} */
  var r = this.bounds.x / scale;
  /** @type {number} */
  var b = this.bounds.y / scale;
  /** @type {number} */
  var h = this.bounds.width / scale;
  /** @type {number} */
  var x = this.bounds.height / scale;
  if (this.isPaintBoundsInverted()) {
    /** @type {number} */
    var e = (h - x) / 2;
    /** @type {number} */
    r = r + e;
    /** @type {number} */
    b = b - e;
    /** @type {number} */
    e = h;
    /** @type {number} */
    h = x;
    /** @type {number} */
    x = e;
  }
  this.updateTransform(ctx, r, b, h, x);
  this.configureCanvas(ctx, r, b, h, x);
  /** @type {null} */
  e = null;
  if (null == this.stencil && null == this.points && this.shapePointerEvents || null != this.stencil && this.stencilPointerEvents) {
    var o = this.createBoundingBox();
    if (this.dialect == mxConstants.DIALECT_SVG) {
      e = this.createTransparentSvgRectangle(o.x, o.y, o.width, o.height);
      this.node.appendChild(e);
    } else {
      o = ctx.createRect("rect", o.x / scale, o.y / scale, o.width / scale, o.height / scale);
      o.appendChild(ctx.createTransparentFill());
      /** @type {string} */
      o.stroked = "false";
      ctx.root.appendChild(o);
    }
  }
  if (null != this.stencil) {
    this.stencil.drawShape(ctx, this, r, b, h, x);
  } else {
    if (ctx.setStrokeWidth(this.strokewidth), null != this.points) {
      /** @type {!Array} */
      o = [];
      /** @type {number} */
      var i = 0;
      for (; i < this.points.length; i++) {
        if (null != this.points[i]) {
          o.push(new mxPoint(this.points[i].x / scale, this.points[i].y / scale));
        }
      }
      this.paintEdgeShape(ctx, o);
    } else {
      this.paintVertexShape(ctx, r, b, h, x);
    }
  }
  if (null != e && null != ctx.state && null != ctx.state.transform) {
    e.setAttribute("transform", ctx.state.transform);
  }
  if (null != ctx && this.outline && !i) {
    ctx.rect(r, b, h, x);
    ctx.stroke();
  }
};
/**
 * @param {!Object} ctx
 * @param {number} data
 * @param {number} props
 * @param {number} options
 * @param {!Function} h
 * @return {undefined}
 */
mxShape.prototype.configureCanvas = function(ctx, data, props, options, h) {
  /** @type {null} */
  var fontSize = null;
  if (null != this.style) {
    fontSize = this.style.dashPattern;
  }
  ctx.setAlpha(this.opacity / 100);
  ctx.setFillAlpha(this.fillOpacity / 100);
  ctx.setStrokeAlpha(this.strokeOpacity / 100);
  if (null != this.isShadow) {
    ctx.setShadow(this.isShadow);
  }
  if (null != this.isDashed) {
    ctx.setDashed(this.isDashed, null != this.style ? 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FIX_DASH, false) : false);
  }
  if (null != fontSize) {
    ctx.setDashPattern(fontSize);
  }
  if (null != this.fill && this.fill != mxConstants.NONE && this.gradient && this.gradient != mxConstants.NONE) {
    data = this.getGradientBounds(ctx, data, props, options, h);
    ctx.setGradient(this.fill, this.gradient, data.x, data.y, data.width, data.height, this.gradientDirection);
  } else {
    ctx.setFillColor(this.fill);
  }
  ctx.setStrokeColor(this.stroke);
};
/**
 * @param {!Object} macro_context
 * @param {number} options
 * @param {number} src
 * @param {number} minWidth
 * @param {!Function} minHeight
 * @return {?}
 */
mxShape.prototype.getGradientBounds = function(macro_context, options, src, minWidth, minHeight) {
  return new mxRectangle(options, src, minWidth, minHeight);
};
/**
 * @param {!Object} ctx
 * @param {number} t
 * @param {number} x
 * @param {number} index
 * @param {number} y
 * @return {undefined}
 */
mxShape.prototype.updateTransform = function(ctx, t, x, index, y) {
  ctx.scale(this.scale);
  ctx.rotate(this.getShapeRotation(), this.flipH, this.flipV, t + index / 2, x + y / 2);
};
/**
 * @param {string} ctx
 * @param {number} i
 * @param {number} c
 * @param {number} t
 * @param {number} left
 * @return {undefined}
 */
mxShape.prototype.paintVertexShape = function(ctx, i, c, t, left) {
  this.paintBackground(ctx, i, c, t, left);
  if (!(this.outline && null != this.style && 0 != mxUtils.getValue(this.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0))) {
    ctx.setShadow(false);
    this.paintForeground(ctx, i, c, t, left);
  }
};
/**
 * @param {string} canvas
 * @param {number} area
 * @param {number} x
 * @param {number} y
 * @param {number} h
 * @return {undefined}
 */
mxShape.prototype.paintBackground = function(canvas, area, x, y, h) {
};
/**
 * @param {string} status
 * @param {number} size
 * @param {number} layer
 * @param {number} e
 * @param {number} context
 * @return {undefined}
 */
mxShape.prototype.paintForeground = function(status, size, layer, e, context) {
};
/**
 * @param {!Object} status
 * @param {?} size
 * @return {undefined}
 */
mxShape.prototype.paintEdgeShape = function(status, size) {
};
/**
 * @param {number} h
 * @param {number} w
 * @return {?}
 */
mxShape.prototype.getArcSize = function(h, w) {
  var devicePixelRatio;
  if ("1" == mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0)) {
    /** @type {number} */
    devicePixelRatio = Math.min(h / 2, Math.min(w / 2, mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2));
  } else {
    /** @type {number} */
    devicePixelRatio = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100;
    /** @type {number} */
    devicePixelRatio = Math.min(h * devicePixelRatio, w * devicePixelRatio);
  }
  return devicePixelRatio;
};
/**
 * @param {!Object} ctx
 * @param {number} x
 * @param {number} h
 * @param {number} a
 * @param {number} i
 * @param {number} r
 * @return {undefined}
 */
mxShape.prototype.paintGlassEffect = function(ctx, x, h, a, i, r) {
  /** @type {number} */
  var radius = Math.ceil(this.strokewidth / 2);
  ctx.setGradient("#ffffff", "#ffffff", x, h, a, .6 * i, "south", .9, .1);
  ctx.begin();
  r = r + 2 * radius;
  if (this.isRounded) {
    ctx.moveTo(x - radius + r, h - radius);
    ctx.quadTo(x - radius, h - radius, x - radius, h - radius + r);
    ctx.lineTo(x - radius, h + .4 * i);
    ctx.quadTo(x + .5 * a, h + .7 * i, x + a + radius, h + .4 * i);
    ctx.lineTo(x + a + radius, h - radius + r);
    ctx.quadTo(x + a + radius, h - radius, x + a + radius - r, h - radius);
  } else {
    ctx.moveTo(x - radius, h - radius);
    ctx.lineTo(x - radius, h + .4 * i);
    ctx.quadTo(x + .5 * a, h + .7 * i, x + a + radius, h + .4 * i);
    ctx.lineTo(x + a + radius, h - radius);
  }
  ctx.close();
  ctx.fill();
};
/**
 * @param {!Object} path
 * @param {!Object} data
 * @param {string} a
 * @param {number} t
 * @param {boolean} b
 * @param {string} value
 * @param {number} p
 * @return {undefined}
 */
mxShape.prototype.addPoints = function(path, data, a, t, b, value, p) {
  if (null != data && 0 < data.length) {
    p = null != p ? p : true;
    var event = data[data.length - 1];
    if (b && a) {
      data = data.slice();
      var start = data[0];
      start = new mxPoint(event.x + (start.x - event.x) / 2, event.y + (start.y - event.y) / 2);
      data.splice(0, 0, start);
    }
    var r = data[0];
    /** @type {number} */
    start = 1;
    if (p) {
      path.moveTo(r.x, r.y);
    } else {
      path.lineTo(r.x, r.y);
    }
    for (; start < (b ? data.length : data.length - 1);) {
      p = data[mxUtils.mod(start, data.length)];
      /** @type {number} */
      var w = r.x - p.x;
      /** @type {number} */
      r = r.y - p.y;
      if (a && (0 != w || 0 != r) && (null == value || 0 > mxUtils.indexOf(value, start - 1))) {
        /** @type {number} */
        var d = Math.sqrt(w * w + r * r);
        path.lineTo(p.x + w * Math.min(t, d / 2) / d, p.y + r * Math.min(t, d / 2) / d);
        r = data[mxUtils.mod(start + 1, data.length)];
        for (; start < data.length - 2 && 0 == Math.round(r.x - p.x) && 0 == Math.round(r.y - p.y);) {
          r = data[mxUtils.mod(start + 2, data.length)];
          start++;
        }
        /** @type {number} */
        w = r.x - p.x;
        /** @type {number} */
        r = r.y - p.y;
        /** @type {number} */
        d = Math.max(1, Math.sqrt(w * w + r * r));
        w = p.x + w * Math.min(t, d / 2) / d;
        r = p.y + r * Math.min(t, d / 2) / d;
        path.quadTo(p.x, p.y, w, r);
        p = new mxPoint(w, r);
      } else {
        path.lineTo(p.x, p.y);
      }
      /** @type {number} */
      r = p;
      start++;
    }
    if (b) {
      path.close();
    } else {
      path.lineTo(event.x, event.y);
    }
  }
};
/**
 * @return {undefined}
 */
mxShape.prototype.resetStyles = function() {
  this.initStyles();
  /** @type {number} */
  this.spacing = 0;
  delete this.fill;
  delete this.gradient;
  delete this.gradientDirection;
  delete this.stroke;
  delete this.startSize;
  delete this.endSize;
  delete this.startArrow;
  delete this.endArrow;
  delete this.direction;
  delete this.isShadow;
  delete this.isDashed;
  delete this.isRounded;
  delete this.glass;
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxShape.prototype.apply = function(data) {
  /** @type {!Object} */
  this.state = data;
  this.style = data.style;
  if (null != this.style) {
    this.fill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, this.fill);
    this.gradient = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENTCOLOR, this.gradient);
    this.gradientDirection = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENT_DIRECTION, this.gradientDirection);
    this.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_OPACITY, this.opacity);
    this.fillOpacity = mxUtils.getValue(this.style, mxConstants.STYLE_FILL_OPACITY, this.fillOpacity);
    this.strokeOpacity = mxUtils.getValue(this.style, mxConstants.STYLE_STROKE_OPACITY, this.strokeOpacity);
    this.stroke = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, this.stroke);
    this.strokewidth = mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth);
    this.spacing = mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing);
    this.startSize = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, this.startSize);
    this.endSize = mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, this.endSize);
    this.startArrow = mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, this.startArrow);
    this.endArrow = mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, this.endArrow);
    this.rotation = mxUtils.getValue(this.style, mxConstants.STYLE_ROTATION, this.rotation);
    this.direction = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, this.direction);
    /** @type {boolean} */
    this.flipH = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0);
    /** @type {boolean} */
    this.flipV = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0);
    if (null != this.stencil) {
      /** @type {boolean} */
      this.flipH = 1 == mxUtils.getValue(this.style, "stencilFlipH", 0) || this.flipH;
      /** @type {boolean} */
      this.flipV = 1 == mxUtils.getValue(this.style, "stencilFlipV", 0) || this.flipV;
    }
    if (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH) {
      /** @type {boolean} */
      data = this.flipH;
      /** @type {boolean} */
      this.flipH = this.flipV;
      /** @type {!Object} */
      this.flipV = data;
    }
    /** @type {boolean} */
    this.isShadow = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SHADOW, this.isShadow);
    /** @type {boolean} */
    this.isDashed = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, this.isDashed);
    /** @type {boolean} */
    this.isRounded = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_ROUNDED, this.isRounded);
    /** @type {boolean} */
    this.glass = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_GLASS, this.glass);
    if (this.fill == mxConstants.NONE) {
      /** @type {null} */
      this.fill = null;
    }
    if (this.gradient == mxConstants.NONE) {
      /** @type {null} */
      this.gradient = null;
    }
    if (this.stroke == mxConstants.NONE) {
      /** @type {null} */
      this.stroke = null;
    }
  }
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxShape.prototype.setCursor = function(value) {
  if (null == value) {
    /** @type {string} */
    value = "";
  }
  /** @type {string} */
  this.cursor = value;
  if (null != this.node) {
    /** @type {string} */
    this.node.style.cursor = value;
  }
};
/**
 * @return {?}
 */
mxShape.prototype.getCursor = function() {
  return this.cursor;
};
/**
 * @return {?}
 */
mxShape.prototype.isRoundable = function() {
  return false;
};
/**
 * @return {undefined}
 */
mxShape.prototype.updateBoundingBox = function() {
  if (this.useSvgBoundingBox && null != this.node && null != this.node.ownerSVGElement) {
    try {
      var ret = this.node.getBBox();
      if (0 < ret.width && 0 < ret.height) {
        this.boundingBox = new mxRectangle(ret.x, ret.y, ret.width, ret.height);
        this.boundingBox.grow(this.strokewidth * this.scale / 2);
        return;
      }
    } catch (c) {
    }
  }
  if (null != this.bounds) {
    ret = this.createBoundingBox();
    if (null != ret) {
      this.augmentBoundingBox(ret);
      var value = this.getShapeRotation();
      if (0 != value) {
        ret = mxUtils.getBoundingBox(ret, value);
      }
    }
    this.boundingBox = ret;
  }
};
/**
 * @return {?}
 */
mxShape.prototype.createBoundingBox = function() {
  var utils = this.bounds.clone();
  if (null != this.stencil && (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH) || this.isPaintBoundsInverted()) {
    utils.rotate90();
  }
  return utils;
};
/**
 * @param {!Object} bbox
 * @return {undefined}
 */
mxShape.prototype.augmentBoundingBox = function(bbox) {
  if (this.isShadow) {
    bbox.width += Math.ceil(mxConstants.SHADOW_OFFSET_X * this.scale);
    bbox.height += Math.ceil(mxConstants.SHADOW_OFFSET_Y * this.scale);
  }
  bbox.grow(this.strokewidth * this.scale / 2);
};
/**
 * @return {?}
 */
mxShape.prototype.isPaintBoundsInverted = function() {
  return null == this.stencil && (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH);
};
/**
 * @return {?}
 */
mxShape.prototype.getRotation = function() {
  return null != this.rotation ? this.rotation : 0;
};
/**
 * @return {?}
 */
mxShape.prototype.getTextRotation = function() {
  var rotation = this.getRotation();
  if (1 != mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1)) {
    rotation = rotation + mxText.prototype.verticalTextRotation;
  }
  return rotation;
};
/**
 * @return {?}
 */
mxShape.prototype.getShapeRotation = function() {
  var rotation = this.getRotation();
  if (null != this.direction) {
    if (this.direction == mxConstants.DIRECTION_NORTH) {
      rotation = rotation + 270;
    } else {
      if (this.direction == mxConstants.DIRECTION_WEST) {
        rotation = rotation + 180;
      } else {
        if (this.direction == mxConstants.DIRECTION_SOUTH) {
          rotation = rotation + 90;
        }
      }
    }
  }
  return rotation;
};
/**
 * @param {string} a
 * @param {string} i
 * @param {string} h
 * @param {string} media
 * @return {?}
 */
mxShape.prototype.createTransparentSvgRectangle = function(a, i, h, media) {
  /** @type {!Element} */
  var el = document.createElementNS(mxConstants.NS_SVG, "rect");
  el.setAttribute("x", a);
  el.setAttribute("y", i);
  el.setAttribute("width", h);
  el.setAttribute("height", media);
  el.setAttribute("fill", "none");
  el.setAttribute("stroke", "none");
  el.setAttribute("pointer-events", "all");
  return el;
};
/**
 * @param {!Element} el
 * @return {undefined}
 */
mxShape.prototype.setTransparentBackgroundImage = function(el) {
  /** @type {string} */
  el.style.backgroundImage = "url('" + mxClient.imageBasePath + "/transparent.gif')";
};
/**
 * @param {!Object} a
 * @return {undefined}
 */
mxShape.prototype.releaseSvgGradients = function(a) {
  if (null != a) {
    var j;
    for (j in a) {
      var e2 = a[j];
      if (null != e2) {
        /** @type {number} */
        e2.mxRefCount = (e2.mxRefCount || 0) - 1;
        if (0 == e2.mxRefCount && null != e2.parentNode) {
          e2.parentNode.removeChild(e2);
        }
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxShape.prototype.destroy = function() {
  if (null != this.node) {
    mxEvent.release(this.node);
    if (null != this.node.parentNode) {
      this.node.parentNode.removeChild(this.node);
    }
    /** @type {null} */
    this.node = null;
  }
  this.releaseSvgGradients(this.oldGradients);
  /** @type {null} */
  this.oldGradients = null;
};
/**
 * @param {string} ceDescription
 * @return {undefined}
 */
function mxStencil(ceDescription) {
  /** @type {string} */
  this.desc = ceDescription;
  this.parseDescription();
  this.parseConstraints();
}
mxUtils.extend(mxStencil, mxShape);
/** @type {boolean} */
mxStencil.defaultLocalized = false;
/** @type {boolean} */
mxStencil.allowEval = false;
/** @type {null} */
mxStencil.prototype.desc = null;
/** @type {null} */
mxStencil.prototype.constraints = null;
/** @type {null} */
mxStencil.prototype.aspect = null;
/** @type {null} */
mxStencil.prototype.w0 = null;
/** @type {null} */
mxStencil.prototype.h0 = null;
/** @type {null} */
mxStencil.prototype.bgNode = null;
/** @type {null} */
mxStencil.prototype.fgNode = null;
/** @type {null} */
mxStencil.prototype.strokewidth = null;
/**
 * @return {undefined}
 */
mxStencil.prototype.parseDescription = function() {
  this.fgNode = this.desc.getElementsByTagName("foreground")[0];
  this.bgNode = this.desc.getElementsByTagName("background")[0];
  /** @type {number} */
  this.w0 = Number(this.desc.getAttribute("w") || 100);
  /** @type {number} */
  this.h0 = Number(this.desc.getAttribute("h") || 100);
  var position = this.desc.getAttribute("aspect");
  this.aspect = null != position ? position : "variable";
  position = this.desc.getAttribute("strokewidth");
  this.strokewidth = null != position ? position : "1";
};
/**
 * @return {undefined}
 */
mxStencil.prototype.parseConstraints = function() {
  var node = this.desc.getElementsByTagName("connections")[0];
  if (null != node && (node = mxUtils.getChildNodes(node), null != node && 0 < node.length)) {
    /** @type {!Array} */
    this.constraints = [];
    /** @type {number} */
    var ii = 0;
    for (; ii < node.length; ii++) {
      this.constraints.push(this.parseConstraint(node[ii]));
    }
  }
};
/**
 * @param {!Object} line
 * @return {?}
 */
mxStencil.prototype.parseConstraint = function(line) {
  /** @type {number} */
  var x = Number(line.getAttribute("x"));
  /** @type {number} */
  var height = Number(line.getAttribute("y"));
  /** @type {boolean} */
  var d = "1" == line.getAttribute("perimeter");
  line = line.getAttribute("name");
  return new mxConnectionConstraint(new mxPoint(x, height), d, line);
};
/**
 * @param {string} node
 * @param {string} name
 * @param {!Object} loader
 * @return {?}
 */
mxStencil.prototype.evaluateTextAttribute = function(node, name, loader) {
  name = this.evaluateAttribute(node, name, loader);
  node = node.getAttribute("localized");
  if (mxStencil.defaultLocalized && null == node || "1" == node) {
    name = mxResources.get(name);
  }
  return name;
};
/**
 * @param {!Object} s
 * @param {string} x
 * @param {!Object} a
 * @return {?}
 */
mxStencil.prototype.evaluateAttribute = function(s, x, a) {
  x = s.getAttribute(x);
  if (null == x) {
    s = mxUtils.getTextContent(s);
    if (null != s && mxStencil.allowEval) {
      s = mxUtils.eval(s);
      if ("function" == typeof s) {
        x = s(a);
      }
    }
  }
  return x;
};
/**
 * @param {!Object} ctx
 * @param {!Object} s
 * @param {number} x
 * @param {number} i
 * @param {number} h
 * @param {number} w
 * @return {undefined}
 */
mxStencil.prototype.drawShape = function(ctx, s, x, i, h, w) {
  var res = ctx.states.slice();
  var value = mxUtils.getValue(s.style, mxConstants.STYLE_DIRECTION, null);
  value = this.computeAspect(s.style, x, i, h, w, value);
  /** @type {number} */
  var borderWidth = Math.min(value.width, value.height);
  /** @type {number} */
  borderWidth = "inherit" == this.strokewidth ? Number(mxUtils.getNumber(s.style, mxConstants.STYLE_STROKEWIDTH, 1)) : Number(this.strokewidth) * borderWidth;
  ctx.setStrokeWidth(borderWidth);
  if (null != s.style && "1" == mxUtils.getValue(s.style, mxConstants.STYLE_POINTER_EVENTS, "0")) {
    ctx.setStrokeColor(mxConstants.NONE);
    ctx.rect(x, i, h, w);
    ctx.stroke();
    ctx.setStrokeColor(s.stroke);
  }
  this.drawChildren(ctx, s, x, i, h, w, this.bgNode, value, false, true);
  this.drawChildren(ctx, s, x, i, h, w, this.fgNode, value, true, !s.outline || null == s.style || 0 == mxUtils.getValue(s.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0));
  if (ctx.states.length != res.length) {
    ctx.states = res;
  }
};
/**
 * @param {!Object} node
 * @param {!Object} o
 * @param {!Object} item
 * @param {number} depth
 * @param {number} parent
 * @param {number} list
 * @param {!Object} context
 * @param {undefined} box
 * @param {string} isClip
 * @param {boolean} isMask
 * @return {undefined}
 */
mxStencil.prototype.drawChildren = function(node, o, item, depth, parent, list, context, box, isClip, isMask) {
  if (null != context && 0 < parent && 0 < list) {
    item = context.firstChild;
    for (; null != item;) {
      if (item.nodeType == mxConstants.NODETYPE_ELEMENT) {
        this.drawNode(node, o, item, box, isClip, isMask);
      }
      item = item.nextSibling;
    }
  }
};
/**
 * @param {number} width
 * @param {number} minWidth
 * @param {number} period
 * @param {number} index
 * @param {number} step
 * @param {number} scale
 * @return {?}
 */
mxStencil.prototype.computeAspect = function(width, minWidth, period, index, step, scale) {
  /** @type {number} */
  width = minWidth;
  /** @type {number} */
  minWidth = index / this.w0;
  /** @type {number} */
  var maxWidth = step / this.h0;
  if (scale = scale == mxConstants.DIRECTION_NORTH || scale == mxConstants.DIRECTION_SOUTH) {
    /** @type {number} */
    maxWidth = index / this.h0;
    /** @type {number} */
    minWidth = step / this.w0;
    /** @type {number} */
    var value = (index - step) / 2;
    width = width + value;
    /** @type {number} */
    period = period - value;
  }
  if ("fixed" == this.aspect) {
    /** @type {number} */
    minWidth = maxWidth = Math.min(minWidth, maxWidth);
    if (scale) {
      width = width + (step - this.w0 * minWidth) / 2;
      period = period + (index - this.h0 * maxWidth) / 2;
    } else {
      width = width + (index - this.w0 * minWidth) / 2;
      period = period + (step - this.h0 * maxWidth) / 2;
    }
  }
  return new mxRectangle(width, period, minWidth, maxWidth);
};
/**
 * @param {!Object} ctx
 * @param {!Object} s
 * @param {!Object} node
 * @param {number} d
 * @param {string} obj
 * @param {number} h
 * @return {undefined}
 */
mxStencil.prototype.drawNode = function(ctx, s, node, d, obj, h) {
  var undefined = node.nodeName;
  var x = d.x;
  var y = d.y;
  var i = d.width;
  var r = d.height;
  /** @type {number} */
  var c = Math.min(i, r);
  if ("save" == undefined) {
    ctx.save();
  } else {
    if ("restore" == undefined) {
      ctx.restore();
    } else {
      if (h) {
        if ("path" == undefined) {
          ctx.begin();
          /** @type {boolean} */
          c = true;
          if ("1" == node.getAttribute("rounded")) {
            /** @type {boolean} */
            c = false;
            /** @type {number} */
            var m = Number(node.getAttribute("arcSize"));
            /** @type {number} */
            var z = 0;
            /** @type {!Array} */
            var listeners = [];
            var child = node.firstChild;
            for (; null != child;) {
              if (child.nodeType == mxConstants.NODETYPE_ELEMENT) {
                var nodeName = child.nodeName;
                if ("move" == nodeName || "line" == nodeName) {
                  if (!("move" != nodeName && 0 != listeners.length)) {
                    listeners.push([]);
                  }
                  listeners[listeners.length - 1].push(new mxPoint(x + Number(child.getAttribute("x")) * i, y + Number(child.getAttribute("y")) * r));
                  z++;
                } else {
                  /** @type {boolean} */
                  c = true;
                  break;
                }
              }
              child = child.nextSibling;
            }
            if (!c && 0 < z) {
              /** @type {number} */
              i = 0;
              for (; i < listeners.length; i++) {
                /** @type {boolean} */
                r = false;
                y = listeners[i][0];
                x = listeners[i][listeners[i].length - 1];
                if (y.x == x.x && y.y == x.y) {
                  listeners[i].pop();
                  /** @type {boolean} */
                  r = true;
                }
                this.addPoints(ctx, listeners[i], true, m, r);
              }
            } else {
              /** @type {boolean} */
              c = true;
            }
          }
          if (c) {
            child = node.firstChild;
            for (; null != child;) {
              if (child.nodeType == mxConstants.NODETYPE_ELEMENT) {
                this.drawNode(ctx, s, child, d, obj, h);
              }
              child = child.nextSibling;
            }
          }
        } else {
          if ("close" == undefined) {
            ctx.close();
          } else {
            if ("move" == undefined) {
              ctx.moveTo(x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r);
            } else {
              if ("line" == undefined) {
                ctx.lineTo(x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r);
              } else {
                if ("quad" == undefined) {
                  ctx.quadTo(x + Number(node.getAttribute("x1")) * i, y + Number(node.getAttribute("y1")) * r, x + Number(node.getAttribute("x2")) * i, y + Number(node.getAttribute("y2")) * r);
                } else {
                  if ("curve" == undefined) {
                    ctx.curveTo(x + Number(node.getAttribute("x1")) * i, y + Number(node.getAttribute("y1")) * r, x + Number(node.getAttribute("x2")) * i, y + Number(node.getAttribute("y2")) * r, x + Number(node.getAttribute("x3")) * i, y + Number(node.getAttribute("y3")) * r);
                  } else {
                    if ("arc" == undefined) {
                      ctx.arcTo(Number(node.getAttribute("rx")) * i, Number(node.getAttribute("ry")) * r, Number(node.getAttribute("x-axis-rotation")), Number(node.getAttribute("large-arc-flag")), Number(node.getAttribute("sweep-flag")), x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r);
                    } else {
                      if ("rect" == undefined) {
                        ctx.rect(x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r, Number(node.getAttribute("w")) * i, Number(node.getAttribute("h")) * r);
                      } else {
                        if ("roundrect" == undefined) {
                          /** @type {number} */
                          s = Number(node.getAttribute("arcsize"));
                          if (0 == s) {
                            /** @type {number} */
                            s = 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR;
                          }
                          /** @type {number} */
                          d = Number(node.getAttribute("w")) * i;
                          /** @type {number} */
                          h = Number(node.getAttribute("h")) * r;
                          /** @type {number} */
                          s = Number(s) / 100;
                          /** @type {number} */
                          s = Math.min(d * s, h * s);
                          ctx.roundrect(x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r, d, h, s, s);
                        } else {
                          if ("ellipse" == undefined) {
                            ctx.ellipse(x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r, Number(node.getAttribute("w")) * i, Number(node.getAttribute("h")) * r);
                          } else {
                            if ("image" == undefined) {
                              if (!s.outline) {
                                s = this.evaluateAttribute(node, "src", s);
                                ctx.image(x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r, Number(node.getAttribute("w")) * i, Number(node.getAttribute("h")) * r, s, false, "1" == node.getAttribute("flipH"), "1" == node.getAttribute("flipV"));
                              }
                            } else {
                              if ("text" == undefined) {
                                if (!s.outline) {
                                  d = this.evaluateTextAttribute(node, "str", s);
                                  /** @type {number} */
                                  h = "1" == node.getAttribute("vertical") ? -90 : 0;
                                  if ("0" == node.getAttribute("align-shape")) {
                                    c = s.rotation;
                                    /** @type {boolean} */
                                    m = 1 == mxUtils.getValue(s.style, mxConstants.STYLE_FLIPH, 0);
                                    /** @type {boolean} */
                                    s = 1 == mxUtils.getValue(s.style, mxConstants.STYLE_FLIPV, 0);
                                    h = m && s ? h - c : m || s ? h + c : h - c;
                                  }
                                  /** @type {number} */
                                  h = h - node.getAttribute("rotation");
                                  ctx.text(x + Number(node.getAttribute("x")) * i, y + Number(node.getAttribute("y")) * r, 0, 0, d, node.getAttribute("align") || "left", node.getAttribute("valign") || "top", false, "", null, false, h);
                                }
                              } else {
                                if ("include-shape" == undefined) {
                                  c = mxStencilRegistry.getStencil(node.getAttribute("name"));
                                  if (null != c) {
                                    x = x + Number(node.getAttribute("x")) * i;
                                    y = y + Number(node.getAttribute("y")) * r;
                                    /** @type {number} */
                                    d = Number(node.getAttribute("w")) * i;
                                    /** @type {number} */
                                    h = Number(node.getAttribute("h")) * r;
                                    c.drawShape(ctx, s, x, y, d, h);
                                  }
                                } else {
                                  if ("fillstroke" == undefined) {
                                    ctx.fillAndStroke();
                                  } else {
                                    if ("fill" == undefined) {
                                      ctx.fill();
                                    } else {
                                      if ("stroke" == undefined) {
                                        ctx.stroke();
                                      } else {
                                        if ("strokewidth" == undefined) {
                                          /** @type {number} */
                                          i = "1" == node.getAttribute("fixed") ? 1 : c;
                                          ctx.setStrokeWidth(Number(node.getAttribute("width")) * i);
                                        } else {
                                          if ("dashed" == undefined) {
                                            ctx.setDashed("1" == node.getAttribute("dashed"));
                                          } else {
                                            if ("dashpattern" == undefined) {
                                              if (node = node.getAttribute("pattern"), null != node) {
                                                node = node.split(" ");
                                                /** @type {!Array} */
                                                r = [];
                                                /** @type {number} */
                                                i = 0;
                                                for (; i < node.length; i++) {
                                                  if (0 < node[i].length) {
                                                    r.push(Number(node[i]) * c);
                                                  }
                                                }
                                                /** @type {string} */
                                                node = r.join(" ");
                                                ctx.setDashPattern(node);
                                              }
                                            } else {
                                              if ("strokecolor" == undefined) {
                                                ctx.setStrokeColor(node.getAttribute("color"));
                                              } else {
                                                if ("linecap" == undefined) {
                                                  ctx.setLineCap(node.getAttribute("cap"));
                                                } else {
                                                  if ("linejoin" == undefined) {
                                                    ctx.setLineJoin(node.getAttribute("join"));
                                                  } else {
                                                    if ("miterlimit" == undefined) {
                                                      ctx.setMiterLimit(Number(node.getAttribute("limit")));
                                                    } else {
                                                      if ("fillcolor" == undefined) {
                                                        ctx.setFillColor(node.getAttribute("color"));
                                                      } else {
                                                        if ("alpha" == undefined) {
                                                          ctx.setAlpha(node.getAttribute("alpha"));
                                                        } else {
                                                          if ("fillalpha" == undefined) {
                                                            ctx.setAlpha(node.getAttribute("alpha"));
                                                          } else {
                                                            if ("strokealpha" == undefined) {
                                                              ctx.setAlpha(node.getAttribute("alpha"));
                                                            } else {
                                                              if ("fontcolor" == undefined) {
                                                                ctx.setFontColor(node.getAttribute("color"));
                                                              } else {
                                                                if ("fontstyle" == undefined) {
                                                                  ctx.setFontStyle(node.getAttribute("style"));
                                                                } else {
                                                                  if ("fontfamily" == undefined) {
                                                                    ctx.setFontFamily(node.getAttribute("family"));
                                                                  } else {
                                                                    if ("fontsize" == undefined) {
                                                                      ctx.setFontSize(Number(node.getAttribute("size")) * c);
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (!(!obj || "fillstroke" != undefined && "fill" != undefined && "stroke" != undefined)) {
          ctx.setShadow(false);
        }
      }
    }
  }
};
var mxStencilRegistry = {
  stencils : {},
  addStencil : function(name, options) {
    mxStencilRegistry.stencils[name] = options;
  },
  getStencil : function(name) {
    return mxStencilRegistry.stencils[name];
  }
};
var mxMarker = {
  markers : [],
  addMarker : function(name, event) {
    /** @type {!Function} */
    mxMarker.markers[name] = event;
  },
  createMarker : function(color, o, i, options, d, obj, type, loc, target, name) {
    var fn = mxMarker.markers[i];
    return null != fn ? fn(color, o, i, options, d, obj, type, loc, target, name) : null;
  }
};
(function() {
  /**
   * @param {number} length
   * @return {?}
   */
  function noDuplicatePointCollector(length) {
    length = null != length ? length : 2;
    return function(ctx, w, l, p, x, y, size, h, tileSize, canCreateDiscussions) {
      /** @type {number} */
      w = x * tileSize * 1.118;
      /** @type {number} */
      h = y * tileSize * 1.118;
      /** @type {number} */
      x = x * (size + tileSize);
      /** @type {number} */
      y = y * (size + tileSize);
      var pos = p.clone();
      pos.x -= w;
      pos.y -= h;
      /** @type {number} */
      size = l != mxConstants.ARROW_CLASSIC && l != mxConstants.ARROW_CLASSIC_THIN ? 1 : .75;
      p.x += -x * size - w;
      p.y += -y * size - h;
      return function() {
        ctx.begin();
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(pos.x - x - y / length, pos.y - y + x / length);
        if (!(l != mxConstants.ARROW_CLASSIC && l != mxConstants.ARROW_CLASSIC_THIN)) {
          ctx.lineTo(pos.x - 3 * x / 4, pos.y - 3 * y / 4);
        }
        ctx.lineTo(pos.x + y / length - x, pos.y - y - x / length);
        ctx.close();
        if (canCreateDiscussions) {
          ctx.fillAndStroke();
        } else {
          ctx.stroke();
        }
      };
    };
  }
  /**
   * @param {number} length
   * @return {?}
   */
  function updateFlowIcons(length) {
    length = null != length ? length : 2;
    return function(ctx, count, rotation, objectToMeasure, d, i, fontSize, p, size, canCreateDiscussions) {
      /** @type {number} */
      count = d * size * 1.118;
      /** @type {number} */
      rotation = i * size * 1.118;
      /** @type {number} */
      d = d * (fontSize + size);
      /** @type {number} */
      i = i * (fontSize + size);
      var data = objectToMeasure.clone();
      data.x -= count;
      data.y -= rotation;
      objectToMeasure.x += 2 * -count;
      objectToMeasure.y += 2 * -rotation;
      return function() {
        ctx.begin();
        ctx.moveTo(data.x - d - i / length, data.y - i + d / length);
        ctx.lineTo(data.x, data.y);
        ctx.lineTo(data.x + i / length - d, data.y - i - d / length);
        ctx.stroke();
      };
    };
  }
  /**
   * @param {!Object} ctx
   * @param {number} w
   * @param {?} data
   * @param {!Object} p
   * @param {number} a
   * @param {number} r
   * @param {number} g
   * @param {number} h
   * @param {number} f
   * @param {?} duration
   * @return {?}
   */
  function init(ctx, w, data, p, a, r, g, h, f, duration) {
    /** @type {number} */
    h = data == mxConstants.ARROW_DIAMOND ? .7071 : .9862;
    /** @type {number} */
    w = a * f * h;
    /** @type {number} */
    h = h * (r * f);
    /** @type {number} */
    a = a * (g + f);
    /** @type {number} */
    r = r * (g + f);
    var pos = p.clone();
    pos.x -= w;
    pos.y -= h;
    p.x += -a - w;
    p.y += -r - h;
    /** @type {number} */
    var d = data == mxConstants.ARROW_DIAMOND ? 2 : 3.4;
    return function() {
      ctx.begin();
      ctx.moveTo(pos.x, pos.y);
      ctx.lineTo(pos.x - a / 2 - r / d, pos.y + a / d - r / 2);
      ctx.lineTo(pos.x - a, pos.y - r);
      ctx.lineTo(pos.x - a / 2 + r / d, pos.y - r / 2 - a / d);
      ctx.close();
      if (duration) {
        ctx.fillAndStroke();
      } else {
        ctx.stroke();
      }
    };
  }
  mxMarker.addMarker("classic", noDuplicatePointCollector(2));
  mxMarker.addMarker("classicThin", noDuplicatePointCollector(3));
  mxMarker.addMarker("block", noDuplicatePointCollector(2));
  mxMarker.addMarker("blockThin", noDuplicatePointCollector(3));
  mxMarker.addMarker("open", updateFlowIcons(2));
  mxMarker.addMarker("openThin", updateFlowIcons(3));
  mxMarker.addMarker("oval", function(canvas, b, canCreateDiscussions, bounds, delta, sign, w, n, p, isSlidingUp) {
    /** @type {number} */
    var r = w / 2;
    var rp = bounds.clone();
    bounds.x -= delta * r;
    bounds.y -= sign * r;
    return function() {
      canvas.ellipse(rp.x - r, rp.y - r, w, w);
      if (isSlidingUp) {
        canvas.fillAndStroke();
      } else {
        canvas.stroke();
      }
    };
  });
  mxMarker.addMarker("diamond", init);
  mxMarker.addMarker("diamondThin", init);
})();
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxActor(bounds, value, size, intSetSource) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxActor, mxShape);
/**
 * @param {!Object} opts
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @return {undefined}
 */
mxActor.prototype.paintVertexShape = function(opts, x, y, w, h) {
  opts.translate(x, y);
  opts.begin();
  this.redrawPath(opts, x, y, w, h);
  opts.fillAndStroke();
};
/**
 * @param {!Object} path
 * @param {number} width
 * @param {number} height
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxActor.prototype.redrawPath = function(path, width, height, x, y) {
  /** @type {number} */
  width = x / 3;
  path.moveTo(0, y);
  path.curveTo(0, 3 * y / 5, 0, 2 * y / 5, x / 2, 2 * y / 5);
  path.curveTo(x / 2 - width, 2 * y / 5, x / 2 - width, 0, x / 2, 0);
  path.curveTo(x / 2 + width, 0, x / 2 + width, 2 * y / 5, x / 2, 2 * y / 5);
  path.curveTo(x, 2 * y / 5, x, 3 * y / 5, x, y);
  path.close();
};
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxCloud(bounds, value, size, intSetSource) {
  mxActor.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxCloud, mxActor);
/**
 * @param {!Object} path
 * @param {number} width
 * @param {number} height
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxCloud.prototype.redrawPath = function(path, width, height, x, y) {
  path.moveTo(.25 * x, .25 * y);
  path.curveTo(.05 * x, .25 * y, 0, .5 * y, .16 * x, .55 * y);
  path.curveTo(0, .66 * y, .18 * x, .9 * y, .31 * x, .8 * y);
  path.curveTo(.4 * x, y, .7 * x, y, .8 * x, .8 * y);
  path.curveTo(x, .8 * y, x, .6 * y, .875 * x, .5 * y);
  path.curveTo(x, .3 * y, .8 * x, .1 * y, .625 * x, .2 * y);
  path.curveTo(.5 * x, .05 * y, .3 * x, .05 * y, .25 * x, .25 * y);
  path.close();
};
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxRectangleShape(bounds, value, size, intSetSource) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxRectangleShape, mxShape);
/**
 * @return {?}
 */
mxRectangleShape.prototype.isHtmlAllowed = function() {
  /** @type {boolean} */
  var a = true;
  if (null != this.style) {
    /** @type {boolean} */
    a = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1");
  }
  return !this.isRounded && !this.glass && 0 == this.rotation && (a || null != this.fill && this.fill != mxConstants.NONE);
};
/**
 * @param {!Object} self
 * @param {number} x
 * @param {number} y
 * @param {number} h
 * @param {number} w
 * @return {undefined}
 */
mxRectangleShape.prototype.paintBackground = function(self, x, y, h, w) {
  /** @type {boolean} */
  var i = true;
  if (null != this.style) {
    /** @type {boolean} */
    i = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1");
  }
  if (i || null != this.fill && this.fill != mxConstants.NONE || null != this.stroke && this.stroke != mxConstants.NONE) {
    if (!(i || null != this.fill && this.fill != mxConstants.NONE)) {
      /** @type {boolean} */
      self.pointerEvents = false;
    }
    if (this.isRounded) {
      if ("1" == mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0)) {
        /** @type {number} */
        i = Math.min(h / 2, Math.min(w / 2, mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2));
      } else {
        /** @type {number} */
        i = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100;
        /** @type {number} */
        i = Math.min(h * i, w * i);
      }
      self.roundrect(x, y, h, w, i, i);
    } else {
      self.rect(x, y, h, w);
    }
    self.fillAndStroke();
  }
};
/**
 * @param {?} a
 * @param {?} b
 * @param {?} variableNames
 * @param {?} bindingRecords
 * @param {?} eventRecords
 * @return {?}
 */
mxRectangleShape.prototype.isRoundable = function(a, b, variableNames, bindingRecords, eventRecords) {
  return true;
};
/**
 * @param {!Object} s
 * @param {number} t
 * @param {number} color
 * @param {number} comment
 * @param {number} context
 * @return {undefined}
 */
mxRectangleShape.prototype.paintForeground = function(s, t, color, comment, context) {
  if (this.glass && !this.outline && null != this.fill && this.fill != mxConstants.NONE) {
    this.paintGlassEffect(s, t, color, comment, context, this.getArcSize(comment + this.strokewidth, context + this.strokewidth));
  }
};
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxEllipse(bounds, value, size, intSetSource) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxEllipse, mxShape);
/**
 * @param {!Entity} canvas
 * @param {number} x
 * @param {number} y
 * @param {number} r
 * @param {number} w
 * @return {undefined}
 */
mxEllipse.prototype.paintVertexShape = function(canvas, x, y, r, w) {
  canvas.ellipse(x, y, r, w);
  canvas.fillAndStroke();
};
/**
 * @param {string} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxDoubleEllipse(bounds, value, size, intSetSource) {
  mxShape.call(this);
  /** @type {string} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxDoubleEllipse, mxShape);
/** @type {number} */
mxDoubleEllipse.prototype.vmlScale = 10;
/**
 * @param {!Entity} canvas
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @return {undefined}
 */
mxDoubleEllipse.prototype.paintBackground = function(canvas, x, y, w, h) {
  canvas.ellipse(x, y, w, h);
  canvas.fillAndStroke();
};
/**
 * @param {!Object} context
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @return {undefined}
 */
mxDoubleEllipse.prototype.paintForeground = function(context, x, y, w, h) {
  if (!this.outline) {
    var s = mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(w / 5, h / 5)));
    /** @type {number} */
    w = w - 2 * s;
    /** @type {number} */
    h = h - 2 * s;
    if (0 < w && 0 < h) {
      context.ellipse(x + s, y + s, w, h);
    }
    context.stroke();
  }
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxDoubleEllipse.prototype.getLabelBounds = function(node) {
  /** @type {number} */
  var i = mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(node.width / 5 / this.scale, node.height / 5 / this.scale))) * this.scale;
  return new mxRectangle(node.x + i, node.y + i, node.width - 2 * i, node.height - 2 * i);
};
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxRhombus(bounds, value, size, intSetSource) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxRhombus, mxShape);
/**
 * @return {?}
 */
mxRhombus.prototype.isRoundable = function() {
  return true;
};
/**
 * @param {!Object} opts
 * @param {number} width
 * @param {number} index
 * @param {number} size
 * @param {number} count
 * @return {undefined}
 */
mxRhombus.prototype.paintVertexShape = function(opts, width, index, size, count) {
  /** @type {number} */
  var px = size / 2;
  /** @type {number} */
  var sz = count / 2;
  /** @type {number} */
  var nameArgs = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  opts.begin();
  this.addPoints(opts, [new mxPoint(width + px, index), new mxPoint(width + size, index + sz), new mxPoint(width + px, index + count), new mxPoint(width, index + sz)], this.isRounded, nameArgs, true);
  opts.fillAndStroke();
};
/**
 * @param {?} points
 * @param {!Object} stroke
 * @param {number} strokewidth
 * @return {undefined}
 */
function mxPolyline(points, stroke, strokewidth) {
  mxShape.call(this);
  this.points = points;
  /** @type {!Object} */
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
}
mxUtils.extend(mxPolyline, mxShape);
/**
 * @return {?}
 */
mxPolyline.prototype.getRotation = function() {
  return 0;
};
/**
 * @return {?}
 */
mxPolyline.prototype.getShapeRotation = function() {
  return 0;
};
/**
 * @return {?}
 */
mxPolyline.prototype.isPaintBoundsInverted = function() {
  return false;
};
/**
 * @param {!Object} context
 * @param {!Object} obj
 * @return {undefined}
 */
mxPolyline.prototype.paintEdgeShape = function(context, obj) {
  var firstSelector = context.pointerEventsValue;
  /** @type {string} */
  context.pointerEventsValue = "stroke";
  if (null == this.style || 1 != this.style[mxConstants.STYLE_CURVED]) {
    this.paintLine(context, obj, this.isRounded);
  } else {
    this.paintCurvedLine(context, obj);
  }
  context.pointerEventsValue = firstSelector;
};
/**
 * @param {!Object} path
 * @param {!Object} f
 * @param {string} context
 * @return {undefined}
 */
mxPolyline.prototype.paintLine = function(path, f, context) {
  /** @type {number} */
  var nameArgs = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  path.begin();
  this.addPoints(path, f, context, nameArgs, false);
  path.stroke();
};
/**
 * @param {!Object} path
 * @param {!Object} args
 * @return {undefined}
 */
mxPolyline.prototype.paintCurvedLine = function(path, args) {
  path.begin();
  var arg = args[0];
  var argsLength = args.length;
  path.moveTo(arg.x, arg.y);
  /** @type {number} */
  arg = 1;
  for (; arg < argsLength - 2; arg++) {
    var node = args[arg];
    var p = args[arg + 1];
    path.quadTo(node.x, node.y, (node.x + p.x) / 2, (node.y + p.y) / 2);
  }
  node = args[argsLength - 2];
  p = args[argsLength - 1];
  path.quadTo(node.x, node.y, p.x, p.y);
  path.stroke();
};
/**
 * @param {?} coords
 * @param {string} value
 * @param {!Object} size
 * @param {number} status
 * @param {number} e
 * @param {number} p
 * @param {number} altCss
 * @return {undefined}
 */
function mxArrow(coords, value, size, status, e, p, altCss) {
  mxShape.call(this);
  this.points = coords;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != status ? status : 1;
  this.arrowWidth = null != e ? e : mxConstants.ARROW_WIDTH;
  this.spacing = null != p ? p : mxConstants.ARROW_SPACING;
  this.endSize = null != altCss ? altCss : mxConstants.ARROW_SIZE;
}
mxUtils.extend(mxArrow, mxShape);
/**
 * @param {?} bbox
 * @return {undefined}
 */
mxArrow.prototype.augmentBoundingBox = function(bbox) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  bbox.grow((Math.max(this.arrowWidth, this.endSize) / 2 + this.strokewidth) * this.scale);
};
/**
 * @param {!Object} ctx
 * @param {!Object} arr
 * @return {undefined}
 */
mxArrow.prototype.paintEdgeShape = function(ctx, arr) {
  var k = mxConstants.ARROW_SPACING;
  var w = mxConstants.ARROW_WIDTH;
  var p = arr[0];
  var p1 = arr[arr.length - 1];
  /** @type {number} */
  var width = p1.x - p.x;
  /** @type {number} */
  var height = p1.y - p.y;
  /** @type {number} */
  var offset = Math.sqrt(width * width + height * height);
  /** @type {number} */
  var j = offset - 2 * k - mxConstants.ARROW_SIZE;
  /** @type {number} */
  width = width / offset;
  /** @type {number} */
  height = height / offset;
  /** @type {number} */
  offset = w * height / 3;
  /** @type {number} */
  w = -w * width / 3;
  /** @type {number} */
  var lastX = p.x - offset / 2 + k * width;
  /** @type {number} */
  p = p.y - w / 2 + k * height;
  /** @type {number} */
  var x = lastX + offset;
  /** @type {number} */
  var r = p + w;
  /** @type {number} */
  var cx = x + j * width;
  /** @type {number} */
  j = r + j * height;
  /** @type {number} */
  var right = cx + offset;
  /** @type {number} */
  var i = j + w;
  /** @type {number} */
  var left = right - 3 * offset;
  /** @type {number} */
  var y = i - 3 * w;
  ctx.begin();
  ctx.moveTo(lastX, p);
  ctx.lineTo(x, r);
  ctx.lineTo(cx, j);
  ctx.lineTo(right, i);
  ctx.lineTo(p1.x - k * width, p1.y - k * height);
  ctx.lineTo(left, y);
  ctx.lineTo(left + offset, y + w);
  ctx.close();
  ctx.fillAndStroke();
};
/**
 * @param {?} coords
 * @param {string} value
 * @param {!Object} size
 * @param {number} status
 * @param {number} e
 * @param {number} p
 * @param {?} altCss
 * @return {undefined}
 */
function mxArrowConnector(coords, value, size, status, e, p, altCss) {
  mxShape.call(this);
  this.points = coords;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != status ? status : 1;
  this.arrowWidth = null != e ? e : mxConstants.ARROW_WIDTH;
  this.arrowSpacing = null != p ? p : mxConstants.ARROW_SPACING;
  /** @type {number} */
  this.startSize = mxConstants.ARROW_SIZE / 5;
  /** @type {number} */
  this.endSize = mxConstants.ARROW_SIZE / 5;
}
mxUtils.extend(mxArrowConnector, mxShape);
/** @type {boolean} */
mxArrowConnector.prototype.useSvgBoundingBox = true;
/**
 * @return {?}
 */
mxArrowConnector.prototype.isRoundable = function() {
  return true;
};
/**
 * @return {undefined}
 */
mxArrowConnector.prototype.resetStyles = function() {
  mxShape.prototype.resetStyles.apply(this, arguments);
  this.arrowSpacing = mxConstants.ARROW_SPACING;
};
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxArrowConnector.prototype.apply = function(obj) {
  mxShape.prototype.apply.apply(this, arguments);
  if (null != this.style) {
    /** @type {number} */
    this.startSize = 3 * mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.ARROW_SIZE / 5);
    /** @type {number} */
    this.endSize = 3 * mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.ARROW_SIZE / 5);
  }
};
/**
 * @param {?} bbox
 * @return {undefined}
 */
mxArrowConnector.prototype.augmentBoundingBox = function(bbox) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  var widestInView = this.getEdgeWidth();
  if (this.isMarkerStart()) {
    /** @type {number} */
    widestInView = Math.max(widestInView, this.getStartArrowWidth());
  }
  if (this.isMarkerEnd()) {
    /** @type {number} */
    widestInView = Math.max(widestInView, this.getEndArrowWidth());
  }
  bbox.grow((widestInView / 2 + this.strokewidth) * this.scale);
};
/**
 * @param {!Object} ctx
 * @param {!Object} args
 * @return {undefined}
 */
mxArrowConnector.prototype.paintEdgeShape = function(ctx, args) {
  var delta = this.strokewidth;
  if (this.outline) {
    /** @type {number} */
    delta = Math.max(1, mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth));
  }
  var num = this.getStartArrowWidth() + delta;
  var radius = this.getEndArrowWidth() + delta;
  var s = this.outline ? this.getEdgeWidth() + delta : this.getEdgeWidth();
  var object = this.isOpenEnded();
  var isFunc = this.isMarkerStart();
  var property = this.isMarkerEnd();
  var m = object ? 0 : this.arrowSpacing + delta / 2;
  var offset = this.startSize + delta;
  delta = this.endSize + delta;
  var _next = this.isArrowRounded();
  var start = args[args.length - 1];
  /** @type {number} */
  var j = 1;
  for (; j < args.length - 1 && args[j].x == args[0].x && args[j].y == args[0].y;) {
    j++;
  }
  /** @type {number} */
  var i = args[j].x - args[0].x;
  /** @type {number} */
  j = args[j].y - args[0].y;
  /** @type {number} */
  var len = Math.sqrt(i * i + j * j);
  if (0 != len) {
    /** @type {number} */
    var x = i / len;
    var y;
    /** @type {number} */
    var r = x;
    /** @type {number} */
    var height = j / len;
    var w;
    /** @type {number} */
    var h = height;
    /** @type {number} */
    len = s * height;
    /** @type {number} */
    var width = -s * x;
    /** @type {!Array} */
    var childrenIDs = [];
    if (_next) {
      ctx.setLineJoin("round");
    } else {
      if (2 < args.length) {
        ctx.setMiterLimit(1.42);
      }
    }
    ctx.begin();
    /** @type {number} */
    i = x;
    /** @type {number} */
    j = height;
    if (isFunc && !object) {
      this.paintMarker(ctx, args[0].x, args[0].y, x, height, offset, num, s, m, true);
    } else {
      y = args[0].x + len / 2 + m * x;
      w = args[0].y + width / 2 + m * height;
      /** @type {number} */
      var indicatorX = args[0].x - len / 2 + m * x;
      /** @type {number} */
      var transformY = args[0].y - width / 2 + m * height;
      if (object) {
        ctx.moveTo(y, w);
        childrenIDs.push(function() {
          ctx.lineTo(indicatorX, transformY);
        });
      } else {
        ctx.moveTo(indicatorX, transformY);
        ctx.lineTo(y, w);
      }
    }
    /** @type {number} */
    var d = w = y = 0;
    /** @type {number} */
    len = 0;
    for (; len < args.length - 2; len++) {
      if (width = mxUtils.relativeCcw(args[len].x, args[len].y, args[len + 1].x, args[len + 1].y, args[len + 2].x, args[len + 2].y), y = args[len + 2].x - args[len + 1].x, w = args[len + 2].y - args[len + 1].y, d = Math.sqrt(y * y + w * w), 0 != d) {
        /** @type {number} */
        r = y / d;
        /** @type {number} */
        h = w / d;
        /** @type {number} */
        d = Math.max(Math.sqrt((x * r + height * h + 1) / 2), .04);
        /** @type {number} */
        y = x + r;
        /** @type {number} */
        w = height + h;
        /** @type {number} */
        var scale = Math.sqrt(y * y + w * w);
        if (0 != scale) {
          /** @type {number} */
          y = y / scale;
          /** @type {number} */
          w = w / scale;
          /** @type {number} */
          scale = Math.max(d, Math.min(this.strokewidth / 200 + .04, .35));
          /** @type {number} */
          d = 0 != width && _next ? Math.max(.1, scale) : Math.max(d, .06);
          var i = args[len + 1].x + w * s / 2 / d;
          /** @type {number} */
          var a = args[len + 1].y - y * s / 2 / d;
          /** @type {number} */
          w = args[len + 1].x - w * s / 2 / d;
          y = args[len + 1].y + y * s / 2 / d;
          if (0 != width && _next) {
            if (-1 == width) {
              /** @type {number} */
              width = w + h * s;
              /** @type {number} */
              d = y - r * s;
              ctx.lineTo(w + height * s, y - x * s);
              ctx.quadTo(i, a, width, d);
              (function(dim, b) {
                childrenIDs.push(function() {
                  ctx.lineTo(dim, b);
                });
              })(w, y);
            } else {
              ctx.lineTo(i, a);
              (function(theta, start) {
                /** @type {number} */
                var w = i - height * s;
                /** @type {number} */
                var b = a + x * s;
                /** @type {number} */
                var right = i - h * s;
                /** @type {number} */
                var val = a + r * s;
                childrenIDs.push(function() {
                  ctx.quadTo(theta, start, w, b);
                });
                childrenIDs.push(function() {
                  ctx.lineTo(right, val);
                });
              })(w, y);
            }
          } else {
            ctx.lineTo(i, a);
            (function(dim, b) {
              childrenIDs.push(function() {
                ctx.lineTo(dim, b);
              });
            })(w, y);
          }
          /** @type {number} */
          x = r;
          /** @type {number} */
          height = h;
        }
      }
    }
    /** @type {number} */
    len = s * h;
    /** @type {number} */
    width = -s * r;
    if (property && !object) {
      this.paintMarker(ctx, start.x, start.y, -x, -height, delta, radius, s, m, false);
    } else {
      ctx.lineTo(start.x - m * r + len / 2, start.y - m * h + width / 2);
      /** @type {number} */
      var indicatorX = start.x - m * r - len / 2;
      /** @type {number} */
      var transformY = start.y - m * h - width / 2;
      if (object) {
        ctx.moveTo(indicatorX, transformY);
        childrenIDs.splice(0, 0, function() {
          ctx.moveTo(indicatorX, transformY);
        });
      } else {
        ctx.lineTo(indicatorX, transformY);
      }
    }
    /** @type {number} */
    len = childrenIDs.length - 1;
    for (; 0 <= len; len--) {
      childrenIDs[len]();
    }
    if (object) {
      ctx.end();
      ctx.stroke();
    } else {
      ctx.close();
      ctx.fillAndStroke();
    }
    ctx.setShadow(false);
    ctx.setMiterLimit(4);
    if (_next) {
      ctx.setLineJoin("flat");
    }
    if (2 < args.length) {
      ctx.setMiterLimit(4);
      if (isFunc && !object) {
        ctx.begin();
        this.paintMarker(ctx, args[0].x, args[0].y, i, j, offset, num, s, m, true);
        ctx.stroke();
        ctx.end();
      }
      if (property && !object) {
        ctx.begin();
        this.paintMarker(ctx, start.x, start.y, -x, -height, delta, radius, s, m, true);
        ctx.stroke();
        ctx.end();
      }
    }
  }
};
/**
 * @param {!Object} ctx
 * @param {number} x
 * @param {number} y
 * @param {number} t
 * @param {number} value
 * @param {number} offset
 * @param {number} scale
 * @param {number} width
 * @param {number} s
 * @param {boolean} length
 * @return {undefined}
 */
mxArrowConnector.prototype.paintMarker = function(ctx, x, y, t, value, offset, scale, width, s, length) {
  /** @type {number} */
  scale = width / scale;
  /** @type {number} */
  var w = width * value / 2;
  /** @type {number} */
  width = -width * t / 2;
  /** @type {number} */
  var dx = (s + offset) * t;
  /** @type {number} */
  offset = (s + offset) * value;
  if (length) {
    ctx.moveTo(x - w + dx, y - width + offset);
  } else {
    ctx.lineTo(x - w + dx, y - width + offset);
  }
  ctx.lineTo(x - w / scale + dx, y - width / scale + offset);
  ctx.lineTo(x + s * t, y + s * value);
  ctx.lineTo(x + w / scale + dx, y + width / scale + offset);
  ctx.lineTo(x + w + dx, y + width + offset);
};
/**
 * @return {?}
 */
mxArrowConnector.prototype.isArrowRounded = function() {
  return this.isRounded;
};
/**
 * @return {?}
 */
mxArrowConnector.prototype.getStartArrowWidth = function() {
  return mxConstants.ARROW_WIDTH;
};
/**
 * @return {?}
 */
mxArrowConnector.prototype.getEndArrowWidth = function() {
  return mxConstants.ARROW_WIDTH;
};
/**
 * @return {?}
 */
mxArrowConnector.prototype.getEdgeWidth = function() {
  return mxConstants.ARROW_WIDTH / 3;
};
/**
 * @return {?}
 */
mxArrowConnector.prototype.isOpenEnded = function() {
  return false;
};
/**
 * @return {?}
 */
mxArrowConnector.prototype.isMarkerStart = function() {
  return mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE;
};
/**
 * @return {?}
 */
mxArrowConnector.prototype.isMarkerEnd = function() {
  return mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE;
};
/**
 * @param {!Object} b
 * @param {!Object} bounds
 * @param {string} position
 * @param {string} defAngle
 * @param {string} color
 * @param {string} family
 * @param {number} size
 * @param {string} total
 * @param {number} duration
 * @param {number} value
 * @param {number} option
 * @param {number} i
 * @param {number} val
 * @param {?} name
 * @param {string} background
 * @param {?} border
 * @param {string} length
 * @param {string} text
 * @param {string} placeholder
 * @param {number} parent
 * @param {?} orderVertical
 * @return {undefined}
 */
function mxText(b, bounds, position, defAngle, color, family, size, total, duration, value, option, i, val, name, background, border, length, text, placeholder, parent, orderVertical) {
  mxShape.call(this);
  /** @type {!Object} */
  this.value = b;
  /** @type {!Object} */
  this.bounds = bounds;
  this.color = null != color ? color : "black";
  this.align = null != position ? position : mxConstants.ALIGN_CENTER;
  this.valign = null != defAngle ? defAngle : mxConstants.ALIGN_MIDDLE;
  this.family = null != family ? family : mxConstants.DEFAULT_FONTFAMILY;
  this.size = null != size ? size : mxConstants.DEFAULT_FONTSIZE;
  this.fontStyle = null != total ? total : mxConstants.DEFAULT_FONTSTYLE;
  /** @type {number} */
  this.spacing = parseInt(duration || 2);
  /** @type {number} */
  this.spacingTop = this.spacing + parseInt(value || 0);
  /** @type {number} */
  this.spacingRight = this.spacing + parseInt(option || 0);
  /** @type {number} */
  this.spacingBottom = this.spacing + parseInt(i || 0);
  /** @type {number} */
  this.spacingLeft = this.spacing + parseInt(val || 0);
  this.horizontal = null != name ? name : true;
  /** @type {string} */
  this.background = background;
  this.border = border;
  this.wrap = null != length ? length : false;
  this.clipped = null != text ? text : false;
  this.overflow = null != placeholder ? placeholder : "visible";
  this.labelPadding = null != parent ? parent : 0;
  this.textDirection = orderVertical;
  /** @type {number} */
  this.rotation = 0;
  this.updateMargin();
}
mxUtils.extend(mxText, mxShape);
/** @type {number} */
mxText.prototype.baseSpacingTop = 0;
/** @type {number} */
mxText.prototype.baseSpacingBottom = 0;
/** @type {number} */
mxText.prototype.baseSpacingLeft = 0;
/** @type {number} */
mxText.prototype.baseSpacingRight = 0;
/** @type {boolean} */
mxText.prototype.replaceLinefeeds = true;
/** @type {number} */
mxText.prototype.verticalTextRotation = -90;
/** @type {boolean} */
mxText.prototype.ignoreClippedStringSize = true;
/** @type {boolean} */
mxText.prototype.ignoreStringSize = false;
/** @type {number} */
mxText.prototype.textWidthPadding = 8 != document.documentMode || mxClient.IS_EM ? 3 : 4;
/** @type {null} */
mxText.prototype.lastValue = null;
/** @type {boolean} */
mxText.prototype.cacheEnabled = true;
/**
 * @return {?}
 */
mxText.prototype.isParseVml = function() {
  return false;
};
/**
 * @return {?}
 */
mxText.prototype.isHtmlAllowed = function() {
  return 8 != document.documentMode || mxClient.IS_EM;
};
/**
 * @return {?}
 */
mxText.prototype.getSvgScreenOffset = function() {
  return 0;
};
/**
 * @return {?}
 */
mxText.prototype.checkBounds = function() {
  return !isNaN(this.scale) && isFinite(this.scale) && 0 < this.scale && null != this.bounds && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height);
};
/**
 * @param {!Object} ctx
 * @param {boolean} fullRefresh
 * @return {undefined}
 */
mxText.prototype.paint = function(ctx, fullRefresh) {
  var r = this.scale;
  /** @type {number} */
  var t = this.bounds.x / r;
  /** @type {number} */
  var value = this.bounds.y / r;
  /** @type {number} */
  var l = this.bounds.width / r;
  /** @type {number} */
  r = this.bounds.height / r;
  this.updateTransform(ctx, t, value, l, r);
  this.configureCanvas(ctx, t, value, l, r);
  if (fullRefresh) {
    ctx.updateText(t, value, l, r, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.getTextRotation(), this.node);
  } else {
    var lastLineHasText = mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML;
    /** @type {string} */
    var h = lastLineHasText || ctx instanceof mxVmlCanvas2D ? "html" : "";
    var s = this.value;
    if (!(lastLineHasText || "html" != h)) {
      s = mxUtils.htmlEntities(s, false);
    }
    if (!("html" != h || mxUtils.isNode(this.value))) {
      s = mxUtils.replaceTrailingNewlines(s, "<div><br></div>");
    }
    s = !mxUtils.isNode(this.value) && this.replaceLinefeeds && "html" == h ? s.replace(/\n/g, "<br/>") : s;
    var i = this.textDirection;
    if (!(i != mxConstants.TEXT_DIRECTION_AUTO || lastLineHasText)) {
      i = this.getAutoDirection();
    }
    if (i != mxConstants.TEXT_DIRECTION_LTR && i != mxConstants.TEXT_DIRECTION_RTL) {
      /** @type {null} */
      i = null;
    }
    ctx.text(t, value, l, r, s, this.align, this.valign, this.wrap, h, this.overflow, this.clipped, this.getTextRotation(), i);
  }
};
/**
 * @return {undefined}
 */
mxText.prototype.redraw = function() {
  if (this.visible && this.checkBounds() && this.cacheEnabled && this.lastValue == this.value && (mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML)) {
    if ("DIV" != this.node.nodeName || !this.isHtmlAllowed() && mxClient.IS_VML) {
      var self = this.createCanvas();
      if (null != self && null != self.updateText) {
        self.pointerEvents = this.pointerEvents;
        this.paint(self, true);
        this.destroyCanvas(self);
        this.updateBoundingBox();
      } else {
        mxShape.prototype.redraw.apply(this, arguments);
      }
    } else {
      if (mxClient.IS_SVG) {
        this.redrawHtmlShapeWithCss3();
      } else {
        this.updateSize(this.node, null == this.state || null == this.state.view.textDiv);
        if (mxClient.IS_IE && (null == document.documentMode || 8 >= document.documentMode)) {
          this.updateHtmlFilter();
        } else {
          this.updateHtmlTransform();
        }
      }
      this.updateBoundingBox();
    }
  } else {
    mxShape.prototype.redraw.apply(this, arguments);
    if (mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML) {
      this.lastValue = this.value;
    } else {
      /** @type {null} */
      this.lastValue = null;
    }
  }
};
/**
 * @return {undefined}
 */
mxText.prototype.resetStyles = function() {
  mxShape.prototype.resetStyles.apply(this, arguments);
  /** @type {string} */
  this.color = "black";
  this.align = mxConstants.ALIGN_CENTER;
  this.valign = mxConstants.ALIGN_MIDDLE;
  this.family = mxConstants.DEFAULT_FONTFAMILY;
  this.size = mxConstants.DEFAULT_FONTSIZE;
  this.fontStyle = mxConstants.DEFAULT_FONTSTYLE;
  /** @type {number} */
  this.spacingLeft = this.spacingBottom = this.spacingRight = this.spacingTop = this.spacing = 2;
  /** @type {boolean} */
  this.horizontal = true;
  delete this.background;
  delete this.border;
  this.textDirection = mxConstants.DEFAULT_TEXT_DIRECTION;
  delete this.margin;
};
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxText.prototype.apply = function(obj) {
  var spacing = this.spacing;
  mxShape.prototype.apply.apply(this, arguments);
  if (null != this.style) {
    this.fontStyle = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSTYLE, this.fontStyle);
    this.family = mxUtils.getValue(this.style, mxConstants.STYLE_FONTFAMILY, this.family);
    this.size = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, this.size);
    this.color = mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, this.color);
    this.align = mxUtils.getValue(this.style, mxConstants.STYLE_ALIGN, this.align);
    this.valign = mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_ALIGN, this.valign);
    /** @type {number} */
    this.spacing = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing));
    /** @type {number} */
    this.spacingTop = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_TOP, this.spacingTop - spacing)) + this.spacing;
    /** @type {number} */
    this.spacingRight = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_RIGHT, this.spacingRight - spacing)) + this.spacing;
    /** @type {number} */
    this.spacingBottom = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_BOTTOM, this.spacingBottom - spacing)) + this.spacing;
    /** @type {number} */
    this.spacingLeft = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_LEFT, this.spacingLeft - spacing)) + this.spacing;
    this.horizontal = mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, this.horizontal);
    this.background = mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_BACKGROUNDCOLOR, this.background);
    this.border = mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_BORDERCOLOR, this.border);
    this.textDirection = mxUtils.getValue(this.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);
    this.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_TEXT_OPACITY, 100);
    this.updateMargin();
  }
  /** @type {null} */
  this.flipH = this.flipV = null;
};
/**
 * @return {?}
 */
mxText.prototype.getAutoDirection = function() {
  /** @type {(Array<string>|null)} */
  var s = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(this.value);
  return null != s && 0 < s.length && "z" < s[0] ? mxConstants.TEXT_DIRECTION_RTL : mxConstants.TEXT_DIRECTION_LTR;
};
/**
 * @return {?}
 */
mxText.prototype.getContentNode = function() {
  var container = this.node;
  if (null != container) {
    container = null == container.ownerSVGElement ? this.node.firstChild.firstChild : container.firstChild.firstChild.firstChild.firstChild.firstChild;
  }
  return container;
};
/**
 * @return {undefined}
 */
mxText.prototype.updateBoundingBox = function() {
  var element = this.node;
  this.boundingBox = this.bounds.clone();
  var b = this.getTextRotation();
  var left = null != this.style ? mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER) : null;
  var value = null != this.style ? mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE) : null;
  if (!(this.ignoreStringSize || null == element || "fill" == this.overflow || this.clipped && this.ignoreClippedStringSize && left == mxConstants.ALIGN_CENTER && value == mxConstants.ALIGN_MIDDLE)) {
    /** @type {null} */
    value = left = null;
    if (null != element.ownerSVGElement) {
      if (null != element.firstChild && null != element.firstChild.firstChild && "foreignObject" == element.firstChild.firstChild.nodeName) {
        element = element.firstChild.firstChild.firstChild.firstChild;
        /** @type {number} */
        value = element.offsetHeight * this.scale;
        left = "width" == this.overflow ? this.boundingBox.width : element.offsetWidth * this.scale;
      } else {
        try {
          var table = element.getBBox();
          if ("string" == typeof this.value && 0 == mxUtils.trim(this.value)) {
            /** @type {null} */
            this.boundingBox = null;
          } else {
            this.boundingBox = 0 == table.width && 0 == table.height ? null : new mxRectangle(table.x, table.y, table.width, table.height);
          }
          return;
        } catch (f) {
        }
      }
    } else {
      left = null != this.state ? this.state.view.textDiv : null;
      if (null == this.offsetWidth || null == this.offsetHeight) {
        if (null != left) {
          this.updateFont(left);
          this.updateSize(left, false);
          this.updateInnerHtml(left);
          element = left;
        }
        table = element;
        if (8 != document.documentMode || mxClient.IS_EM) {
          if (null != table.firstChild && "DIV" == table.firstChild.nodeName) {
            table = table.firstChild;
          }
        } else {
          /** @type {number} */
          value = Math.round(this.bounds.width / this.scale);
          if (this.wrap && 0 < value) {
            element.style.wordWrap = mxConstants.WORD_WRAP;
            /** @type {string} */
            element.style.whiteSpace = "normal";
            if ("break-word" != element.style.wordWrap) {
              element = table.getElementsByTagName("div");
              if (0 < element.length) {
                table = element[element.length - 1];
              }
              left = table.offsetWidth + 2;
              element = this.node.getElementsByTagName("div");
              if (this.clipped) {
                /** @type {number} */
                left = Math.min(value, left);
              }
              if (1 < element.length) {
                /** @type {string} */
                element[element.length - 2].style.width = left + "px";
              }
            }
          } else {
            /** @type {string} */
            element.style.whiteSpace = "nowrap";
          }
        }
        this.offsetWidth = table.offsetWidth + this.textWidthPadding;
        this.offsetHeight = table.offsetHeight;
      }
      /** @type {number} */
      left = this.offsetWidth * this.scale;
      /** @type {number} */
      value = this.offsetHeight * this.scale;
    }
    if (null != left && null != value) {
      this.boundingBox = new mxRectangle(this.bounds.x, this.bounds.y, left, value);
    }
  }
  if (null != this.boundingBox) {
    if (0 != b) {
      b = mxUtils.getBoundingBox(new mxRectangle(this.margin.x * this.boundingBox.width, this.margin.y * this.boundingBox.height, this.boundingBox.width, this.boundingBox.height), b, new mxPoint(0, 0));
      this.unrotatedBoundingBox = mxRectangle.fromRectangle(this.boundingBox);
      this.unrotatedBoundingBox.x += this.margin.x * this.unrotatedBoundingBox.width;
      this.unrotatedBoundingBox.y += this.margin.y * this.unrotatedBoundingBox.height;
      this.boundingBox.x += b.x;
      this.boundingBox.y += b.y;
      this.boundingBox.width = b.width;
      this.boundingBox.height = b.height;
    } else {
      this.boundingBox.x += this.margin.x * this.boundingBox.width;
      this.boundingBox.y += this.margin.y * this.boundingBox.height;
      /** @type {null} */
      this.unrotatedBoundingBox = null;
    }
  }
};
/**
 * @return {?}
 */
mxText.prototype.getShapeRotation = function() {
  return 0;
};
/**
 * @return {?}
 */
mxText.prototype.getTextRotation = function() {
  return null != this.state && null != this.state.shape ? this.state.shape.getTextRotation() : 0;
};
/**
 * @return {?}
 */
mxText.prototype.isPaintBoundsInverted = function() {
  return !this.horizontal && null != this.state && this.state.view.graph.model.isVertex(this.state.cell);
};
/**
 * @param {!Object} context
 * @param {number} options
 * @param {number} props
 * @param {number} o
 * @param {number} s
 * @return {undefined}
 */
mxText.prototype.configureCanvas = function(context, options, props, o, s) {
  mxShape.prototype.configureCanvas.apply(this, arguments);
  context.setFontColor(this.color);
  context.setFontBackgroundColor(this.background);
  context.setFontBorderColor(this.border);
  context.setFontFamily(this.family);
  context.setFontSize(this.size);
  context.setFontStyle(this.fontStyle);
};
/**
 * @return {undefined}
 */
mxText.prototype.updateVmlContainer = function() {
  /** @type {string} */
  this.node.style.left = Math.round(this.bounds.x) + "px";
  /** @type {string} */
  this.node.style.top = Math.round(this.bounds.y) + "px";
  /** @type {string} */
  this.node.style.width = "1px";
  /** @type {string} */
  this.node.style.height = "1px";
  /** @type {string} */
  this.node.style.overflow = "visible";
};
/**
 * @return {?}
 */
mxText.prototype.getHtmlValue = function() {
  var value = this.value;
  if (this.dialect != mxConstants.DIALECT_STRICTHTML) {
    value = mxUtils.htmlEntities(value, false);
  }
  value = mxUtils.replaceTrailingNewlines(value, "<div><br></div>");
  return value = this.replaceLinefeeds ? value.replace(/\n/g, "<br/>") : value;
};
/**
 * @return {?}
 */
mxText.prototype.getTextCss = function() {
  /** @type {string} */
  var chunkIndex = "display: inline-block; font-size: " + this.size + "px; font-family: " + this.family + "; color: " + this.color + "; line-height: " + (mxConstants.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT) + "; pointer-events: " + (this.pointerEvents ? "all" : "none") + "; ";
  if ((this.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
    /** @type {string} */
    chunkIndex = chunkIndex + "font-weight: bold; ";
  }
  if ((this.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
    /** @type {string} */
    chunkIndex = chunkIndex + "font-style: italic; ";
  }
  /** @type {!Array} */
  var textDecorations = [];
  if ((this.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    textDecorations.push("underline");
  }
  if ((this.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
    textDecorations.push("line-through");
  }
  if (0 < textDecorations.length) {
    /** @type {string} */
    chunkIndex = chunkIndex + ("text-decoration: " + textDecorations.join(" ") + "; ");
  }
  return chunkIndex;
};
/**
 * @return {undefined}
 */
mxText.prototype.redrawHtmlShape = function() {
  if (mxClient.IS_SVG) {
    this.redrawHtmlShapeWithCss3();
  } else {
    var style = this.node.style;
    /** @type {string} */
    style.whiteSpace = "normal";
    /** @type {string} */
    style.overflow = "";
    /** @type {string} */
    style.width = "";
    /** @type {string} */
    style.height = "";
    this.updateValue();
    this.updateFont(this.node);
    this.updateSize(this.node, null == this.state || null == this.state.view.textDiv);
    /** @type {null} */
    this.offsetHeight = this.offsetWidth = null;
    if (mxClient.IS_IE && (null == document.documentMode || 8 >= document.documentMode)) {
      this.updateHtmlFilter();
    } else {
      this.updateHtmlTransform();
    }
  }
};
/**
 * @return {undefined}
 */
mxText.prototype.redrawHtmlShapeWithCss3 = function() {
  /** @type {number} */
  var a = Math.max(0, Math.round(this.bounds.width / this.scale));
  /** @type {number} */
  var IMG_WIDTH = Math.max(0, Math.round(this.bounds.height / this.scale));
  /** @type {string} */
  var skeletonId = "position: absolute; left: " + Math.round(this.bounds.x) + "px; top: " + Math.round(this.bounds.y) + "px; pointer-events: none; ";
  var el_l = this.getTextCss();
  mxSvgCanvas2D.createCss(a + 2, IMG_WIDTH, this.align, this.valign, this.wrap, this.overflow, this.clipped, null != this.background ? mxUtils.htmlEntities(this.background) : null, null != this.border ? mxUtils.htmlEntities(this.border) : null, skeletonId, el_l, this.scale, mxUtils.bind(this, function(c, b, name, s, i, key) {
    c = this.getTextRotation();
    /** @type {string} */
    c = (1 != this.scale ? "scale(" + this.scale + ") " : "") + (0 != c ? "rotate(" + c + "deg) " : "") + (0 != this.margin.x || 0 != this.margin.y ? "translate(" + 100 * this.margin.x + "%," + 100 * this.margin.y + "%)" : "");
    if ("" != c) {
      /** @type {string} */
      c = "transform-origin: 0 0; transform: " + c + "; ";
    }
    if ("" == key) {
      name = name + s;
      /** @type {string} */
      s = "display:inline-block; min-width: 100%; " + c;
    } else {
      /** @type {string} */
      s = s + c;
      if (mxClient.IS_SF) {
        /** @type {string} */
        s = s + "-webkit-clip-path: content-box;";
      }
    }
    if (100 > this.opacity) {
      /** @type {string} */
      i = i + ("opacity: " + this.opacity / 100 + "; ");
    }
    this.node.setAttribute("style", name);
    name = mxUtils.isNode(this.value) ? this.value.outerHTML : this.getHtmlValue();
    if (null == this.node.firstChild) {
      /** @type {string} */
      this.node.innerHTML = "<div><div>" + name + "</div></div>";
    }
    this.node.firstChild.firstChild.setAttribute("style", i);
    this.node.firstChild.setAttribute("style", s);
  }));
};
/**
 * @return {undefined}
 */
mxText.prototype.updateHtmlTransform = function() {
  var a = this.getTextRotation();
  var style = this.node.style;
  var x = this.margin.x;
  var cy = this.margin.y;
  if (0 != a) {
    mxUtils.setPrefixedStyle(style, "transformOrigin", 100 * -x + "% " + 100 * -cy + "%");
    mxUtils.setPrefixedStyle(style, "transform", "translate(" + 100 * x + "%," + 100 * cy + "%) scale(" + this.scale + ") rotate(" + a + "deg)");
  } else {
    mxUtils.setPrefixedStyle(style, "transformOrigin", "0% 0%");
    mxUtils.setPrefixedStyle(style, "transform", "scale(" + this.scale + ") translate(" + 100 * x + "%," + 100 * cy + "%)");
  }
  /** @type {string} */
  style.left = Math.round(this.bounds.x - Math.ceil(x * ("fill" != this.overflow && "width" != this.overflow ? 3 : 1))) + "px";
  /** @type {string} */
  style.top = Math.round(this.bounds.y - cy * ("fill" != this.overflow ? 3 : 1)) + "px";
  /** @type {(number|string)} */
  style.opacity = 100 > this.opacity ? this.opacity / 100 : "";
};
/**
 * @param {!Object} p
 * @return {undefined}
 */
mxText.prototype.updateInnerHtml = function(p) {
  if (mxUtils.isNode(this.value)) {
    p.innerHTML = this.value.outerHTML;
  } else {
    var value = this.value;
    if (this.dialect != mxConstants.DIALECT_STRICTHTML) {
      value = mxUtils.htmlEntities(value, false);
    }
    value = mxUtils.replaceTrailingNewlines(value, "<div>&nbsp;</div>");
    value = this.replaceLinefeeds ? value.replace(/\n/g, "<br/>") : value;
    /** @type {string} */
    p.innerHTML = '<div style="display:inline-block;_display:inline;">' + value + "</div>";
  }
};
/**
 * @return {undefined}
 */
mxText.prototype.updateHtmlFilter = function() {
  var s = this.node.style;
  var offset = this.margin.x;
  var shiftY = this.margin.y;
  var scale = this.scale;
  mxUtils.setOpacity(this.node, this.opacity);
  var height;
  /** @type {number} */
  var value = 0;
  var i = null != this.state ? this.state.view.textDiv : null;
  var a = this.node;
  if (null != i) {
    /** @type {string} */
    i.style.overflow = "";
    /** @type {string} */
    i.style.height = "";
    /** @type {string} */
    i.style.width = "";
    this.updateFont(i);
    this.updateSize(i, false);
    this.updateInnerHtml(i);
    /** @type {number} */
    var y = Math.round(this.bounds.width / this.scale);
    if (this.wrap && 0 < y) {
      /** @type {string} */
      i.style.whiteSpace = "normal";
      i.style.wordWrap = mxConstants.WORD_WRAP;
      /** @type {number} */
      height = y;
      if (this.clipped) {
        /** @type {number} */
        height = Math.min(height, this.bounds.width);
      }
      /** @type {string} */
      i.style.width = height + "px";
    } else {
      /** @type {string} */
      i.style.whiteSpace = "nowrap";
    }
    a = i;
    if (null != a.firstChild && "DIV" == a.firstChild.nodeName) {
      a = a.firstChild;
      if (this.wrap && "break-word" == i.style.wordWrap) {
        /** @type {string} */
        a.style.width = "100%";
      }
    }
    if (!this.clipped && this.wrap && 0 < y) {
      height = a.offsetWidth + this.textWidthPadding;
      /** @type {string} */
      i.style.width = height + "px";
    }
    value = a.offsetHeight + 2;
    if (mxClient.IS_QUIRKS && null != this.border && this.border != mxConstants.NONE) {
      value = value + 3;
    }
  } else {
    if (null != a.firstChild && "DIV" == a.firstChild.nodeName) {
      a = a.firstChild;
      value = a.offsetHeight;
    }
  }
  height = a.offsetWidth + this.textWidthPadding;
  if (this.clipped) {
    /** @type {number} */
    value = Math.min(value, this.bounds.height);
  }
  /** @type {number} */
  y = this.bounds.width / scale;
  /** @type {number} */
  i = this.bounds.height / scale;
  if ("fill" == this.overflow) {
    /** @type {number} */
    value = i;
    /** @type {number} */
    height = y;
  } else {
    if ("width" == this.overflow) {
      value = a.scrollHeight;
      /** @type {number} */
      height = y;
    }
  }
  this.offsetWidth = height;
  this.offsetHeight = value;
  if (mxClient.IS_QUIRKS && (this.clipped || "width" == this.overflow && 0 < i)) {
    /** @type {number} */
    i = Math.min(i, value);
    /** @type {string} */
    s.height = Math.round(i) + "px";
  } else {
    i = value;
  }
  if ("fill" != this.overflow && "width" != this.overflow && (this.clipped && (height = Math.min(y, height)), y = height, mxClient.IS_QUIRKS && this.clipped || this.wrap)) {
    /** @type {string} */
    s.width = Math.round(y) + "px";
  }
  /** @type {number} */
  i = i * scale;
  /** @type {number} */
  y = y * scale;
  /** @type {number} */
  var angle = this.getTextRotation() * (Math.PI / 180);
  /** @type {number} */
  height = parseFloat(parseFloat(Math.cos(angle)).toFixed(8));
  /** @type {number} */
  value = parseFloat(parseFloat(Math.sin(-angle)).toFixed(8));
  /** @type {number} */
  angle = angle % (2 * Math.PI);
  if (0 > angle) {
    /** @type {number} */
    angle = angle + 2 * Math.PI;
  }
  /** @type {number} */
  angle = angle % Math.PI;
  if (angle > Math.PI / 2) {
    /** @type {number} */
    angle = Math.PI - angle;
  }
  /** @type {number} */
  a = Math.cos(angle);
  /** @type {number} */
  var spacing = Math.sin(-angle);
  /** @type {number} */
  offset = y * -(offset + .5);
  /** @type {number} */
  var r = i * -(shiftY + .5);
  if (0 != angle) {
    /** @type {string} */
    shiftY = "progid:DXImageTransform.Microsoft.Matrix(M11=" + height + ", M12=" + value + ", M21=" + -value + ", M22=" + height + ", sizingMethod='auto expand')";
    /** @type {string} */
    s.filter = null != s.filter && 0 < s.filter.length ? s.filter + (" " + shiftY) : shiftY;
  }
  /** @type {number} */
  shiftY = 0;
  if ("fill" != this.overflow && mxClient.IS_QUIRKS) {
    /** @type {number} */
    shiftY = this.valign == mxConstants.ALIGN_TOP ? shiftY - 1 : this.valign == mxConstants.ALIGN_BOTTOM ? shiftY + 2 : shiftY + 1;
  }
  s.zoom = scale;
  /** @type {string} */
  s.left = Math.round(this.bounds.x + ((y - y * a + i * spacing) / 2 - height * offset - value * r) - y / 2) + "px";
  /** @type {string} */
  s.top = Math.round(this.bounds.y + ((i - i * a + y * spacing) / 2 + value * offset - height * r) - i / 2 + shiftY) + "px";
};
/**
 * @return {undefined}
 */
mxText.prototype.updateValue = function() {
  if (mxUtils.isNode(this.value)) {
    /** @type {string} */
    this.node.innerHTML = "";
    this.node.appendChild(this.value);
  } else {
    var text = this.value;
    if (this.dialect != mxConstants.DIALECT_STRICTHTML) {
      text = mxUtils.htmlEntities(text, false);
    }
    text = mxUtils.replaceTrailingNewlines(text, "<div><br></div>");
    text = this.replaceLinefeeds ? text.replace(/\n/g, "<br/>") : text;
    var value = null != this.background && this.background != mxConstants.NONE ? this.background : null;
    var emoji = null != this.border && this.border != mxConstants.NONE ? this.border : null;
    if ("fill" == this.overflow || "width" == this.overflow) {
      if (null != value) {
        this.node.style.backgroundColor = value;
      }
      if (null != emoji) {
        /** @type {string} */
        this.node.style.border = "1px solid " + emoji;
      }
    } else {
      /** @type {string} */
      var pix_color = "";
      if (null != value) {
        /** @type {string} */
        pix_color = pix_color + ("background-color:" + mxUtils.htmlEntities(value) + ";");
      }
      if (null != emoji) {
        /** @type {string} */
        pix_color = pix_color + ("border:1px solid " + mxUtils.htmlEntities(emoji) + ";");
      }
      /** @type {string} */
      text = '<div style="zoom:1;' + pix_color + "display:inline-block;_display:inline;text-decoration:inherit;padding-bottom:1px;padding-right:1px;line-height:" + (mxConstants.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT) + '">' + text + "</div>";
    }
    this.node.innerHTML = text;
    text = this.node.getElementsByTagName("div");
    if (0 < text.length) {
      value = this.textDirection;
      if (value == mxConstants.TEXT_DIRECTION_AUTO && this.dialect != mxConstants.DIALECT_STRICTHTML) {
        value = this.getAutoDirection();
      }
      if (value == mxConstants.TEXT_DIRECTION_LTR || value == mxConstants.TEXT_DIRECTION_RTL) {
        text[text.length - 1].setAttribute("dir", value);
      } else {
        text[text.length - 1].removeAttribute("dir");
      }
    }
  }
};
/**
 * @param {!Object} style
 * @return {undefined}
 */
mxText.prototype.updateFont = function(style) {
  style = style.style;
  style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT;
  /** @type {string} */
  style.fontSize = this.size + "px";
  style.fontFamily = this.family;
  /** @type {string} */
  style.verticalAlign = "top";
  style.color = this.color;
  /** @type {string} */
  style.fontWeight = (this.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD ? "bold" : "";
  /** @type {string} */
  style.fontStyle = (this.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC ? "italic" : "";
  /** @type {!Array} */
  var textDecorations = [];
  if ((this.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    textDecorations.push("underline");
  }
  if ((this.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
    textDecorations.push("line-through");
  }
  /** @type {string} */
  style.textDecoration = textDecorations.join(" ");
  /** @type {string} */
  style.textAlign = this.align == mxConstants.ALIGN_CENTER ? "center" : this.align == mxConstants.ALIGN_RIGHT ? "right" : "left";
};
/**
 * @param {!Object} element
 * @param {boolean} height
 * @return {undefined}
 */
mxText.prototype.updateSize = function(element, height) {
  /** @type {number} */
  var width = Math.max(0, Math.round(this.bounds.width / this.scale));
  /** @type {number} */
  var t = Math.max(0, Math.round(this.bounds.height / this.scale));
  var style = element.style;
  if (this.clipped) {
    /** @type {string} */
    style.overflow = "hidden";
    if (mxClient.IS_QUIRKS) {
      /** @type {string} */
      style.width = width + "px";
    } else {
      /** @type {string} */
      style.maxHeight = t + "px";
      /** @type {string} */
      style.maxWidth = width + "px";
    }
  } else {
    if ("fill" == this.overflow) {
      /** @type {string} */
      style.width = width + 1 + "px";
      /** @type {string} */
      style.height = t + 1 + "px";
      /** @type {string} */
      style.overflow = "hidden";
    } else {
      if ("width" == this.overflow) {
        /** @type {string} */
        style.width = width + 1 + "px";
        /** @type {string} */
        style.maxHeight = t + 1 + "px";
        /** @type {string} */
        style.overflow = "hidden";
      }
    }
  }
  if (this.wrap && 0 < width) {
    if (style.wordWrap = mxConstants.WORD_WRAP, style.whiteSpace = "normal", style.width = width + "px", height && "fill" != this.overflow && "width" != this.overflow) {
      /** @type {!Object} */
      t = element;
      if (null != t.firstChild && "DIV" == t.firstChild.nodeName) {
        t = t.firstChild;
        if ("break-word" == element.style.wordWrap) {
          /** @type {string} */
          t.style.width = "100%";
        }
      }
      var w = t.offsetWidth;
      if (0 == w) {
        var paren = element.parentNode;
        /** @type {string} */
        element.style.visibility = "hidden";
        document.body.appendChild(element);
        w = t.offsetWidth;
        /** @type {string} */
        element.style.visibility = "";
        paren.appendChild(element);
      }
      w = w + 3;
      if (this.clipped) {
        /** @type {number} */
        w = Math.min(w, width);
      }
      /** @type {string} */
      style.width = w + "px";
    }
  } else {
    /** @type {string} */
    style.whiteSpace = "nowrap";
  }
};
/**
 * @return {undefined}
 */
mxText.prototype.updateMargin = function() {
  this.margin = mxUtils.getAlignmentAsPoint(this.align, this.valign);
};
/**
 * @return {?}
 */
mxText.prototype.getSpacing = function() {
  return new mxPoint(this.align == mxConstants.ALIGN_CENTER ? (this.spacingLeft - this.spacingRight) / 2 : this.align == mxConstants.ALIGN_RIGHT ? -this.spacingRight - this.baseSpacingRight : this.spacingLeft + this.baseSpacingLeft, this.valign == mxConstants.ALIGN_MIDDLE ? (this.spacingTop - this.spacingBottom) / 2 : this.valign == mxConstants.ALIGN_BOTTOM ? -this.spacingBottom - this.baseSpacingBottom : this.spacingTop + this.baseSpacingTop);
};
/**
 * @return {undefined}
 */
function mxTriangle() {
  mxActor.call(this);
}
mxUtils.extend(mxTriangle, mxActor);
/**
 * @return {?}
 */
mxTriangle.prototype.isRoundable = function() {
  return true;
};
/**
 * @param {!Object} path
 * @param {number} c
 * @param {number} arg
 * @param {number} width
 * @param {number} height
 * @return {undefined}
 */
mxTriangle.prototype.redrawPath = function(path, c, arg, width, height) {
  /** @type {number} */
  c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  this.addPoints(path, [new mxPoint(0, 0), new mxPoint(width, .5 * height), new mxPoint(0, height)], this.isRounded, c, true);
};
/**
 * @return {undefined}
 */
function mxHexagon() {
  mxActor.call(this);
}
mxUtils.extend(mxHexagon, mxActor);
/**
 * @param {!Object} path
 * @param {number} c
 * @param {number} arg
 * @param {number} width
 * @param {number} height
 * @return {undefined}
 */
mxHexagon.prototype.redrawPath = function(path, c, arg, width, height) {
  /** @type {number} */
  c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  this.addPoints(path, [new mxPoint(.25 * width, 0), new mxPoint(.75 * width, 0), new mxPoint(width, .5 * height), new mxPoint(.75 * width, height), new mxPoint(.25 * width, height), new mxPoint(0, .5 * height)], this.isRounded, c, true);
};
/**
 * @param {!Object} bounds
 * @param {!Object} size
 * @param {number} c
 * @param {number} initlength
 * @return {undefined}
 */
function mxLine(bounds, size, c, initlength) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != c ? c : 1;
  this.vertical = null != initlength ? initlength : this.vertical;
}
mxUtils.extend(mxLine, mxShape);
/** @type {boolean} */
mxLine.prototype.vertical = false;
/**
 * @param {!Object} ctx
 * @param {number} x
 * @param {number} r
 * @param {number} w
 * @param {number} t
 * @return {undefined}
 */
mxLine.prototype.paintVertexShape = function(ctx, x, r, w, t) {
  ctx.begin();
  if (this.vertical) {
    var y = x + w / 2;
    ctx.moveTo(y, r);
    ctx.lineTo(y, r + t);
  } else {
    y = r + t / 2;
    ctx.moveTo(x, y);
    ctx.lineTo(x + w, y);
  }
  ctx.stroke();
};
/**
 * @param {!Object} radius
 * @param {number} canvas
 * @param {string} fill
 * @param {!Object} stroke
 * @param {number} strokewidth
 * @return {undefined}
 */
function mxImageShape(radius, canvas, fill, stroke, strokewidth) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = radius;
  /** @type {number} */
  this.image = canvas;
  /** @type {string} */
  this.fill = fill;
  /** @type {!Object} */
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
  /** @type {boolean} */
  this.shadow = false;
}
mxUtils.extend(mxImageShape, mxRectangleShape);
/** @type {boolean} */
mxImageShape.prototype.preserveImageAspect = true;
/**
 * @return {?}
 */
mxImageShape.prototype.getSvgScreenOffset = function() {
  return 0;
};
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxImageShape.prototype.apply = function(obj) {
  mxShape.prototype.apply.apply(this, arguments);
  /** @type {null} */
  this.gradient = this.stroke = this.fill = null;
  if (null != this.style) {
    /** @type {boolean} */
    this.preserveImageAspect = 1 == mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_ASPECT, 1);
    this.flipH = this.flipH || 1 == mxUtils.getValue(this.style, "imageFlipH", 0);
    this.flipV = this.flipV || 1 == mxUtils.getValue(this.style, "imageFlipV", 0);
  }
};
/**
 * @return {?}
 */
mxImageShape.prototype.isHtmlAllowed = function() {
  return !this.preserveImageAspect;
};
/**
 * @return {?}
 */
mxImageShape.prototype.createHtml = function() {
  /** @type {!Element} */
  var b = document.createElement("div");
  /** @type {string} */
  b.style.position = "absolute";
  return b;
};
/**
 * @param {?} a
 * @param {?} b
 * @param {?} variableNames
 * @param {?} bindingRecords
 * @param {?} eventRecords
 * @return {?}
 */
mxImageShape.prototype.isRoundable = function(a, b, variableNames, bindingRecords, eventRecords) {
  return false;
};
/**
 * @param {!Object} ctx
 * @param {number} i
 * @param {number} y
 * @param {number} x
 * @param {number} width
 * @return {undefined}
 */
mxImageShape.prototype.paintVertexShape = function(ctx, i, y, x, width) {
  if (null != this.image) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, null);
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, null);
    if (null != fillColor) {
      ctx.setFillColor(fillColor);
      ctx.setStrokeColor(strokeColor);
      ctx.rect(i, y, x, width);
      ctx.fillAndStroke();
    }
    ctx.image(i, y, x, width, this.image, this.preserveImageAspect, false, false);
    strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, null);
    if (null != strokeColor) {
      ctx.setShadow(false);
      ctx.setStrokeColor(strokeColor);
      ctx.rect(i, y, x, width);
      ctx.stroke();
    }
  } else {
    mxRectangleShape.prototype.paintBackground.apply(this, arguments);
  }
};
/**
 * @return {undefined}
 */
mxImageShape.prototype.redrawHtmlShape = function() {
  /** @type {string} */
  this.node.style.left = Math.round(this.bounds.x) + "px";
  /** @type {string} */
  this.node.style.top = Math.round(this.bounds.y) + "px";
  /** @type {string} */
  this.node.style.width = Math.max(0, Math.round(this.bounds.width)) + "px";
  /** @type {string} */
  this.node.style.height = Math.max(0, Math.round(this.bounds.height)) + "px";
  /** @type {string} */
  this.node.innerHTML = "";
  if (null != this.image) {
    var obj = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, "");
    var value = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, "");
    this.node.style.backgroundColor = obj;
    this.node.style.borderColor = value;
    /** @type {!Element} */
    obj = document.createElement(mxClient.IS_IE6 || (null == document.documentMode || 8 >= document.documentMode) && 0 != this.rotation ? mxClient.VML_PREFIX + ":image" : "img");
    obj.setAttribute("border", "0");
    /** @type {string} */
    obj.style.position = "absolute";
    obj.src = this.image;
    /** @type {string} */
    value = 100 > this.opacity ? "alpha(opacity=" + this.opacity + ")" : "";
    /** @type {string} */
    this.node.style.filter = value;
    if (this.flipH && this.flipV) {
      /** @type {string} */
      value = value + "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";
    } else {
      if (this.flipH) {
        /** @type {string} */
        value = value + "progid:DXImageTransform.Microsoft.BasicImage(mirror=1)";
      } else {
        if (this.flipV) {
          /** @type {string} */
          value = value + "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
        }
      }
    }
    if (obj.style.filter != value) {
      /** @type {string} */
      obj.style.filter = value;
    }
    if ("image" == obj.nodeName) {
      obj.style.rotation = this.rotation;
    } else {
      if (0 != this.rotation) {
        mxUtils.setPrefixedStyle(obj.style, "transform", "rotate(" + this.rotation + "deg)");
      } else {
        mxUtils.setPrefixedStyle(obj.style, "transform", "");
      }
    }
    /** @type {string} */
    obj.style.width = this.node.style.width;
    /** @type {string} */
    obj.style.height = this.node.style.height;
    /** @type {string} */
    this.node.style.backgroundImage = "";
    this.node.appendChild(obj);
  } else {
    this.setTransparentBackgroundImage(this.node);
  }
};
/**
 * @param {?} a
 * @param {?} b
 * @param {?} c
 * @param {?} quality
 * @return {undefined}
 */
function mxLabel(a, b, c, quality) {
  mxRectangleShape.call(this, a, b, c, quality);
}
mxUtils.extend(mxLabel, mxRectangleShape);
/** @type {number} */
mxLabel.prototype.imageSize = mxConstants.DEFAULT_IMAGESIZE;
/** @type {number} */
mxLabel.prototype.spacing = 2;
/** @type {number} */
mxLabel.prototype.indicatorSize = 10;
/** @type {number} */
mxLabel.prototype.indicatorSpacing = 2;
/**
 * @param {string} key
 * @return {undefined}
 */
mxLabel.prototype.init = function(key) {
  mxShape.prototype.init.apply(this, arguments);
  if (null != this.indicatorShape) {
    this.indicator = new this.indicatorShape;
    this.indicator.dialect = this.dialect;
    this.indicator.init(this.node);
  }
};
/**
 * @return {undefined}
 */
mxLabel.prototype.redraw = function() {
  if (null != this.indicator) {
    this.indicator.fill = this.indicatorColor;
    this.indicator.stroke = this.indicatorStrokeColor;
    this.indicator.gradient = this.indicatorGradientColor;
    this.indicator.direction = this.indicatorDirection;
    this.indicator.redraw();
  }
  mxShape.prototype.redraw.apply(this, arguments);
};
/**
 * @return {?}
 */
mxLabel.prototype.isHtmlAllowed = function() {
  return mxRectangleShape.prototype.isHtmlAllowed.apply(this, arguments) && null == this.indicatorColor && null == this.indicatorShape;
};
/**
 * @param {!Object} ctx
 * @param {number} img
 * @param {number} mode
 * @param {number} context
 * @param {number} x
 * @return {undefined}
 */
mxLabel.prototype.paintForeground = function(ctx, img, mode, context, x) {
  this.paintImage(ctx, img, mode, context, x);
  this.paintIndicator(ctx, img, mode, context, x);
  mxRectangleShape.prototype.paintForeground.apply(this, arguments);
};
/**
 * @param {!Object} ctx
 * @param {number} image
 * @param {number} y
 * @param {number} name
 * @param {number} x
 * @return {undefined}
 */
mxLabel.prototype.paintImage = function(ctx, image, y, name, x) {
  if (null != this.image) {
    image = this.getImageBounds(image, y, name, x);
    ctx.image(image.x, image.y, image.width, image.height, this.image, false, false, false);
  }
};
/**
 * @param {number} y
 * @param {number} x
 * @param {number} k
 * @param {number} r
 * @return {?}
 */
mxLabel.prototype.getImageBounds = function(y, x, k, r) {
  var align = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT);
  var valign = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
  var w = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_WIDTH, mxConstants.DEFAULT_IMAGESIZE);
  var splitLineLen = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_HEIGHT, mxConstants.DEFAULT_IMAGESIZE);
  var distance = mxUtils.getNumber(this.style, mxConstants.STYLE_SPACING, this.spacing) + 5;
  y = align == mxConstants.ALIGN_CENTER ? y + (k - w) / 2 : align == mxConstants.ALIGN_RIGHT ? y + (k - w - distance) : y + distance;
  x = valign == mxConstants.ALIGN_TOP ? x + distance : valign == mxConstants.ALIGN_BOTTOM ? x + (r - splitLineLen - distance) : x + (r - splitLineLen) / 2;
  return new mxRectangle(y, x, w, splitLineLen);
};
/**
 * @param {!Object} ctx
 * @param {number} data
 * @param {number} y
 * @param {number} s
 * @param {number} h
 * @return {undefined}
 */
mxLabel.prototype.paintIndicator = function(ctx, data, y, s, h) {
  if (null != this.indicator) {
    this.indicator.bounds = this.getIndicatorBounds(data, y, s, h);
    this.indicator.paint(ctx);
  } else {
    if (null != this.indicatorImage) {
      data = this.getIndicatorBounds(data, y, s, h);
      ctx.image(data.x, data.y, data.width, data.height, this.indicatorImage, false, false, false);
    }
  }
};
/**
 * @param {number} y
 * @param {number} x
 * @param {number} r
 * @param {number} height
 * @return {?}
 */
mxLabel.prototype.getIndicatorBounds = function(y, x, r, height) {
  var align = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT);
  var valign = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
  var w = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_WIDTH, this.indicatorSize);
  var textHeight = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_HEIGHT, this.indicatorSize);
  var distance = this.spacing + 5;
  y = align == mxConstants.ALIGN_RIGHT ? y + (r - w - distance) : align == mxConstants.ALIGN_CENTER ? y + (r - w) / 2 : y + distance;
  x = valign == mxConstants.ALIGN_BOTTOM ? x + (height - textHeight - distance) : valign == mxConstants.ALIGN_TOP ? x + distance : x + (height - textHeight) / 2;
  return new mxRectangle(y, x, w, textHeight);
};
/**
 * @return {undefined}
 */
mxLabel.prototype.redrawHtmlShape = function() {
  mxRectangleShape.prototype.redrawHtmlShape.apply(this, arguments);
  for (; this.node.hasChildNodes();) {
    this.node.removeChild(this.node.lastChild);
  }
  if (null != this.image) {
    /** @type {!Element} */
    var img = document.createElement("img");
    /** @type {string} */
    img.style.position = "relative";
    img.setAttribute("border", "0");
    var size = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
    size.x -= this.bounds.x;
    size.y -= this.bounds.y;
    /** @type {string} */
    img.style.left = Math.round(size.x) + "px";
    /** @type {string} */
    img.style.top = Math.round(size.y) + "px";
    /** @type {string} */
    img.style.width = Math.round(size.width) + "px";
    /** @type {string} */
    img.style.height = Math.round(size.height) + "px";
    img.src = this.image;
    this.node.appendChild(img);
  }
};
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxCylinder(bounds, value, size, intSetSource) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxCylinder, mxShape);
/** @type {number} */
mxCylinder.prototype.maxHeight = 40;
/** @type {number} */
mxCylinder.prototype.svgStrokeTolerance = 0;
/**
 * @param {!Object} path
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @return {undefined}
 */
mxCylinder.prototype.paintVertexShape = function(path, x, y, w, h) {
  path.translate(x, y);
  path.begin();
  this.redrawPath(path, x, y, w, h, false);
  path.fillAndStroke();
  if (!(this.outline && null != this.style && 0 != mxUtils.getValue(this.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0))) {
    path.setShadow(false);
    path.begin();
    this.redrawPath(path, x, y, w, h, true);
    path.stroke();
  }
};
/**
 * @param {number} val
 * @param {number} dim
 * @param {number} n
 * @param {number} units
 * @return {?}
 */
mxCylinder.prototype.getCylinderSize = function(val, dim, n, units) {
  return Math.min(this.maxHeight, Math.round(units / 5));
};
/**
 * @param {!Object} path
 * @param {number} r
 * @param {number} h
 * @param {number} x
 * @param {number} y
 * @param {string} width
 * @return {undefined}
 */
mxCylinder.prototype.redrawPath = function(path, r, h, x, y, width) {
  r = this.getCylinderSize(r, h, x, y);
  if (width && null != this.fill || !width && null == this.fill) {
    path.moveTo(0, r);
    path.curveTo(0, 2 * r, x, 2 * r, x, r);
    if (!width) {
      path.stroke();
      path.begin();
    }
  }
  if (!width) {
    path.moveTo(0, r);
    path.curveTo(0, -r / 3, x, -r / 3, x, r);
    path.lineTo(x, y - r);
    path.curveTo(x, y + r / 3, 0, y + r / 3, 0, y - r);
    path.close();
  }
};
/**
 * @param {?} a
 * @param {?} b
 * @param {?} rev
 * @return {undefined}
 */
function mxConnector(a, b, rev) {
  mxPolyline.call(this, a, b, rev);
}
mxUtils.extend(mxConnector, mxPolyline);
/**
 * @return {undefined}
 */
mxConnector.prototype.updateBoundingBox = function() {
  /** @type {boolean} */
  this.useSvgBoundingBox = null != this.style && 1 == this.style[mxConstants.STYLE_CURVED];
  mxShape.prototype.updateBoundingBox.apply(this, arguments);
};
/**
 * @param {!Object} ctx
 * @param {undefined} options
 * @return {undefined}
 */
mxConnector.prototype.paintEdgeShape = function(ctx, options) {
  var triangle = this.createMarker(ctx, options, true);
  var logger = this.createMarker(ctx, options, false);
  mxPolyline.prototype.paintEdgeShape.apply(this, arguments);
  ctx.setFillColor(this.stroke);
  ctx.setShadow(false);
  ctx.setDashed(false);
  if (null != triangle) {
    triangle();
  }
  if (null != logger) {
    logger();
  }
};
/**
 * @param {!Object} id
 * @param {number} n
 * @param {boolean} e
 * @return {?}
 */
mxConnector.prototype.createMarker = function(id, n, e) {
  /** @type {null} */
  var i = null;
  var l = n.length;
  var row = mxUtils.getValue(this.style, e ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW);
  var event = e ? n[1] : n[l - 2];
  var self = e ? n[0] : n[l - 1];
  if (null != row && null != event && null != self) {
    /** @type {number} */
    i = 1;
    for (; i < l - 1 && 0 == Math.round(event.x - self.x) && 0 == Math.round(event.y - self.y);) {
      event = e ? n[1 + i] : n[l - 2 - i];
      i++;
    }
    /** @type {number} */
    n = self.x - event.x;
    /** @type {number} */
    l = self.y - event.y;
    /** @type {number} */
    i = Math.max(1, Math.sqrt(n * n + l * l));
    /** @type {number} */
    event = n / i;
    /** @type {number} */
    n = l / i;
    l = mxUtils.getNumber(this.style, e ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE);
    i = mxMarker.createMarker(id, this, row, self, event, n, l, e, this.strokewidth, 0 != this.style[e ? mxConstants.STYLE_STARTFILL : mxConstants.STYLE_ENDFILL]);
  }
  return i;
};
/**
 * @param {?} bbox
 * @return {undefined}
 */
mxConnector.prototype.augmentBoundingBox = function(bbox) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  /** @type {number} */
  var radius = 0;
  if (mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE) {
    radius = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_MARKERSIZE) + 1;
  }
  if (mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE) {
    /** @type {number} */
    radius = Math.max(radius, mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE)) + 1;
  }
  bbox.grow(radius * this.scale);
};
/**
 * @param {!Object} bounds
 * @param {string} value
 * @param {!Object} size
 * @param {number} intSetSource
 * @return {undefined}
 */
function mxSwimlane(bounds, value, size, intSetSource) {
  mxShape.call(this);
  /** @type {!Object} */
  this.bounds = bounds;
  /** @type {string} */
  this.fill = value;
  /** @type {!Object} */
  this.stroke = size;
  this.strokewidth = null != intSetSource ? intSetSource : 1;
}
mxUtils.extend(mxSwimlane, mxShape);
/** @type {number} */
mxSwimlane.prototype.imageSize = 16;
/**
 * @param {?} a
 * @param {?} b
 * @param {?} variableNames
 * @param {?} bindingRecords
 * @param {?} eventRecords
 * @return {?}
 */
mxSwimlane.prototype.isRoundable = function(a, b, variableNames, bindingRecords, eventRecords) {
  return true;
};
/**
 * @return {?}
 */
mxSwimlane.prototype.getTitleSize = function() {
  return Math.max(0, mxUtils.getValue(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
};
/**
 * @param {!Object} b
 * @return {?}
 */
mxSwimlane.prototype.getLabelBounds = function(b) {
  var width = this.getTitleSize();
  b = new mxRectangle(b.x, b.y, b.width, b.height);
  var variable = this.isHorizontal();
  /** @type {boolean} */
  var inputWin = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0);
  /** @type {boolean} */
  var winRef = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0);
  /** @type {boolean} */
  var undefined = this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH;
  /** @type {boolean} */
  variable = variable == !undefined;
  /** @type {boolean} */
  inputWin = !variable && inputWin != (this.direction == mxConstants.DIRECTION_SOUTH || this.direction == mxConstants.DIRECTION_WEST);
  /** @type {boolean} */
  winRef = variable && winRef != (this.direction == mxConstants.DIRECTION_SOUTH || this.direction == mxConstants.DIRECTION_WEST);
  if (undefined) {
    /** @type {number} */
    width = Math.min(b.width, width * this.scale);
    if (inputWin || winRef) {
      b.x += b.width - width;
    }
    /** @type {number} */
    b.width = width;
  } else {
    /** @type {number} */
    width = Math.min(b.height, width * this.scale);
    if (inputWin || winRef) {
      b.y += b.height - width;
    }
    /** @type {number} */
    b.height = width;
  }
  return b;
};
/**
 * @param {!Object} size
 * @param {!Object} view
 * @param {!Function} elements
 * @param {!Function} height
 * @param {!Function} minHeight
 * @return {?}
 */
mxSwimlane.prototype.getGradientBounds = function(size, view, elements, height, minHeight) {
  size = this.getTitleSize();
  if (this.isHorizontal()) {
    return size = Math.min(size, minHeight), new mxRectangle(view, elements, height, size);
  }
  /** @type {number} */
  size = Math.min(size, height);
  return new mxRectangle(view, elements, size, minHeight);
};
/**
 * @param {number} y
 * @param {number} index
 * @param {number} prop
 * @return {?}
 */
mxSwimlane.prototype.getSwimlaneArcSize = function(y, index, prop) {
  if ("1" == mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0)) {
    return Math.min(y / 2, Math.min(index / 2, mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2));
  }
  /** @type {number} */
  y = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100;
  return prop * y * 3;
};
/**
 * @return {?}
 */
mxSwimlane.prototype.isHorizontal = function() {
  return 1 == mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1);
};
/**
 * @param {!Object} ctx
 * @param {number} m
 * @param {number} r
 * @param {number} n
 * @param {number} p
 * @return {undefined}
 */
mxSwimlane.prototype.paintVertexShape = function(ctx, m, r, n, p) {
  var i = this.getTitleSize();
  var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_FILLCOLOR, mxConstants.NONE);
  /** @type {boolean} */
  var charMidX = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_LINE, 1);
  /** @type {number} */
  var v = 0;
  /** @type {number} */
  i = this.isHorizontal() ? Math.min(i, p) : Math.min(i, n);
  ctx.translate(m, r);
  if (this.isRounded) {
    v = this.getSwimlaneArcSize(n, p, i);
    /** @type {number} */
    v = Math.min((this.isHorizontal() ? p : n) - i, Math.min(i, v));
    this.paintRoundedSwimlane(ctx, m, r, n, p, i, v, strokeColor, charMidX);
  } else {
    this.paintSwimlane(ctx, m, r, n, p, i, strokeColor, charMidX);
  }
  strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_SEPARATORCOLOR, mxConstants.NONE);
  this.paintSeparator(ctx, m, r, n, p, i, strokeColor);
  if (null != this.image) {
    p = this.getImageBounds(m, r, n, p);
    ctx.image(p.x - m, p.y - r, p.width, p.height, this.image, false, false, false);
  }
  if (this.glass) {
    ctx.setShadow(false);
    this.paintGlassEffect(ctx, 0, 0, n, i, v);
  }
};
/**
 * @param {!Object} ctx
 * @param {number} shape
 * @param {number} t
 * @param {number} d
 * @param {number} h
 * @param {undefined} r
 * @param {string} color
 * @param {boolean} l
 * @return {undefined}
 */
mxSwimlane.prototype.paintSwimlane = function(ctx, shape, t, d, h, r, color, l) {
  ctx.begin();
  /** @type {boolean} */
  var pointSizeParam = true;
  if (null != this.style) {
    /** @type {boolean} */
    pointSizeParam = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1");
  }
  if (!(pointSizeParam || null != this.fill && this.fill != mxConstants.NONE)) {
    /** @type {boolean} */
    ctx.pointerEvents = false;
  }
  if (this.isHorizontal()) {
    ctx.moveTo(0, r);
    ctx.lineTo(0, 0);
    ctx.lineTo(d, 0);
    ctx.lineTo(d, r);
    ctx.fillAndStroke();
    if (r < h) {
      if (!(color != mxConstants.NONE && pointSizeParam)) {
        /** @type {boolean} */
        ctx.pointerEvents = false;
      }
      if (color != mxConstants.NONE) {
        ctx.setFillColor(color);
      }
      ctx.begin();
      ctx.moveTo(0, r);
      ctx.lineTo(0, h);
      ctx.lineTo(d, h);
      ctx.lineTo(d, r);
      if (color == mxConstants.NONE) {
        ctx.stroke();
      } else {
        ctx.fillAndStroke();
      }
    }
  } else {
    ctx.moveTo(r, 0);
    ctx.lineTo(0, 0);
    ctx.lineTo(0, h);
    ctx.lineTo(r, h);
    ctx.fillAndStroke();
    if (r < d) {
      if (!(color != mxConstants.NONE && pointSizeParam)) {
        /** @type {boolean} */
        ctx.pointerEvents = false;
      }
      if (color != mxConstants.NONE) {
        ctx.setFillColor(color);
      }
      ctx.begin();
      ctx.moveTo(r, 0);
      ctx.lineTo(d, 0);
      ctx.lineTo(d, h);
      ctx.lineTo(r, h);
      if (color == mxConstants.NONE) {
        ctx.stroke();
      } else {
        ctx.fillAndStroke();
      }
    }
  }
  if (l) {
    this.paintDivider(ctx, shape, t, d, h, r, color == mxConstants.NONE);
  }
};
/**
 * @param {!Object} ctx
 * @param {number} t
 * @param {number} f
 * @param {number} x
 * @param {number} h
 * @param {undefined} r
 * @param {number} w
 * @param {string} color
 * @param {boolean} l
 * @return {undefined}
 */
mxSwimlane.prototype.paintRoundedSwimlane = function(ctx, t, f, x, h, r, w, color, l) {
  ctx.begin();
  /** @type {boolean} */
  var m = true;
  if (null != this.style) {
    /** @type {boolean} */
    m = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1");
  }
  if (!(m || null != this.fill && this.fill != mxConstants.NONE)) {
    /** @type {boolean} */
    ctx.pointerEvents = false;
  }
  if (this.isHorizontal()) {
    ctx.moveTo(x, r);
    ctx.lineTo(x, w);
    ctx.quadTo(x, 0, x - Math.min(x / 2, w), 0);
    ctx.lineTo(Math.min(x / 2, w), 0);
    ctx.quadTo(0, 0, 0, w);
    ctx.lineTo(0, r);
    ctx.fillAndStroke();
    if (r < h) {
      if (!(color != mxConstants.NONE && m)) {
        /** @type {boolean} */
        ctx.pointerEvents = false;
      }
      if (color != mxConstants.NONE) {
        ctx.setFillColor(color);
      }
      ctx.begin();
      ctx.moveTo(0, r);
      ctx.lineTo(0, h - w);
      ctx.quadTo(0, h, Math.min(x / 2, w), h);
      ctx.lineTo(x - Math.min(x / 2, w), h);
      ctx.quadTo(x, h, x, h - w);
      ctx.lineTo(x, r);
      if (color == mxConstants.NONE) {
        ctx.stroke();
      } else {
        ctx.fillAndStroke();
      }
    }
  } else {
    ctx.moveTo(r, 0);
    ctx.lineTo(w, 0);
    ctx.quadTo(0, 0, 0, Math.min(h / 2, w));
    ctx.lineTo(0, h - Math.min(h / 2, w));
    ctx.quadTo(0, h, w, h);
    ctx.lineTo(r, h);
    ctx.fillAndStroke();
    if (r < x) {
      if (!(color != mxConstants.NONE && m)) {
        /** @type {boolean} */
        ctx.pointerEvents = false;
      }
      if (color != mxConstants.NONE) {
        ctx.setFillColor(color);
      }
      ctx.begin();
      ctx.moveTo(r, h);
      ctx.lineTo(x - w, h);
      ctx.quadTo(x, h, x, h - Math.min(h / 2, w));
      ctx.lineTo(x, Math.min(h / 2, w));
      ctx.quadTo(x, 0, x - w, 0);
      ctx.lineTo(r, 0);
      if (color == mxConstants.NONE) {
        ctx.stroke();
      } else {
        ctx.fillAndStroke();
      }
    }
  }
  if (l) {
    this.paintDivider(ctx, t, f, x, h, r, color == mxConstants.NONE);
  }
};
/**
 * @param {!Object} ctx
 * @param {number} text
 * @param {number} f
 * @param {number} x
 * @param {number} y
 * @param {number} r
 * @param {boolean} agumentsArr
 * @return {undefined}
 */
mxSwimlane.prototype.paintDivider = function(ctx, text, f, x, y, r, agumentsArr) {
  if (!agumentsArr) {
    ctx.setShadow(false);
  }
  ctx.begin();
  if (this.isHorizontal()) {
    ctx.moveTo(0, r);
    ctx.lineTo(x, r);
  } else {
    ctx.moveTo(r, 0);
    ctx.lineTo(r, y);
  }
  ctx.stroke();
};
/**
 * @param {!Object} ctx
 * @param {number} method
 * @param {number} alpha
 * @param {number} x
 * @param {number} y
 * @param {undefined} r
 * @param {string} stroke
 * @return {undefined}
 */
mxSwimlane.prototype.paintSeparator = function(ctx, method, alpha, x, y, r, stroke) {
  if (stroke != mxConstants.NONE) {
    ctx.setStrokeColor(stroke);
    ctx.setDashed(true);
    ctx.begin();
    if (this.isHorizontal()) {
      ctx.moveTo(x, r);
      ctx.lineTo(x, y);
    } else {
      ctx.moveTo(r, 0);
      ctx.lineTo(x, 0);
    }
    ctx.stroke();
    ctx.setDashed(false);
  }
};
/**
 * @param {number} name
 * @param {number} a
 * @param {number} v
 * @param {number} component
 * @return {?}
 */
mxSwimlane.prototype.getImageBounds = function(name, a, v, component) {
  return this.isHorizontal() ? new mxRectangle(name + v - this.imageSize, a, this.imageSize, this.imageSize) : new mxRectangle(name, a, this.imageSize, this.imageSize);
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxGraphLayout(targetGraph) {
  /** @type {!Object} */
  this.graph = targetGraph;
}
/** @type {null} */
mxGraphLayout.prototype.graph = null;
/** @type {boolean} */
mxGraphLayout.prototype.useBoundingBox = true;
/** @type {null} */
mxGraphLayout.prototype.parent = null;
/**
 * @param {?} index
 * @param {?} id
 * @param {?} destinationId
 * @return {undefined}
 */
mxGraphLayout.prototype.moveCell = function(index, id, destinationId) {
};
/**
 * @param {string} height
 * @param {?} width
 * @return {undefined}
 */
mxGraphLayout.prototype.resizeCell = function(height, width) {
};
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxGraphLayout.prototype.execute = function(obj) {
};
/**
 * @return {?}
 */
mxGraphLayout.prototype.getGraph = function() {
  return this.graph;
};
/**
 * @param {?} name
 * @param {!Object} node
 * @param {?} attributeViewModelBindings
 * @param {?} templateType
 * @return {?}
 */
mxGraphLayout.prototype.getConstraint = function(name, node, attributeViewModelBindings, templateType) {
  return this.graph.getCurrentCellStyle(node)[name];
};
/**
 * @param {?} e
 * @param {?} data
 * @param {?} func
 * @param {number} o
 * @param {!Object} value
 * @return {undefined}
 */
mxGraphLayout.traverse = function(e, data, func, o, value) {
  if (null != func && null != e && (data = null != data ? data : true, value = value || new mxDictionary, !value.get(e) && (value.put(e, true), o = func(e, o), null == o || o)) && (o = this.graph.model.getEdgeCount(e), 0 < o)) {
    /** @type {number} */
    var y = 0;
    for (; y < o; y++) {
      var target = this.graph.model.getEdgeAt(e, y);
      /** @type {boolean} */
      var name = this.graph.model.getTerminal(target, true) == e;
      if (!data || name) {
        name = this.graph.view.getVisibleTerminal(target, !name);
        this.traverse(name, data, func, target, value);
      }
    }
  }
};
/**
 * @param {!Object} element
 * @param {!Object} node
 * @param {?} child
 * @return {?}
 */
mxGraphLayout.prototype.isAncestor = function(element, node, child) {
  if (!child) {
    return this.graph.model.getParent(node) == element;
  }
  if (node == element) {
    return false;
  }
  for (; null != node && node != element;) {
    node = this.graph.model.getParent(node);
  }
  return node == element;
};
/**
 * @param {!Object} name
 * @return {?}
 */
mxGraphLayout.prototype.isVertexMovable = function(name) {
  return this.graph.isCellMovable(name);
};
/**
 * @param {!Object} cell
 * @return {?}
 */
mxGraphLayout.prototype.isVertexIgnored = function(cell) {
  return !this.graph.getModel().isVertex(cell) || !this.graph.isCellVisible(cell);
};
/**
 * @param {string} cell
 * @return {?}
 */
mxGraphLayout.prototype.isEdgeIgnored = function(cell) {
  var model = this.graph.getModel();
  return !model.isEdge(cell) || !this.graph.isCellVisible(cell) || null == model.getTerminal(cell, true) || null == model.getTerminal(cell, false);
};
/**
 * @param {?} text
 * @param {string} isHeavy
 * @return {undefined}
 */
mxGraphLayout.prototype.setEdgeStyleEnabled = function(text, isHeavy) {
  this.graph.setCellStyles(mxConstants.STYLE_NOEDGESTYLE, isHeavy ? "0" : "1", [text]);
};
/**
 * @param {?} cell
 * @param {string} is_resize
 * @return {undefined}
 */
mxGraphLayout.prototype.setOrthogonalEdge = function(cell, is_resize) {
  this.graph.setCellStyles(mxConstants.STYLE_ORTHOGONAL, is_resize ? "1" : "0", [cell]);
};
/**
 * @param {?} element
 * @return {?}
 */
mxGraphLayout.prototype.getParentOffset = function(element) {
  var pt = new mxPoint;
  if (null != element && element != this.parent) {
    var dom = this.graph.getModel();
    if (dom.isAncestor(this.parent, element)) {
      var d = dom.getGeometry(element);
      for (; element != this.parent;) {
        pt.x += d.x;
        pt.y += d.y;
        element = dom.getParent(element);
        d = dom.getGeometry(element);
      }
    }
  }
  return pt;
};
/**
 * @param {!Object} target
 * @param {?} data
 * @return {undefined}
 */
mxGraphLayout.prototype.setEdgePoints = function(target, data) {
  if (null != target) {
    var layer = this.graph.model;
    var res = layer.getGeometry(target);
    if (null == res) {
      res = new mxGeometry;
      res.setRelative(true);
    } else {
      res = res.clone();
    }
    if (null != this.parent && null != data) {
      var about = layer.getParent(target);
      about = this.getParentOffset(about);
      /** @type {number} */
      var i = 0;
      for (; i < data.length; i++) {
        data[i].x -= about.x;
        data[i].y -= about.y;
      }
    }
    res.points = data;
    layer.setGeometry(target, res);
  }
};
/**
 * @param {undefined} element
 * @param {number} x
 * @param {number} y
 * @return {?}
 */
mxGraphLayout.prototype.setVertexLocation = function(element, x, y) {
  var m = this.graph.getModel();
  var c = m.getGeometry(element);
  /** @type {null} */
  var box = null;
  if (null != c) {
    box = new mxRectangle(x, y, c.width, c.height);
    if (this.useBoundingBox) {
      var e = this.graph.getView().getState(element);
      if (null != e && null != e.text && null != e.text.boundingBox) {
        var scale = this.graph.getView().scale;
        var bbox = e.text.boundingBox;
        if (e.text.boundingBox.x < e.x) {
          x = x + (e.x - bbox.x) / scale;
          box.width = bbox.width;
        }
        if (e.text.boundingBox.y < e.y) {
          y = y + (e.y - bbox.y) / scale;
          box.height = bbox.height;
        }
      }
    }
    if (null != this.parent) {
      e = m.getParent(element);
      if (null != e && e != this.parent) {
        e = this.getParentOffset(e);
        /** @type {number} */
        x = x - e.x;
        /** @type {number} */
        y = y - e.y;
      }
    }
    if (c.x != x || c.y != y) {
      c = c.clone();
      /** @type {number} */
      c.x = x;
      /** @type {number} */
      c.y = y;
      m.setGeometry(element, c);
    }
  }
  return box;
};
/**
 * @param {?} el
 * @return {?}
 */
mxGraphLayout.prototype.getVertexBounds = function(el) {
  var pos = this.graph.getModel().getGeometry(el);
  if (this.useBoundingBox) {
    var obj = this.graph.getView().getState(el);
    if (null != obj && null != obj.text && null != obj.text.boundingBox) {
      var rows = this.graph.getView().scale;
      var bb = obj.text.boundingBox;
      /** @type {number} */
      var a = Math.max(obj.x - bb.x, 0) / rows;
      /** @type {number} */
      var height = Math.max(obj.y - bb.y, 0) / rows;
      pos = new mxRectangle(pos.x - a, pos.y - height, pos.width + a + Math.max(bb.x + bb.width - (obj.x + obj.width), 0) / rows, pos.height + height + Math.max(bb.y + bb.height - (obj.y + obj.height), 0) / rows);
    }
  }
  if (null != this.parent) {
    el = this.graph.getModel().getParent(el);
    pos = pos.clone();
    if (null != el && el != this.parent) {
      el = this.getParentOffset(el);
      pos.x += el.x;
      pos.y += el.y;
    }
  }
  return new mxRectangle(pos.x, pos.y, pos.width, pos.height);
};
/**
 * @param {!Object} link
 * @param {undefined} label
 * @param {undefined} callback
 * @param {undefined} obj
 * @param {undefined} start
 * @param {undefined} end
 * @return {?}
 */
mxGraphLayout.prototype.arrangeGroups = function(link, label, callback, obj, start, end) {
  return this.graph.updateGroupBounds(link, label, true, callback, obj, start, end);
};
/**
 * @param {?} cell
 * @param {!Function} heightProbeCell
 * @return {undefined}
 */
function WeightedCellSorter(cell, heightProbeCell) {
  this.cell = cell;
  /** @type {!Function} */
  this.weightedValue = heightProbeCell;
}
/** @type {number} */
WeightedCellSorter.prototype.weightedValue = 0;
/** @type {boolean} */
WeightedCellSorter.prototype.nudge = false;
/** @type {boolean} */
WeightedCellSorter.prototype.visited = false;
/** @type {null} */
WeightedCellSorter.prototype.rankIndex = null;
/** @type {null} */
WeightedCellSorter.prototype.cell = null;
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
WeightedCellSorter.prototype.compare = function(a, b) {
  return null != a && null != b ? b.weightedValue > a.weightedValue ? -1 : b.weightedValue < a.weightedValue ? 1 : b.nudge ? -1 : 1 : 0;
};
/**
 * @param {?} result
 * @param {number} continuation
 * @param {number} name
 * @param {number} status
 * @param {number} e
 * @param {number} islongclick
 * @return {undefined}
 */
function mxStackLayout(result, continuation, name, status, e, islongclick) {
  mxGraphLayout.call(this, result);
  this.horizontal = null != continuation ? continuation : true;
  this.spacing = null != name ? name : 0;
  this.x0 = null != status ? status : 0;
  this.y0 = null != e ? e : 0;
  this.border = null != islongclick ? islongclick : 0;
}
mxStackLayout.prototype = new mxGraphLayout;
/** @type {function(?, number, number, number, number, number): undefined} */
mxStackLayout.prototype.constructor = mxStackLayout;
/** @type {null} */
mxStackLayout.prototype.horizontal = null;
/** @type {null} */
mxStackLayout.prototype.spacing = null;
/** @type {null} */
mxStackLayout.prototype.x0 = null;
/** @type {null} */
mxStackLayout.prototype.y0 = null;
/** @type {number} */
mxStackLayout.prototype.border = 0;
/** @type {number} */
mxStackLayout.prototype.marginTop = 0;
/** @type {number} */
mxStackLayout.prototype.marginLeft = 0;
/** @type {number} */
mxStackLayout.prototype.marginRight = 0;
/** @type {number} */
mxStackLayout.prototype.marginBottom = 0;
/** @type {boolean} */
mxStackLayout.prototype.keepFirstLocation = false;
/** @type {boolean} */
mxStackLayout.prototype.fill = false;
/** @type {boolean} */
mxStackLayout.prototype.resizeParent = false;
/** @type {boolean} */
mxStackLayout.prototype.resizeParentMax = false;
/** @type {boolean} */
mxStackLayout.prototype.resizeLast = false;
/** @type {null} */
mxStackLayout.prototype.wrap = null;
/** @type {boolean} */
mxStackLayout.prototype.borderCollapse = true;
/** @type {boolean} */
mxStackLayout.prototype.allowGaps = false;
/** @type {number} */
mxStackLayout.prototype.gridSize = 0;
/**
 * @return {?}
 */
mxStackLayout.prototype.isHorizontal = function() {
  return this.horizontal;
};
/**
 * @param {(Object|string)} id
 * @param {number} i
 * @param {number} index
 * @return {undefined}
 */
mxStackLayout.prototype.moveCell = function(id, i, index) {
  var self = this.graph.getModel();
  var node = self.getParent(id);
  var last = this.isHorizontal();
  if (null != id && null != node) {
    /** @type {number} */
    var exist = 0;
    var controlFlowActionMsg = self.getChildCount(node);
    index = last ? i : index;
    i = this.graph.getView().getState(node);
    if (null != i) {
      /** @type {number} */
      index = index - (last ? i.x : i.y);
    }
    /** @type {number} */
    index = index / this.graph.view.scale;
    /** @type {number} */
    i = 0;
    for (; i < controlFlowActionMsg; i++) {
      var value = self.getChildAt(node, i);
      if (value != id && (value = self.getGeometry(value), null != value)) {
        value = last ? value.x + value.width / 2 : value.y + value.height / 2;
        if (exist <= index && value > index) {
          break;
        }
        exist = value;
      }
    }
    last = node.getIndex(id);
    /** @type {number} */
    last = Math.max(0, i - (i > last ? 1 : 0));
    self.add(node, id, last);
  }
};
/**
 * @param {(Object|string)} value
 * @return {?}
 */
mxStackLayout.prototype.getParentSize = function(value) {
  var shape = this.graph.getModel();
  var operator = shape.getGeometry(value);
  if (null != this.graph.container && (null == operator && shape.isLayer(value) || value == this.graph.getView().currentRoot)) {
    operator = new mxRectangle(0, 0, this.graph.container.offsetWidth - 1, this.graph.container.offsetHeight - 1);
  }
  return operator;
};
/**
 * @param {!Object} start
 * @return {?}
 */
mxStackLayout.prototype.getLayoutCells = function(start) {
  var menu = this.graph.getModel();
  var sectionLength = menu.getChildCount(start);
  /** @type {!Array} */
  var wordsList = [];
  /** @type {number} */
  var i = 0;
  for (; i < sectionLength; i++) {
    var t = menu.getChildAt(start, i);
    if (!this.isVertexIgnored(t) && this.isVertexMovable(t)) {
      wordsList.push(t);
    }
  }
  if (this.allowGaps) {
    wordsList.sort(mxUtils.bind(this, function(embed, cell) {
      var srcPoint = this.graph.getCellGeometry(embed);
      var tgtPoint = this.graph.getCellGeometry(cell);
      return this.horizontal ? srcPoint.x == tgtPoint.x ? 0 : srcPoint.x > tgtPoint.x > 0 ? 1 : -1 : srcPoint.y == tgtPoint.y ? 0 : srcPoint.y > tgtPoint.y > 0 ? 1 : -1;
    }));
  }
  return wordsList;
};
/**
 * @param {number} pos
 * @return {?}
 */
mxStackLayout.prototype.snap = function(pos) {
  if (null != this.gridSize && 0 < this.gridSize && (pos = Math.max(pos, this.gridSize), 1 < pos / this.gridSize)) {
    /** @type {number} */
    var b = pos % this.gridSize;
    /** @type {number} */
    pos = pos + (b > this.gridSize / 2 ? this.gridSize - b : -b);
  }
  return pos;
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxStackLayout.prototype.execute = function(value) {
  if (null != value) {
    var b = this.getParentSize(value);
    var cropped = this.isHorizontal();
    var me = this.graph.getModel();
    /** @type {null} */
    var height = null;
    if (null != b) {
      /** @type {number} */
      height = cropped ? b.height - this.marginTop - this.marginBottom : b.width - this.marginLeft - this.marginRight;
    }
    /** @type {number} */
    height = height - 2 * this.border;
    var x = this.x0 + this.border + this.marginLeft;
    var y = this.y0 + this.border + this.marginTop;
    if (this.graph.isSwimlane(value)) {
      var a = this.graph.getCellStyle(value);
      var h = mxUtils.getNumber(a, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE);
      /** @type {boolean} */
      a = 1 == mxUtils.getValue(a, mxConstants.STYLE_HORIZONTAL, true);
      if (null != b) {
        /** @type {number} */
        h = a ? Math.min(h, b.height) : Math.min(h, b.width);
      }
      if (cropped == a) {
        /** @type {number} */
        height = height - h;
      }
      if (a) {
        y = y + h;
      } else {
        x = x + h;
      }
    }
    me.beginUpdate();
    try {
      /** @type {number} */
      h = 0;
      /** @type {null} */
      a = null;
      /** @type {number} */
      var rowSize = 0;
      /** @type {null} */
      var val = null;
      var edges = this.getLayoutCells(value);
      /** @type {number} */
      var i = 0;
      for (; i < edges.length; i++) {
        var edge = edges[i];
        var self = me.getGeometry(edge);
        if (null != self) {
          self = self.clone();
          if (null != this.wrap && null != a && (cropped && a.x + a.width + self.width + 2 * this.spacing > this.wrap || !cropped && a.y + a.height + self.height + 2 * this.spacing > this.wrap)) {
            /** @type {null} */
            a = null;
            if (cropped) {
              y = y + (h + this.spacing);
            } else {
              x = x + (h + this.spacing);
            }
            /** @type {number} */
            h = 0;
          }
          /** @type {number} */
          h = Math.max(h, cropped ? self.height : self.width);
          /** @type {number} */
          var mouse_x = 0;
          if (!this.borderCollapse) {
            var e = this.graph.getCellStyle(edge);
            mouse_x = mxUtils.getNumber(e, mxConstants.STYLE_STROKEWIDTH, 1);
          }
          if (null != a) {
            var widestInView = rowSize + this.spacing + Math.floor(mouse_x / 2);
            if (cropped) {
              self.x = this.snap((this.allowGaps ? Math.max(widestInView, self.x) : widestInView) - this.marginLeft) + this.marginLeft;
            } else {
              self.y = this.snap((this.allowGaps ? Math.max(widestInView, self.y) : widestInView) - this.marginTop) + this.marginTop;
            }
          } else {
            if (!this.keepFirstLocation) {
              if (cropped) {
                self.x = this.allowGaps && self.x > x ? Math.max(this.snap(self.x - this.marginLeft) + this.marginLeft, x) : x;
              } else {
                self.y = this.allowGaps && self.y > y ? Math.max(this.snap(self.y - this.marginTop) + this.marginTop, y) : y;
              }
            }
          }
          if (cropped) {
            self.y = y;
          } else {
            self.x = x;
          }
          if (this.fill && null != height) {
            if (cropped) {
              /** @type {number} */
              self.height = height;
            } else {
              /** @type {number} */
              self.width = height;
            }
          }
          if (cropped) {
            self.width = this.snap(self.width);
          } else {
            self.height = this.snap(self.height);
          }
          this.setChildGeometry(edge, self);
          val = edge;
          a = self;
          rowSize = cropped ? a.x + a.width + Math.floor(mouse_x / 2) : a.y + a.height + Math.floor(mouse_x / 2);
        }
      }
      if (this.resizeParent && null != b && null != a && !this.graph.isCellCollapsed(value)) {
        this.updateParentGeometry(value, b, a);
      } else {
        if (this.resizeLast && null != b && null != a && null != val) {
          if (cropped) {
            /** @type {number} */
            a.width = b.width - a.x - this.spacing - this.marginRight - this.marginLeft;
          } else {
            /** @type {number} */
            a.height = b.height - a.y - this.spacing - this.marginBottom;
          }
          this.setChildGeometry(val, a);
        }
      }
    } finally {
      me.endUpdate();
    }
  }
};
/**
 * @param {?} model
 * @param {!Object} one
 * @return {undefined}
 */
mxStackLayout.prototype.setChildGeometry = function(model, one) {
  var two = this.graph.getCellGeometry(model);
  if (!(null != two && one.x == two.x && one.y == two.y && one.width == two.width && one.height == two.height)) {
    this.graph.getModel().setGeometry(model, one);
  }
};
/**
 * @param {!Object} x
 * @param {!Object} a
 * @param {!Object} c
 * @return {undefined}
 */
mxStackLayout.prototype.updateParentGeometry = function(x, a, c) {
  var isHorizontal = this.isHorizontal();
  var mesh = this.graph.getModel();
  var b = a.clone();
  if (isHorizontal) {
    c = c.x + c.width + this.marginRight + this.border;
    b.width = this.resizeParentMax ? Math.max(b.width, c) : c;
  } else {
    c = c.y + c.height + this.marginBottom + this.border;
    b.height = this.resizeParentMax ? Math.max(b.height, c) : c;
  }
  if (!(a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height)) {
    mesh.setGeometry(x, b);
  }
};
/**
 * @param {?} dbName
 * @param {number} name
 * @param {number} size
 * @param {string} border
 * @return {undefined}
 */
function mxPartitionLayout(dbName, name, size, border) {
  mxGraphLayout.call(this, dbName);
  this.horizontal = null != name ? name : true;
  this.spacing = size || 0;
  this.border = border || 0;
}
mxPartitionLayout.prototype = new mxGraphLayout;
/** @type {function(?, number, number, string): undefined} */
mxPartitionLayout.prototype.constructor = mxPartitionLayout;
/** @type {null} */
mxPartitionLayout.prototype.horizontal = null;
/** @type {null} */
mxPartitionLayout.prototype.spacing = null;
/** @type {null} */
mxPartitionLayout.prototype.border = null;
/** @type {boolean} */
mxPartitionLayout.prototype.resizeVertices = true;
/**
 * @return {?}
 */
mxPartitionLayout.prototype.isHorizontal = function() {
  return this.horizontal;
};
/**
 * @param {(Object|string)} id
 * @param {number} p
 * @param {!Object} layer
 * @return {undefined}
 */
mxPartitionLayout.prototype.moveCell = function(id, p, layer) {
  layer = this.graph.getModel();
  var cell = layer.getParent(id);
  if (null != id && null != cell) {
    var i;
    /** @type {number} */
    var c = 0;
    var childCount = layer.getChildCount(cell);
    /** @type {number} */
    i = 0;
    for (; i < childCount; i++) {
      var n = layer.getChildAt(cell, i);
      n = this.getVertexBounds(n);
      if (null != n) {
        n = n.x + n.width / 2;
        if (c < p && n > p) {
          break;
        }
        c = n;
      }
    }
    p = cell.getIndex(id);
    /** @type {number} */
    p = Math.max(0, i - (i > p ? 1 : 0));
    layer.add(cell, id, p);
  }
};
/**
 * @param {number} node
 * @return {undefined}
 */
mxPartitionLayout.prototype.execute = function(node) {
  var vertical = this.isHorizontal();
  var self = this.graph.getModel();
  var options = self.getGeometry(node);
  if (null != this.graph.container && (null == options && self.isLayer(node) || node == this.graph.getView().currentRoot)) {
    options = new mxRectangle(0, 0, this.graph.container.offsetWidth - 1, this.graph.container.offsetHeight - 1);
  }
  if (null != options) {
    /** @type {!Array} */
    var result = [];
    var columns = self.getChildCount(node);
    /** @type {number} */
    var i = 0;
    for (; i < columns; i++) {
      var child = self.getChildAt(node, i);
      if (!this.isVertexIgnored(child) && this.isVertexMovable(child)) {
        result.push(child);
      }
    }
    /** @type {number} */
    columns = result.length;
    if (0 < columns) {
      var x = this.border;
      var y = this.border;
      var value = vertical ? options.height : options.width;
      /** @type {number} */
      value = value - 2 * this.border;
      node = this.graph.isSwimlane(node) ? this.graph.getStartSize(node) : new mxRectangle;
      /** @type {number} */
      value = value - (vertical ? node.height : node.width);
      x = x + node.width;
      y = y + node.height;
      node = this.border + (columns - 1) * this.spacing;
      /** @type {number} */
      options = vertical ? (options.width - x - node) / columns : (options.height - y - node) / columns;
      if (0 < options) {
        self.beginUpdate();
        try {
          /** @type {number} */
          i = 0;
          for (; i < columns; i++) {
            child = result[i];
            var res = self.getGeometry(child);
            if (null != res) {
              res = res.clone();
              res.x = x;
              res.y = y;
              if (vertical) {
                if (this.resizeVertices) {
                  /** @type {number} */
                  res.width = options;
                  /** @type {number} */
                  res.height = value;
                }
                x = x + (options + this.spacing);
              } else {
                if (this.resizeVertices) {
                  /** @type {number} */
                  res.height = options;
                  /** @type {number} */
                  res.width = value;
                }
                y = y + (options + this.spacing);
              }
              self.setGeometry(child, res);
            }
          }
        } finally {
          self.endUpdate();
        }
      }
    }
  }
};
/**
 * @param {?} promiseOrResolver
 * @param {?} name
 * @param {string} prefixAgnostic
 * @return {undefined}
 */
function mxCompactTreeLayout(promiseOrResolver, name, prefixAgnostic) {
  mxGraphLayout.call(this, promiseOrResolver);
  this.horizontal = null != name ? name : true;
  this.invert = null != prefixAgnostic ? prefixAgnostic : false;
}
mxCompactTreeLayout.prototype = new mxGraphLayout;
/** @type {function(?, ?, string): undefined} */
mxCompactTreeLayout.prototype.constructor = mxCompactTreeLayout;
/** @type {null} */
mxCompactTreeLayout.prototype.horizontal = null;
/** @type {null} */
mxCompactTreeLayout.prototype.invert = null;
/** @type {boolean} */
mxCompactTreeLayout.prototype.resizeParent = true;
/** @type {boolean} */
mxCompactTreeLayout.prototype.maintainParentLocation = false;
/** @type {number} */
mxCompactTreeLayout.prototype.groupPadding = 10;
/** @type {number} */
mxCompactTreeLayout.prototype.groupPaddingTop = 0;
/** @type {number} */
mxCompactTreeLayout.prototype.groupPaddingRight = 0;
/** @type {number} */
mxCompactTreeLayout.prototype.groupPaddingBottom = 0;
/** @type {number} */
mxCompactTreeLayout.prototype.groupPaddingLeft = 0;
/** @type {null} */
mxCompactTreeLayout.prototype.parentsChanged = null;
/** @type {boolean} */
mxCompactTreeLayout.prototype.moveTree = false;
/** @type {null} */
mxCompactTreeLayout.prototype.visited = null;
/** @type {number} */
mxCompactTreeLayout.prototype.levelDistance = 10;
/** @type {number} */
mxCompactTreeLayout.prototype.nodeDistance = 20;
/** @type {boolean} */
mxCompactTreeLayout.prototype.resetEdges = true;
/** @type {number} */
mxCompactTreeLayout.prototype.prefHozEdgeSep = 5;
/** @type {number} */
mxCompactTreeLayout.prototype.prefVertEdgeOff = 4;
/** @type {number} */
mxCompactTreeLayout.prototype.minEdgeJetty = 8;
/** @type {number} */
mxCompactTreeLayout.prototype.channelBuffer = 4;
/** @type {boolean} */
mxCompactTreeLayout.prototype.edgeRouting = true;
/** @type {boolean} */
mxCompactTreeLayout.prototype.sortEdges = false;
/** @type {boolean} */
mxCompactTreeLayout.prototype.alignRanks = false;
/** @type {null} */
mxCompactTreeLayout.prototype.maxRankHeight = null;
/** @type {null} */
mxCompactTreeLayout.prototype.root = null;
/** @type {null} */
mxCompactTreeLayout.prototype.node = null;
/**
 * @param {!Array} cell
 * @return {?}
 */
mxCompactTreeLayout.prototype.isVertexIgnored = function(cell) {
  return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || 0 == this.graph.getConnections(cell).length;
};
/**
 * @return {?}
 */
mxCompactTreeLayout.prototype.isHorizontal = function() {
  return this.horizontal;
};
/**
 * @param {?} parent
 * @param {!Object} obj
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.execute = function(parent, obj) {
  this.parent = parent;
  var model = this.graph.getModel();
  if (null == obj) {
    if (0 < this.graph.getEdges(parent, model.getParent(parent), this.invert, !this.invert, false).length) {
      this.root = parent;
    } else {
      var t = this.graph.findTreeRoots(parent, true, this.invert);
      if (0 < t.length) {
        /** @type {number} */
        var j = 0;
        for (; j < t.length; j++) {
          if (!this.isVertexIgnored(t[j]) && 0 < this.graph.getEdges(t[j], null, this.invert, !this.invert, false).length) {
            this.root = t[j];
            break;
          }
        }
      }
    }
  } else {
    /** @type {!Object} */
    this.root = obj;
  }
  if (null != this.root) {
    /** @type {(null|{})} */
    this.parentsChanged = this.resizeParent ? {} : null;
    /** @type {null} */
    this.parentY = this.parentX = null;
    if (parent != this.root && null != model.isVertex(parent) && this.maintainParentLocation) {
      var res = this.graph.getCellGeometry(parent);
      if (null != res) {
        this.parentX = res.x;
        this.parentY = res.y;
      }
    }
    model.beginUpdate();
    try {
      if (this.visited = {}, this.node = this.dfs(this.root, parent), this.alignRanks && (this.maxRankHeight = [], this.findRankHeights(this.node, 0), this.setCellHeights(this.node, 0)), null != this.node) {
        this.layout(this.node);
        var x = this.graph.gridSize;
        t = x;
        if (!this.moveTree) {
          var p = this.getVertexBounds(this.root);
          if (null != p) {
            x = p.x;
            t = p.y;
          }
        }
        /** @type {null} */
        p = null;
        p = this.isHorizontal() ? this.horizontalLayout(this.node, x, t) : this.verticalLayout(this.node, null, x, t);
        if (null != p) {
          /** @type {number} */
          var i = j = 0;
          if (0 > p.x) {
            /** @type {number} */
            j = Math.abs(x - p.x);
          }
          if (0 > p.y) {
            /** @type {number} */
            i = Math.abs(t - p.y);
          }
          if (!(0 == j && 0 == i)) {
            this.moveNode(this.node, j, i);
          }
          if (this.resizeParent) {
            this.adjustParents();
          }
          if (this.edgeRouting) {
            this.localEdgeProcessing(this.node);
          }
        }
        if (null != this.parentX && null != this.parentY) {
          res = this.graph.getCellGeometry(parent);
          if (null != res) {
            res = res.clone();
            res.x = this.parentX;
            res.y = this.parentY;
            model.setGeometry(parent, res);
          }
        }
      }
    } finally {
      model.endUpdate();
    }
  }
};
/**
 * @param {!Object} node
 * @param {number} offset
 * @param {number} count
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.moveNode = function(node, offset, count) {
  node.x += offset;
  node.y += count;
  this.apply(node);
  node = node.child;
  for (; null != node;) {
    this.moveNode(node, offset, count);
    node = node.next;
  }
};
/**
 * @param {?} data
 * @param {!Array} colors
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.sortOutgoingEdges = function(data, colors) {
  var router = new mxDictionary;
  colors.sort(function(wru, edge) {
    var key = wru.getTerminal(wru.getTerminal(false) == data);
    var item = router.get(key);
    if (null == item) {
      item = mxCellPath.create(key).split(mxCellPath.PATH_SEPARATOR);
      router.put(key, item);
    }
    key = edge.getTerminal(edge.getTerminal(false) == data);
    var k = router.get(key);
    if (null == k) {
      k = mxCellPath.create(key).split(mxCellPath.PATH_SEPARATOR);
      router.put(key, k);
    }
    return mxCellPath.compare(item, k);
  });
};
/**
 * @param {!Object} obj
 * @param {number} i
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.findRankHeights = function(obj, i) {
  if (null == this.maxRankHeight[i] || this.maxRankHeight[i] < obj.height) {
    this.maxRankHeight[i] = obj.height;
  }
  var item = obj.child;
  for (; null != item;) {
    this.findRankHeights(item, i + 1);
    item = item.next;
  }
};
/**
 * @param {!Object} obj
 * @param {number} i
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.setCellHeights = function(obj, i) {
  if (null != this.maxRankHeight[i] && this.maxRankHeight[i] > obj.height) {
    obj.height = this.maxRankHeight[i];
  }
  var item = obj.child;
  for (; null != item;) {
    this.setCellHeights(item, i + 1);
    item = item.next;
  }
};
/**
 * @param {?} element
 * @param {!Array} i
 * @return {?}
 */
mxCompactTreeLayout.prototype.dfs = function(element, i) {
  var target = mxCellPath.create(element);
  /** @type {null} */
  var node = null;
  if (null != element && null == this.visited[target] && !this.isVertexIgnored(element)) {
    this.visited[target] = element;
    node = this.createNode(element);
    target = this.graph.getModel();
    /** @type {null} */
    var layer = null;
    var c = this.graph.getEdges(element, i, this.invert, !this.invert, false, true);
    var morph = this.graph.getView();
    if (this.sortEdges) {
      this.sortOutgoingEdges(element, c);
    }
    /** @type {number} */
    var e = 0;
    for (; e < c.length; e++) {
      var element = c[e];
      if (!this.isEdgeIgnored(element)) {
        if (this.resetEdges) {
          this.setEdgePoints(element, null);
        }
        if (this.edgeRouting) {
          this.setEdgeStyleEnabled(element, false);
          this.setEdgePoints(element, null);
        }
        var child = morph.getState(element);
        element = null != child ? child.getVisibleTerminal(this.invert) : morph.getVisibleTerminal(element, this.invert);
        child = this.dfs(element, i);
        if (null != child && null != target.getGeometry(element)) {
          if (null == layer) {
            node.child = child;
          } else {
            layer.next = child;
          }
          layer = child;
        }
      }
    }
  }
  return node;
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.layout = function(value) {
  if (null != value) {
    var item = value.child;
    for (; null != item;) {
      this.layout(item);
      item = item.next;
    }
    if (null != value.child) {
      this.attachParent(value, this.join(value));
    } else {
      this.layoutLeaf(value);
    }
  }
};
/**
 * @param {!Object} self
 * @param {!Object} s
 * @param {?} key
 * @param {?} value
 * @return {?}
 */
mxCompactTreeLayout.prototype.horizontalLayout = function(self, s, key, value) {
  self.x += s + self.offsetX;
  self.y += key + self.offsetY;
  value = this.apply(self, value);
  s = self.child;
  if (null != s) {
    value = this.horizontalLayout(s, self.x, self.y, value);
    key = self.y + s.offsetY;
    var node = s.next;
    for (; null != node;) {
      value = this.horizontalLayout(node, self.x + s.offsetX, key, value);
      key = key + node.offsetY;
      node = node.next;
    }
  }
  return value;
};
/**
 * @param {!Object} self
 * @param {!Object} o
 * @param {?} w
 * @param {!Object} r
 * @param {?} value
 * @return {?}
 */
mxCompactTreeLayout.prototype.verticalLayout = function(self, o, w, r, value) {
  self.x += w + self.offsetY;
  self.y += r + self.offsetX;
  value = this.apply(self, value);
  o = self.child;
  if (null != o) {
    value = this.verticalLayout(o, self, self.x, self.y, value);
    w = self.x + o.offsetY;
    r = o.next;
    for (; null != r;) {
      value = this.verticalLayout(r, self, w, self.y + o.offsetX, value);
      w = w + r.offsetY;
      r = r.next;
    }
  }
  return value;
};
/**
 * @param {!Object} data
 * @param {!Date} offset
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.attachParent = function(data, offset) {
  var start = this.nodeDistance + this.levelDistance;
  /** @type {number} */
  var x1 = (offset - data.width) / 2 - this.nodeDistance;
  /** @type {number} */
  var end = x1 + data.width + 2 * this.nodeDistance - offset;
  data.child.offsetX = start + data.height;
  /** @type {number} */
  data.child.offsetY = end;
  data.contour.upperHead = this.createLine(data.height, 0, this.createLine(start, end, data.contour.upperHead));
  data.contour.lowerHead = this.createLine(data.height, 0, this.createLine(start, x1, data.contour.lowerHead));
};
/**
 * @param {!Object} c
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.layoutLeaf = function(c) {
  /** @type {number} */
  var gap = 2 * this.nodeDistance;
  c.contour.upperTail = this.createLine(c.height + gap, 0);
  c.contour.upperHead = c.contour.upperTail;
  c.contour.lowerTail = this.createLine(0, -c.width - gap);
  c.contour.lowerHead = this.createLine(c.height + gap, 0, c.contour.lowerTail);
};
/**
 * @param {!Object} params
 * @return {?}
 */
mxCompactTreeLayout.prototype.join = function(params) {
  /** @type {number} */
  var router = 2 * this.nodeDistance;
  var options = params.child;
  params.contour = options.contour;
  var name = options.width + router;
  var output = name;
  options = options.next;
  for (; null != options;) {
    var _ = this.merge(params.contour, options.contour);
    options.offsetY = _ + name;
    /** @type {number} */
    options.offsetX = 0;
    name = options.width + router;
    output = output + (_ + name);
    options = options.next;
  }
  return output;
};
/**
 * @param {?} r
 * @param {?} s
 * @return {?}
 */
mxCompactTreeLayout.prototype.merge = function(r, s) {
  /** @type {number} */
  var x = 0;
  /** @type {number} */
  var y = 0;
  /** @type {number} */
  var origin = 0;
  var c = r.lowerHead;
  var p = s.upperHead;
  for (; null != p && null != c;) {
    var offset = this.offset(x, y, p.dx, p.dy, c.dx, c.dy);
    y = y + offset;
    origin = origin + offset;
    if (x + p.dx <= c.dx) {
      x = x + p.dx;
      y = y + p.dy;
      p = p.next;
    } else {
      /** @type {number} */
      x = x - c.dx;
      /** @type {number} */
      y = y - c.dy;
      c = c.next;
    }
  }
  if (null != p) {
    x = this.bridge(r.upperTail, 0, 0, p, x, y);
    r.upperTail = null != x.next ? s.upperTail : x;
    r.lowerTail = s.lowerTail;
  } else {
    x = this.bridge(s.lowerTail, x, y, c, 0, 0);
    if (null == x.next) {
      r.lowerTail = x;
    }
  }
  r.lowerHead = s.lowerHead;
  return origin;
};
/**
 * @param {number} d
 * @param {number} x
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @param {number} e
 * @return {?}
 */
mxCompactTreeLayout.prototype.offset = function(d, x, a, b, c, e) {
  if (c <= d || 0 >= d + a) {
    return 0;
  }
  /** @type {number} */
  d = 0 < c * b - a * e ? 0 > d ? d * b / a - x : 0 < d ? d * e / c - x : -x : c < d + a ? e - (x + (c - d) * b / a) : c > d + a ? (a + d) * e / c - (x + b) : e - (x + b);
  return 0 < d ? d : 0;
};
/**
 * @param {!Node} p
 * @param {number} r
 * @param {number} s
 * @param {!Object} config
 * @param {number} width
 * @param {number} name
 * @return {?}
 */
mxCompactTreeLayout.prototype.bridge = function(p, r, s, config, width, name) {
  /** @type {number} */
  r = width + config.dx - r;
  if (0 == config.dx) {
    width = config.dy;
  } else {
    /** @type {number} */
    width = r * config.dy;
    /** @type {number} */
    width = width / config.dx;
  }
  r = this.createLine(r, width, config.next);
  p.next = this.createLine(0, name + config.dy - width - s, r);
  return r;
};
/**
 * @param {!Object} target
 * @return {?}
 */
mxCompactTreeLayout.prototype.createNode = function(target) {
  var p = {};
  /** @type {!Object} */
  p.cell = target;
  /** @type {number} */
  p.x = 0;
  /** @type {number} */
  p.y = 0;
  /** @type {number} */
  p.width = 0;
  /** @type {number} */
  p.height = 0;
  target = this.getVertexBounds(target);
  if (null != target) {
    if (this.isHorizontal()) {
      p.width = target.height;
      p.height = target.width;
    } else {
      p.width = target.width;
      p.height = target.height;
    }
  }
  /** @type {number} */
  p.offsetX = 0;
  /** @type {number} */
  p.offsetY = 0;
  p.contour = {};
  return p;
};
/**
 * @param {!Object} obj
 * @param {?} val
 * @return {?}
 */
mxCompactTreeLayout.prototype.apply = function(obj, val) {
  var item = this.graph.getModel();
  var name = obj.cell;
  var n = item.getGeometry(name);
  if (null != name && null != n) {
    if (this.isVertexMovable(name)) {
      n = this.setVertexLocation(name, obj.x, obj.y);
      if (this.resizeParent) {
        item = item.getParent(name);
        name = mxCellPath.create(item);
        if (null == this.parentsChanged[name]) {
          this.parentsChanged[name] = item;
        }
      }
    }
    val = null == val ? new mxRectangle(n.x, n.y, n.width, n.height) : new mxRectangle(Math.min(val.x, n.x), Math.min(val.y, n.y), Math.max(val.x + val.width, n.x + n.width), Math.max(val.y + val.height, n.y + n.height));
  }
  return val;
};
/**
 * @param {number} a
 * @param {number} v
 * @param {!Function} t
 * @return {?}
 */
mxCompactTreeLayout.prototype.createLine = function(a, v, t) {
  var target = {};
  /** @type {number} */
  target.dx = a;
  /** @type {number} */
  target.dy = v;
  /** @type {!Function} */
  target.next = t;
  return target;
};
/**
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.adjustParents = function() {
  /** @type {!Array} */
  var pt = [];
  var i;
  for (i in this.parentsChanged) {
    pt.push(this.parentsChanged[i]);
  }
  this.arrangeGroups(mxUtils.sortCells(pt, true), this.groupPadding, this.groupPaddingTop, this.groupPaddingRight, this.groupPaddingBottom, this.groupPaddingLeft);
};
/**
 * @param {!Object} c
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.localEdgeProcessing = function(c) {
  this.processNodeOutgoing(c);
  c = c.child;
  for (; null != c;) {
    this.localEdgeProcessing(c);
    c = c.next;
  }
};
/**
 * @param {!Object} r
 * @return {undefined}
 */
mxCompactTreeLayout.prototype.processNodeOutgoing = function(r) {
  var x = r.child;
  var n = r.cell;
  /** @type {number} */
  var count = 0;
  /** @type {!Array} */
  var a = [];
  for (; null != x;) {
    count++;
    var t = x.x;
    if (this.horizontal) {
      t = x.y;
    }
    a.push(new WeightedCellSorter(x, t));
    x = x.next;
  }
  a.sort(WeightedCellSorter.prototype.compare);
  t = r.width;
  /** @type {number} */
  var b = (count + 1) * this.prefHozEdgeSep;
  if (t > b + 2 * this.prefHozEdgeSep) {
    /** @type {number} */
    t = t - 2 * this.prefHozEdgeSep;
  }
  /** @type {number} */
  r = t / count;
  /** @type {number} */
  x = r / 2;
  if (t > b + 2 * this.prefHozEdgeSep) {
    x = x + this.prefHozEdgeSep;
  }
  /** @type {number} */
  t = this.minEdgeJetty - this.prefVertEdgeOff;
  b = this.getVertexBounds(n);
  /** @type {number} */
  var i = 0;
  for (; i < a.length; i++) {
    var c = a[i].cell.cell;
    var ic = this.getVertexBounds(c);
    c = this.graph.getEdgesBetween(n, c, false);
    /** @type {!Array} */
    var result = [];
    var html;
    var p;
    /** @type {number} */
    var ci = 0;
    for (; ci < c.length; ci++) {
      if (this.horizontal) {
        html = b.x + b.width;
        p = b.y + x;
        result.push(new mxPoint(html, p));
        html = b.x + b.width + t;
        result.push(new mxPoint(html, p));
        p = ic.y + ic.height / 2;
      } else {
        html = b.x + x;
        p = b.y + b.height;
        result.push(new mxPoint(html, p));
        p = b.y + b.height + t;
        result.push(new mxPoint(html, p));
        html = ic.x + ic.width / 2;
      }
      result.push(new mxPoint(html, p));
      this.setEdgePoints(c[ci], result);
    }
    if (i < count / 2) {
      t = t + this.prefVertEdgeOff;
    } else {
      if (i > count / 2) {
        /** @type {number} */
        t = t - this.prefVertEdgeOff;
      }
    }
    x = x + r;
  }
};
/**
 * @param {?} p1__3354_SHARP_
 * @return {undefined}
 */
function mxRadialTreeLayout(p1__3354_SHARP_) {
  mxCompactTreeLayout.call(this, p1__3354_SHARP_, false);
}
mxUtils.extend(mxRadialTreeLayout, mxCompactTreeLayout);
/** @type {number} */
mxRadialTreeLayout.prototype.angleOffset = .5;
/** @type {number} */
mxRadialTreeLayout.prototype.rootx = 0;
/** @type {number} */
mxRadialTreeLayout.prototype.rooty = 0;
/** @type {number} */
mxRadialTreeLayout.prototype.levelDistance = 120;
/** @type {number} */
mxRadialTreeLayout.prototype.nodeDistance = 10;
/** @type {boolean} */
mxRadialTreeLayout.prototype.autoRadius = false;
/** @type {boolean} */
mxRadialTreeLayout.prototype.sortEdges = false;
/** @type {!Array} */
mxRadialTreeLayout.prototype.rowMinX = [];
/** @type {!Array} */
mxRadialTreeLayout.prototype.rowMaxX = [];
/** @type {!Array} */
mxRadialTreeLayout.prototype.rowMinCenX = [];
/** @type {!Array} */
mxRadialTreeLayout.prototype.rowMaxCenX = [];
/** @type {!Array} */
mxRadialTreeLayout.prototype.rowRadi = [];
/** @type {!Array} */
mxRadialTreeLayout.prototype.row = [];
/**
 * @param {!Array} cell
 * @return {?}
 */
mxRadialTreeLayout.prototype.isVertexIgnored = function(cell) {
  return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || 0 == this.graph.getConnections(cell).length;
};
/**
 * @param {!Object} obj
 * @param {!Object} tag
 * @return {undefined}
 */
mxRadialTreeLayout.prototype.execute = function(obj, tag) {
  /** @type {!Object} */
  this.parent = obj;
  /** @type {boolean} */
  this.edgeRouting = this.useBoundingBox = false;
  mxCompactTreeLayout.prototype.execute.apply(this, arguments);
  /** @type {null} */
  var index = null;
  var p = this.getVertexBounds(this.root);
  this.centerX = p.x + p.width / 2;
  this.centerY = p.y + p.height / 2;
  var n;
  for (n in this.visited) {
    var s = this.getVertexBounds(this.visited[n]);
    index = null != index ? index : s.clone();
    index.add(s);
  }
  this.calcRowDims([this.node], 0);
  /** @type {number} */
  var i = 0;
  /** @type {number} */
  var bytes = 0;
  /** @type {number} */
  index = 0;
  for (; index < this.row.length; index++) {
    /** @type {number} */
    n = (this.rowMaxX[index] - this.centerX - this.nodeDistance) / this.rowRadi[index];
    /** @type {number} */
    i = Math.max(i, (this.centerX - this.rowMinX[index] - this.nodeDistance) / this.rowRadi[index]);
    /** @type {number} */
    bytes = Math.max(bytes, n);
  }
  /** @type {number} */
  index = 0;
  for (; index < this.row.length; index++) {
    /** @type {number} */
    var accumulator = this.centerX - this.nodeDistance - i * this.rowRadi[index];
    /** @type {number} */
    var bevelSegments = this.centerX + this.nodeDistance + bytes * this.rowRadi[index] - accumulator;
    /** @type {number} */
    n = 0;
    for (; n < this.row[index].length; n++) {
      s = this.row[index];
      p = s[n];
      s = this.getVertexBounds(p.cell);
      /** @type {number} */
      p.theta = (s.x + s.width / 2 - accumulator) / bevelSegments * Math.PI * 2;
    }
  }
  /** @type {number} */
  index = this.row.length - 2;
  for (; 0 <= index; index--) {
    s = this.row[index];
    /** @type {number} */
    n = 0;
    for (; n < s.length; n++) {
      p = s[n];
      i = p.child;
      /** @type {number} */
      accumulator = bytes = 0;
      for (; null != i;) {
        accumulator = accumulator + i.theta;
        bytes++;
        i = i.next;
      }
      if (0 < bytes) {
        /** @type {number} */
        i = accumulator / bytes;
        if (i > p.theta && n < s.length - 1) {
          /** @type {number} */
          p.theta = Math.min(i, s[n + 1].theta - Math.PI / 10);
        } else {
          if (i < p.theta && 0 < n) {
            /** @type {number} */
            p.theta = Math.max(i, s[n - 1].theta + Math.PI / 10);
          }
        }
      }
    }
  }
  /** @type {number} */
  index = 0;
  for (; index < this.row.length; index++) {
    /** @type {number} */
    n = 0;
    for (; n < this.row[index].length; n++) {
      s = this.row[index];
      p = s[n];
      s = this.getVertexBounds(p.cell);
      this.setVertexLocation(p.cell, this.centerX - s.width / 2 + this.rowRadi[index] * Math.cos(p.theta), this.centerY - s.height / 2 + this.rowRadi[index] * Math.sin(p.theta));
    }
  }
};
/**
 * @param {!Object} data
 * @param {number} index
 * @return {undefined}
 */
mxRadialTreeLayout.prototype.calcRowDims = function(data, index) {
  if (null != data && 0 != data.length) {
    this.rowMinX[index] = this.centerX;
    this.rowMaxX[index] = this.centerX;
    this.rowMinCenX[index] = this.centerX;
    this.rowMaxCenX[index] = this.centerX;
    /** @type {!Array} */
    this.row[index] = [];
    /** @type {boolean} */
    var c = false;
    /** @type {number} */
    var i = 0;
    for (; i < data.length; i++) {
      var t = null != data[i] ? data[i].child : null;
      for (; null != t;) {
        var f = this.getVertexBounds(t.cell);
        /** @type {number} */
        this.rowMinX[index] = Math.min(f.x, this.rowMinX[index]);
        /** @type {number} */
        this.rowMaxX[index] = Math.max(f.x + f.width, this.rowMaxX[index]);
        /** @type {number} */
        this.rowMinCenX[index] = Math.min(f.x + f.width / 2, this.rowMinCenX[index]);
        /** @type {number} */
        this.rowMaxCenX[index] = Math.max(f.x + f.width / 2, this.rowMaxCenX[index]);
        /** @type {number} */
        this.rowRadi[index] = f.y - this.getVertexBounds(this.root).y;
        if (null != t.child) {
          /** @type {boolean} */
          c = true;
        }
        this.row[index].push(t);
        t = t.next;
      }
    }
    if (c) {
      this.calcRowDims(this.row[index], index + 1);
    }
  }
};
/**
 * @param {?} p1__3354_SHARP_
 * @return {undefined}
 */
function mxFastOrganicLayout(p1__3354_SHARP_) {
  mxGraphLayout.call(this, p1__3354_SHARP_);
}
mxFastOrganicLayout.prototype = new mxGraphLayout;
/** @type {function(?): undefined} */
mxFastOrganicLayout.prototype.constructor = mxFastOrganicLayout;
/** @type {boolean} */
mxFastOrganicLayout.prototype.useInputOrigin = true;
/** @type {boolean} */
mxFastOrganicLayout.prototype.resetEdges = true;
/** @type {boolean} */
mxFastOrganicLayout.prototype.disableEdgeStyle = true;
/** @type {number} */
mxFastOrganicLayout.prototype.forceConstant = 50;
/** @type {number} */
mxFastOrganicLayout.prototype.forceConstantSquared = 0;
/** @type {number} */
mxFastOrganicLayout.prototype.minDistanceLimit = 2;
/** @type {number} */
mxFastOrganicLayout.prototype.maxDistanceLimit = 500;
/** @type {number} */
mxFastOrganicLayout.prototype.minDistanceLimitSquared = 4;
/** @type {number} */
mxFastOrganicLayout.prototype.initialTemp = 200;
/** @type {number} */
mxFastOrganicLayout.prototype.temperature = 0;
/** @type {number} */
mxFastOrganicLayout.prototype.maxIterations = 0;
/** @type {number} */
mxFastOrganicLayout.prototype.iteration = 0;
/** @type {boolean} */
mxFastOrganicLayout.prototype.allowedToRun = true;
/**
 * @param {!Array} cell
 * @return {?}
 */
mxFastOrganicLayout.prototype.isVertexIgnored = function(cell) {
  return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || 0 == this.graph.getConnections(cell).length;
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxFastOrganicLayout.prototype.execute = function(value) {
  var targetFragment = this.graph.getModel();
  /** @type {!Array} */
  this.vertexArray = [];
  var m = this.graph.getChildVertices(value);
  /** @type {number} */
  var i = 0;
  for (; i < m.length; i++) {
    if (!this.isVertexIgnored(m[i])) {
      this.vertexArray.push(m[i]);
    }
  }
  var props = this.useInputOrigin ? this.graph.getBoundingBoxFromGeometry(this.vertexArray) : null;
  /** @type {number} */
  var f = this.vertexArray.length;
  /** @type {!Array} */
  this.indices = [];
  /** @type {!Array} */
  this.dispX = [];
  /** @type {!Array} */
  this.dispY = [];
  /** @type {!Array} */
  this.cellLocation = [];
  /** @type {!Array} */
  this.isMoveable = [];
  /** @type {!Array} */
  this.neighbours = [];
  /** @type {!Array} */
  this.radius = [];
  /** @type {!Array} */
  this.radiusSquared = [];
  if (.001 > this.forceConstant) {
    /** @type {number} */
    this.forceConstant = .001;
  }
  /** @type {number} */
  this.forceConstantSquared = this.forceConstant * this.forceConstant;
  /** @type {number} */
  i = 0;
  for (; i < this.vertexArray.length; i++) {
    var s = this.vertexArray[i];
    /** @type {!Array} */
    this.cellLocation[i] = [];
    var a = mxObjectIdentity.get(s);
    /** @type {number} */
    this.indices[a] = i;
    var r = this.getVertexBounds(s);
    var j = r.width;
    var h = r.height;
    var offset = r.x;
    var t = r.y;
    this.cellLocation[i][0] = offset + j / 2;
    this.cellLocation[i][1] = t + h / 2;
    /** @type {number} */
    this.radius[i] = Math.min(j, h);
    /** @type {number} */
    this.radiusSquared[i] = this.radius[i] * this.radius[i];
  }
  targetFragment.beginUpdate();
  try {
    /** @type {number} */
    i = 0;
    for (; i < f; i++) {
      /** @type {number} */
      this.dispX[i] = 0;
      /** @type {number} */
      this.dispY[i] = 0;
      this.isMoveable[i] = this.isVertexMovable(this.vertexArray[i]);
      var path = this.graph.getConnections(this.vertexArray[i], value);
      m = this.graph.getOpposites(path, this.vertexArray[i]);
      /** @type {!Array} */
      this.neighbours[i] = [];
      /** @type {number} */
      j = 0;
      for (; j < m.length; j++) {
        if (this.resetEdges) {
          this.graph.resetEdge(path[j]);
        }
        if (this.disableEdgeStyle) {
          this.setEdgeStyleEnabled(path[j], false);
        }
        a = mxObjectIdentity.get(m[j]);
        var index = this.indices[a];
        this.neighbours[i][j] = null != index ? index : i;
      }
    }
    this.temperature = this.initialTemp;
    if (0 == this.maxIterations) {
      /** @type {number} */
      this.maxIterations = 20 * Math.sqrt(f);
    }
    /** @type {number} */
    this.iteration = 0;
    for (; this.iteration < this.maxIterations; this.iteration++) {
      if (!this.allowedToRun) {
        return;
      }
      this.calcRepulsion();
      this.calcAttraction();
      this.calcPositions();
      this.reduceTemperature();
    }
    /** @type {null} */
    value = m = null;
    /** @type {number} */
    i = 0;
    for (; i < this.vertexArray.length; i++) {
      s = this.vertexArray[i];
      if (this.isVertexMovable(s)) {
        r = this.getVertexBounds(s);
        if (null != r) {
          this.cellLocation[i][0] -= r.width / 2;
          this.cellLocation[i][1] -= r.height / 2;
          offset = this.graph.snap(Math.round(this.cellLocation[i][0]));
          t = this.graph.snap(Math.round(this.cellLocation[i][1]));
          this.setVertexLocation(s, offset, t);
          m = null == m ? offset : Math.min(m, offset);
          value = null == value ? t : Math.min(value, t);
        }
      }
    }
    /** @type {number} */
    i = -(m || 0) + 1;
    /** @type {number} */
    s = -(value || 0) + 1;
    if (null != props) {
      i = i + props.x;
      s = s + props.y;
    }
    this.graph.moveCells(this.vertexArray, i, s);
  } finally {
    targetFragment.endUpdate();
  }
};
/**
 * @return {undefined}
 */
mxFastOrganicLayout.prototype.calcPositions = function() {
  /** @type {number} */
  var i = 0;
  for (; i < this.vertexArray.length; i++) {
    if (this.isMoveable[i]) {
      /** @type {number} */
      var n = Math.sqrt(this.dispX[i] * this.dispX[i] + this.dispY[i] * this.dispY[i]);
      if (.001 > n) {
        /** @type {number} */
        n = .001;
      }
      /** @type {number} */
      var c = this.dispX[i] / n * Math.min(n, this.temperature);
      /** @type {number} */
      n = this.dispY[i] / n * Math.min(n, this.temperature);
      /** @type {number} */
      this.dispX[i] = 0;
      /** @type {number} */
      this.dispY[i] = 0;
      this.cellLocation[i][0] += c;
      this.cellLocation[i][1] += n;
    }
  }
};
/**
 * @return {undefined}
 */
mxFastOrganicLayout.prototype.calcAttraction = function() {
  /** @type {number} */
  var p = 0;
  for (; p < this.vertexArray.length; p++) {
    /** @type {number} */
    var i = 0;
    for (; i < this.neighbours[p].length; i++) {
      var root = this.neighbours[p][i];
      if (p != root && this.isMoveable[p] && this.isMoveable[root]) {
        /** @type {number} */
        var lightI = this.cellLocation[p][0] - this.cellLocation[root][0];
        /** @type {number} */
        var lightJ = this.cellLocation[p][1] - this.cellLocation[root][1];
        /** @type {number} */
        var x = lightI * lightI + lightJ * lightJ - this.radiusSquared[p] - this.radiusSquared[root];
        if (x < this.minDistanceLimitSquared) {
          x = this.minDistanceLimitSquared;
        }
        /** @type {number} */
        var y = Math.sqrt(x);
        /** @type {number} */
        x = x / this.forceConstant;
        /** @type {number} */
        lightI = lightI / y * x;
        /** @type {number} */
        lightJ = lightJ / y * x;
        this.dispX[p] -= lightI;
        this.dispY[p] -= lightJ;
        this.dispX[root] += lightI;
        this.dispY[root] += lightJ;
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxFastOrganicLayout.prototype.calcRepulsion = function() {
  var numSpawners = this.vertexArray.length;
  /** @type {number} */
  var i = 0;
  for (; i < numSpawners; i++) {
    /** @type {number} */
    var j = i;
    for (; j < numSpawners; j++) {
      if (!this.allowedToRun) {
        return;
      }
      if (j != i && this.isMoveable[i] && this.isMoveable[j]) {
        /** @type {number} */
        var x = this.cellLocation[i][0] - this.cellLocation[j][0];
        /** @type {number} */
        var y = this.cellLocation[i][1] - this.cellLocation[j][1];
        if (0 == x) {
          /** @type {number} */
          x = .01 + Math.random();
        }
        if (0 == y) {
          /** @type {number} */
          y = .01 + Math.random();
        }
        /** @type {number} */
        var h = Math.sqrt(x * x + y * y);
        /** @type {number} */
        var d = h - this.radius[i] - this.radius[j];
        if (!(d > this.maxDistanceLimit)) {
          if (d < this.minDistanceLimit) {
            d = this.minDistanceLimit;
          }
          /** @type {number} */
          d = this.forceConstantSquared / d;
          /** @type {number} */
          x = x / h * d;
          /** @type {number} */
          y = y / h * d;
          this.dispX[i] += x;
          this.dispY[i] += y;
          this.dispX[j] -= x;
          this.dispY[j] -= y;
        }
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxFastOrganicLayout.prototype.reduceTemperature = function() {
  /** @type {number} */
  this.temperature = this.initialTemp * (1 - this.iteration / this.maxIterations);
};
/**
 * @param {?} conn
 * @param {number} maxRadius
 * @return {undefined}
 */
function mxCircleLayout(conn, maxRadius) {
  mxGraphLayout.call(this, conn);
  this.radius = null != maxRadius ? maxRadius : 100;
}
mxCircleLayout.prototype = new mxGraphLayout;
/** @type {function(?, number): undefined} */
mxCircleLayout.prototype.constructor = mxCircleLayout;
/** @type {null} */
mxCircleLayout.prototype.radius = null;
/** @type {boolean} */
mxCircleLayout.prototype.moveCircle = false;
/** @type {number} */
mxCircleLayout.prototype.x0 = 0;
/** @type {number} */
mxCircleLayout.prototype.y0 = 0;
/** @type {boolean} */
mxCircleLayout.prototype.resetEdges = true;
/** @type {boolean} */
mxCircleLayout.prototype.disableEdgeStyle = true;
/**
 * @param {!Object} n
 * @return {undefined}
 */
mxCircleLayout.prototype.execute = function(n) {
  var node = this.graph.getModel();
  node.beginUpdate();
  try {
    /** @type {number} */
    var padding = 0;
    /** @type {null} */
    var steps = null;
    /** @type {null} */
    var r = null;
    /** @type {!Array} */
    var x = [];
    var requestsToPerform = node.getChildCount(n);
    /** @type {number} */
    var i = 0;
    for (; i < requestsToPerform; i++) {
      var name = node.getChildAt(n, i);
      if (this.isVertexIgnored(name)) {
        if (!this.isEdgeIgnored(name)) {
          if (this.resetEdges) {
            this.graph.resetEdge(name);
          }
          if (this.disableEdgeStyle) {
            this.setEdgeStyleEnabled(name, false);
          }
        }
      } else {
        x.push(name);
        var target = this.getVertexBounds(name);
        steps = null == steps ? target.y : Math.min(steps, target.y);
        r = null == r ? target.x : Math.min(r, target.x);
        /** @type {number} */
        padding = Math.max(padding, Math.max(target.width, target.height));
      }
    }
    var options = this.getRadius(x.length, padding);
    if (this.moveCircle) {
      r = this.x0;
      steps = this.y0;
    }
    this.circle(x, options, r, steps);
  } finally {
    node.endUpdate();
  }
};
/**
 * @param {number} a
 * @param {number} b
 * @return {?}
 */
mxCircleLayout.prototype.getRadius = function(a, b) {
  return Math.max(a * b / Math.PI, this.radius);
};
/**
 * @param {!Array} p
 * @param {number} r
 * @param {string} c
 * @param {string} y
 * @return {undefined}
 */
mxCircleLayout.prototype.circle = function(p, r, c, y) {
  var m = p.length;
  /** @type {number} */
  var x = 2 * Math.PI / m;
  /** @type {number} */
  var j = 0;
  for (; j < m; j++) {
    if (this.isVertexMovable(p[j])) {
      this.setVertexLocation(p[j], Math.round(c + r + r * Math.sin(j * x)), Math.round(y + r + r * Math.cos(j * x)));
    }
  }
};
/**
 * @param {?} p1__3354_SHARP_
 * @return {undefined}
 */
function mxParallelEdgeLayout(p1__3354_SHARP_) {
  mxGraphLayout.call(this, p1__3354_SHARP_);
}
mxParallelEdgeLayout.prototype = new mxGraphLayout;
/** @type {function(?): undefined} */
mxParallelEdgeLayout.prototype.constructor = mxParallelEdgeLayout;
/** @type {number} */
mxParallelEdgeLayout.prototype.spacing = 20;
/** @type {boolean} */
mxParallelEdgeLayout.prototype.checkOverlap = false;
/**
 * @param {!Object} obj
 * @param {!Object} tag
 * @return {undefined}
 */
mxParallelEdgeLayout.prototype.execute = function(obj, tag) {
  var data = this.findParallels(obj, tag);
  this.graph.model.beginUpdate();
  try {
    var dataKey;
    for (dataKey in data) {
      var items = data[dataKey];
      if (1 < items.length) {
        this.layout(items);
      }
    }
  } finally {
    this.graph.model.endUpdate();
  }
};
/**
 * @param {!Object} n
 * @param {!Object} that
 * @return {?}
 */
mxParallelEdgeLayout.prototype.findParallels = function(n, that) {
  /** @type {!Array} */
  var bandwidthData = [];
  var $ = mxUtils.bind(this, function(root) {
    if (!this.isEdgeIgnored(root)) {
      var index = this.getEdgeId(root);
      if (null != index) {
        if (null == bandwidthData[index]) {
          /** @type {!Array} */
          bandwidthData[index] = [];
        }
        bandwidthData[index].push(root);
      }
    }
  });
  if (null != that) {
    /** @type {number} */
    var i = 0;
    for (; i < that.length; i++) {
      $(that[i]);
    }
  } else {
    var menu = this.graph.getModel();
    var requestsToPerform = menu.getChildCount(n);
    /** @type {number} */
    i = 0;
    for (; i < requestsToPerform; i++) {
      $(menu.getChildAt(n, i));
    }
  }
  return bandwidthData;
};
/**
 * @param {string} r
 * @return {?}
 */
mxParallelEdgeLayout.prototype.getEdgeId = function(r) {
  var a = this.graph.getView();
  var b = a.getVisibleTerminal(r, true);
  a = a.getVisibleTerminal(r, false);
  /** @type {string} */
  var tVertexLocations = "";
  if (null != b && null != a) {
    b = mxObjectIdentity.get(b);
    a = mxObjectIdentity.get(a);
    if (this.checkOverlap && (r = this.graph.view.getState(r), null != r && null != r.absolutePoints)) {
      /** @type {!Array} */
      tVertexLocations = [];
      /** @type {number} */
      var page = 0;
      for (; page < r.absolutePoints.length; page++) {
        var tPrevVertex = r.absolutePoints[page];
        if (null != tPrevVertex) {
          tVertexLocations.push(tPrevVertex.x, tPrevVertex.y);
        }
      }
      /** @type {string} */
      tVertexLocations = tVertexLocations.join(",");
    }
    return (b > a ? a + "-" + b : b + "-" + a) + tVertexLocations;
  }
  return null;
};
/**
 * @param {!Array} v
 * @return {undefined}
 */
mxParallelEdgeLayout.prototype.layout = function(v) {
  var y = v[0];
  var msg = this.graph.getView();
  var x = this.graph.getModel();
  var p = x.getGeometry(msg.getVisibleTerminal(y, true));
  x = x.getGeometry(msg.getVisibleTerminal(y, false));
  if (p == x) {
    y = p.x + p.width + this.spacing;
    msg = p.y + p.height / 2;
    /** @type {number} */
    var i = 0;
    for (; i < v.length; i++) {
      this.route(v[i], y, msg);
      y = y + this.spacing;
    }
  } else {
    if (null != p && null != x) {
      y = p.x + p.width / 2;
      msg = p.y + p.height / 2;
      /** @type {number} */
      i = x.x + x.width / 2 - y;
      /** @type {number} */
      var j = x.y + x.height / 2 - msg;
      /** @type {number} */
      x = Math.sqrt(i * i + j * j);
      if (0 < x) {
        /** @type {number} */
        p = j * this.spacing / x;
        /** @type {number} */
        x = i * this.spacing / x;
        y = y + i / 2 + p * (v.length - 1) / 2;
        /** @type {number} */
        msg = msg + j / 2 - x * (v.length - 1) / 2;
        /** @type {number} */
        i = 0;
        for (; i < v.length; i++) {
          this.route(v[i], y, msg);
          /** @type {number} */
          y = y - p;
          /** @type {number} */
          msg = msg + x;
        }
      }
    }
  }
};
/**
 * @param {!Object} config
 * @param {?} type
 * @param {boolean} name
 * @return {undefined}
 */
mxParallelEdgeLayout.prototype.route = function(config, type, name) {
  if (this.graph.isCellMovable(config)) {
    this.setEdgePoints(config, [new mxPoint(type, name)]);
  }
};
/**
 * @param {?} categories
 * @param {!Object} next
 * @param {boolean} server
 * @return {undefined}
 */
function mxCompositeLayout(categories, next, server) {
  mxGraphLayout.call(this, categories);
  /** @type {!Object} */
  this.layouts = next;
  /** @type {boolean} */
  this.master = server;
}
mxCompositeLayout.prototype = new mxGraphLayout;
/** @type {function(?, !Object, boolean): undefined} */
mxCompositeLayout.prototype.constructor = mxCompositeLayout;
/** @type {null} */
mxCompositeLayout.prototype.layouts = null;
/** @type {null} */
mxCompositeLayout.prototype.master = null;
/**
 * @param {?} index
 * @param {?} id
 * @param {?} destinationId
 * @return {undefined}
 */
mxCompositeLayout.prototype.moveCell = function(index, id, destinationId) {
  if (null != this.master) {
    this.master.moveCell.apply(this.master, arguments);
  } else {
    this.layouts[0].moveCell.apply(this.layouts[0], arguments);
  }
};
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxCompositeLayout.prototype.execute = function(obj) {
  var targetFragment = this.graph.getModel();
  targetFragment.beginUpdate();
  try {
    /** @type {number} */
    var i = 0;
    for (; i < this.layouts.length; i++) {
      this.layouts[i].execute.apply(this.layouts[i], arguments);
    }
  } finally {
    targetFragment.endUpdate();
  }
};
/**
 * @param {?} a
 * @param {?} b
 * @return {undefined}
 */
function mxEdgeLabelLayout(a, b) {
  mxGraphLayout.call(this, a);
}
mxEdgeLabelLayout.prototype = new mxGraphLayout;
/** @type {function(?, ?): undefined} */
mxEdgeLabelLayout.prototype.constructor = mxEdgeLabelLayout;
/**
 * @param {!Object} n
 * @return {undefined}
 */
mxEdgeLabelLayout.prototype.execute = function(n) {
  var model = this.graph.view;
  var menu = this.graph.getModel();
  /** @type {!Array} */
  var configs = [];
  /** @type {!Array} */
  var e = [];
  var requestsToPerform = menu.getChildCount(n);
  /** @type {number} */
  var i = 0;
  for (; i < requestsToPerform; i++) {
    var r = menu.getChildAt(n, i);
    var engine = model.getState(r);
    if (null != engine) {
      if (this.isVertexIgnored(r)) {
        if (!this.isEdgeIgnored(r)) {
          configs.push(engine);
        }
      } else {
        e.push(engine);
      }
    }
  }
  this.placeLabels(e, configs);
};
/**
 * @param {!Array} m
 * @param {!Array} s
 * @return {undefined}
 */
mxEdgeLabelLayout.prototype.placeLabels = function(m, s) {
  var targetFragment = this.graph.getModel();
  targetFragment.beginUpdate();
  try {
    /** @type {number} */
    var i = 0;
    for (; i < s.length; i++) {
      var e = s[i];
      if (null != e && null != e.text && null != e.text.boundingBox) {
        /** @type {number} */
        var i = 0;
        for (; i < m.length; i++) {
          var word = m[i];
          if (null != word) {
            this.avoid(e, word);
          }
        }
      }
    }
  } finally {
    targetFragment.endUpdate();
  }
};
/**
 * @param {!Object} e
 * @param {?} graph
 * @return {undefined}
 */
mxEdgeLabelLayout.prototype.avoid = function(e, graph) {
  var marker = this.graph.getModel();
  var x = e.text.boundingBox;
  if (mxUtils.intersects(x, graph)) {
    var y = -x.y - x.height + graph.y;
    var a = -x.y + graph.y + graph.height;
    y = Math.abs(y) < Math.abs(a) ? y : a;
    a = -x.x - x.width + graph.x;
    x = -x.x + graph.x + graph.width;
    x = Math.abs(a) < Math.abs(x) ? a : x;
    if (Math.abs(x) < Math.abs(y)) {
      /** @type {number} */
      y = 0;
    } else {
      /** @type {number} */
      x = 0;
    }
    a = marker.getGeometry(e.cell);
    if (null != a) {
      a = a.clone();
      if (null != a.offset) {
        a.offset.x += x;
        a.offset.y += y;
      } else {
        a.offset = new mxPoint(x, y);
      }
      marker.setGeometry(e.cell, a);
    }
  }
};
/**
 * @return {undefined}
 */
function mxGraphAbstractHierarchyCell() {
  /** @type {!Array} */
  this.x = [];
  /** @type {!Array} */
  this.y = [];
  /** @type {!Array} */
  this.temp = [];
}
/** @type {number} */
mxGraphAbstractHierarchyCell.prototype.maxRank = -1;
/** @type {number} */
mxGraphAbstractHierarchyCell.prototype.minRank = -1;
/** @type {null} */
mxGraphAbstractHierarchyCell.prototype.x = null;
/** @type {null} */
mxGraphAbstractHierarchyCell.prototype.y = null;
/** @type {number} */
mxGraphAbstractHierarchyCell.prototype.width = 0;
/** @type {number} */
mxGraphAbstractHierarchyCell.prototype.height = 0;
/** @type {null} */
mxGraphAbstractHierarchyCell.prototype.nextLayerConnectedCells = null;
/** @type {null} */
mxGraphAbstractHierarchyCell.prototype.previousLayerConnectedCells = null;
/** @type {null} */
mxGraphAbstractHierarchyCell.prototype.temp = null;
/**
 * @param {number} lC
 * @return {?}
 */
mxGraphAbstractHierarchyCell.prototype.getNextLayerConnectedCells = function(lC) {
  return null;
};
/**
 * @param {number} targetChar
 * @return {?}
 */
mxGraphAbstractHierarchyCell.prototype.getPreviousLayerConnectedCells = function(targetChar) {
  return null;
};
/**
 * @return {?}
 */
mxGraphAbstractHierarchyCell.prototype.isEdge = function() {
  return false;
};
/**
 * @return {?}
 */
mxGraphAbstractHierarchyCell.prototype.isVertex = function() {
  return false;
};
/**
 * @param {number} targetChar
 * @return {?}
 */
mxGraphAbstractHierarchyCell.prototype.getGeneralPurposeVariable = function(targetChar) {
  return null;
};
/**
 * @param {number} key
 * @param {number} val
 * @return {?}
 */
mxGraphAbstractHierarchyCell.prototype.setGeneralPurposeVariable = function(key, val) {
  return null;
};
/**
 * @param {number} value
 * @param {number} i
 * @return {undefined}
 */
mxGraphAbstractHierarchyCell.prototype.setX = function(value, i) {
  if (this.isVertex()) {
    /** @type {number} */
    this.x[0] = i;
  } else {
    if (this.isEdge()) {
      /** @type {number} */
      this.x[value - this.minRank - 1] = i;
    }
  }
};
/**
 * @param {number} val
 * @return {?}
 */
mxGraphAbstractHierarchyCell.prototype.getX = function(val) {
  return this.isVertex() ? this.x[0] : this.isEdge() ? this.x[val - this.minRank - 1] : 0;
};
/**
 * @param {?} value
 * @param {number} el
 * @return {undefined}
 */
mxGraphAbstractHierarchyCell.prototype.setY = function(value, el) {
  if (this.isVertex()) {
    /** @type {number} */
    this.y[0] = el;
  } else {
    if (this.isEdge()) {
      /** @type {number} */
      this.y[value - this.minRank - 1] = el;
    }
  }
};
/**
 * @param {!Object} el
 * @return {undefined}
 */
function mxGraphHierarchyNode(el) {
  mxGraphAbstractHierarchyCell.apply(this, arguments);
  /** @type {!Object} */
  this.cell = el;
  this.id = mxObjectIdentity.get(el);
  /** @type {!Array} */
  this.connectsAsTarget = [];
  /** @type {!Array} */
  this.connectsAsSource = [];
}
mxGraphHierarchyNode.prototype = new mxGraphAbstractHierarchyCell;
/** @type {function(!Object): undefined} */
mxGraphHierarchyNode.prototype.constructor = mxGraphHierarchyNode;
/** @type {null} */
mxGraphHierarchyNode.prototype.cell = null;
/** @type {null} */
mxGraphHierarchyNode.prototype.id = null;
/** @type {null} */
mxGraphHierarchyNode.prototype.connectsAsTarget = null;
/** @type {null} */
mxGraphHierarchyNode.prototype.connectsAsSource = null;
/** @type {boolean} */
mxGraphHierarchyNode.prototype.hashCode = false;
/**
 * @param {?} a
 * @return {?}
 */
mxGraphHierarchyNode.prototype.getRankValue = function(a) {
  return this.maxRank;
};
/**
 * @param {number} lC
 * @return {?}
 */
mxGraphHierarchyNode.prototype.getNextLayerConnectedCells = function(lC) {
  if (null == this.nextLayerConnectedCells) {
    /** @type {!Array} */
    this.nextLayerConnectedCells = [];
    /** @type {!Array} */
    this.nextLayerConnectedCells[0] = [];
    /** @type {number} */
    var cI = 0;
    for (; cI < this.connectsAsTarget.length; cI++) {
      var value = this.connectsAsTarget[cI];
      if (-1 == value.maxRank || value.maxRank == lC + 1) {
        this.nextLayerConnectedCells[0].push(value.source);
      } else {
        this.nextLayerConnectedCells[0].push(value);
      }
    }
  }
  return this.nextLayerConnectedCells[0];
};
/**
 * @param {number} start
 * @return {?}
 */
mxGraphHierarchyNode.prototype.getPreviousLayerConnectedCells = function(start) {
  if (null == this.previousLayerConnectedCells) {
    /** @type {!Array} */
    this.previousLayerConnectedCells = [];
    /** @type {!Array} */
    this.previousLayerConnectedCells[0] = [];
    /** @type {number} */
    var child = 0;
    for (; child < this.connectsAsSource.length; child++) {
      var node = this.connectsAsSource[child];
      if (-1 == node.minRank || node.minRank == start - 1) {
        this.previousLayerConnectedCells[0].push(node.target);
      } else {
        this.previousLayerConnectedCells[0].push(node);
      }
    }
  }
  return this.previousLayerConnectedCells[0];
};
/**
 * @return {?}
 */
mxGraphHierarchyNode.prototype.isVertex = function() {
  return true;
};
/**
 * @param {number} targetChar
 * @return {?}
 */
mxGraphHierarchyNode.prototype.getGeneralPurposeVariable = function(targetChar) {
  return this.temp[0];
};
/**
 * @param {number} key
 * @param {number} val
 * @return {undefined}
 */
mxGraphHierarchyNode.prototype.setGeneralPurposeVariable = function(key, val) {
  /** @type {number} */
  this.temp[0] = val;
};
/**
 * @param {!Function} parent
 * @return {?}
 */
mxGraphHierarchyNode.prototype.isAncestor = function(parent) {
  if (null != parent && null != this.hashCode && null != parent.hashCode && this.hashCode.length < parent.hashCode.length) {
    if (this.hashCode == parent.hashCode) {
      return true;
    }
    if (null == this.hashCode || null == this.hashCode) {
      return false;
    }
    /** @type {number} */
    var i = 0;
    for (; i < this.hashCode.length; i++) {
      if (this.hashCode[i] != parent.hashCode[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
};
/**
 * @return {?}
 */
mxGraphHierarchyNode.prototype.getCoreCell = function() {
  return this.cell;
};
/**
 * @param {string} chunkIds
 * @return {undefined}
 */
function mxGraphHierarchyEdge(chunkIds) {
  mxGraphAbstractHierarchyCell.apply(this, arguments);
  /** @type {string} */
  this.edges = chunkIds;
  /** @type {!Array} */
  this.ids = [];
  /** @type {number} */
  var i = 0;
  for (; i < chunkIds.length; i++) {
    this.ids.push(mxObjectIdentity.get(chunkIds[i]));
  }
}
mxGraphHierarchyEdge.prototype = new mxGraphAbstractHierarchyCell;
/** @type {function(string): undefined} */
mxGraphHierarchyEdge.prototype.constructor = mxGraphHierarchyEdge;
/** @type {null} */
mxGraphHierarchyEdge.prototype.edges = null;
/** @type {null} */
mxGraphHierarchyEdge.prototype.ids = null;
/** @type {null} */
mxGraphHierarchyEdge.prototype.source = null;
/** @type {null} */
mxGraphHierarchyEdge.prototype.target = null;
/** @type {boolean} */
mxGraphHierarchyEdge.prototype.isReversed = false;
/**
 * @param {string} target
 * @return {undefined}
 */
mxGraphHierarchyEdge.prototype.invert = function(target) {
  target = this.source;
  this.source = this.target;
  /** @type {string} */
  this.target = target;
  /** @type {boolean} */
  this.isReversed = !this.isReversed;
};
/**
 * @param {number} lC
 * @return {?}
 */
mxGraphHierarchyEdge.prototype.getNextLayerConnectedCells = function(lC) {
  if (null == this.nextLayerConnectedCells) {
    /** @type {!Array} */
    this.nextLayerConnectedCells = [];
    /** @type {number} */
    var b = 0;
    for (; b < this.temp.length; b++) {
      /** @type {!Array} */
      this.nextLayerConnectedCells[b] = [];
      if (b == this.temp.length - 1) {
        this.nextLayerConnectedCells[b].push(this.source);
      } else {
        this.nextLayerConnectedCells[b].push(this);
      }
    }
  }
  return this.nextLayerConnectedCells[lC - this.minRank - 1];
};
/**
 * @param {number} targetChar
 * @return {?}
 */
mxGraphHierarchyEdge.prototype.getPreviousLayerConnectedCells = function(targetChar) {
  if (null == this.previousLayerConnectedCells) {
    /** @type {!Array} */
    this.previousLayerConnectedCells = [];
    /** @type {number} */
    var b = 0;
    for (; b < this.temp.length; b++) {
      /** @type {!Array} */
      this.previousLayerConnectedCells[b] = [];
      if (0 == b) {
        this.previousLayerConnectedCells[b].push(this.target);
      } else {
        this.previousLayerConnectedCells[b].push(this);
      }
    }
  }
  return this.previousLayerConnectedCells[targetChar - this.minRank - 1];
};
/**
 * @return {?}
 */
mxGraphHierarchyEdge.prototype.isEdge = function() {
  return true;
};
/**
 * @param {number} targetChar
 * @return {?}
 */
mxGraphHierarchyEdge.prototype.getGeneralPurposeVariable = function(targetChar) {
  return this.temp[targetChar - this.minRank - 1];
};
/**
 * @param {number} key
 * @param {number} val
 * @return {undefined}
 */
mxGraphHierarchyEdge.prototype.setGeneralPurposeVariable = function(key, val) {
  /** @type {number} */
  this.temp[key - this.minRank - 1] = val;
};
/**
 * @return {?}
 */
mxGraphHierarchyEdge.prototype.getCoreCell = function() {
  return null != this.edges && 0 < this.edges.length ? this.edges[0] : null;
};
/**
 * @param {string} n
 * @param {string} val
 * @param {string} arr
 * @param {number} i
 * @param {number} e
 * @return {undefined}
 */
function mxGraphHierarchyModel(n, val, arr, i, e) {
  n.getGraph();
  /** @type {number} */
  this.tightenToSource = e;
  /** @type {string} */
  this.roots = arr;
  /** @type {number} */
  this.parent = i;
  this.vertexMapper = new mxDictionary;
  this.edgeMapper = new mxDictionary;
  /** @type {number} */
  this.maxRank = 0;
  /** @type {!Array} */
  arr = [];
  if (null == val) {
    val = this.graph.getChildVertices(i);
  }
  this.maxRank = this.SOURCESCANSTARTRANK;
  this.createInternalCells(n, val, arr);
  /** @type {number} */
  i = 0;
  for (; i < val.length; i++) {
    e = arr[i].connectsAsSource;
    /** @type {number} */
    var j = 0;
    for (; j < e.length; j++) {
      var value = e[j];
      var selector = value.edges;
      if (null != selector && 0 < selector.length) {
        selector = selector[0];
        var obj = n.getVisibleTerminal(selector, false);
        obj = this.vertexMapper.get(obj);
        if (arr[i] == obj) {
          obj = n.getVisibleTerminal(selector, true);
          obj = this.vertexMapper.get(obj);
        }
        if (null != obj && arr[i] != obj) {
          value.target = obj;
          if (0 == obj.connectsAsTarget.length) {
            /** @type {!Array} */
            obj.connectsAsTarget = [];
          }
          if (0 > mxUtils.indexOf(obj.connectsAsTarget, value)) {
            obj.connectsAsTarget.push(value);
          }
        }
      }
    }
    /** @type {number} */
    arr[i].temp[0] = 1;
  }
}
/** @type {null} */
mxGraphHierarchyModel.prototype.maxRank = null;
/** @type {null} */
mxGraphHierarchyModel.prototype.vertexMapper = null;
/** @type {null} */
mxGraphHierarchyModel.prototype.edgeMapper = null;
/** @type {null} */
mxGraphHierarchyModel.prototype.ranks = null;
/** @type {null} */
mxGraphHierarchyModel.prototype.roots = null;
/** @type {null} */
mxGraphHierarchyModel.prototype.parent = null;
/** @type {number} */
mxGraphHierarchyModel.prototype.dfsCount = 0;
/** @type {number} */
mxGraphHierarchyModel.prototype.SOURCESCANSTARTRANK = 1E8;
/** @type {boolean} */
mxGraphHierarchyModel.prototype.tightenToSource = false;
/**
 * @param {string} a
 * @param {string} s
 * @param {string} results
 * @return {undefined}
 */
mxGraphHierarchyModel.prototype.createInternalCells = function(a, s, results) {
  var mapEditor = a.getGraph();
  /** @type {number} */
  var i = 0;
  for (; i < s.length; i++) {
    results[i] = new mxGraphHierarchyNode(s[i]);
    this.vertexMapper.put(s[i], results[i]);
    var dupArray = a.getEdges(s[i]);
    /** @type {!Array} */
    results[i].connectsAsSource = [];
    /** @type {number} */
    var j = 0;
    for (; j < dupArray.length; j++) {
      var value = a.getVisibleTerminal(dupArray[j], false);
      if (value != s[i] && a.graph.model.isVertex(value) && !a.isVertexIgnored(value)) {
        var args = a.getEdgesBetween(s[i], value, false);
        value = a.getEdgesBetween(s[i], value, true);
        if (null != args && 0 < args.length && null == this.edgeMapper.get(args[0]) && 2 * value.length >= args.length) {
          value = new mxGraphHierarchyEdge(args);
          /** @type {number} */
          var index = 0;
          for (; index < args.length; index++) {
            var t = args[index];
            this.edgeMapper.put(t, value);
            mapEditor.resetEdge(t);
            if (a.disableEdgeStyle) {
              a.setEdgeStyleEnabled(t, false);
              a.setOrthogonalEdge(t, true);
            }
          }
          value.source = results[i];
          if (0 > mxUtils.indexOf(results[i].connectsAsSource, value)) {
            results[i].connectsAsSource.push(value);
          }
        }
      }
    }
    /** @type {number} */
    results[i].temp[0] = 0;
  }
};
/**
 * @return {undefined}
 */
mxGraphHierarchyModel.prototype.initialRank = function() {
  /** @type {!Array} */
  var a = [];
  if (null != this.roots) {
    /** @type {number} */
    var i = 0;
    for (; i < this.roots.length; i++) {
      var t = this.vertexMapper.get(this.roots[i]);
      if (null != t) {
        a.push(t);
      }
    }
  }
  var index = this.vertexMapper.getValues();
  /** @type {number} */
  i = 0;
  for (; i < index.length; i++) {
    /** @type {number} */
    index[i].temp[0] = -1;
  }
  /** @type {!Array<?>} */
  var tagsAny = a.slice();
  for (; 0 < a.length;) {
    t = a[0];
    var val;
    var params;
    val = t.connectsAsTarget;
    params = t.connectsAsSource;
    /** @type {boolean} */
    var k = true;
    var endTime = this.SOURCESCANSTARTRANK;
    /** @type {number} */
    i = 0;
    for (; i < val.length; i++) {
      var value = val[i];
      if (5270620 == value.temp[0]) {
        value = value.source;
        /** @type {number} */
        endTime = Math.min(endTime, value.temp[0] - 1);
      } else {
        /** @type {boolean} */
        k = false;
        break;
      }
    }
    if (k) {
      t.temp[0] = endTime;
      /** @type {number} */
      this.maxRank = Math.min(this.maxRank, endTime);
      if (null != params) {
        /** @type {number} */
        i = 0;
        for (; i < params.length; i++) {
          value = params[i];
          /** @type {number} */
          value.temp[0] = 5270620;
          value = value.target;
          if (-1 == value.temp[0]) {
            a.push(value);
            /** @type {number} */
            value.temp[0] = -2;
          }
        }
      }
      a.shift();
    } else {
      if (i = a.shift(), a.push(t), i == t && 1 == a.length) {
        break;
      }
    }
  }
  /** @type {number} */
  i = 0;
  for (; i < index.length; i++) {
    index[i].temp[0] -= this.maxRank;
  }
  /** @type {number} */
  i = 0;
  for (; i < tagsAny.length; i++) {
    t = tagsAny[i];
    /** @type {number} */
    a = 0;
    val = t.connectsAsSource;
    /** @type {number} */
    index = 0;
    for (; index < val.length; index++) {
      value = val[index];
      value = value.target;
      /** @type {number} */
      t.temp[0] = Math.max(a, value.temp[0] + 1);
      a = t.temp[0];
    }
  }
  /** @type {number} */
  this.maxRank = this.SOURCESCANSTARTRANK - this.maxRank;
};
/**
 * @return {undefined}
 */
mxGraphHierarchyModel.prototype.fixRanks = function() {
  /** @type {!Array} */
  var values = [];
  /** @type {!Array} */
  this.ranks = [];
  /** @type {number} */
  var i = 0;
  for (; i < this.maxRank + 1; i++) {
    /** @type {!Array} */
    values[i] = [];
    this.ranks[i] = values[i];
  }
  /** @type {null} */
  var left = null;
  if (null != this.roots) {
    var childrenGUIDs = this.roots;
    /** @type {!Array} */
    left = [];
    /** @type {number} */
    i = 0;
    for (; i < childrenGUIDs.length; i++) {
      var item_b = this.vertexMapper.get(childrenGUIDs[i]);
      left[i] = item_b;
    }
  }
  this.visit(function(attr, value, node, canCreateDiscussions, isSlidingUp) {
    if (0 == isSlidingUp && 0 > value.maxRank && 0 > value.minRank) {
      values[value.temp[0]].push(value);
      value.maxRank = value.temp[0];
      value.minRank = value.temp[0];
      /** @type {number} */
      value.temp[0] = values[value.maxRank].length - 1;
    }
    if (null != attr && null != node && 1 < attr.maxRank - value.maxRank) {
      node.maxRank = attr.maxRank;
      node.minRank = value.maxRank;
      /** @type {!Array} */
      node.temp = [];
      /** @type {!Array} */
      node.x = [];
      /** @type {!Array} */
      node.y = [];
      attr = node.minRank + 1;
      for (; attr < node.maxRank; attr++) {
        values[attr].push(node);
        node.setGeneralPurposeVariable(attr, values[attr].length - 1);
      }
    }
  }, left, false, null);
};
/**
 * @param {!Function} fn
 * @param {!Object} b
 * @param {boolean} c
 * @param {!Object} position
 * @return {undefined}
 */
mxGraphHierarchyModel.prototype.visit = function(fn, b, c, position) {
  if (null != b) {
    /** @type {number} */
    var i = 0;
    for (; i < b.length; i++) {
      var a = b[i];
      if (null != a) {
        if (null == position) {
          position = {};
        }
        if (c) {
          /** @type {!Array} */
          a.hashCode = [];
          a.hashCode[0] = this.dfsCount;
          /** @type {number} */
          a.hashCode[1] = i;
          this.extendedDfs(null, a, null, fn, position, a.hashCode, i, 0);
        } else {
          this.dfs(null, a, null, fn, position, 0);
        }
      }
    }
    this.dfsCount++;
  }
};
/**
 * @param {!Object} path
 * @param {!Object} node
 * @param {number} index
 * @param {!Function} f
 * @param {!Function} arr
 * @param {number} n
 * @return {undefined}
 */
mxGraphHierarchyModel.prototype.dfs = function(path, node, index, f, arr, n) {
  if (null != node) {
    var parent = node.id;
    if (null == arr[parent]) {
      /** @type {!Object} */
      arr[parent] = node;
      f(path, node, index, n, 0);
      path = node.connectsAsSource.slice();
      /** @type {number} */
      index = 0;
      for (; index < path.length; index++) {
        parent = path[index];
        this.dfs(node, parent.target, parent, f, arr, n + 1);
      }
    } else {
      f(path, node, index, n, 1);
    }
  }
};
/**
 * @param {string} a
 * @param {!Function} c
 * @param {number} b
 * @param {!Function} f
 * @param {!Object} p
 * @param {number} step
 * @param {!Object} value
 * @param {number} i
 * @return {undefined}
 */
mxGraphHierarchyModel.prototype.extendedDfs = function(a, c, b, f, p, step, value, i) {
  if (null != c) {
    if (null == a || null != c.hashCode && c.hashCode[0] == a.hashCode[0] || (step = a.hashCode.length + 1, c.hashCode = a.hashCode.slice(), c.hashCode[step - 1] = value), value = c.id, null == p[value]) {
      /** @type {!Function} */
      p[value] = c;
      f(a, c, b, i, 0);
      a = c.connectsAsSource.slice();
      /** @type {number} */
      b = 0;
      for (; b < a.length; b++) {
        value = a[b];
        this.extendedDfs(c, value.target, value, f, p, c.hashCode, b, i + 1);
      }
    } else {
      f(a, c, b, i, 1);
    }
  }
};
/**
 * @param {string} n
 * @param {string} val
 * @param {string} arr
 * @param {number} i
 * @param {number} e
 * @return {undefined}
 */
function mxSwimlaneModel(n, val, arr, i, e) {
  n.getGraph();
  /** @type {number} */
  this.tightenToSource = e;
  /** @type {string} */
  this.roots = arr;
  /** @type {number} */
  this.parent = i;
  this.vertexMapper = new mxDictionary;
  this.edgeMapper = new mxDictionary;
  /** @type {number} */
  this.maxRank = 0;
  /** @type {!Array} */
  arr = [];
  if (null == val) {
    val = this.graph.getChildVertices(i);
  }
  this.maxRank = this.SOURCESCANSTARTRANK;
  this.createInternalCells(n, val, arr);
  /** @type {number} */
  i = 0;
  for (; i < val.length; i++) {
    e = arr[i].connectsAsSource;
    /** @type {number} */
    var j = 0;
    for (; j < e.length; j++) {
      var value = e[j];
      var selector = value.edges;
      if (null != selector && 0 < selector.length) {
        selector = selector[0];
        var obj = n.getVisibleTerminal(selector, false);
        obj = this.vertexMapper.get(obj);
        if (arr[i] == obj) {
          obj = n.getVisibleTerminal(selector, true);
          obj = this.vertexMapper.get(obj);
        }
        if (null != obj && arr[i] != obj) {
          value.target = obj;
          if (0 == obj.connectsAsTarget.length) {
            /** @type {!Array} */
            obj.connectsAsTarget = [];
          }
          if (0 > mxUtils.indexOf(obj.connectsAsTarget, value)) {
            obj.connectsAsTarget.push(value);
          }
        }
      }
    }
    /** @type {number} */
    arr[i].temp[0] = 1;
  }
}
/** @type {null} */
mxSwimlaneModel.prototype.maxRank = null;
/** @type {null} */
mxSwimlaneModel.prototype.vertexMapper = null;
/** @type {null} */
mxSwimlaneModel.prototype.edgeMapper = null;
/** @type {null} */
mxSwimlaneModel.prototype.ranks = null;
/** @type {null} */
mxSwimlaneModel.prototype.roots = null;
/** @type {null} */
mxSwimlaneModel.prototype.parent = null;
/** @type {number} */
mxSwimlaneModel.prototype.dfsCount = 0;
/** @type {number} */
mxSwimlaneModel.prototype.SOURCESCANSTARTRANK = 1E8;
/** @type {boolean} */
mxSwimlaneModel.prototype.tightenToSource = false;
/** @type {null} */
mxSwimlaneModel.prototype.ranksPerGroup = null;
/**
 * @param {string} self
 * @param {string} nodes
 * @param {string} results
 * @return {undefined}
 */
mxSwimlaneModel.prototype.createInternalCells = function(self, nodes, results) {
  var thread = self.getGraph();
  var groups = self.swimlanes;
  /** @type {number} */
  var i = 0;
  for (; i < nodes.length; i++) {
    results[i] = new mxGraphHierarchyNode(nodes[i]);
    this.vertexMapper.put(nodes[i], results[i]);
    /** @type {number} */
    results[i].swimlaneIndex = -1;
    /** @type {number} */
    var g = 0;
    for (; g < groups.length; g++) {
      if (thread.model.getParent(nodes[i]) == groups[g]) {
        /** @type {number} */
        results[i].swimlaneIndex = g;
        break;
      }
    }
    g = self.getEdges(nodes[i]);
    /** @type {!Array} */
    results[i].connectsAsSource = [];
    /** @type {number} */
    var j = 0;
    for (; j < g.length; j++) {
      var value = self.getVisibleTerminal(g[j], false);
      if (value != nodes[i] && self.graph.model.isVertex(value) && !self.isVertexIgnored(value)) {
        var data = self.getEdgesBetween(nodes[i], value, false);
        value = self.getEdgesBetween(nodes[i], value, true);
        if (null != data && 0 < data.length && null == this.edgeMapper.get(data[0]) && 2 * value.length >= data.length) {
          value = new mxGraphHierarchyEdge(data);
          /** @type {number} */
          var page = 0;
          for (; page < data.length; page++) {
            var p = data[page];
            this.edgeMapper.put(p, value);
            thread.resetEdge(p);
            if (self.disableEdgeStyle) {
              self.setEdgeStyleEnabled(p, false);
              self.setOrthogonalEdge(p, true);
            }
          }
          value.source = results[i];
          if (0 > mxUtils.indexOf(results[i].connectsAsSource, value)) {
            results[i].connectsAsSource.push(value);
          }
        }
      }
    }
    /** @type {number} */
    results[i].temp[0] = 0;
  }
};
/**
 * @return {undefined}
 */
mxSwimlaneModel.prototype.initialRank = function() {
  /** @type {!Array} */
  this.ranksPerGroup = [];
  /** @type {!Array} */
  var steps = [];
  var b = {};
  if (null != this.roots) {
    /** @type {number} */
    var i = 0;
    for (; i < this.roots.length; i++) {
      var val = this.vertexMapper.get(this.roots[i]);
      this.maxChainDfs(null, val, null, b, 0);
      if (null != val) {
        steps.push(val);
      }
    }
  }
  /** @type {!Array} */
  val = [];
  /** @type {!Array} */
  b = [];
  /** @type {number} */
  i = this.ranksPerGroup.length - 1;
  for (; 0 <= i; i--) {
    val[i] = i == this.ranksPerGroup.length - 1 ? 0 : b[i + 1] + 1;
    b[i] = val[i] + this.ranksPerGroup[i];
  }
  this.maxRank = b[0];
  val = this.vertexMapper.getValues();
  /** @type {number} */
  i = 0;
  for (; i < val.length; i++) {
    /** @type {number} */
    val[i].temp[0] = -1;
  }
  steps.slice();
  for (; 0 < steps.length;) {
    val = steps[0];
    var value;
    var cell;
    value = val.connectsAsTarget;
    cell = val.connectsAsSource;
    /** @type {boolean} */
    var g = true;
    var a = b[0];
    /** @type {number} */
    i = 0;
    for (; i < value.length; i++) {
      var e = value[i];
      if (5270620 == e.temp[0]) {
        e = e.source;
        /** @type {number} */
        a = Math.min(a, e.temp[0] - 1);
      } else {
        /** @type {boolean} */
        g = false;
        break;
      }
    }
    if (g) {
      if (a > b[val.swimlaneIndex]) {
        a = b[val.swimlaneIndex];
      }
      val.temp[0] = a;
      if (null != cell) {
        /** @type {number} */
        i = 0;
        for (; i < cell.length; i++) {
          e = cell[i];
          /** @type {number} */
          e.temp[0] = 5270620;
          e = e.target;
          if (-1 == e.temp[0]) {
            steps.push(e);
            /** @type {number} */
            e.temp[0] = -2;
          }
        }
      }
      steps.shift();
    } else {
      if (i = steps.shift(), steps.push(val), i == val && 1 == steps.length) {
        break;
      }
    }
  }
};
/**
 * @param {string} a
 * @param {!Object} b
 * @param {number} i
 * @param {!Object} data
 * @param {number} key
 * @return {undefined}
 */
mxSwimlaneModel.prototype.maxChainDfs = function(a, b, i, data, key) {
  if (null != b && (a = mxCellPath.create(b.cell), null == data[a])) {
    /** @type {!Object} */
    data[a] = b;
    a = b.swimlaneIndex;
    if (null == this.ranksPerGroup[a] || this.ranksPerGroup[a] < key) {
      /** @type {number} */
      this.ranksPerGroup[a] = key;
    }
    a = b.connectsAsSource.slice();
    /** @type {number} */
    i = 0;
    for (; i < a.length; i++) {
      var p = a[i];
      var button = p.target;
      if (b.swimlaneIndex < button.swimlaneIndex) {
        this.maxChainDfs(b, button, p, mxUtils.clone(data, null, true), 0);
      } else {
        if (b.swimlaneIndex == button.swimlaneIndex) {
          this.maxChainDfs(b, button, p, mxUtils.clone(data, null, true), key + 1);
        }
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxSwimlaneModel.prototype.fixRanks = function() {
  /** @type {!Array} */
  var values = [];
  /** @type {!Array} */
  this.ranks = [];
  /** @type {number} */
  var i = 0;
  for (; i < this.maxRank + 1; i++) {
    /** @type {!Array} */
    values[i] = [];
    this.ranks[i] = values[i];
  }
  /** @type {null} */
  var left = null;
  if (null != this.roots) {
    var childrenGUIDs = this.roots;
    /** @type {!Array} */
    left = [];
    /** @type {number} */
    i = 0;
    for (; i < childrenGUIDs.length; i++) {
      var item_b = this.vertexMapper.get(childrenGUIDs[i]);
      left[i] = item_b;
    }
  }
  this.visit(function(attr, value, node, canCreateDiscussions, isSlidingUp) {
    if (0 == isSlidingUp && 0 > value.maxRank && 0 > value.minRank) {
      values[value.temp[0]].push(value);
      value.maxRank = value.temp[0];
      value.minRank = value.temp[0];
      /** @type {number} */
      value.temp[0] = values[value.maxRank].length - 1;
    }
    if (null != attr && null != node && 1 < attr.maxRank - value.maxRank) {
      node.maxRank = attr.maxRank;
      node.minRank = value.maxRank;
      /** @type {!Array} */
      node.temp = [];
      /** @type {!Array} */
      node.x = [];
      /** @type {!Array} */
      node.y = [];
      attr = node.minRank + 1;
      for (; attr < node.maxRank; attr++) {
        values[attr].push(node);
        node.setGeneralPurposeVariable(attr, values[attr].length - 1);
      }
    }
  }, left, false, null);
};
/**
 * @param {!Function} fn
 * @param {!Object} b
 * @param {boolean} c
 * @param {!Object} position
 * @return {undefined}
 */
mxSwimlaneModel.prototype.visit = function(fn, b, c, position) {
  if (null != b) {
    /** @type {number} */
    var i = 0;
    for (; i < b.length; i++) {
      var a = b[i];
      if (null != a) {
        if (null == position) {
          position = {};
        }
        if (c) {
          /** @type {!Array} */
          a.hashCode = [];
          a.hashCode[0] = this.dfsCount;
          /** @type {number} */
          a.hashCode[1] = i;
          this.extendedDfs(null, a, null, fn, position, a.hashCode, i, 0);
        } else {
          this.dfs(null, a, null, fn, position, 0);
        }
      }
    }
    this.dfsCount++;
  }
};
/**
 * @param {!Object} node
 * @param {!Object} i
 * @param {number} idx
 * @param {!Function} f
 * @param {!Function} arr
 * @param {number} n
 * @return {undefined}
 */
mxSwimlaneModel.prototype.dfs = function(node, i, idx, f, arr, n) {
  if (null != i) {
    var key = i.id;
    if (null == arr[key]) {
      /** @type {!Object} */
      arr[key] = i;
      f(node, i, idx, n, 0);
      node = i.connectsAsSource.slice();
      /** @type {number} */
      idx = 0;
      for (; idx < node.length; idx++) {
        key = node[idx];
        this.dfs(i, key.target, key, f, arr, n + 1);
      }
    } else {
      f(node, i, idx, n, 1);
    }
  }
};
/**
 * @param {!Function} a
 * @param {!Function} b
 * @param {!Object} result
 * @param {!Function} callback
 * @param {!Object} e
 * @param {string} n
 * @param {string} i
 * @param {number} name
 * @return {undefined}
 */
mxSwimlaneModel.prototype.extendedDfs = function(a, b, result, callback, e, n, i, name) {
  if (null != b) {
    if (null == a || null != b.hashCode && b.hashCode[0] == a.hashCode[0] || (n = a.hashCode.length + 1, b.hashCode = a.hashCode.slice(), b.hashCode[n - 1] = i), i = b.id, null == e[i]) {
      /** @type {!Function} */
      e[i] = b;
      callback(a, b, result, name, 0);
      a = b.connectsAsSource.slice();
      result = b.connectsAsTarget.slice();
      /** @type {number} */
      i = 0;
      for (; i < a.length; i++) {
        n = a[i];
        var c = n.target;
        if (b.swimlaneIndex <= c.swimlaneIndex) {
          this.extendedDfs(b, c, n, callback, e, b.hashCode, i, name + 1);
        }
      }
      /** @type {number} */
      i = 0;
      for (; i < result.length; i++) {
        n = result[i];
        c = n.source;
        if (b.swimlaneIndex < c.swimlaneIndex) {
          this.extendedDfs(b, c, n, callback, e, b.hashCode, i, name + 1);
        }
      }
    } else {
      callback(a, b, result, name, 1);
    }
  }
};
/**
 * @return {undefined}
 */
function mxHierarchicalLayoutStage() {
}
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxHierarchicalLayoutStage.prototype.execute = function(obj) {
};
/**
 * @param {!Object} layoutParam
 * @return {undefined}
 */
function mxMedianHybridCrossingReduction(layoutParam) {
  /** @type {!Object} */
  this.layout = layoutParam;
}
mxMedianHybridCrossingReduction.prototype = new mxHierarchicalLayoutStage;
/** @type {function(!Object): undefined} */
mxMedianHybridCrossingReduction.prototype.constructor = mxMedianHybridCrossingReduction;
/** @type {null} */
mxMedianHybridCrossingReduction.prototype.layout = null;
/** @type {number} */
mxMedianHybridCrossingReduction.prototype.maxIterations = 24;
/** @type {null} */
mxMedianHybridCrossingReduction.prototype.nestedBestRanks = null;
/** @type {number} */
mxMedianHybridCrossingReduction.prototype.currentBestCrossings = 0;
/** @type {number} */
mxMedianHybridCrossingReduction.prototype.iterationsWithoutImprovement = 0;
/** @type {number} */
mxMedianHybridCrossingReduction.prototype.maxNoImprovementIterations = 2;
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxMedianHybridCrossingReduction.prototype.execute = function(value) {
  value = this.layout.getModel();
  /** @type {!Array} */
  this.nestedBestRanks = [];
  /** @type {number} */
  var i = 0;
  for (; i < value.ranks.length; i++) {
    this.nestedBestRanks[i] = value.ranks[i].slice();
  }
  /** @type {number} */
  var e = 0;
  var a = this.calculateCrossings(value);
  /** @type {number} */
  i = 0;
  for (; i < this.maxIterations && e < this.maxNoImprovementIterations; i++) {
    this.weightedMedian(i, value);
    this.transpose(i, value);
    var n = this.calculateCrossings(value);
    if (n < a) {
      a = n;
      /** @type {number} */
      n = e = 0;
      for (; n < this.nestedBestRanks.length; n++) {
        var o = value.ranks[n];
        /** @type {number} */
        var j = 0;
        for (; j < o.length; j++) {
          var s = o[j];
          this.nestedBestRanks[n][s.getGeneralPurposeVariable(n)] = s;
        }
      }
    } else {
      e++;
      /** @type {number} */
      n = 0;
      for (; n < this.nestedBestRanks.length; n++) {
        o = value.ranks[n];
        /** @type {number} */
        j = 0;
        for (; j < o.length; j++) {
          s = o[j];
          s.setGeneralPurposeVariable(n, j);
        }
      }
    }
    if (0 == a) {
      break;
    }
  }
  /** @type {!Array} */
  e = [];
  /** @type {!Array} */
  a = [];
  /** @type {number} */
  i = 0;
  for (; i < value.maxRank + 1; i++) {
    /** @type {!Array} */
    a[i] = [];
    e[i] = a[i];
  }
  /** @type {number} */
  i = 0;
  for (; i < this.nestedBestRanks.length; i++) {
    /** @type {number} */
    n = 0;
    for (; n < this.nestedBestRanks[i].length; n++) {
      a[i].push(this.nestedBestRanks[i][n]);
    }
  }
  /** @type {!Array} */
  value.ranks = e;
};
/**
 * @param {!Object} n
 * @return {?}
 */
mxMedianHybridCrossingReduction.prototype.calculateCrossings = function(n) {
  var gLen = n.ranks.length;
  /** @type {number} */
  var str = 0;
  /** @type {number} */
  var g = 1;
  for (; g < gLen; g++) {
    str = str + this.calculateRankCrossing(g, n);
  }
  return str;
};
/**
 * @param {number} j
 * @param {!Object} n
 * @return {?}
 */
mxMedianHybridCrossingReduction.prototype.calculateRankCrossing = function(j, n) {
  /** @type {number} */
  var s_menu = 0;
  var a = n.ranks[j];
  var e = n.ranks[j - 1];
  /** @type {!Array} */
  var b = [];
  /** @type {number} */
  var i = 0;
  for (; i < a.length; i++) {
    var k = a[i];
    var key = k.getGeneralPurposeVariable(j);
    k = k.getPreviousLayerConnectedCells(j);
    /** @type {!Array} */
    var tmp = [];
    /** @type {number} */
    var km = 0;
    for (; km < k.length; km++) {
      var new_layer = k[km].getGeneralPurposeVariable(j - 1);
      tmp.push(new_layer);
    }
    tmp.sort(function(b, a) {
      return b - a;
    });
    /** @type {!Array} */
    b[key] = tmp;
  }
  /** @type {!Array} */
  a = [];
  /** @type {number} */
  i = 0;
  for (; i < b.length; i++) {
    /** @type {!Array<?>} */
    a = a.concat(b[i]);
  }
  /** @type {number} */
  b = 1;
  for (; b < e.length;) {
    /** @type {number} */
    b = b << 1;
  }
  /** @type {number} */
  key = 2 * b - 1;
  --b;
  /** @type {!Array} */
  e = [];
  /** @type {number} */
  i = 0;
  for (; i < key; ++i) {
    /** @type {number} */
    e[i] = 0;
  }
  /** @type {number} */
  i = 0;
  for (; i < a.length; i++) {
    key = a[i] + b;
    ++e[key];
    for (; 0 < key;) {
      if (key % 2) {
        s_menu = s_menu + e[key + 1];
      }
      /** @type {number} */
      key = key - 1 >> 1;
      ++e[key];
    }
  }
  return s_menu;
};
/**
 * @param {number} array
 * @param {!Object} results
 * @return {undefined}
 */
mxMedianHybridCrossingReduction.prototype.transpose = function(array, results) {
  /** @type {boolean} */
  var c = true;
  /** @type {number} */
  var d = 0;
  for (; c && 10 > d++;) {
    /** @type {boolean} */
    var ie = 1 == array % 2 && 1 == d % 2;
    /** @type {boolean} */
    c = false;
    /** @type {number} */
    var i = 0;
    for (; i < results.ranks.length; i++) {
      var list = results.ranks[i];
      /** @type {!Array} */
      var c = [];
      /** @type {number} */
      var l = 0;
      for (; l < list.length; l++) {
        var m = list[l];
        var s = m.getGeneralPurposeVariable(i);
        if (0 > s) {
          /** @type {number} */
          s = l;
        }
        c[s] = m;
      }
      /** @type {null} */
      var f = null;
      /** @type {null} */
      var h = null;
      var b;
      var result;
      /** @type {null} */
      var a = null;
      /** @type {null} */
      var items = null;
      var v;
      /** @type {null} */
      var r = null;
      /** @type {number} */
      l = 0;
      for (; l < list.length - 1; l++) {
        if (0 == l) {
          v = c[l];
          m = v.getNextLayerConnectedCells(i);
          s = v.getPreviousLayerConnectedCells(i);
          /** @type {!Array} */
          b = [];
          /** @type {!Array} */
          result = [];
          /** @type {number} */
          var j = 0;
          for (; j < m.length; j++) {
            b[j] = m[j].getGeneralPurposeVariable(i + 1);
          }
          /** @type {number} */
          j = 0;
          for (; j < s.length; j++) {
            result[j] = s[j].getGeneralPurposeVariable(i - 1);
          }
        } else {
          m = f;
          s = h;
          /** @type {(Array|null)} */
          b = a;
          /** @type {(Array|null)} */
          result = items;
          v = r;
        }
        r = c[l + 1];
        f = r.getNextLayerConnectedCells(i);
        h = r.getPreviousLayerConnectedCells(i);
        /** @type {!Array} */
        a = [];
        /** @type {!Array} */
        items = [];
        /** @type {number} */
        j = 0;
        for (; j < f.length; j++) {
          a[j] = f[j].getGeneralPurposeVariable(i + 1);
        }
        /** @type {number} */
        j = 0;
        for (; j < h.length; j++) {
          items[j] = h[j].getGeneralPurposeVariable(i - 1);
        }
        /** @type {number} */
        var PRV_M = 0;
        /** @type {number} */
        var current_privilege_level = 0;
        /** @type {number} */
        j = 0;
        for (; j < b.length; j++) {
          /** @type {number} */
          var i = 0;
          for (; i < a.length; i++) {
            if (b[j] > a[i]) {
              PRV_M++;
            }
            if (b[j] < a[i]) {
              current_privilege_level++;
            }
          }
        }
        /** @type {number} */
        j = 0;
        for (; j < result.length; j++) {
          /** @type {number} */
          i = 0;
          for (; i < items.length; i++) {
            if (result[j] > items[i]) {
              PRV_M++;
            }
            if (result[j] < items[i]) {
              current_privilege_level++;
            }
          }
        }
        if (current_privilege_level < PRV_M || current_privilege_level == PRV_M && ie) {
          f = v.getGeneralPurposeVariable(i);
          v.setGeneralPurposeVariable(i, r.getGeneralPurposeVariable(i));
          r.setGeneralPurposeVariable(i, f);
          f = m;
          h = s;
          /** @type {!Array} */
          a = b;
          /** @type {!Array} */
          items = result;
          r = v;
          if (!ie) {
            /** @type {boolean} */
            c = true;
          }
        }
      }
    }
  }
};
/**
 * @param {number} depsOptions
 * @param {!Object} node
 * @return {undefined}
 */
mxMedianHybridCrossingReduction.prototype.weightedMedian = function(depsOptions, node) {
  /** @type {boolean} */
  var QueryLanguageComponent = 0 == depsOptions % 2;
  if (QueryLanguageComponent) {
    /** @type {number} */
    var x = node.maxRank - 1;
    for (; 0 <= x; x--) {
      this.medianRank(x, QueryLanguageComponent);
    }
  } else {
    /** @type {number} */
    x = 1;
    for (; x < node.maxRank; x++) {
      this.medianRank(x, QueryLanguageComponent);
    }
  }
};
/**
 * @param {number} a
 * @param {boolean} b
 * @return {undefined}
 */
mxMedianHybridCrossingReduction.prototype.medianRank = function(a, b) {
  var styleDefLen = this.nestedBestRanks[a].length;
  /** @type {!Array} */
  var array = [];
  /** @type {!Array} */
  var tries = [];
  /** @type {number} */
  var t = 0;
  for (; t < styleDefLen; t++) {
    var i = this.nestedBestRanks[a][t];
    var row = new MedianCellSorter;
    row.cell = i;
    var value;
    value = b ? i.getNextLayerConnectedCells(a) : i.getPreviousLayerConnectedCells(a);
    var bValue;
    bValue = b ? a + 1 : a - 1;
    if (null != value && 0 != value.length) {
      row.medianValue = this.medianValue(value, bValue);
      array.push(row);
    } else {
      /** @type {boolean} */
      tries[i.getGeneralPurposeVariable(a)] = true;
    }
  }
  array.sort(MedianCellSorter.prototype.compare);
  /** @type {number} */
  t = 0;
  for (; t < styleDefLen; t++) {
    if (null == tries[t]) {
      i = array.shift().cell;
      i.setGeneralPurposeVariable(a, t);
    }
  }
};
/**
 * @param {!NodeList} t
 * @param {undefined} b
 * @return {?}
 */
mxMedianHybridCrossingReduction.prototype.medianValue = function(t, b) {
  /** @type {!Array} */
  var a = [];
  /** @type {number} */
  var i = 0;
  /** @type {number} */
  var j = 0;
  for (; j < t.length; j++) {
    var r = t[j];
    a[i++] = r.getGeneralPurposeVariable(b);
  }
  a.sort(function(b, a) {
    return b - a;
  });
  if (1 == i % 2) {
    return a[Math.floor(i / 2)];
  }
  if (2 == i) {
    return (a[0] + a[1]) / 2;
  }
  /** @type {number} */
  j = i / 2;
  /** @type {number} */
  r = a[j - 1] - a[0];
  /** @type {number} */
  i = a[i - 1] - a[j];
  return (a[j - 1] * i + a[j] * r) / (r + i);
};
/**
 * @return {undefined}
 */
function MedianCellSorter() {
}
/** @type {number} */
MedianCellSorter.prototype.medianValue = 0;
/** @type {boolean} */
MedianCellSorter.prototype.cell = false;
/**
 * @param {?} x
 * @param {?} y
 * @return {?}
 */
MedianCellSorter.prototype.compare = function(x, y) {
  return null != x && null != y ? y.medianValue > x.medianValue ? -1 : y.medianValue < x.medianValue ? 1 : 0 : 0;
};
/**
 * @param {!Object} layoutParam
 * @return {undefined}
 */
function mxMinimumCycleRemover(layoutParam) {
  /** @type {!Object} */
  this.layout = layoutParam;
}
mxMinimumCycleRemover.prototype = new mxHierarchicalLayoutStage;
/** @type {function(!Object): undefined} */
mxMinimumCycleRemover.prototype.constructor = mxMinimumCycleRemover;
/** @type {null} */
mxMinimumCycleRemover.prototype.layout = null;
/**
 * @param {!Object} node
 * @return {undefined}
 */
mxMinimumCycleRemover.prototype.execute = function(node) {
  node = this.layout.getModel();
  var data = {};
  var path = node.vertexMapper.getValues();
  var options = {};
  /** @type {number} */
  var i = 0;
  for (; i < path.length; i++) {
    options[path[i].id] = path[i];
  }
  /** @type {null} */
  path = null;
  if (null != node.roots) {
    var childrenIds = node.roots;
    /** @type {!Array} */
    path = [];
    /** @type {number} */
    i = 0;
    for (; i < childrenIds.length; i++) {
      path[i] = node.vertexMapper.get(childrenIds[i]);
    }
  }
  node.visit(function(parent, child, e, canCreateDiscussions, n) {
    if (child.isAncestor(parent)) {
      e.invert();
      mxUtils.remove(e, parent.connectsAsSource);
      parent.connectsAsTarget.push(e);
      mxUtils.remove(e, child.connectsAsTarget);
      child.connectsAsSource.push(e);
    }
    /** @type {!Node} */
    data[child.id] = child;
    delete options[child.id];
  }, path, true, null);
  i = mxUtils.clone(data, null, true);
  node.visit(function(parent, child, e, canCreateDiscussions, n) {
    if (child.isAncestor(parent)) {
      e.invert();
      mxUtils.remove(e, parent.connectsAsSource);
      child.connectsAsSource.push(e);
      parent.connectsAsTarget.push(e);
      mxUtils.remove(e, child.connectsAsTarget);
    }
    /** @type {!Node} */
    data[child.id] = child;
    delete options[child.id];
  }, options, true, i);
};
/**
 * @param {!Object} layoutParam
 * @param {number} textStyleModel
 * @param {number} aMetadata
 * @param {string} aOrientation
 * @param {number} aPanel_height
 * @param {number} aInstance_id
 * @return {undefined}
 */
function mxCoordinateAssignment(layoutParam, textStyleModel, aMetadata, aOrientation, aPanel_height, aInstance_id) {
  /** @type {!Object} */
  this.layout = layoutParam;
  /** @type {number} */
  this.intraCellSpacing = textStyleModel;
  /** @type {number} */
  this.interRankCellSpacing = aMetadata;
  /** @type {string} */
  this.orientation = aOrientation;
  /** @type {number} */
  this.initialX = aPanel_height;
  /** @type {number} */
  this.parallelEdgeSpacing = aInstance_id;
}
mxCoordinateAssignment.prototype = new mxHierarchicalLayoutStage;
/** @type {function(!Object, number, number, string, number, number): undefined} */
mxCoordinateAssignment.prototype.constructor = mxCoordinateAssignment;
/** @type {null} */
mxCoordinateAssignment.prototype.layout = null;
/** @type {number} */
mxCoordinateAssignment.prototype.intraCellSpacing = 30;
/** @type {number} */
mxCoordinateAssignment.prototype.interRankCellSpacing = 100;
/** @type {number} */
mxCoordinateAssignment.prototype.parallelEdgeSpacing = 10;
/** @type {number} */
mxCoordinateAssignment.prototype.maxIterations = 8;
/** @type {number} */
mxCoordinateAssignment.prototype.prefHozEdgeSep = 5;
/** @type {number} */
mxCoordinateAssignment.prototype.prefVertEdgeOff = 2;
/** @type {number} */
mxCoordinateAssignment.prototype.minEdgeJetty = 12;
/** @type {number} */
mxCoordinateAssignment.prototype.channelBuffer = 4;
/** @type {null} */
mxCoordinateAssignment.prototype.jettyPositions = null;
/** @type {string} */
mxCoordinateAssignment.prototype.orientation = mxConstants.DIRECTION_NORTH;
/** @type {null} */
mxCoordinateAssignment.prototype.initialX = null;
/** @type {null} */
mxCoordinateAssignment.prototype.limitX = null;
/** @type {null} */
mxCoordinateAssignment.prototype.currentXDelta = null;
/** @type {null} */
mxCoordinateAssignment.prototype.widestRank = null;
/** @type {null} */
mxCoordinateAssignment.prototype.rankTopY = null;
/** @type {null} */
mxCoordinateAssignment.prototype.rankBottomY = null;
/** @type {null} */
mxCoordinateAssignment.prototype.widestRankValue = null;
/** @type {null} */
mxCoordinateAssignment.prototype.rankWidths = null;
/** @type {null} */
mxCoordinateAssignment.prototype.rankY = null;
/** @type {boolean} */
mxCoordinateAssignment.prototype.fineTuning = true;
/** @type {null} */
mxCoordinateAssignment.prototype.nextLayerConnectedCache = null;
/** @type {null} */
mxCoordinateAssignment.prototype.previousLayerConnectedCache = null;
/** @type {number} */
mxCoordinateAssignment.prototype.groupPadding = 10;
/**
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.printStatus = function() {
  var other = this.layout.getModel();
  mxLog.show();
  mxLog.writeln("======Coord assignment debug=======");
  /** @type {number} */
  var i = 0;
  for (; i < other.ranks.length; i++) {
    mxLog.write("Rank ", i, " : ");
    var month_name = other.ranks[i];
    /** @type {number} */
    var month_full_i = 0;
    for (; month_full_i < month_name.length; month_full_i++) {
      mxLog.write(month_name[month_full_i].getGeneralPurposeVariable(i), "  ");
    }
    mxLog.writeln();
  }
  mxLog.writeln("====================================");
};
/**
 * @param {!Object} n
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.execute = function(n) {
  this.jettyPositions = {};
  n = this.layout.getModel();
  /** @type {number} */
  this.currentXDelta = 0;
  this.initialCoords(this.layout.getGraph(), n);
  if (this.fineTuning) {
    this.minNode(n);
  }
  /** @type {number} */
  var b = 1E8;
  if (this.fineTuning) {
    /** @type {number} */
    var valueProgess = 0;
    for (; valueProgess < this.maxIterations; valueProgess++) {
      if (0 != valueProgess) {
        this.medianPos(valueProgess, n);
        this.minNode(n);
      }
      if (this.currentXDelta < b) {
        /** @type {number} */
        var j = 0;
        for (; j < n.ranks.length; j++) {
          var q = n.ranks[j];
          /** @type {number} */
          var i = 0;
          for (; i < q.length; i++) {
            var view = q[i];
            view.setX(j, view.getGeneralPurposeVariable(j));
          }
        }
        /** @type {number} */
        b = this.currentXDelta;
      } else {
        /** @type {number} */
        j = 0;
        for (; j < n.ranks.length; j++) {
          q = n.ranks[j];
          /** @type {number} */
          i = 0;
          for (; i < q.length; i++) {
            view = q[i];
            view.setGeneralPurposeVariable(j, view.getX(j));
          }
        }
      }
      this.minPath(this.layout.getGraph(), n);
      /** @type {number} */
      this.currentXDelta = 0;
    }
  }
  this.setCellLocations(this.layout.getGraph(), n);
};
/**
 * @param {string} n
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.minNode = function(n) {
  /** @type {!Array} */
  var col = [];
  var p = new mxDictionary;
  /** @type {!Array} */
  var storage = [];
  /** @type {number} */
  var i = 0;
  for (; i <= n.maxRank; i++) {
    storage[i] = n.ranks[i];
    /** @type {number} */
    var index = 0;
    for (; index < storage[i].length; index++) {
      var item = storage[i][index];
      var data = new WeightedCellSorter(item, i);
      /** @type {number} */
      data.rankIndex = index;
      /** @type {boolean} */
      data.visited = true;
      col.push(data);
      p.put(item, data);
    }
  }
  /** @type {number} */
  n = 10 * col.length;
  /** @type {number} */
  index = 0;
  for (; 0 < col.length && index <= n;) {
    item = col.shift();
    i = item.cell;
    var c = item.weightedValue;
    /** @type {number} */
    var r = parseInt(item.rankIndex);
    data = i.getNextLayerConnectedCells(c);
    var val = i.getPreviousLayerConnectedCells(c);
    var y = data.length;
    var x = val.length;
    var w = this.medianXValue(data, c + 1);
    var z = this.medianXValue(val, c - 1);
    var a22 = y + x;
    var b = i.getGeneralPurposeVariable(c);
    var a = b;
    if (0 < a22) {
      /** @type {number} */
      a = (w * y + z * x) / a22;
    }
    /** @type {boolean} */
    y = false;
    if (a < b - 1) {
      if (0 == r) {
        i.setGeneralPurposeVariable(c, a);
        /** @type {boolean} */
        y = true;
      } else {
        r = storage[c][r - 1];
        b = r.getGeneralPurposeVariable(c);
        b = b + r.width / 2 + this.intraCellSpacing + i.width / 2;
        if (b < a) {
          i.setGeneralPurposeVariable(c, a);
          /** @type {boolean} */
          y = true;
        } else {
          if (b < i.getGeneralPurposeVariable(c) - 1) {
            i.setGeneralPurposeVariable(c, b);
            /** @type {boolean} */
            y = true;
          }
        }
      }
    } else {
      if (a > b + 1) {
        if (r == storage[c].length - 1) {
          i.setGeneralPurposeVariable(c, a);
          /** @type {boolean} */
          y = true;
        } else {
          r = storage[c][r + 1];
          b = r.getGeneralPurposeVariable(c);
          /** @type {number} */
          b = b - r.width / 2 - this.intraCellSpacing - i.width / 2;
          if (b > a) {
            i.setGeneralPurposeVariable(c, a);
            /** @type {boolean} */
            y = true;
          } else {
            if (b > i.getGeneralPurposeVariable(c) + 1) {
              i.setGeneralPurposeVariable(c, b);
              /** @type {boolean} */
              y = true;
            }
          }
        }
      }
    }
    if (y) {
      /** @type {number} */
      i = 0;
      for (; i < data.length; i++) {
        c = data[i];
        c = p.get(c);
        if (null != c && 0 == c.visited) {
          /** @type {boolean} */
          c.visited = true;
          col.push(c);
        }
      }
      /** @type {number} */
      i = 0;
      for (; i < val.length; i++) {
        c = val[i];
        c = p.get(c);
        if (null != c && 0 == c.visited) {
          /** @type {boolean} */
          c.visited = true;
          col.push(c);
        }
      }
    }
    /** @type {boolean} */
    item.visited = false;
    index++;
  }
};
/**
 * @param {number} a
 * @param {?} value
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.medianPos = function(a, value) {
  if (0 == a % 2) {
    var maxLength = value.maxRank;
    for (; 0 < maxLength; maxLength--) {
      this.rankMedianPosition(maxLength - 1, value, maxLength);
    }
  } else {
    /** @type {number} */
    maxLength = 0;
    for (; maxLength < value.maxRank - 1; maxLength++) {
      this.rankMedianPosition(maxLength + 1, value, maxLength);
    }
  }
};
/**
 * @param {number} i
 * @param {!Array} results
 * @param {undefined} n
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.rankMedianPosition = function(i, results, n) {
  results = results.ranks[i];
  /** @type {!Array} */
  var result = [];
  var list = {};
  /** @type {number} */
  var k = 0;
  for (; k < results.length; k++) {
    var cell = results[k];
    result[k] = new WeightedCellSorter;
    result[k].cell = cell;
    /** @type {number} */
    result[k].rankIndex = k;
    list[cell.id] = result[k];
    var end;
    end = n < i ? cell.getPreviousLayerConnectedCells(i) : cell.getNextLayerConnectedCells(i);
    result[k].weightedValue = this.calculatedWeightedValue(cell, end);
  }
  result.sort(WeightedCellSorter.prototype.compare);
  /** @type {number} */
  k = 0;
  for (; k < result.length; k++) {
    var value;
    cell = result[k].cell;
    /** @type {number} */
    value = 0;
    end = n < i ? cell.getPreviousLayerConnectedCells(i).slice() : cell.getNextLayerConnectedCells(i).slice();
    if (null != end) {
      value = end.length;
      value = 0 < value ? this.medianXValue(end, n) : cell.getGeneralPurposeVariable(i);
    }
    /** @type {number} */
    var ret = 0;
    /** @type {number} */
    end = -1E8;
    /** @type {number} */
    var index = result[k].rankIndex - 1;
    for (; 0 <= index;) {
      var data = list[results[index].id];
      if (null != data) {
        var start = data.cell;
        if (data.visited) {
          end = start.getGeneralPurposeVariable(i) + start.width / 2 + this.intraCellSpacing + ret + cell.width / 2;
          /** @type {number} */
          index = -1;
        } else {
          ret = ret + (start.width + this.intraCellSpacing);
          index--;
        }
      }
    }
    /** @type {number} */
    ret = 0;
    /** @type {number} */
    start = 1E8;
    index = result[k].rankIndex + 1;
    for (; index < result.length;) {
      if (data = list[results[index].id], null != data) {
        var content = data.cell;
        if (data.visited) {
          /** @type {number} */
          start = content.getGeneralPurposeVariable(i) - content.width / 2 - this.intraCellSpacing - ret - cell.width / 2;
          /** @type {number} */
          index = result.length;
        } else {
          ret = ret + (content.width + this.intraCellSpacing);
          index++;
        }
      }
    }
    if (value >= end && value <= start) {
      cell.setGeneralPurposeVariable(i, value);
    } else {
      if (value < end) {
        cell.setGeneralPurposeVariable(i, end);
        this.currentXDelta += end - value;
      } else {
        if (value > start) {
          cell.setGeneralPurposeVariable(i, start);
          this.currentXDelta += value - start;
        }
      }
    }
    /** @type {boolean} */
    result[k].visited = true;
  }
};
/**
 * @param {?} model
 * @param {!NodeList} value
 * @return {?}
 */
mxCoordinateAssignment.prototype.calculatedWeightedValue = function(model, value) {
  /** @type {number} */
  var c = 0;
  /** @type {number} */
  var idx = 0;
  for (; idx < value.length; idx++) {
    var V = value[idx];
    if (model.isVertex() && V.isVertex()) {
      c++;
    } else {
      /** @type {number} */
      c = model.isEdge() && V.isEdge() ? c + 8 : c + 2;
    }
  }
  return c;
};
/**
 * @param {!NodeList} s
 * @param {number} o
 * @return {?}
 */
mxCoordinateAssignment.prototype.medianXValue = function(s, o) {
  if (0 == s.length) {
    return 0;
  }
  /** @type {!Array} */
  var a = [];
  /** @type {number} */
  var i = 0;
  for (; i < s.length; i++) {
    a[i] = s[i].getGeneralPurposeVariable(o);
  }
  a.sort(function(b, a) {
    return b - a;
  });
  if (1 == s.length % 2) {
    return a[Math.floor(s.length / 2)];
  }
  /** @type {number} */
  i = s.length / 2;
  return (a[i - 1] + a[i]) / 2;
};
/**
 * @param {undefined} classAtom
 * @param {boolean} value
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.initialCoords = function(classAtom, value) {
  this.calculateWidestRank(classAtom, value);
  var j = this.widestRank;
  for (; 0 <= j; j--) {
    if (j < value.maxRank) {
      this.rankCoordinates(j, classAtom, value);
    }
  }
  j = this.widestRank + 1;
  for (; j <= value.maxRank; j++) {
    if (0 < j) {
      this.rankCoordinates(j, classAtom, value);
    }
  }
};
/**
 * @param {undefined} i
 * @param {number} str
 * @param {number} n
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.rankCoordinates = function(i, str, n) {
  str = n.ranks[i];
  n = this.initialX + (this.widestRankValue - this.rankWidths[i]) / 2;
  /** @type {boolean} */
  var d = false;
  /** @type {number} */
  var num = 0;
  for (; num < str.length; num++) {
    var self = str[num];
    if (self.isVertex()) {
      var params = this.layout.getVertexBounds(self.cell);
      if (null != params) {
        if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
          self.width = params.width;
          self.height = params.height;
        } else {
          self.width = params.height;
          self.height = params.width;
        }
      } else {
        /** @type {boolean} */
        d = true;
      }
    } else {
      if (self.isEdge()) {
        /** @type {number} */
        params = 1;
        if (null != self.edges) {
          params = self.edges.length;
        } else {
          mxLog.warn("edge.edges is null");
        }
        /** @type {number} */
        self.width = (params - 1) * this.parallelEdgeSpacing;
      }
    }
    n = n + self.width / 2;
    self.setX(i, n);
    self.setGeneralPurposeVariable(i, n);
    n = n + self.width / 2;
    n = n + this.intraCellSpacing;
  }
  if (1 == d) {
    mxLog.warn("At least one cell has no bounds");
  }
};
/**
 * @param {!Object} str
 * @param {boolean} value
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.calculateWidestRank = function(str, value) {
  /** @type {number} */
  var y = -this.interRankCellSpacing;
  /** @type {number} */
  var toX = 0;
  /** @type {!Array} */
  this.rankWidths = [];
  /** @type {!Array} */
  this.rankY = [];
  var j = value.maxRank;
  for (; 0 <= j; j--) {
    /** @type {number} */
    var fromX = 0;
    var name = value.ranks[j];
    var i = this.initialX;
    /** @type {boolean} */
    var l = false;
    /** @type {number} */
    var k = 0;
    for (; k < name.length; k++) {
      var a = name[k];
      if (a.isVertex()) {
        var elem = this.layout.getVertexBounds(a.cell);
        if (null != elem) {
          if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
            a.width = elem.width;
            a.height = elem.height;
          } else {
            a.width = elem.height;
            a.height = elem.width;
          }
        } else {
          /** @type {boolean} */
          l = true;
        }
        /** @type {number} */
        fromX = Math.max(fromX, a.height);
      } else {
        if (a.isEdge()) {
          /** @type {number} */
          elem = 1;
          if (null != a.edges) {
            elem = a.edges.length;
          } else {
            mxLog.warn("edge.edges is null");
          }
          /** @type {number} */
          a.width = (elem - 1) * this.parallelEdgeSpacing;
        }
      }
      i = i + a.width / 2;
      a.setX(j, i);
      a.setGeneralPurposeVariable(j, i);
      i = i + a.width / 2;
      i = i + this.intraCellSpacing;
      if (i > this.widestRankValue) {
        this.widestRankValue = i;
        this.widestRank = j;
      }
      this.rankWidths[j] = i;
    }
    if (1 == l) {
      mxLog.warn("At least one cell has no bounds");
    }
    this.rankY[j] = y;
    i = fromX / 2 + toX / 2 + this.interRankCellSpacing;
    /** @type {number} */
    toX = fromX;
    y = this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_WEST ? y + i : y - i;
    /** @type {number} */
    k = 0;
    for (; k < name.length; k++) {
      name[k].setY(j, y);
    }
  }
};
/**
 * @param {?} result
 * @param {!Object} r
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.minPath = function(result, r) {
  var bodyChildNodes = r.edgeMapper.getValues();
  /** @type {number} */
  var i = 0;
  for (; i < bodyChildNodes.length; i++) {
    var node = bodyChildNodes[i];
    if (!(1 > node.maxRank - node.minRank - 1)) {
      var h = node.getGeneralPurposeVariable(node.minRank + 1);
      /** @type {boolean} */
      var w = true;
      /** @type {number} */
      var max = 0;
      var i = node.minRank + 2;
      for (; i < node.maxRank; i++) {
        var n = node.getGeneralPurposeVariable(i);
        if (h != n) {
          /** @type {boolean} */
          w = false;
          h = n;
        } else {
          max++;
        }
      }
      if (!w) {
        /** @type {number} */
        w = h = 0;
        /** @type {!Array} */
        n = [];
        /** @type {!Array} */
        var object = [];
        var p = node.getGeneralPurposeVariable(node.minRank + 1);
        i = node.minRank + 1;
        for (; i < node.maxRank - 1; i++) {
          var b = node.getX(i + 1);
          if (p == b) {
            n[i - node.minRank - 1] = p;
            h++;
          } else {
            if (this.repositionValid(r, node, i + 1, p)) {
              n[i - node.minRank - 1] = p;
              h++;
            } else {
              p = n[i - node.minRank - 1] = b;
            }
          }
        }
        p = node.getX(i);
        /** @type {number} */
        i = node.maxRank - 1;
        for (; i > node.minRank + 1; i--) {
          b = node.getX(i - 1);
          if (p == b) {
            object[i - node.minRank - 2] = p;
            w++;
          } else {
            if (this.repositionValid(r, node, i - 1, p)) {
              object[i - node.minRank - 2] = p;
              w++;
            } else {
              object[i - node.minRank - 2] = node.getX(i - 1);
              p = b;
            }
          }
        }
        if (w > max || h > max) {
          if (w >= h) {
            /** @type {number} */
            i = node.maxRank - 2;
            for (; i > node.minRank; i--) {
              node.setX(i, object[i - node.minRank - 1]);
            }
          } else {
            if (h > w) {
              i = node.minRank + 2;
              for (; i < node.maxRank; i++) {
                node.setX(i, n[i - node.minRank - 2]);
              }
            }
          }
        }
      }
    }
  }
};
/**
 * @param {!Object} n
 * @param {!Object} d
 * @param {number} i
 * @param {number} y
 * @return {?}
 */
mxCoordinateAssignment.prototype.repositionValid = function(n, d, i, y) {
  n = n.ranks[i];
  /** @type {number} */
  var l = -1;
  /** @type {number} */
  var x = 0;
  for (; x < n.length; x++) {
    if (d == n[x]) {
      /** @type {number} */
      l = x;
      break;
    }
  }
  if (0 > l) {
    return false;
  }
  x = d.getGeneralPurposeVariable(i);
  if (y < x) {
    if (0 == l) {
      return true;
    }
    n = n[l - 1];
    i = n.getGeneralPurposeVariable(i);
    i = i + n.width / 2 + this.intraCellSpacing + d.width / 2;
    if (!(i <= y)) {
      return false;
    }
  } else {
    if (y > x) {
      if (l == n.length - 1) {
        return true;
      }
      n = n[l + 1];
      i = n.getGeneralPurposeVariable(i);
      /** @type {number} */
      i = i - n.width / 2 - this.intraCellSpacing - d.width / 2;
      if (!(i >= y)) {
        return false;
      }
    }
  }
  return true;
};
/**
 * @param {?} finalizers
 * @param {!Object} self
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.setCellLocations = function(finalizers, self) {
  /** @type {!Array} */
  this.rankTopY = [];
  /** @type {!Array} */
  this.rankBottomY = [];
  /** @type {number} */
  var i = 0;
  for (; i < self.ranks.length; i++) {
    /** @type {number} */
    this.rankTopY[i] = Number.MAX_VALUE;
    /** @type {number} */
    this.rankBottomY[i] = -Number.MAX_VALUE;
  }
  var keywordResults = self.vertexMapper.getValues();
  /** @type {number} */
  i = 0;
  for (; i < keywordResults.length; i++) {
    this.setVertexLocation(keywordResults[i]);
  }
  if (!(this.layout.edgeStyle != mxHierarchicalEdgeStyle.ORTHOGONAL && this.layout.edgeStyle != mxHierarchicalEdgeStyle.POLYLINE && this.layout.edgeStyle != mxHierarchicalEdgeStyle.CURVE)) {
    this.localEdgeProcessing(self);
  }
  keywordResults = self.edgeMapper.getValues();
  /** @type {number} */
  i = 0;
  for (; i < keywordResults.length; i++) {
    this.setEdgePosition(keywordResults[i]);
  }
};
/**
 * @param {!Object} other
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.localEdgeProcessing = function(other) {
  /** @type {number} */
  var i = 0;
  for (; i < other.ranks.length; i++) {
    var track = other.ranks[i];
    /** @type {number} */
    var j = 0;
    for (; j < track.length; j++) {
      var segment = track[j];
      if (segment.isVertex()) {
        var count = segment.getPreviousLayerConnectedCells(i);
        /** @type {number} */
        var index = i - 1;
        /** @type {number} */
        var connected_anchor_id = 0;
        for (; 2 > connected_anchor_id; connected_anchor_id++) {
          if (-1 < index && index < other.ranks.length && null != count && 0 < count.length) {
            /** @type {!Array} */
            var r = [];
            /** @type {number} */
            var i = 0;
            for (; i < count.length; i++) {
              var y = new WeightedCellSorter(count[i], count[i].getX(index));
              r.push(y);
            }
            r.sort(WeightedCellSorter.prototype.compare);
            /** @type {number} */
            y = segment.x[0] - segment.width / 2;
            var height = y + segment.width;
            /** @type {number} */
            var tableslen = count = 0;
            /** @type {!Array} */
            index = [];
            /** @type {number} */
            i = 0;
            for (; i < r.length; i++) {
              var obj = r[i].cell;
              var values;
              if (obj.isVertex()) {
                values = 0 == connected_anchor_id ? segment.connectsAsSource : segment.connectsAsTarget;
                /** @type {number} */
                var i = 0;
                for (; i < values.length; i++) {
                  if (values[i].source == obj || values[i].target == obj) {
                    count = count + values[i].edges.length;
                    tableslen++;
                    index.push(values[i]);
                  }
                }
              } else {
                count = count + obj.edges.length;
                tableslen++;
                index.push(obj);
              }
            }
            if (segment.width > (count + 1) * this.prefHozEdgeSep + 2 * this.prefHozEdgeSep) {
              y = y + this.prefHozEdgeSep;
              /** @type {number} */
              height = height - this.prefHozEdgeSep;
            }
            /** @type {number} */
            r = (height - y) / count;
            y = y + r / 2;
            /** @type {number} */
            height = this.minEdgeJetty - this.prefVertEdgeOff;
            /** @type {number} */
            i = 0;
            for (; i < index.length; i++) {
              tableslen = index[i].edges.length;
              obj = this.jettyPositions[index[i].ids[0]];
              if (null == obj) {
                /** @type {!Array} */
                obj = [];
                /** @type {!Array} */
                this.jettyPositions[index[i].ids[0]] = obj;
              }
              if (i < count / 2) {
                height = height + this.prefVertEdgeOff;
              } else {
                if (i > count / 2) {
                  /** @type {number} */
                  height = height - this.prefVertEdgeOff;
                }
              }
              /** @type {number} */
              values = 0;
              for (; values < tableslen; values++) {
                obj[4 * values + 2 * connected_anchor_id] = y;
                y = y + r;
                /** @type {number} */
                obj[4 * values + 2 * connected_anchor_id + 1] = height;
              }
            }
          }
          count = segment.getNextLayerConnectedCells(i);
          /** @type {number} */
          index = i + 1;
        }
      }
    }
  }
};
/**
 * @param {!Object} d
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.setEdgePosition = function(d) {
  /** @type {number} */
  var rootInt = 0;
  if (101207 != d.temp[0]) {
    var hours = d.maxRank;
    var i = d.minRank;
    if (hours == i) {
      hours = d.source.maxRank;
      i = d.target.minRank;
    }
    /** @type {number} */
    var t = 0;
    var m = this.jettyPositions[d.ids[0]];
    var childCount = d.isReversed ? d.target.cell : d.source.cell;
    var options = this.layout.graph;
    /** @type {boolean} */
    var v = this.orientation == mxConstants.DIRECTION_EAST || this.orientation == mxConstants.DIRECTION_SOUTH;
    /** @type {number} */
    var j = 0;
    for (; j < d.edges.length; j++) {
      var c = d.edges[j];
      var val = this.layout.getVisibleTerminal(c, true);
      /** @type {!Array} */
      var self = [];
      var value = d.isReversed;
      if (val != childCount) {
        /** @type {boolean} */
        value = !value;
      }
      if (null != m) {
        /** @type {number} */
        var s = value ? 2 : 0;
        var x = value ? v ? this.rankBottomY[i] : this.rankTopY[i] : v ? this.rankTopY[hours] : this.rankBottomY[hours];
        var size = m[4 * t + 1 + s];
        if (value != v) {
          /** @type {number} */
          size = -size;
        }
        x = x + size;
        s = m[4 * t + s];
        var item = options.model.getTerminal(c, true);
        if (this.layout.isPort(item) && options.model.getParent(item) == val) {
          s = options.view.getState(item);
          s = null != s ? s.x : val.geometry.x + d.source.width * item.geometry.x;
        }
        if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
          self.push(new mxPoint(s, x));
          if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
            self.push(new mxPoint(s, x + size));
          }
        } else {
          self.push(new mxPoint(x, s));
          if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
            self.push(new mxPoint(x + size, s));
          }
        }
      }
      /** @type {number} */
      s = d.x.length - 1;
      /** @type {number} */
      x = size = -1;
      /** @type {number} */
      val = d.maxRank - 1;
      if (value) {
        /** @type {number} */
        s = 0;
        size = d.x.length;
        /** @type {number} */
        x = 1;
        val = d.minRank + 1;
      }
      for (; d.maxRank != d.minRank && s != size; s = s + x) {
        item = d.x[s] + rootInt;
        /** @type {number} */
        var body = (this.rankTopY[val] + this.rankBottomY[val + 1]) / 2;
        /** @type {number} */
        var url = (this.rankTopY[val - 1] + this.rankBottomY[val]) / 2;
        if (value) {
          /** @type {number} */
          var root = body;
          /** @type {number} */
          body = url;
          /** @type {number} */
          url = root;
        }
        if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
          self.push(new mxPoint(item, body));
          self.push(new mxPoint(item, url));
        } else {
          self.push(new mxPoint(body, item));
          self.push(new mxPoint(url, item));
        }
        /** @type {number} */
        this.limitX = Math.max(this.limitX, item);
        val = val + x;
      }
      if (null != m) {
        /** @type {number} */
        s = value ? 2 : 0;
        x = value ? v ? this.rankTopY[hours] : this.rankBottomY[hours] : v ? this.rankBottomY[i] : this.rankTopY[i];
        size = m[4 * t + 3 - s];
        if (value != v) {
          /** @type {number} */
          size = -size;
        }
        /** @type {number} */
        x = x - size;
        s = m[4 * t + 2 - s];
        value = options.model.getTerminal(c, false);
        val = this.layout.getVisibleTerminal(c, false);
        if (this.layout.isPort(value) && options.model.getParent(value) == val) {
          s = options.view.getState(value);
          s = null != s ? s.x : val.geometry.x + d.target.width * value.geometry.x;
        }
        if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
          if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
            self.push(new mxPoint(s, x - size));
          }
          self.push(new mxPoint(s, x));
        } else {
          if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
            self.push(new mxPoint(x - size, s));
          }
          self.push(new mxPoint(x, s));
        }
      }
      if (d.isReversed) {
        this.processReversedEdge(d, c);
      }
      this.layout.setEdgePoints(c, self);
      rootInt = 0 == rootInt ? this.parallelEdgeSpacing : 0 < rootInt ? -rootInt : -rootInt + this.parallelEdgeSpacing;
      t++;
    }
    /** @type {number} */
    d.temp[0] = 101207;
  }
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.setVertexLocation = function(data) {
  var content = data.cell;
  /** @type {number} */
  var y = data.x[0] - data.width / 2;
  /** @type {number} */
  var top = data.y[0] - data.height / 2;
  /** @type {number} */
  this.rankTopY[data.minRank] = Math.min(this.rankTopY[data.minRank], top);
  /** @type {number} */
  this.rankBottomY[data.minRank] = Math.max(this.rankBottomY[data.minRank], top + data.height);
  if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
    this.layout.setVertexLocation(content, y, top);
  } else {
    this.layout.setVertexLocation(content, top, y);
  }
  /** @type {number} */
  this.limitX = Math.max(this.limitX, y + data.width);
};
/**
 * @param {!Object} s
 * @param {?} n
 * @return {undefined}
 */
mxCoordinateAssignment.prototype.processReversedEdge = function(s, n) {
};
/**
 * @param {!Object} layoutParam
 * @return {undefined}
 */
function mxSwimlaneOrdering(layoutParam) {
  /** @type {!Object} */
  this.layout = layoutParam;
}
mxSwimlaneOrdering.prototype = new mxHierarchicalLayoutStage;
/** @type {function(!Object): undefined} */
mxSwimlaneOrdering.prototype.constructor = mxSwimlaneOrdering;
/** @type {null} */
mxSwimlaneOrdering.prototype.layout = null;
/**
 * @param {!Object} node
 * @return {undefined}
 */
mxSwimlaneOrdering.prototype.execute = function(node) {
  node = this.layout.getModel();
  var rfcParsed = mxUtils.clone(node.vertexMapper, null, true);
  /** @type {null} */
  var path = null;
  if (null != node.roots) {
    var childrenIds = node.roots;
    /** @type {!Array} */
    path = [];
    /** @type {number} */
    var i = 0;
    for (; i < childrenIds.length; i++) {
      path[i] = node.vertexMapper.get(childrenIds[i]);
    }
  }
  node.visit(function(p, c, e, canCreateDiscussions, isSlidingUp) {
    canCreateDiscussions = null != p && p.swimlaneIndex == c.swimlaneIndex && c.isAncestor(p);
    /** @type {boolean} */
    isSlidingUp = null != p && null != e && p.swimlaneIndex < c.swimlaneIndex && e.source == c;
    if (canCreateDiscussions) {
      e.invert();
      mxUtils.remove(e, p.connectsAsSource);
      c.connectsAsSource.push(e);
      p.connectsAsTarget.push(e);
      mxUtils.remove(e, c.connectsAsTarget);
    } else {
      if (isSlidingUp) {
        e.invert();
        mxUtils.remove(e, p.connectsAsTarget);
        c.connectsAsTarget.push(e);
        p.connectsAsSource.push(e);
        mxUtils.remove(e, c.connectsAsSource);
      }
    }
    p = mxCellPath.create(c.cell);
    delete rfcParsed[p];
  }, path, true, null);
};
/**
 * @param {?} game
 * @param {string} orientation
 * @param {?} min
 * @return {undefined}
 */
function mxHierarchicalLayout(game, orientation, min) {
  mxGraphLayout.call(this, game);
  this.orientation = null != orientation ? orientation : mxConstants.DIRECTION_NORTH;
  this.deterministic = null != min ? min : true;
}
var mxHierarchicalEdgeStyle = {
  ORTHOGONAL : 1,
  POLYLINE : 2,
  STRAIGHT : 3,
  CURVE : 4
};
mxHierarchicalLayout.prototype = new mxGraphLayout;
/** @type {function(?, string, ?): undefined} */
mxHierarchicalLayout.prototype.constructor = mxHierarchicalLayout;
/** @type {null} */
mxHierarchicalLayout.prototype.roots = null;
/** @type {boolean} */
mxHierarchicalLayout.prototype.resizeParent = false;
/** @type {boolean} */
mxHierarchicalLayout.prototype.maintainParentLocation = false;
/** @type {boolean} */
mxHierarchicalLayout.prototype.moveParent = false;
/** @type {number} */
mxHierarchicalLayout.prototype.parentBorder = 0;
/** @type {number} */
mxHierarchicalLayout.prototype.intraCellSpacing = 30;
/** @type {number} */
mxHierarchicalLayout.prototype.interRankCellSpacing = 100;
/** @type {number} */
mxHierarchicalLayout.prototype.interHierarchySpacing = 60;
/** @type {number} */
mxHierarchicalLayout.prototype.parallelEdgeSpacing = 10;
/** @type {string} */
mxHierarchicalLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;
/** @type {boolean} */
mxHierarchicalLayout.prototype.fineTuning = true;
/** @type {boolean} */
mxHierarchicalLayout.prototype.tightenToSource = true;
/** @type {boolean} */
mxHierarchicalLayout.prototype.disableEdgeStyle = true;
/** @type {boolean} */
mxHierarchicalLayout.prototype.traverseAncestors = true;
/** @type {null} */
mxHierarchicalLayout.prototype.model = null;
/** @type {null} */
mxHierarchicalLayout.prototype.edgesCache = null;
/** @type {null} */
mxHierarchicalLayout.prototype.edgeSourceTermCache = null;
/** @type {null} */
mxHierarchicalLayout.prototype.edgesTargetTermCache = null;
/** @type {number} */
mxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;
/**
 * @return {?}
 */
mxHierarchicalLayout.prototype.getModel = function() {
  return this.model;
};
/**
 * @param {?} element
 * @param {!Object} args
 * @return {undefined}
 */
mxHierarchicalLayout.prototype.execute = function(element, args) {
  this.parent = element;
  var model = this.graph.model;
  this.edgesCache = new mxDictionary;
  this.edgeSourceTermCache = new mxDictionary;
  this.edgesTargetTermCache = new mxDictionary;
  if (!(null == args || args instanceof Array)) {
    /** @type {!Array} */
    args = [args];
  }
  if (null != args || null != element) {
    /** @type {null} */
    this.parentY = this.parentX = null;
    if (element != this.root && null != model.isVertex(element) && this.maintainParentLocation) {
      var res = this.graph.getCellGeometry(element);
      if (null != res) {
        this.parentX = res.x;
        this.parentY = res.y;
      }
    }
    if (null != args) {
      /** @type {!Array} */
      var command_line_args = [];
      /** @type {number} */
      var i = 0;
      for (; i < args.length; i++) {
        if ((null != element ? model.isAncestor(element, args[i]) : 1) && model.isVertex(args[i])) {
          command_line_args.push(args[i]);
        }
      }
      /** @type {!Array} */
      this.roots = command_line_args;
    }
    model.beginUpdate();
    try {
      this.run(element);
      if (this.resizeParent && !this.graph.isCellCollapsed(element)) {
        this.graph.updateGroupBounds([element], this.parentBorder, this.moveParent);
      }
      if (null != this.parentX && null != this.parentY) {
        res = this.graph.getCellGeometry(element);
        if (null != res) {
          res = res.clone();
          res.x = this.parentX;
          res.y = this.parentY;
          model.setGeometry(element, res);
        }
      }
    } finally {
      model.endUpdate();
    }
  }
};
/**
 * @param {number} addr
 * @param {?} v
 * @return {?}
 */
mxHierarchicalLayout.prototype.findRoots = function(addr, v) {
  /** @type {!Array} */
  var r = [];
  if (null != addr && null != v) {
    var model = this.graph.model;
    /** @type {null} */
    var e = null;
    /** @type {number} */
    var theHeight = -1E5;
    var i;
    for (i in v) {
      var element = v[i];
      if (model.isVertex(element) && this.graph.isCellVisible(element)) {
        var h = this.getEdges(element);
        /** @type {number} */
        var m = 0;
        /** @type {number} */
        var n = 0;
        /** @type {number} */
        var i = 0;
        for (; i < h.length; i++) {
          if (this.getVisibleTerminal(h[i], true) == element) {
            m++;
          } else {
            n++;
          }
        }
        if (0 == n && 0 < m) {
          r.push(element);
        }
        /** @type {number} */
        h = m - n;
        if (h > theHeight) {
          /** @type {number} */
          theHeight = h;
          e = element;
        }
      }
    }
    if (0 == r.length && null != e) {
      r.push(e);
    }
  }
  return r;
};
/**
 * @param {!Array} node
 * @return {?}
 */
mxHierarchicalLayout.prototype.getEdges = function(node) {
  var options = this.edgesCache.get(node);
  if (null != options) {
    return options;
  }
  var model = this.graph.model;
  /** @type {!Array} */
  options = [];
  var target = this.graph.isCellCollapsed(node);
  var n = model.getChildCount(node);
  /** @type {number} */
  var i = 0;
  for (; i < n; i++) {
    var element = model.getChildAt(node, i);
    if (this.isPort(element)) {
      /** @type {!Array<?>} */
      options = options.concat(model.getEdges(element, true, true));
    } else {
      if (target || !this.graph.isCellVisible(element)) {
        /** @type {!Array<?>} */
        options = options.concat(model.getEdges(element, true, true));
      }
    }
  }
  /** @type {!Array<?>} */
  options = options.concat(model.getEdges(node, true, true));
  /** @type {!Array} */
  model = [];
  /** @type {number} */
  i = 0;
  for (; i < options.length; i++) {
    target = this.getVisibleTerminal(options[i], true);
    n = this.getVisibleTerminal(options[i], false);
    if (target == n || target != n && (n == node && (null == this.parent || this.isAncestor(this.parent, target, this.traverseAncestors)) || target == node && (null == this.parent || this.isAncestor(this.parent, n, this.traverseAncestors)))) {
      model.push(options[i]);
    }
  }
  this.edgesCache.put(node, model);
  return model;
};
/**
 * @param {string} s
 * @param {boolean} b
 * @return {?}
 */
mxHierarchicalLayout.prototype.getVisibleTerminal = function(s, b) {
  var c = this.edgesTargetTermCache;
  if (b) {
    c = this.edgeSourceTermCache;
  }
  var e = c.get(s);
  if (null != e) {
    return e;
  }
  e = this.graph.view.getState(s);
  var d = null != e ? e.getVisibleTerminal(b) : this.graph.view.getVisibleTerminal(s, b);
  if (null == d) {
    d = null != e ? e.getVisibleTerminal(b) : this.graph.view.getVisibleTerminal(s, b);
  }
  if (null != d) {
    if (this.isPort(d)) {
      d = this.graph.model.getParent(d);
    }
    c.put(s, d);
  }
  return d;
};
/**
 * @param {number} target
 * @return {undefined}
 */
mxHierarchicalLayout.prototype.run = function(target) {
  /** @type {!Array} */
  var f = [];
  /** @type {!Array} */
  var r = [];
  if (null == this.roots && null != target) {
    var n = {};
    this.filterDescendants(target, n);
    /** @type {!Array} */
    this.roots = [];
    /** @type {boolean} */
    var i = true;
    var j;
    for (j in n) {
      if (null != n[j]) {
        /** @type {boolean} */
        i = false;
        break;
      }
    }
    for (; !i;) {
      var object = this.findRoots(target, n);
      /** @type {number} */
      i = 0;
      for (; i < object.length; i++) {
        var v = {};
        f.push(v);
        this.traverse(object[i], true, null, r, v, f, n);
      }
      /** @type {number} */
      i = 0;
      for (; i < object.length; i++) {
        this.roots.push(object[i]);
      }
      /** @type {boolean} */
      i = true;
      for (j in n) {
        if (null != n[j]) {
          /** @type {boolean} */
          i = false;
          break;
        }
      }
    }
  } else {
    /** @type {number} */
    i = 0;
    for (; i < this.roots.length; i++) {
      v = {};
      f.push(v);
      this.traverse(this.roots[i], true, null, r, v, f, null);
    }
  }
  /** @type {number} */
  i = r = 0;
  for (; i < f.length; i++) {
    v = f[i];
    /** @type {!Array} */
    n = [];
    for (j in v) {
      n.push(v[j]);
    }
    this.model = new mxGraphHierarchyModel(this, n, this.roots, target, this.tightenToSource);
    this.cycleStage(target);
    this.layeringStage();
    this.crossingStage(target);
    r = this.placementStage(r, target);
  }
};
/**
 * @param {string} node
 * @param {boolean} parent
 * @return {undefined}
 */
mxHierarchicalLayout.prototype.filterDescendants = function(node, parent) {
  var model = this.graph.model;
  if (model.isVertex(node) && node != this.parent && this.graph.isCellVisible(node)) {
    /** @type {string} */
    parent[mxObjectIdentity.get(node)] = node;
  }
  if (this.traverseAncestors || node == this.parent && this.graph.isCellVisible(node)) {
    var distance = model.getChildCount(node);
    /** @type {number} */
    var d = 0;
    for (; d < distance; d++) {
      var c1 = model.getChildAt(node, d);
      if (!this.isPort(c1)) {
        this.filterDescendants(c1, parent);
      }
    }
  }
};
/**
 * @param {string} obj
 * @return {?}
 */
mxHierarchicalLayout.prototype.isPort = function(obj) {
  return null != obj && null != obj.geometry ? obj.geometry.relative : false;
};
/**
 * @param {!Array} a
 * @param {?} b
 * @param {string} status
 * @return {?}
 */
mxHierarchicalLayout.prototype.getEdgesBetween = function(a, b, status) {
  status = null != status ? status : false;
  var edges = this.getEdges(a);
  /** @type {!Array} */
  var visited = [];
  /** @type {number} */
  var i = 0;
  for (; i < edges.length; i++) {
    var bP = this.getVisibleTerminal(edges[i], true);
    var comp = this.getVisibleTerminal(edges[i], false);
    if (bP == a && comp == b || !status && bP == b && comp == a) {
      visited.push(edges[i]);
    }
  }
  return visited;
};
/**
 * @param {?} value
 * @param {boolean} data
 * @param {number} n
 * @param {?} current
 * @param {!Object} next
 * @param {!Object} obj
 * @param {!Object} target
 * @return {?}
 */
mxHierarchicalLayout.prototype.traverse = function(value, data, n, current, next, obj, target) {
  if (null != value && null != current) {
    var key = mxObjectIdentity.get(value);
    if (null == current[key] && (null == target || null != target[key])) {
      if (null == next[key]) {
        next[key] = value;
      }
      if (null == current[key]) {
        current[key] = value;
      }
      if (null !== target) {
        delete target[key];
      }
      var i = this.getEdges(value);
      /** @type {!Array} */
      key = [];
      /** @type {number} */
      n = 0;
      for (; n < i.length; n++) {
        /** @type {boolean} */
        key[n] = this.getVisibleTerminal(i[n], true) == value;
      }
      /** @type {number} */
      n = 0;
      for (; n < i.length; n++) {
        if (!data || key[n]) {
          value = this.getVisibleTerminal(i[n], !key[n]);
          /** @type {number} */
          var m = 1;
          /** @type {number} */
          var t = 0;
          for (; t < i.length; t++) {
            if (t != n) {
              var type = key[t];
              if (this.getVisibleTerminal(i[t], !type) == value) {
                if (type) {
                  m++;
                } else {
                  m--;
                }
              }
            }
          }
          if (0 <= m) {
            next = this.traverse(value, data, i[n], current, next, obj, target);
          }
        }
      }
    } else {
      if (null == next[key]) {
        /** @type {number} */
        n = 0;
        for (; n < obj.length; n++) {
          if (data = obj[n], null != data[key]) {
            for (i in data) {
              next[i] = data[i];
            }
            obj.splice(n, 1);
            break;
          }
        }
      }
    }
  }
  return next;
};
/**
 * @param {?} a
 * @return {undefined}
 */
mxHierarchicalLayout.prototype.cycleStage = function(a) {
  (new mxMinimumCycleRemover(this)).execute(a);
};
/**
 * @return {undefined}
 */
mxHierarchicalLayout.prototype.layeringStage = function() {
  this.model.initialRank();
  this.model.fixRanks();
};
/**
 * @param {?} a
 * @return {undefined}
 */
mxHierarchicalLayout.prototype.crossingStage = function(a) {
  (new mxMedianHybridCrossingReduction(this)).execute(a);
};
/**
 * @param {number} index
 * @param {?} item
 * @return {?}
 */
mxHierarchicalLayout.prototype.placementStage = function(index, item) {
  var _this = new mxCoordinateAssignment(this, this.intraCellSpacing, this.interRankCellSpacing, this.orientation, index, this.parallelEdgeSpacing);
  _this.fineTuning = this.fineTuning;
  _this.execute(item);
  return _this.limitX + this.interHierarchySpacing;
};
/**
 * @param {?} game
 * @param {string} orientation
 * @param {?} min
 * @return {undefined}
 */
function mxSwimlaneLayout(game, orientation, min) {
  mxGraphLayout.call(this, game);
  this.orientation = null != orientation ? orientation : mxConstants.DIRECTION_NORTH;
  this.deterministic = null != min ? min : true;
}
mxSwimlaneLayout.prototype = new mxGraphLayout;
/** @type {function(?, string, ?): undefined} */
mxSwimlaneLayout.prototype.constructor = mxSwimlaneLayout;
/** @type {null} */
mxSwimlaneLayout.prototype.roots = null;
/** @type {null} */
mxSwimlaneLayout.prototype.swimlanes = null;
/** @type {number} */
mxSwimlaneLayout.prototype.dummyVertexWidth = 50;
/** @type {boolean} */
mxSwimlaneLayout.prototype.resizeParent = false;
/** @type {boolean} */
mxSwimlaneLayout.prototype.maintainParentLocation = false;
/** @type {boolean} */
mxSwimlaneLayout.prototype.moveParent = false;
/** @type {number} */
mxSwimlaneLayout.prototype.parentBorder = 30;
/** @type {number} */
mxSwimlaneLayout.prototype.intraCellSpacing = 30;
/** @type {number} */
mxSwimlaneLayout.prototype.interRankCellSpacing = 100;
/** @type {number} */
mxSwimlaneLayout.prototype.interHierarchySpacing = 60;
/** @type {number} */
mxSwimlaneLayout.prototype.parallelEdgeSpacing = 10;
/** @type {string} */
mxSwimlaneLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;
/** @type {boolean} */
mxSwimlaneLayout.prototype.fineTuning = true;
/** @type {boolean} */
mxSwimlaneLayout.prototype.tightenToSource = true;
/** @type {boolean} */
mxSwimlaneLayout.prototype.disableEdgeStyle = true;
/** @type {boolean} */
mxSwimlaneLayout.prototype.traverseAncestors = true;
/** @type {null} */
mxSwimlaneLayout.prototype.model = null;
/** @type {null} */
mxSwimlaneLayout.prototype.edgesCache = null;
/** @type {null} */
mxHierarchicalLayout.prototype.edgeSourceTermCache = null;
/** @type {null} */
mxHierarchicalLayout.prototype.edgesTargetTermCache = null;
/** @type {number} */
mxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;
/**
 * @return {?}
 */
mxSwimlaneLayout.prototype.getModel = function() {
  return this.model;
};
/**
 * @param {?} element
 * @param {!Object} args
 * @return {undefined}
 */
mxSwimlaneLayout.prototype.execute = function(element, args) {
  this.parent = element;
  var model = this.graph.model;
  this.edgesCache = new mxDictionary;
  this.edgeSourceTermCache = new mxDictionary;
  this.edgesTargetTermCache = new mxDictionary;
  if (!(null == args || 1 > args.length)) {
    if (null == element) {
      element = model.getParent(args[0]);
    }
    /** @type {null} */
    this.parentY = this.parentX = null;
    if (element != this.root && null != model.isVertex(element) && this.maintainParentLocation) {
      var res = this.graph.getCellGeometry(element);
      if (null != res) {
        this.parentX = res.x;
        this.parentY = res.y;
      }
    }
    /** @type {!Object} */
    this.swimlanes = args;
    /** @type {!Array} */
    var before = [];
    /** @type {number} */
    var i = 0;
    for (; i < args.length; i++) {
      var url = this.graph.getChildCells(args[i]);
      if (null == url || 0 == url.length) {
        url = this.graph.insertVertex(args[i], null, null, 0, 0, this.dummyVertexWidth, 0);
        before.push(url);
      }
    }
    model.beginUpdate();
    try {
      this.run(element);
      if (this.resizeParent && !this.graph.isCellCollapsed(element)) {
        this.graph.updateGroupBounds([element], this.parentBorder, this.moveParent);
      }
      if (null != this.parentX && null != this.parentY) {
        res = this.graph.getCellGeometry(element);
        if (null != res) {
          res = res.clone();
          res.x = this.parentX;
          res.y = this.parentY;
          model.setGeometry(element, res);
        }
      }
      this.graph.removeCells(before);
    } finally {
      model.endUpdate();
    }
  }
};
/**
 * @return {undefined}
 */
mxSwimlaneLayout.prototype.updateGroupBounds = function() {
  /** @type {!Array} */
  var d = [];
  var row = this.model;
  var key;
  for (key in row.edgeMapper) {
    var props = row.edgeMapper[key];
    /** @type {number} */
    var i = 0;
    for (; i < props.edges.length; i++) {
      d.push(props.edges[i]);
    }
  }
  d = this.graph.getBoundingBoxFromGeometry(d, true);
  /** @type {!Array} */
  row = [];
  /** @type {number} */
  i = 0;
  for (; i < this.swimlanes.length; i++) {
    var cell = this.swimlanes[i];
    key = this.graph.getCellGeometry(cell);
    if (null != key) {
      var cells = this.graph.getChildCells(cell);
      props = this.graph.isSwimlane(cell) ? this.graph.getStartSize(cell) : new mxRectangle;
      cell = this.graph.getBoundingBoxFromGeometry(cells);
      row[i] = cell;
      /** @type {number} */
      props = cell.y + key.y - props.height - this.parentBorder;
      key = cell.y + key.y + cell.height;
      if (null == d) {
        d = new mxRectangle(0, props, 0, key - props);
      } else {
        /** @type {number} */
        d.y = Math.min(d.y, props);
        /** @type {number} */
        d.height = Math.max(d.y + d.height, key) - d.y;
      }
    }
  }
  /** @type {number} */
  i = 0;
  for (; i < this.swimlanes.length; i++) {
    if (cell = this.swimlanes[i], key = this.graph.getCellGeometry(cell), null != key) {
      cells = this.graph.getChildCells(cell);
      props = this.graph.isSwimlane(cell) ? this.graph.getStartSize(cell) : new mxRectangle;
      var res = key.clone();
      var offsetLeft = props.width + (0 == i ? this.parentBorder : this.interRankCellSpacing / 2);
      /** @type {number} */
      var x = row[i].x - offsetLeft;
      /** @type {number} */
      var time = d.y - this.parentBorder;
      res.x += x;
      /** @type {number} */
      res.y = time;
      res.width = row[i].width + offsetLeft + this.interRankCellSpacing / 2;
      res.height = d.height + props.height + 2 * this.parentBorder;
      this.graph.model.setGeometry(cell, res);
      this.graph.moveCells(cells, -x, key.y - time);
    }
  }
};
/**
 * @param {!Object} node
 * @param {?} t
 * @return {?}
 */
mxSwimlaneLayout.prototype.findRoots = function(node, t) {
  /** @type {!Array} */
  var r = [];
  if (null != node && null != t) {
    var model = this.graph.model;
    /** @type {null} */
    var e = null;
    /** @type {number} */
    var theHeight = -1E5;
    var elem;
    for (elem in t) {
      var element = t[elem];
      if (null != element && model.isVertex(element) && this.graph.isCellVisible(element) && model.isAncestor(node, element)) {
        var h = this.getEdges(element);
        /** @type {number} */
        var m = 0;
        /** @type {number} */
        var n = 0;
        /** @type {number} */
        var i = 0;
        for (; i < h.length; i++) {
          var child = this.getVisibleTerminal(h[i], true);
          if (child == element) {
            child = this.getVisibleTerminal(h[i], false);
            if (model.isAncestor(node, child)) {
              m++;
            }
          } else {
            if (model.isAncestor(node, child)) {
              n++;
            }
          }
        }
        if (0 == n && 0 < m) {
          r.push(element);
        }
        /** @type {number} */
        h = m - n;
        if (h > theHeight) {
          /** @type {number} */
          theHeight = h;
          e = element;
        }
      }
    }
    if (0 == r.length && null != e) {
      r.push(e);
    }
  }
  return r;
};
/**
 * @param {!Array} node
 * @return {?}
 */
mxSwimlaneLayout.prototype.getEdges = function(node) {
  var options = this.edgesCache.get(node);
  if (null != options) {
    return options;
  }
  var model = this.graph.model;
  /** @type {!Array} */
  options = [];
  var el = this.graph.isCellCollapsed(node);
  var parent = model.getChildCount(node);
  /** @type {number} */
  var i = 0;
  for (; i < parent; i++) {
    var element = model.getChildAt(node, i);
    if (this.isPort(element)) {
      /** @type {!Array<?>} */
      options = options.concat(model.getEdges(element, true, true));
    } else {
      if (el || !this.graph.isCellVisible(element)) {
        /** @type {!Array<?>} */
        options = options.concat(model.getEdges(element, true, true));
      }
    }
  }
  /** @type {!Array<?>} */
  options = options.concat(model.getEdges(node, true, true));
  /** @type {!Array} */
  model = [];
  /** @type {number} */
  i = 0;
  for (; i < options.length; i++) {
    el = this.getVisibleTerminal(options[i], true);
    parent = this.getVisibleTerminal(options[i], false);
    if (el == parent || el != parent && (parent == node && (null == this.parent || this.graph.isValidAncestor(el, this.parent, this.traverseAncestors)) || el == node && (null == this.parent || this.graph.isValidAncestor(parent, this.parent, this.traverseAncestors)))) {
      model.push(options[i]);
    }
  }
  this.edgesCache.put(node, model);
  return model;
};
/**
 * @param {string} s
 * @param {boolean} b
 * @return {?}
 */
mxSwimlaneLayout.prototype.getVisibleTerminal = function(s, b) {
  var c = this.edgesTargetTermCache;
  if (b) {
    c = this.edgeSourceTermCache;
  }
  var e = c.get(s);
  if (null != e) {
    return e;
  }
  e = this.graph.view.getState(s);
  var d = null != e ? e.getVisibleTerminal(b) : this.graph.view.getVisibleTerminal(s, b);
  if (null == d) {
    d = null != e ? e.getVisibleTerminal(b) : this.graph.view.getVisibleTerminal(s, b);
  }
  if (null != d) {
    if (this.isPort(d)) {
      d = this.graph.model.getParent(d);
    }
    c.put(s, d);
  }
  return d;
};
/**
 * @param {number} item
 * @return {undefined}
 */
mxSwimlaneLayout.prototype.run = function(item) {
  /** @type {!Array} */
  var target = [];
  var current = {};
  if (null != this.swimlanes && 0 < this.swimlanes.length && null != item) {
    var n = {};
    /** @type {number} */
    var i = 0;
    for (; i < this.swimlanes.length; i++) {
      this.filterDescendants(this.swimlanes[i], n);
    }
    /** @type {!Array} */
    this.roots = [];
    /** @type {boolean} */
    i = true;
    var p;
    for (p in n) {
      if (null != n[p]) {
        /** @type {boolean} */
        i = false;
        break;
      }
    }
    /** @type {number} */
    var rank = 0;
    for (; !i && rank < this.swimlanes.length;) {
      var object = this.findRoots(this.swimlanes[rank], n);
      if (0 == object.length) {
        rank++;
      } else {
        /** @type {number} */
        i = 0;
        for (; i < object.length; i++) {
          var l = {};
          target.push(l);
          this.traverse(object[i], true, null, current, l, target, n, rank);
        }
        /** @type {number} */
        i = 0;
        for (; i < object.length; i++) {
          this.roots.push(object[i]);
        }
        /** @type {boolean} */
        i = true;
        for (p in n) {
          if (null != n[p]) {
            /** @type {boolean} */
            i = false;
            break;
          }
        }
      }
    }
  } else {
    /** @type {number} */
    i = 0;
    for (; i < this.roots.length; i++) {
      l = {};
      target.push(l);
      this.traverse(this.roots[i], true, null, current, l, target, null);
    }
  }
  /** @type {!Array} */
  target = [];
  for (p in current) {
    target.push(current[p]);
  }
  this.model = new mxSwimlaneModel(this, target, this.roots, item, this.tightenToSource);
  this.cycleStage(item);
  this.layeringStage();
  this.crossingStage(item);
  this.placementStage(0, item);
};
/**
 * @param {string} node
 * @param {boolean} parent
 * @return {undefined}
 */
mxSwimlaneLayout.prototype.filterDescendants = function(node, parent) {
  var model = this.graph.model;
  if (model.isVertex(node) && node != this.parent && model.getParent(node) != this.parent && this.graph.isCellVisible(node)) {
    /** @type {string} */
    parent[mxObjectIdentity.get(node)] = node;
  }
  if (this.traverseAncestors || node == this.parent && this.graph.isCellVisible(node)) {
    var distance = model.getChildCount(node);
    /** @type {number} */
    var d = 0;
    for (; d < distance; d++) {
      var c1 = model.getChildAt(node, d);
      if (!this.isPort(c1)) {
        this.filterDescendants(c1, parent);
      }
    }
  }
};
/**
 * @param {string} obj
 * @return {?}
 */
mxSwimlaneLayout.prototype.isPort = function(obj) {
  return obj.geometry.relative ? true : false;
};
/**
 * @param {!Array} a
 * @param {?} b
 * @param {string} status
 * @return {?}
 */
mxSwimlaneLayout.prototype.getEdgesBetween = function(a, b, status) {
  status = null != status ? status : false;
  var edges = this.getEdges(a);
  /** @type {!Array} */
  var visited = [];
  /** @type {number} */
  var i = 0;
  for (; i < edges.length; i++) {
    var bP = this.getVisibleTerminal(edges[i], true);
    var comp = this.getVisibleTerminal(edges[i], false);
    if (bP == a && comp == b || !status && bP == b && comp == a) {
      visited.push(edges[i]);
    }
  }
  return visited;
};
/**
 * @param {?} value
 * @param {boolean} data
 * @param {number} n
 * @param {?} current
 * @param {!Object} next
 * @param {!Object} p
 * @param {!Object} obj
 * @param {number} index
 * @return {?}
 */
mxSwimlaneLayout.prototype.traverse = function(value, data, n, current, next, p, obj, index) {
  if (null != value && null != current) {
    var item = mxObjectIdentity.get(value);
    if (null == current[item] && (null == obj || null != obj[item])) {
      if (null == next[item]) {
        next[item] = value;
      }
      if (null == current[item]) {
        current[item] = value;
      }
      if (null !== obj) {
        delete obj[item];
      }
      var key = this.getEdges(value);
      item = this.graph.model;
      /** @type {number} */
      n = 0;
      for (; n < key.length; n++) {
        var name = this.getVisibleTerminal(key[n], true);
        /** @type {boolean} */
        var isValue = name == value;
        if (isValue) {
          name = this.getVisibleTerminal(key[n], false);
        }
        var i;
        /** @type {number} */
        i = 0;
        for (; i < this.swimlanes.length && !item.isAncestor(this.swimlanes[i], name); i++) {
        }
        if (!(i >= this.swimlanes.length || !(i > index || (!data || isValue) && i == index))) {
          next = this.traverse(name, data, key[n], current, next, p, obj, i);
        }
      }
    } else {
      if (null == next[item]) {
        /** @type {number} */
        n = 0;
        for (; n < p.length; n++) {
          if (value = p[n], null != value[item]) {
            for (key in value) {
              next[key] = value[key];
            }
            p.splice(n, 1);
            break;
          }
        }
      }
    }
  }
  return next;
};
/**
 * @param {?} a
 * @return {undefined}
 */
mxSwimlaneLayout.prototype.cycleStage = function(a) {
  (new mxSwimlaneOrdering(this)).execute(a);
};
/**
 * @return {undefined}
 */
mxSwimlaneLayout.prototype.layeringStage = function() {
  this.model.initialRank();
  this.model.fixRanks();
};
/**
 * @param {?} a
 * @return {undefined}
 */
mxSwimlaneLayout.prototype.crossingStage = function(a) {
  (new mxMedianHybridCrossingReduction(this)).execute(a);
};
/**
 * @param {number} index
 * @param {?} item
 * @return {?}
 */
mxSwimlaneLayout.prototype.placementStage = function(index, item) {
  var _this = new mxCoordinateAssignment(this, this.intraCellSpacing, this.interRankCellSpacing, this.orientation, index, this.parallelEdgeSpacing);
  _this.fineTuning = this.fineTuning;
  _this.execute(item);
  return _this.limitX + this.interHierarchySpacing;
};
/**
 * @param {!Object} newRoot
 * @return {undefined}
 */
function mxGraphModel(newRoot) {
  this.currentEdit = this.createUndoableEdit();
  if (null != newRoot) {
    this.setRoot(newRoot);
  } else {
    this.clear();
  }
}
mxGraphModel.prototype = new mxEventSource;
/** @type {function(!Object): undefined} */
mxGraphModel.prototype.constructor = mxGraphModel;
/** @type {null} */
mxGraphModel.prototype.root = null;
/** @type {null} */
mxGraphModel.prototype.cells = null;
/** @type {boolean} */
mxGraphModel.prototype.maintainEdgeParent = true;
/** @type {boolean} */
mxGraphModel.prototype.ignoreRelativeEdgeParent = true;
/** @type {boolean} */
mxGraphModel.prototype.createIds = true;
/** @type {string} */
mxGraphModel.prototype.prefix = "";
/** @type {string} */
mxGraphModel.prototype.postfix = "";
/** @type {number} */
mxGraphModel.prototype.nextId = 0;
/** @type {null} */
mxGraphModel.prototype.currentEdit = null;
/** @type {number} */
mxGraphModel.prototype.updateLevel = 0;
/** @type {boolean} */
mxGraphModel.prototype.endingUpdate = false;
/**
 * @return {undefined}
 */
mxGraphModel.prototype.clear = function() {
  this.setRoot(this.createRoot());
};
/**
 * @return {?}
 */
mxGraphModel.prototype.isCreateIds = function() {
  return this.createIds;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraphModel.prototype.setCreateIds = function(a) {
  /** @type {boolean} */
  this.createIds = a;
};
/**
 * @return {?}
 */
mxGraphModel.prototype.createRoot = function() {
  var svg = new mxCell;
  svg.insert(new mxCell);
  return svg;
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxGraphModel.prototype.getCell = function(value) {
  return null != this.cells ? this.cells[value] : null;
};
/**
 * @param {!Object} flags
 * @param {?} ready
 * @return {?}
 */
mxGraphModel.prototype.filterCells = function(flags, ready) {
  /** @type {null} */
  var buildFlags = null;
  if (null != flags) {
    /** @type {!Array} */
    buildFlags = [];
    /** @type {number} */
    var i = 0;
    for (; i < flags.length; i++) {
      if (ready(flags[i])) {
        buildFlags.push(flags[i]);
      }
    }
  }
  return buildFlags;
};
/**
 * @param {boolean} id
 * @return {?}
 */
mxGraphModel.prototype.getDescendants = function(id) {
  return this.filterDescendants(null, id);
};
/**
 * @param {string} node
 * @param {string} i
 * @return {?}
 */
mxGraphModel.prototype.filterDescendants = function(node, i) {
  /** @type {!Array} */
  var result = [];
  i = i || this.getRoot();
  if (null == node || node(i)) {
    result.push(i);
  }
  var count = this.getChildCount(i);
  /** @type {number} */
  var x = 0;
  for (; x < count; x++) {
    var c = this.getChildAt(i, x);
    /** @type {!Array<?>} */
    result = result.concat(this.filterDescendants(node, c));
  }
  return result;
};
/**
 * @param {string} node
 * @return {?}
 */
mxGraphModel.prototype.getRoot = function(node) {
  var n = node || this.root;
  if (null != node) {
    for (; null != node;) {
      /** @type {string} */
      n = node;
      node = this.getParent(node);
    }
  }
  return n;
};
/**
 * @param {!Object} root
 * @return {?}
 */
mxGraphModel.prototype.setRoot = function(root) {
  this.execute(new mxRootChange(this, root));
  return root;
};
/**
 * @param {!Object} root
 * @return {?}
 */
mxGraphModel.prototype.rootChanged = function(root) {
  var mesh = this.root;
  /** @type {!Object} */
  this.root = root;
  /** @type {number} */
  this.nextId = 0;
  /** @type {null} */
  this.cells = null;
  this.cellAdded(root);
  return mesh;
};
/**
 * @param {?} next
 * @return {?}
 */
mxGraphModel.prototype.isRoot = function(next) {
  return null != next && this.root == next;
};
/**
 * @param {!Object} one
 * @return {?}
 */
mxGraphModel.prototype.isLayer = function(one) {
  return this.isRoot(this.getParent(one));
};
/**
 * @param {!Object} parent
 * @param {!Object} node
 * @return {?}
 */
mxGraphModel.prototype.isAncestor = function(parent, node) {
  for (; null != node && node != parent;) {
    node = this.getParent(node);
  }
  return node == parent;
};
/**
 * @param {!Object} el
 * @return {?}
 */
mxGraphModel.prototype.contains = function(el) {
  return this.isAncestor(this.root, el);
};
/**
 * @param {!Object} obj
 * @return {?}
 */
mxGraphModel.prototype.getParent = function(obj) {
  return null != obj ? obj.getParent() : null;
};
/**
 * @param {string} el
 * @param {string} child
 * @param {string} index
 * @return {?}
 */
mxGraphModel.prototype.add = function(el, child, index) {
  if (child != el && null != el && null != child) {
    if (null == index) {
      index = this.getChildCount(el);
    }
    /** @type {boolean} */
    var result = el != this.getParent(child);
    this.execute(new mxChildChange(this, el, child, index));
    if (this.maintainEdgeParent && result) {
      this.updateEdgeParents(child);
    }
  }
  return child;
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxGraphModel.prototype.cellAdded = function(value) {
  if (null != value) {
    if (null == value.getId() && this.createIds) {
      value.setId(this.createId(value));
    }
    if (null != value.getId()) {
      var obj = this.getCell(value.getId());
      if (obj != value) {
        for (; null != obj;) {
          value.setId(this.createId(value));
          obj = this.getCell(value.getId());
        }
        if (null == this.cells) {
          this.cells = {};
        }
        /** @type {!Object} */
        this.cells[value.getId()] = value;
      }
    }
    if (mxUtils.isNumeric(value.getId())) {
      /** @type {number} */
      this.nextId = Math.max(this.nextId, value.getId());
    }
    obj = this.getChildCount(value);
    /** @type {number} */
    var to = 0;
    for (; to < obj; to++) {
      this.cellAdded(this.getChildAt(value, to));
    }
  }
};
/**
 * @param {?} name
 * @return {?}
 */
mxGraphModel.prototype.createId = function(name) {
  name = this.nextId;
  this.nextId++;
  return this.prefix + name + this.postfix;
};
/**
 * @param {!Object} name
 * @param {!Object} root
 * @return {undefined}
 */
mxGraphModel.prototype.updateEdgeParents = function(name, root) {
  root = root || this.getRoot(name);
  var l = this.getChildCount(name);
  /** @type {number} */
  var i = 0;
  for (; i < l; i++) {
    var el = this.getChildAt(name, i);
    this.updateEdgeParents(el, root);
  }
  el = this.getEdgeCount(name);
  /** @type {!Array} */
  l = [];
  /** @type {number} */
  i = 0;
  for (; i < el; i++) {
    l.push(this.getEdgeAt(name, i));
  }
  /** @type {number} */
  i = 0;
  for (; i < l.length; i++) {
    el = l[i];
    if (this.isAncestor(root, el)) {
      this.updateEdgeParent(el, root);
    }
  }
};
/**
 * @param {string} parent
 * @param {!Object} element
 * @return {undefined}
 */
mxGraphModel.prototype.updateEdgeParent = function(parent, element) {
  var node = this.getTerminal(parent, true);
  var el = this.getTerminal(parent, false);
  for (; null != node && !this.isEdge(node) && null != node.geometry && node.geometry.relative;) {
    node = this.getParent(node);
  }
  for (; null != el && this.ignoreRelativeEdgeParent && !this.isEdge(el) && null != el.geometry && el.geometry.relative;) {
    el = this.getParent(el);
  }
  if (this.isAncestor(element, node) && this.isAncestor(element, el) && (node = node == el ? this.getParent(node) : this.getNearestCommonAncestor(node, el), null != node && (this.getParent(node) != this.root || this.isAncestor(node, parent)) && this.getParent(parent) != node)) {
    el = this.getGeometry(parent);
    if (null != el) {
      var position = this.getOrigin(this.getParent(parent));
      var rect = this.getOrigin(node);
      /** @type {number} */
      var recoverLength = rect.x - position.x;
      /** @type {number} */
      position = rect.y - position.y;
      el = el.clone();
      el.translate(-recoverLength, -position);
      this.setGeometry(parent, el);
    }
    this.add(node, parent, this.getChildCount(node));
  }
};
/**
 * @param {?} parent
 * @return {?}
 */
mxGraphModel.prototype.getOrigin = function(parent) {
  var pos;
  if (null != parent) {
    pos = this.getOrigin(this.getParent(parent));
    if (!this.isEdge(parent)) {
      parent = this.getGeometry(parent);
      if (null != parent) {
        pos.x += parent.x;
        pos.y += parent.y;
      }
    }
  } else {
    pos = new mxPoint;
  }
  return pos;
};
/**
 * @param {!Object} node1
 * @param {number} node2
 * @return {?}
 */
mxGraphModel.prototype.getNearestCommonAncestor = function(node1, node2) {
  if (null != node1 && null != node2) {
    var b = mxCellPath.create(node2);
    if (null != b && 0 < b.length) {
      /** @type {!Object} */
      var node = node1;
      var a = mxCellPath.create(node);
      if (b.length < a.length) {
        /** @type {number} */
        node = node2;
        var parent = a;
        a = b;
        b = parent;
      }
      for (; null != node;) {
        parent = this.getParent(node);
        if (0 == b.indexOf(a + mxCellPath.PATH_SEPARATOR) && null != parent) {
          return node;
        }
        a = mxCellPath.getParentPath(a);
        node = parent;
      }
    }
  }
  return null;
};
/**
 * @param {(Object|string)} child
 * @return {?}
 */
mxGraphModel.prototype.remove = function(child) {
  if (child == this.root) {
    this.setRoot(null);
  } else {
    if (null != this.getParent(child)) {
      this.execute(new mxChildChange(this, null, child));
    }
  }
  return child;
};
/**
 * @param {!Object} index
 * @return {undefined}
 */
mxGraphModel.prototype.cellRemoved = function(index) {
  if (null != index && null != this.cells) {
    /** @type {number} */
    var v_13869 = this.getChildCount(index) - 1;
    for (; 0 <= v_13869; v_13869--) {
      this.cellRemoved(this.getChildAt(index, v_13869));
    }
    if (null != this.cells && null != index.getId()) {
      delete this.cells[index.getId()];
    }
  }
};
/**
 * @param {undefined} i
 * @param {!Object} a
 * @param {!Array} c
 * @return {?}
 */
mxGraphModel.prototype.parentForCellChanged = function(i, a, c) {
  var b = this.getParent(i);
  if (null != a) {
    if (!(a == b && b.getIndex(i) == c)) {
      a.insert(i, c);
    }
  } else {
    if (null != b) {
      c = b.getIndex(i);
      b.remove(c);
    }
  }
  a = this.contains(a);
  c = this.contains(b);
  if (a && !c) {
    this.cellAdded(i);
  } else {
    if (c && !a) {
      this.cellRemoved(i);
    }
  }
  return b;
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxGraphModel.prototype.getChildCount = function(node) {
  return null != node ? node.getChildCount() : 0;
};
/**
 * @param {!Object} item
 * @param {number} x
 * @return {?}
 */
mxGraphModel.prototype.getChildAt = function(item, x) {
  return null != item ? item.getChildAt(x) : null;
};
/**
 * @param {!Object} object
 * @return {?}
 */
mxGraphModel.prototype.getChildren = function(object) {
  return null != object ? object.children : null;
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraphModel.prototype.getChildVertices = function(a) {
  return this.getChildCells(a, true, false);
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraphModel.prototype.getChildEdges = function(a) {
  return this.getChildCells(a, false, true);
};
/**
 * @param {?} i
 * @param {string} min
 * @param {string} max
 * @return {?}
 */
mxGraphModel.prototype.getChildCells = function(i, min, max) {
  min = null != min ? min : false;
  max = null != max ? max : false;
  var count = this.getChildCount(i);
  /** @type {!Array} */
  var firebotButtonArray = [];
  /** @type {number} */
  var y = 0;
  for (; y < count; y++) {
    var control = this.getChildAt(i, y);
    if (!max && !min || max && this.isEdge(control) || min && this.isVertex(control)) {
      firebotButtonArray.push(control);
    }
  }
  return firebotButtonArray;
};
/**
 * @param {string} obj
 * @param {string} arg
 * @return {?}
 */
mxGraphModel.prototype.getTerminal = function(obj, arg) {
  return null != obj ? obj.getTerminal(arg) : null;
};
/**
 * @param {string} id
 * @param {string} value
 * @param {string} args
 * @return {?}
 */
mxGraphModel.prototype.setTerminal = function(id, value, args) {
  /** @type {boolean} */
  var move = value != this.getTerminal(id, args);
  this.execute(new mxTerminalChange(this, id, value, args));
  if (this.maintainEdgeParent && move) {
    this.updateEdgeParent(id, this.getRoot());
  }
  return value;
};
/**
 * @param {string} m
 * @param {string} b
 * @param {string} status
 * @return {undefined}
 */
mxGraphModel.prototype.setTerminals = function(m, b, status) {
  this.beginUpdate();
  try {
    this.setTerminal(m, b, true);
    this.setTerminal(m, status, false);
  } finally {
    this.endUpdate();
  }
};
/**
 * @param {boolean} key
 * @param {!Object} source
 * @param {boolean} z
 * @return {?}
 */
mxGraphModel.prototype.terminalForCellChanged = function(key, source, z) {
  var result = this.getTerminal(key, z);
  if (null != source) {
    source.insertEdge(key, z);
  } else {
    if (null != result) {
      result.removeEdge(key, z);
    }
  }
  return result;
};
/**
 * @param {!Object} v
 * @return {?}
 */
mxGraphModel.prototype.getEdgeCount = function(v) {
  return null != v ? v.getEdgeCount() : 0;
};
/**
 * @param {!Object} a
 * @param {number} b
 * @return {?}
 */
mxGraphModel.prototype.getEdgeAt = function(a, b) {
  return null != a ? a.getEdgeAt(b) : null;
};
/**
 * @param {!Object} value
 * @param {boolean} name
 * @param {!Object} n
 * @return {?}
 */
mxGraphModel.prototype.getDirectedEdgeCount = function(value, name, n) {
  /** @type {number} */
  var d = 0;
  var be = this.getEdgeCount(value);
  /** @type {number} */
  var b = 0;
  for (; b < be; b++) {
    var i = this.getEdgeAt(value, b);
    if (i != n && this.getTerminal(i, name) == value) {
      d++;
    }
  }
  return d;
};
/**
 * @param {!Array} scope
 * @return {?}
 */
mxGraphModel.prototype.getConnections = function(scope) {
  return this.getEdges(scope, true, true, false);
};
/**
 * @param {!Array} node
 * @return {?}
 */
mxGraphModel.prototype.getIncomingEdges = function(node) {
  return this.getEdges(node, true, false, false);
};
/**
 * @param {!Array} node
 * @return {?}
 */
mxGraphModel.prototype.getOutgoingEdges = function(node) {
  return this.getEdges(node, false, true, false);
};
/**
 * @param {!Array} target
 * @param {?} id
 * @param {?} direction
 * @param {?} e
 * @return {?}
 */
mxGraphModel.prototype.getEdges = function(target, id, direction, e) {
  id = null != id ? id : true;
  direction = null != direction ? direction : true;
  e = null != e ? e : true;
  var a = this.getEdgeCount(target);
  /** @type {!Array} */
  var list = [];
  /** @type {number} */
  var b = 0;
  for (; b < a; b++) {
    var c = this.getEdgeAt(target, b);
    var n = this.getTerminal(c, true);
    var node = this.getTerminal(c, false);
    if (e && n == node || n != node && (id && node == target || direction && n == target)) {
      list.push(c);
    }
  }
  return list;
};
/**
 * @param {!Array} b
 * @param {!Array} a
 * @param {string} options
 * @return {?}
 */
mxGraphModel.prototype.getEdgesBetween = function(b, a, options) {
  options = null != options ? options : false;
  var o = this.getEdgeCount(b);
  var y = this.getEdgeCount(a);
  /** @type {!Array} */
  var B = b;
  var x = o;
  if (y < o) {
    x = y;
    /** @type {!Array} */
    B = a;
  }
  /** @type {!Array} */
  o = [];
  /** @type {number} */
  y = 0;
  for (; y < x; y++) {
    var value = this.getEdgeAt(B, y);
    var name = this.getTerminal(value, true);
    var url = this.getTerminal(value, false);
    /** @type {boolean} */
    var tabless = url == b && name == a;
    if (name == b && url == a || !options && tabless) {
      o.push(value);
    }
  }
  return o;
};
/**
 * @param {!Object} newPath
 * @param {?} parent
 * @param {?} status
 * @param {?} e
 * @return {?}
 */
mxGraphModel.prototype.getOpposites = function(newPath, parent, status, e) {
  status = null != status ? status : true;
  e = null != e ? e : true;
  /** @type {!Array} */
  var register = [];
  if (null != newPath) {
    /** @type {number} */
    var i = 0;
    for (; i < newPath.length; i++) {
      var node = this.getTerminal(newPath[i], true);
      var key = this.getTerminal(newPath[i], false);
      if (node == parent && null != key && key != parent && e) {
        register.push(key);
      } else {
        if (key == parent && null != node && node != parent && status) {
          register.push(node);
        }
      }
    }
  }
  return register;
};
/**
 * @param {string} items
 * @return {?}
 */
mxGraphModel.prototype.getTopmostCells = function(items) {
  var group = new mxDictionary;
  /** @type {!Array} */
  var noDupes = [];
  /** @type {number} */
  var i = 0;
  for (; i < items.length; i++) {
    group.put(items[i], true);
  }
  /** @type {number} */
  i = 0;
  for (; i < items.length; i++) {
    var el = items[i];
    /** @type {boolean} */
    var f = true;
    var parent = this.getParent(el);
    for (; null != parent;) {
      if (group.get(parent)) {
        /** @type {boolean} */
        f = false;
        break;
      }
      parent = this.getParent(parent);
    }
    if (f) {
      noDupes.push(el);
    }
  }
  return noDupes;
};
/**
 * @param {!Object} child
 * @return {?}
 */
mxGraphModel.prototype.isVertex = function(child) {
  return null != child ? child.isVertex() : false;
};
/**
 * @param {?} item
 * @return {?}
 */
mxGraphModel.prototype.isEdge = function(item) {
  return null != item ? item.isEdge() : false;
};
/**
 * @param {?} target
 * @return {?}
 */
mxGraphModel.prototype.isConnectable = function(target) {
  return null != target ? target.isConnectable() : false;
};
/**
 * @param {!Object} obj
 * @return {?}
 */
mxGraphModel.prototype.getValue = function(obj) {
  return null != obj ? obj.getValue() : null;
};
/**
 * @param {!Object} cell
 * @param {!Object} value
 * @return {?}
 */
mxGraphModel.prototype.setValue = function(cell, value) {
  this.execute(new mxValueChange(this, cell, value));
  return value;
};
/**
 * @param {?} exp
 * @param {undefined} val
 * @return {?}
 */
mxGraphModel.prototype.valueForCellChanged = function(exp, val) {
  return exp.valueChanged(val);
};
/**
 * @param {!Object} object
 * @return {?}
 */
mxGraphModel.prototype.getGeometry = function(object) {
  return null != object ? object.getGeometry() : null;
};
/**
 * @param {!Object} value
 * @param {!Object} id
 * @return {?}
 */
mxGraphModel.prototype.setGeometry = function(value, id) {
  if (id != this.getGeometry(value)) {
    this.execute(new mxGeometryChange(this, value, id));
  }
  return id;
};
/**
 * @param {!Object} f
 * @param {!Object} p
 * @return {?}
 */
mxGraphModel.prototype.geometryForCellChanged = function(f, p) {
  var geom = this.getGeometry(f);
  f.setGeometry(p);
  return geom;
};
/**
 * @param {!Object} object
 * @return {?}
 */
mxGraphModel.prototype.getStyle = function(object) {
  return null != object ? object.getStyle() : null;
};
/**
 * @param {string} obj
 * @param {!Object} value
 * @return {?}
 */
mxGraphModel.prototype.setStyle = function(obj, value) {
  if (value != this.getStyle(obj)) {
    this.execute(new mxStyleChange(this, obj, value));
  }
  return value;
};
/**
 * @param {!Object} cell
 * @param {string} style
 * @return {?}
 */
mxGraphModel.prototype.styleForCellChanged = function(cell, style) {
  var d = this.getStyle(cell);
  cell.setStyle(style);
  return d;
};
/**
 * @param {!Object} parent
 * @return {?}
 */
mxGraphModel.prototype.isCollapsed = function(parent) {
  return null != parent ? parent.isCollapsed() : false;
};
/**
 * @param {!Object} comp
 * @param {!Object} status
 * @return {?}
 */
mxGraphModel.prototype.setCollapsed = function(comp, status) {
  if (status != this.isCollapsed(comp)) {
    this.execute(new mxCollapseChange(this, comp, status));
  }
  return status;
};
/**
 * @param {!Object} button
 * @param {undefined} value
 * @return {?}
 */
mxGraphModel.prototype.collapsedStateForCellChanged = function(button, value) {
  var btn11 = this.isCollapsed(button);
  button.setCollapsed(value);
  return btn11;
};
/**
 * @param {!Object} element
 * @return {?}
 */
mxGraphModel.prototype.isVisible = function(element) {
  return null != element ? element.isVisible() : false;
};
/**
 * @param {string} value
 * @param {!Object} elem
 * @return {?}
 */
mxGraphModel.prototype.setVisible = function(value, elem) {
  if (elem != this.isVisible(value)) {
    this.execute(new mxVisibleChange(this, value, elem));
  }
  return elem;
};
/**
 * @param {!Object} el
 * @param {boolean} value
 * @return {?}
 */
mxGraphModel.prototype.visibleStateForCellChanged = function(el, value) {
  var visible = this.isVisible(el);
  el.setVisible(value);
  return visible;
};
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxGraphModel.prototype.execute = function(obj) {
  obj.execute();
  this.beginUpdate();
  this.currentEdit.add(obj);
  this.fireEvent(new mxEventObject(mxEvent.EXECUTE, "change", obj));
  this.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", obj));
  this.endUpdate();
};
/**
 * @return {undefined}
 */
mxGraphModel.prototype.beginUpdate = function() {
  this.updateLevel++;
  this.fireEvent(new mxEventObject(mxEvent.BEGIN_UPDATE));
  if (1 == this.updateLevel) {
    this.fireEvent(new mxEventObject(mxEvent.START_EDIT));
  }
};
/**
 * @return {undefined}
 */
mxGraphModel.prototype.endUpdate = function() {
  this.updateLevel--;
  if (0 == this.updateLevel) {
    this.fireEvent(new mxEventObject(mxEvent.END_EDIT));
  }
  if (!this.endingUpdate) {
    /** @type {boolean} */
    this.endingUpdate = 0 == this.updateLevel;
    this.fireEvent(new mxEventObject(mxEvent.END_UPDATE, "edit", this.currentEdit));
    try {
      if (this.endingUpdate && !this.currentEdit.isEmpty()) {
        this.fireEvent(new mxEventObject(mxEvent.BEFORE_UNDO, "edit", this.currentEdit));
        var edit = this.currentEdit;
        this.currentEdit = this.createUndoableEdit();
        edit.notify();
        this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", edit));
      }
    } finally {
      /** @type {boolean} */
      this.endingUpdate = false;
    }
  }
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraphModel.prototype.createUndoableEdit = function(a) {
  var edit = new mxUndoableEdit(this, null != a ? a : true);
  /**
   * @return {undefined}
   */
  edit.notify = function() {
    edit.source.fireEvent(new mxEventObject(mxEvent.CHANGE, "edit", edit, "changes", edit.changes));
    edit.source.fireEvent(new mxEventObject(mxEvent.NOTIFY, "edit", edit, "changes", edit.changes));
  };
  return edit;
};
/**
 * @param {?} refNode
 * @param {?} forward
 * @param {?} e
 * @return {undefined}
 */
mxGraphModel.prototype.mergeChildren = function(refNode, forward, e) {
  e = null != e ? e : true;
  this.beginUpdate();
  try {
    var parent = {};
    this.mergeChildrenImpl(refNode, forward, e, parent);
    var key;
    for (key in parent) {
      var value = parent[key];
      var node = this.getTerminal(value, true);
      if (null != node) {
        node = parent[mxCellPath.create(node)];
        this.setTerminal(value, node, true);
      }
      node = this.getTerminal(value, false);
      if (null != node) {
        node = parent[mxCellPath.create(node)];
        this.setTerminal(value, node, false);
      }
    }
  } finally {
    this.endUpdate();
  }
};
/**
 * @param {?} node
 * @param {?} path
 * @param {?} result
 * @param {?} style
 * @return {undefined}
 */
mxGraphModel.prototype.mergeChildrenImpl = function(node, path, result, style) {
  this.beginUpdate();
  try {
    var cell_amount = node.getChildCount();
    /** @type {number} */
    var i = 0;
    for (; i < cell_amount; i++) {
      var obj = node.getChildAt(i);
      if ("function" == typeof obj.getId) {
        var node = obj.getId();
        var value = null == node || this.isEdge(obj) && result ? null : this.getCell(node);
        if (null == value) {
          var tab = obj.clone();
          tab.setId(node);
          tab.setTerminal(obj.getTerminal(true), true);
          tab.setTerminal(obj.getTerminal(false), false);
          value = path.insert(tab);
          this.cellAdded(value);
        }
        style[mxCellPath.create(obj)] = value;
        this.mergeChildrenImpl(obj, value, result, style);
      }
    }
  } finally {
    this.endUpdate();
  }
};
/**
 * @param {!Object} options
 * @return {?}
 */
mxGraphModel.prototype.getParents = function(options) {
  /** @type {!Array} */
  var parents = [];
  if (null != options) {
    var dagService = new mxDictionary;
    /** @type {number} */
    var i = 0;
    for (; i < options.length; i++) {
      var node = this.getParent(options[i]);
      if (!(null == node || dagService.get(node))) {
        dagService.put(node, true);
        parents.push(node);
      }
    }
  }
  return parents;
};
/**
 * @param {string} s
 * @param {?} chars
 * @return {?}
 */
mxGraphModel.prototype.cloneCell = function(s, chars) {
  return null != s ? this.cloneCells([s], chars)[0] : null;
};
/**
 * @param {!Object} cells
 * @param {?} data
 * @param {number} e
 * @return {?}
 */
mxGraphModel.prototype.cloneCells = function(cells, data, e) {
  data = null != data ? data : true;
  e = null != e ? e : {};
  /** @type {!Array} */
  var self = [];
  /** @type {number} */
  var i = 0;
  for (; i < cells.length; i++) {
    if (null != cells[i]) {
      self.push(this.cloneCellImpl(cells[i], e, data));
    } else {
      self.push(null);
    }
  }
  /** @type {number} */
  i = 0;
  for (; i < self.length; i++) {
    if (null != self[i]) {
      this.restoreClone(self[i], cells[i], e);
    }
  }
  return self;
};
/**
 * @param {undefined} n
 * @param {number} e
 * @param {boolean} c
 * @return {?}
 */
mxGraphModel.prototype.cloneCellImpl = function(n, e, c) {
  var i = mxObjectIdentity.get(n);
  var d = e[i];
  if (null == d && (d = this.cellCloned(n), e[i] = d, c)) {
    c = this.getChildCount(n);
    /** @type {number} */
    i = 0;
    for (; i < c; i++) {
      var directory = this.cloneCellImpl(this.getChildAt(n, i), e, true);
      d.insert(directory);
    }
  }
  return d;
};
/**
 * @param {!Object} att
 * @return {?}
 */
mxGraphModel.prototype.cellCloned = function(att) {
  return att.clone();
};
/**
 * @param {undefined} n
 * @param {undefined} i
 * @param {number} t
 * @return {undefined}
 */
mxGraphModel.prototype.restoreClone = function(n, i, t) {
  var target = this.getTerminal(i, true);
  if (null != target) {
    target = t[mxObjectIdentity.get(target)];
    if (null != target) {
      target.insertEdge(n, true);
    }
  }
  target = this.getTerminal(i, false);
  if (null != target) {
    target = t[mxObjectIdentity.get(target)];
    if (null != target) {
      target.insertEdge(n, false);
    }
  }
  target = this.getChildCount(n);
  /** @type {number} */
  var w = 0;
  for (; w < target; w++) {
    this.restoreClone(this.getChildAt(n, w), this.getChildAt(i, w), t);
  }
};
/**
 * @param {!Object} val
 * @param {string} len
 * @return {undefined}
 */
function mxRootChange(val, len) {
  /** @type {!Object} */
  this.model = val;
  this.previous = this.root = len;
}
/**
 * @return {undefined}
 */
mxRootChange.prototype.execute = function() {
  this.root = this.previous;
  this.previous = this.model.rootChanged(this.previous);
};
/**
 * @param {!Object} game
 * @param {?} parent
 * @param {!Node} child
 * @param {number} index
 * @return {undefined}
 */
function mxChildChange(game, parent, child, index) {
  /** @type {!Object} */
  this.model = game;
  this.previous = this.parent = parent;
  /** @type {!Node} */
  this.child = child;
  this.previousIndex = this.index = index;
}
/**
 * @return {undefined}
 */
mxChildChange.prototype.execute = function() {
  if (null != this.child) {
    var old = this.model.getParent(this.child);
    var index = null != old ? old.getIndex(this.child) : 0;
    if (null == this.previous) {
      this.connect(this.child, false);
    }
    old = this.model.parentForCellChanged(this.child, this.previous, this.previousIndex);
    if (null != this.previous) {
      this.connect(this.child, true);
    }
    this.parent = this.previous;
    this.previous = old;
    this.index = this.previousIndex;
    this.previousIndex = index;
  }
};
/**
 * @param {!Object} parent
 * @param {?} name
 * @return {undefined}
 */
mxChildChange.prototype.connect = function(parent, name) {
  name = null != name ? name : true;
  var id = parent.getTerminal(true);
  var i = parent.getTerminal(false);
  if (null != id) {
    if (name) {
      this.model.terminalForCellChanged(parent, id, true);
    } else {
      this.model.terminalForCellChanged(parent, null, true);
    }
  }
  if (null != i) {
    if (name) {
      this.model.terminalForCellChanged(parent, i, false);
    } else {
      this.model.terminalForCellChanged(parent, null, false);
    }
  }
  parent.setTerminal(id, true);
  parent.setTerminal(i, false);
  id = this.model.getChildCount(parent);
  /** @type {number} */
  i = 0;
  for (; i < id; i++) {
    this.connect(this.model.getChildAt(parent, i), name);
  }
};
/**
 * @param {!Object} newModel
 * @param {?} sync
 * @param {?} er
 * @param {string} data
 * @return {undefined}
 */
function mxTerminalChange(newModel, sync, er, data) {
  /** @type {!Object} */
  this.model = newModel;
  this.cell = sync;
  this.previous = this.terminal = er;
  /** @type {string} */
  this.source = data;
}
/**
 * @return {undefined}
 */
mxTerminalChange.prototype.execute = function() {
  if (null != this.cell) {
    this.terminal = this.previous;
    this.previous = this.model.terminalForCellChanged(this.cell, this.previous, this.source);
  }
};
/**
 * @param {!Object} newModel
 * @param {?} _at_variable
 * @param {!Object} _at_value
 * @return {undefined}
 */
function mxValueChange(newModel, _at_variable, _at_value) {
  /** @type {!Object} */
  this.model = newModel;
  this.cell = _at_variable;
  this.previous = this.value = _at_value;
}
/**
 * @return {undefined}
 */
mxValueChange.prototype.execute = function() {
  if (null != this.cell) {
    this.value = this.previous;
    this.previous = this.model.valueForCellChanged(this.cell, this.previous);
  }
};
/**
 * @param {!Object} model
 * @param {?} cell
 * @param {?} className
 * @return {undefined}
 */
function mxStyleChange(model, cell, className) {
  /** @type {!Object} */
  this.model = model;
  this.cell = cell;
  this.previous = this.style = className;
}
/**
 * @return {undefined}
 */
mxStyleChange.prototype.execute = function() {
  if (null != this.cell) {
    this.style = this.previous;
    this.previous = this.model.styleForCellChanged(this.cell, this.previous);
  }
};
/**
 * @param {!Object} game
 * @param {?} context
 * @param {!Object} geometry
 * @return {undefined}
 */
function mxGeometryChange(game, context, geometry) {
  /** @type {!Object} */
  this.model = game;
  this.cell = context;
  this.previous = this.geometry = geometry;
}
/**
 * @return {undefined}
 */
mxGeometryChange.prototype.execute = function() {
  if (null != this.cell) {
    this.geometry = this.previous;
    this.previous = this.model.geometryForCellChanged(this.cell, this.previous);
  }
};
/**
 * @param {!Object} newModel
 * @param {?} rowHeight
 * @param {boolean} groupInitState
 * @return {undefined}
 */
function mxCollapseChange(newModel, rowHeight, groupInitState) {
  /** @type {!Object} */
  this.model = newModel;
  this.cell = rowHeight;
  this.previous = this.collapsed = groupInitState;
}
/**
 * @return {undefined}
 */
mxCollapseChange.prototype.execute = function() {
  if (null != this.cell) {
    this.collapsed = this.previous;
    this.previous = this.model.collapsedStateForCellChanged(this.cell, this.previous);
  }
};
/**
 * @param {!Object} model
 * @param {?} cell
 * @param {boolean} value
 * @return {undefined}
 */
function mxVisibleChange(model, cell, value) {
  /** @type {!Object} */
  this.model = model;
  this.cell = cell;
  this.previous = this.visible = value;
}
/**
 * @return {undefined}
 */
mxVisibleChange.prototype.execute = function() {
  if (null != this.cell) {
    this.visible = this.previous;
    this.previous = this.model.visibleStateForCellChanged(this.cell, this.previous);
  }
};
/**
 * @param {?} cell
 * @param {string} attribute
 * @param {!Object} value
 * @return {undefined}
 */
function mxCellAttributeChange(cell, attribute, value) {
  this.cell = cell;
  /** @type {string} */
  this.attribute = attribute;
  this.previous = this.value = value;
}
/**
 * @return {undefined}
 */
mxCellAttributeChange.prototype.execute = function() {
  if (null != this.cell) {
    var data = this.cell.getAttribute(this.attribute);
    if (null == this.previous) {
      this.cell.value.removeAttribute(this.attribute);
    } else {
      this.cell.setAttribute(this.attribute, this.previous);
    }
    this.previous = data;
  }
};
/**
 * @param {!Object} p2
 * @param {!Object} fn
 * @param {string} value
 * @return {undefined}
 */
function mxCell(p2, fn, value) {
  /** @type {!Object} */
  this.value = p2;
  this.setGeometry(fn);
  this.setStyle(value);
  if (null != this.onInit) {
    this.onInit();
  }
}
/** @type {null} */
mxCell.prototype.id = null;
/** @type {null} */
mxCell.prototype.value = null;
/** @type {null} */
mxCell.prototype.geometry = null;
/** @type {null} */
mxCell.prototype.style = null;
/** @type {boolean} */
mxCell.prototype.vertex = false;
/** @type {boolean} */
mxCell.prototype.edge = false;
/** @type {boolean} */
mxCell.prototype.connectable = true;
/** @type {boolean} */
mxCell.prototype.visible = true;
/** @type {boolean} */
mxCell.prototype.collapsed = false;
/** @type {null} */
mxCell.prototype.parent = null;
/** @type {null} */
mxCell.prototype.source = null;
/** @type {null} */
mxCell.prototype.target = null;
/** @type {null} */
mxCell.prototype.children = null;
/** @type {null} */
mxCell.prototype.edges = null;
/** @type {!Array<string>} */
mxCell.prototype.mxTransient = "id value parent source target children edges".split(" ");
/**
 * @return {?}
 */
mxCell.prototype.getId = function() {
  return this.id;
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxCell.prototype.setId = function(value) {
  /** @type {string} */
  this.id = value;
};
/**
 * @return {?}
 */
mxCell.prototype.getValue = function() {
  return this.value;
};
/**
 * @param {!Object} date
 * @return {undefined}
 */
mxCell.prototype.setValue = function(date) {
  /** @type {!Object} */
  this.value = date;
};
/**
 * @param {!Object} v
 * @return {?}
 */
mxCell.prototype.valueChanged = function(v) {
  var currentPrefs = this.getValue();
  this.setValue(v);
  return currentPrefs;
};
/**
 * @return {?}
 */
mxCell.prototype.getGeometry = function() {
  return this.geometry;
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxCell.prototype.setGeometry = function(value) {
  /** @type {!Object} */
  this.geometry = value;
};
/**
 * @return {?}
 */
mxCell.prototype.getStyle = function() {
  return this.style;
};
/**
 * @param {string} style
 * @return {undefined}
 */
mxCell.prototype.setStyle = function(style) {
  /** @type {string} */
  this.style = style;
};
/**
 * @return {?}
 */
mxCell.prototype.isVertex = function() {
  return 0 != this.vertex;
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxCell.prototype.setVertex = function(value) {
  /** @type {string} */
  this.vertex = value;
};
/**
 * @return {?}
 */
mxCell.prototype.isEdge = function() {
  return 0 != this.edge;
};
/**
 * @param {string} edge
 * @return {undefined}
 */
mxCell.prototype.setEdge = function(edge) {
  /** @type {string} */
  this.edge = edge;
};
/**
 * @return {?}
 */
mxCell.prototype.isConnectable = function() {
  return 0 != this.connectable;
};
/**
 * @param {string} isIron
 * @return {undefined}
 */
mxCell.prototype.setConnectable = function(isIron) {
  /** @type {string} */
  this.connectable = isIron;
};
/**
 * @return {?}
 */
mxCell.prototype.isVisible = function() {
  return 0 != this.visible;
};
/**
 * @param {boolean} isVisible
 * @return {undefined}
 */
mxCell.prototype.setVisible = function(isVisible) {
  /** @type {boolean} */
  this.visible = isVisible;
};
/**
 * @return {?}
 */
mxCell.prototype.isCollapsed = function() {
  return 0 != this.collapsed;
};
/**
 * @param {boolean} collapsed
 * @return {undefined}
 */
mxCell.prototype.setCollapsed = function(collapsed) {
  /** @type {boolean} */
  this.collapsed = collapsed;
};
/**
 * @return {?}
 */
mxCell.prototype.getParent = function() {
  return this.parent;
};
/**
 * @param {!Object} parent
 * @return {undefined}
 */
mxCell.prototype.setParent = function(parent) {
  /** @type {!Object} */
  this.parent = parent;
};
/**
 * @param {string} arg
 * @return {?}
 */
mxCell.prototype.getTerminal = function(arg) {
  return arg ? this.source : this.target;
};
/**
 * @param {string} data
 * @param {string} id
 * @return {?}
 */
mxCell.prototype.setTerminal = function(data, id) {
  if (id) {
    /** @type {string} */
    this.source = data;
  } else {
    /** @type {string} */
    this.target = data;
  }
  return data;
};
/**
 * @return {?}
 */
mxCell.prototype.getChildCount = function() {
  return null == this.children ? 0 : this.children.length;
};
/**
 * @param {?} value
 * @return {?}
 */
mxCell.prototype.getIndex = function(value) {
  return mxUtils.indexOf(this.children, value);
};
/**
 * @param {!Object} index
 * @return {?}
 */
mxCell.prototype.getChildAt = function(index) {
  return null == this.children ? null : this.children[index];
};
/**
 * @param {!Object} node
 * @param {!Object} child
 * @return {?}
 */
mxCell.prototype.insert = function(node, child) {
  if (null != node) {
    if (null == child) {
      child = this.getChildCount();
      if (node.getParent() == this) {
        child--;
      }
    }
    node.removeFromParent();
    node.setParent(this);
    if (null == this.children) {
      /** @type {!Array} */
      this.children = [];
      this.children.push(node);
    } else {
      this.children.splice(child, 0, node);
    }
  }
  return node;
};
/**
 * @param {number} n
 * @return {?}
 */
mxCell.prototype.remove = function(n) {
  /** @type {null} */
  var child = null;
  if (null != this.children && 0 <= n) {
    child = this.getChildAt(n);
    if (null != child) {
      this.children.splice(n, 1);
      child.setParent(null);
    }
  }
  return child;
};
/**
 * @return {undefined}
 */
mxCell.prototype.removeFromParent = function() {
  if (null != this.parent) {
    var value = this.parent.getIndex(this);
    this.parent.remove(value);
  }
};
/**
 * @return {?}
 */
mxCell.prototype.getEdgeCount = function() {
  return null == this.edges ? 0 : this.edges.length;
};
/**
 * @param {!Array} value
 * @return {?}
 */
mxCell.prototype.getEdgeIndex = function(value) {
  return mxUtils.indexOf(this.edges, value);
};
/**
 * @param {!Object} key
 * @return {?}
 */
mxCell.prototype.getEdgeAt = function(key) {
  return null == this.edges ? null : this.edges[key];
};
/**
 * @param {?} value
 * @param {string} type
 * @return {?}
 */
mxCell.prototype.insertEdge = function(value, type) {
  if (null != value && (value.removeFromTerminal(type), value.setTerminal(this, type), null == this.edges || value.getTerminal(!type) != this || 0 > mxUtils.indexOf(this.edges, value))) {
    if (null == this.edges) {
      /** @type {!Array} */
      this.edges = [];
    }
    this.edges.push(value);
  }
  return value;
};
/**
 * @param {?} node
 * @param {boolean} id
 * @return {?}
 */
mxCell.prototype.removeEdge = function(node, id) {
  if (null != node) {
    if (node.getTerminal(!id) != this && null != this.edges) {
      var i = this.getEdgeIndex(node);
      if (0 <= i) {
        this.edges.splice(i, 1);
      }
    }
    node.setTerminal(null, id);
  }
  return node;
};
/**
 * @param {!Object} key
 * @return {undefined}
 */
mxCell.prototype.removeFromTerminal = function(key) {
  var result = this.getTerminal(key);
  if (null != result) {
    result.removeEdge(this, key);
  }
};
/**
 * @param {string} attribute
 * @return {?}
 */
mxCell.prototype.hasAttribute = function(attribute) {
  var image = this.getValue();
  return null != image && image.nodeType == mxConstants.NODETYPE_ELEMENT && image.hasAttribute ? image.hasAttribute(attribute) : null != image.getAttribute(attribute);
};
/**
 * @param {string} name
 * @param {string} setCompiled
 * @return {?}
 */
mxCell.prototype.getAttribute = function(name, setCompiled) {
  var parent = this.getValue();
  parent = null != parent && parent.nodeType == mxConstants.NODETYPE_ELEMENT ? parent.getAttribute(name) : null;
  return null != parent ? parent : setCompiled;
};
/**
 * @param {string} name
 * @param {string} value
 * @return {undefined}
 */
mxCell.prototype.setAttribute = function(name, value) {
  var parent = this.getValue();
  if (null != parent && parent.nodeType == mxConstants.NODETYPE_ELEMENT) {
    parent.setAttribute(name, value);
  }
};
/**
 * @return {?}
 */
mxCell.prototype.clone = function() {
  var material = mxUtils.clone(this, this.mxTransient);
  material.setValue(this.cloneValue());
  return material;
};
/**
 * @return {?}
 */
mxCell.prototype.cloneValue = function() {
  var val = this.getValue();
  if (null != val) {
    if ("function" == typeof val.clone) {
      val = val.clone();
    } else {
      if (!isNaN(val.nodeType)) {
        val = val.cloneNode(true);
      }
    }
  }
  return val;
};
/**
 * @param {?} a
 * @param {?} b
 * @param {?} c
 * @param {?} quality
 * @return {undefined}
 */
function mxGeometry(a, b, c, quality) {
  mxRectangle.call(this, a, b, c, quality);
}
mxGeometry.prototype = new mxRectangle;
/** @type {function(?, ?, ?, ?): undefined} */
mxGeometry.prototype.constructor = mxGeometry;
/** @type {boolean} */
mxGeometry.prototype.TRANSLATE_CONTROL_POINTS = true;
/** @type {null} */
mxGeometry.prototype.alternateBounds = null;
/** @type {null} */
mxGeometry.prototype.sourcePoint = null;
/** @type {null} */
mxGeometry.prototype.targetPoint = null;
/** @type {null} */
mxGeometry.prototype.points = null;
/** @type {null} */
mxGeometry.prototype.offset = null;
/** @type {boolean} */
mxGeometry.prototype.relative = false;
/**
 * @return {undefined}
 */
mxGeometry.prototype.swap = function() {
  if (null != this.alternateBounds) {
    var d = new mxRectangle(this.x, this.y, this.width, this.height);
    this.x = this.alternateBounds.x;
    this.y = this.alternateBounds.y;
    this.width = this.alternateBounds.width;
    this.height = this.alternateBounds.height;
    this.alternateBounds = d;
  }
};
/**
 * @param {boolean} num
 * @return {?}
 */
mxGeometry.prototype.getTerminalPoint = function(num) {
  return num ? this.sourcePoint : this.targetPoint;
};
/**
 * @param {string} point
 * @param {boolean} result
 * @return {?}
 */
mxGeometry.prototype.setTerminalPoint = function(point, result) {
  if (result) {
    /** @type {string} */
    this.sourcePoint = point;
  } else {
    /** @type {string} */
    this.targetPoint = point;
  }
  return point;
};
/**
 * @param {number} data
 * @param {undefined} ct
 * @return {undefined}
 */
mxGeometry.prototype.rotate = function(data, ct) {
  var r = mxUtils.toRadians(data);
  /** @type {number} */
  var cos = Math.cos(r);
  /** @type {number} */
  r = Math.sin(r);
  if (!this.relative) {
    var pt = new mxPoint(this.getCenterX(), this.getCenterY());
    pt = mxUtils.getRotatedPoint(pt, cos, r, ct);
    /** @type {number} */
    this.x = Math.round(pt.x - this.width / 2);
    /** @type {number} */
    this.y = Math.round(pt.y - this.height / 2);
  }
  if (null != this.sourcePoint) {
    pt = mxUtils.getRotatedPoint(this.sourcePoint, cos, r, ct);
    /** @type {number} */
    this.sourcePoint.x = Math.round(pt.x);
    /** @type {number} */
    this.sourcePoint.y = Math.round(pt.y);
  }
  if (null != this.targetPoint) {
    pt = mxUtils.getRotatedPoint(this.targetPoint, cos, r, ct);
    /** @type {number} */
    this.targetPoint.x = Math.round(pt.x);
    /** @type {number} */
    this.targetPoint.y = Math.round(pt.y);
  }
  if (null != this.points) {
    /** @type {number} */
    var i = 0;
    for (; i < this.points.length; i++) {
      if (null != this.points[i]) {
        pt = mxUtils.getRotatedPoint(this.points[i], cos, r, ct);
        /** @type {number} */
        this.points[i].x = Math.round(pt.x);
        /** @type {number} */
        this.points[i].y = Math.round(pt.y);
      }
    }
  }
};
/**
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxGeometry.prototype.translate = function(x, y) {
  /** @type {number} */
  x = parseFloat(x);
  /** @type {number} */
  y = parseFloat(y);
  if (!this.relative) {
    /** @type {number} */
    this.x = parseFloat(this.x) + x;
    /** @type {number} */
    this.y = parseFloat(this.y) + y;
  }
  if (null != this.sourcePoint) {
    /** @type {number} */
    this.sourcePoint.x = parseFloat(this.sourcePoint.x) + x;
    /** @type {number} */
    this.sourcePoint.y = parseFloat(this.sourcePoint.y) + y;
  }
  if (null != this.targetPoint) {
    /** @type {number} */
    this.targetPoint.x = parseFloat(this.targetPoint.x) + x;
    /** @type {number} */
    this.targetPoint.y = parseFloat(this.targetPoint.y) + y;
  }
  if (this.TRANSLATE_CONTROL_POINTS && null != this.points) {
    /** @type {number} */
    var i = 0;
    for (; i < this.points.length; i++) {
      if (null != this.points[i]) {
        /** @type {number} */
        this.points[i].x = parseFloat(this.points[i].x) + x;
        /** @type {number} */
        this.points[i].y = parseFloat(this.points[i].y) + y;
      }
    }
  }
};
/**
 * @param {number} value
 * @param {number} scale
 * @param {number} def
 * @return {undefined}
 */
mxGeometry.prototype.scale = function(value, scale, def) {
  /** @type {number} */
  value = parseFloat(value);
  /** @type {number} */
  scale = parseFloat(scale);
  if (null != this.sourcePoint) {
    /** @type {number} */
    this.sourcePoint.x = parseFloat(this.sourcePoint.x) * value;
    /** @type {number} */
    this.sourcePoint.y = parseFloat(this.sourcePoint.y) * scale;
  }
  if (null != this.targetPoint) {
    /** @type {number} */
    this.targetPoint.x = parseFloat(this.targetPoint.x) * value;
    /** @type {number} */
    this.targetPoint.y = parseFloat(this.targetPoint.y) * scale;
  }
  if (null != this.points) {
    /** @type {number} */
    var i = 0;
    for (; i < this.points.length; i++) {
      if (null != this.points[i]) {
        /** @type {number} */
        this.points[i].x = parseFloat(this.points[i].x) * value;
        /** @type {number} */
        this.points[i].y = parseFloat(this.points[i].y) * scale;
      }
    }
  }
  if (!this.relative) {
    /** @type {number} */
    this.x = parseFloat(this.x) * value;
    /** @type {number} */
    this.y = parseFloat(this.y) * scale;
    if (def) {
      /** @type {number} */
      scale = value = Math.min(value, scale);
    }
    /** @type {number} */
    this.width = parseFloat(this.width) * value;
    /** @type {number} */
    this.height = parseFloat(this.height) * scale;
  }
};
/**
 * @param {!Object} d
 * @return {?}
 */
mxGeometry.prototype.equals = function(d) {
  return mxRectangle.prototype.equals.apply(this, arguments) && this.relative == d.relative && (null == this.sourcePoint && null == d.sourcePoint || null != this.sourcePoint && this.sourcePoint.equals(d.sourcePoint)) && (null == this.targetPoint && null == d.targetPoint || null != this.targetPoint && this.targetPoint.equals(d.targetPoint)) && (null == this.points && null == d.points || null != this.points && mxUtils.equalPoints(this.points, d.points)) && (null == this.alternateBounds && null == d.alternateBounds || 
  null != this.alternateBounds && this.alternateBounds.equals(d.alternateBounds)) && (null == this.offset && null == d.offset || null != this.offset && this.offset.equals(d.offset));
};
var mxCellPath = {
  PATH_SEPARATOR : ".",
  create : function(n) {
    /** @type {string} */
    var s = "";
    if (null != n) {
      var item = n.getParent();
      for (; null != item;) {
        /** @type {string} */
        s = item.getIndex(n) + mxCellPath.PATH_SEPARATOR + s;
        n = item;
        item = n.getParent();
      }
    }
    /** @type {number} */
    n = s.length;
    if (1 < n) {
      /** @type {string} */
      s = s.substring(0, n - 1);
    }
    return s;
  },
  getParentPath : function(path) {
    if (null != path) {
      var expEnd = path.lastIndexOf(mxCellPath.PATH_SEPARATOR);
      if (0 <= expEnd) {
        return path.substring(0, expEnd);
      }
      if (0 < path.length) {
        return "";
      }
    }
    return null;
  },
  resolve : function(callback, type) {
    /** @type {!Element} */
    var node = callback;
    if (null != type) {
      var enmlHash = type.split(mxCellPath.PATH_SEPARATOR);
      /** @type {number} */
      var i = 0;
      for (; i < enmlHash.length; i++) {
        node = node.getChildAt(parseInt(enmlHash[i]));
      }
    }
    return node;
  },
  compare : function(a, b) {
    /** @type {number} */
    var i = Math.min(a.length, b.length);
    /** @type {number} */
    var _ref = 0;
    /** @type {number} */
    var j = 0;
    for (; j < i; j++) {
      if (a[j] != b[j]) {
        if (0 == a[j].length || 0 == b[j].length) {
          /** @type {number} */
          _ref = a[j] == b[j] ? 0 : a[j] > b[j] ? 1 : -1;
        } else {
          /** @type {number} */
          i = parseInt(a[j]);
          /** @type {number} */
          j = parseInt(b[j]);
          /** @type {number} */
          _ref = i == j ? 0 : i > j ? 1 : -1;
        }
        break;
      }
    }
    if (0 == _ref) {
      i = a.length;
      j = b.length;
      if (i != j) {
        /** @type {number} */
        _ref = i > j ? 1 : -1;
      }
    }
    return _ref;
  }
};
var mxPerimeter = {
  RectanglePerimeter : function(point, x, p, altCss) {
    x = point.getCenterX();
    var height = point.getCenterY();
    /** @type {number} */
    var angle = Math.atan2(p.y - height, p.x - x);
    var self = new mxPoint(0, 0);
    /** @type {number} */
    var stemBase = Math.PI;
    /** @type {number} */
    var y = Math.PI / 2 - angle;
    /** @type {number} */
    var hb = Math.atan2(point.height, point.width);
    if (angle < -stemBase + hb || angle > stemBase - hb) {
      self.x = point.x;
      /** @type {number} */
      self.y = height - point.width * Math.tan(angle) / 2;
    } else {
      if (angle < -hb) {
        self.y = point.y;
        /** @type {number} */
        self.x = x - point.height * Math.tan(y) / 2;
      } else {
        if (angle < hb) {
          self.x = point.x + point.width;
          self.y = height + point.width * Math.tan(angle) / 2;
        } else {
          self.y = point.y + point.height;
          self.x = x + point.height * Math.tan(y) / 2;
        }
      }
    }
    if (altCss) {
      if (p.x >= point.x && p.x <= point.x + point.width) {
        self.x = p.x;
      } else {
        if (p.y >= point.y && p.y <= point.y + point.height) {
          self.y = p.y;
        }
      }
      if (p.x < point.x) {
        self.x = point.x;
      } else {
        if (p.x > point.x + point.width) {
          self.x = point.x + point.width;
        }
      }
      if (p.y < point.y) {
        self.y = point.y;
      } else {
        if (p.y > point.y + point.height) {
          self.y = point.y + point.height;
        }
      }
    }
    return self;
  },
  EllipsePerimeter : function(s, x, i, forceOptional) {
    var a = s.x;
    var t = s.y;
    /** @type {number} */
    var d = s.width / 2;
    /** @type {number} */
    var b = s.height / 2;
    var y = a + d;
    var c = t + b;
    x = i.x;
    i = i.y;
    /** @type {number} */
    var h = parseInt(x - y);
    /** @type {number} */
    var w = parseInt(i - c);
    if (0 == h && 0 != w) {
      return new mxPoint(y, c + b * w / Math.abs(w));
    }
    if (0 == h && 0 == w) {
      return new mxPoint(x, i);
    }
    if (forceOptional) {
      if (i >= t && i <= t + s.height) {
        return s = i - c, s = Math.sqrt(d * d * (1 - s * s / (b * b))) || 0, x <= a && (s = -s), new mxPoint(y + s, i);
      }
      if (x >= a && x <= a + s.width) {
        return s = x - y, s = Math.sqrt(b * b * (1 - s * s / (d * d))) || 0, i <= t && (s = -s), new mxPoint(x, c + s);
      }
    }
    /** @type {number} */
    a = w / h;
    /** @type {number} */
    c = c - a * y;
    /** @type {number} */
    t = d * d * a * a + b * b;
    /** @type {number} */
    s = -2 * y * t;
    /** @type {number} */
    b = Math.sqrt(s * s - 4 * t * (d * d * a * a * y * y + b * b * y * y - d * d * b * b));
    /** @type {number} */
    d = (-s + b) / (2 * t);
    /** @type {number} */
    y = (-s - b) / (2 * t);
    b = a * d + c;
    c = a * y + c;
    if (Math.sqrt(Math.pow(d - x, 2) + Math.pow(b - i, 2)) < Math.sqrt(Math.pow(y - x, 2) + Math.pow(c - i, 2))) {
      /** @type {number} */
      x = d;
      i = b;
    } else {
      /** @type {number} */
      x = y;
      i = c;
    }
    return new mxPoint(x, i);
  },
  RhombusPerimeter : function(size, x, index, _$suspendResize) {
    x = size.x;
    var h = size.y;
    var l = size.width;
    size = size.height;
    var n = x + l / 2;
    var count = h + size / 2;
    var i = index.x;
    index = index.y;
    if (n == i) {
      return count > index ? new mxPoint(n, h) : new mxPoint(n, h + size);
    }
    if (count == index) {
      return n > i ? new mxPoint(x, count) : new mxPoint(x + l, count);
    }
    var result = n;
    var before = count;
    if (_$suspendResize) {
      if (i >= x && i <= x + l) {
        result = i;
      } else {
        if (index >= h && index <= h + size) {
          before = index;
        }
      }
    }
    return i < n ? index < count ? mxUtils.intersection(i, index, result, before, n, h, x, count) : mxUtils.intersection(i, index, result, before, n, h + size, x, count) : index < count ? mxUtils.intersection(i, index, result, before, n, h, x + l, count) : mxUtils.intersection(i, index, result, before, n, h + size, x + l, count);
  },
  TrianglePerimeter : function(x, node, point, that) {
    node = null != node ? node.style[mxConstants.STYLE_DIRECTION] : null;
    /** @type {boolean} */
    var position = node == mxConstants.DIRECTION_NORTH || node == mxConstants.DIRECTION_SOUTH;
    var width = x.x;
    var y = x.y;
    var height = x.width;
    var r = x.height;
    x = width + height / 2;
    var top = y + r / 2;
    var bounds = new mxPoint(width, y);
    var target = new mxPoint(width + height, top);
    var pt = new mxPoint(width, y + r);
    if (node == mxConstants.DIRECTION_NORTH) {
      bounds = pt;
      target = new mxPoint(x, y);
      pt = new mxPoint(width + height, y + r);
    } else {
      if (node == mxConstants.DIRECTION_SOUTH) {
        target = new mxPoint(x, y + r);
        pt = new mxPoint(width + height, y);
      } else {
        if (node == mxConstants.DIRECTION_WEST) {
          bounds = new mxPoint(width + height, y);
          target = new mxPoint(width, top);
          pt = new mxPoint(width + height, y + r);
        }
      }
    }
    /** @type {number} */
    var a = point.x - x;
    /** @type {number} */
    var b = point.y - top;
    /** @type {number} */
    a = position ? Math.atan2(a, b) : Math.atan2(b, a);
    /** @type {number} */
    b = position ? Math.atan2(height, r) : Math.atan2(r, height);
    if (node == mxConstants.DIRECTION_NORTH || node == mxConstants.DIRECTION_WEST ? a > -b && a < b : a < -Math.PI + b || a > Math.PI - b) {
      point = that && (position && point.x >= bounds.x && point.x <= pt.x || !position && point.y >= bounds.y && point.y <= pt.y) ? position ? new mxPoint(point.x, bounds.y) : new mxPoint(bounds.x, point.y) : node == mxConstants.DIRECTION_NORTH ? new mxPoint(width + height / 2 + r * Math.tan(a) / 2, y + r) : node == mxConstants.DIRECTION_SOUTH ? new mxPoint(width + height / 2 - r * Math.tan(a) / 2, y) : node == mxConstants.DIRECTION_WEST ? new mxPoint(width + height, y + r / 2 + height * Math.tan(a) / 
      2) : new mxPoint(width, y + r / 2 - height * Math.tan(a) / 2);
    } else {
      if (that) {
        that = new mxPoint(x, top);
        if (point.y >= y && point.y <= y + r) {
          that.x = position ? x : node == mxConstants.DIRECTION_WEST ? width + height : width;
          that.y = point.y;
        } else {
          if (point.x >= width && point.x <= width + height) {
            that.x = point.x;
            that.y = position ? node == mxConstants.DIRECTION_NORTH ? y + r : y : top;
          }
        }
        x = that.x;
        top = that.y;
      }
      point = position && point.x <= width + height / 2 || !position && point.y <= y + r / 2 ? mxUtils.intersection(point.x, point.y, x, top, bounds.x, bounds.y, target.x, target.y) : mxUtils.intersection(point.x, point.y, x, top, target.x, target.y, pt.x, pt.y);
    }
    if (null == point) {
      point = new mxPoint(x, top);
    }
    return point;
  },
  HexagonPerimeter : function(value, cell, content, data) {
    var start = value.x;
    var x = value.y;
    var len = value.width;
    var y = value.height;
    var width = value.getCenterX();
    value = value.getCenterY();
    var i = content.x;
    var j = content.y;
    /** @type {number} */
    var index = -Math.atan2(j - value, i - width);
    /** @type {number} */
    var length = Math.PI;
    /** @type {number} */
    var max = Math.PI / 2;
    new mxPoint(width, value);
    cell = null != cell ? mxUtils.getValue(cell.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST) : mxConstants.DIRECTION_EAST;
    /** @type {boolean} */
    var t = cell == mxConstants.DIRECTION_NORTH || cell == mxConstants.DIRECTION_SOUTH;
    cell = new mxPoint;
    var item = new mxPoint;
    if (i < start && j < x || i < start && j > x + y || i > start + len && j < x || i > start + len && j > x + y) {
      /** @type {boolean} */
      data = false;
    }
    if (data) {
      if (t) {
        if (i == width) {
          if (j <= x) {
            return new mxPoint(width, x);
          }
          if (j >= x + y) {
            return new mxPoint(width, x + y);
          }
        } else {
          if (i < start) {
            if (j == x + y / 4) {
              return new mxPoint(start, x + y / 4);
            }
            if (j == x + 3 * y / 4) {
              return new mxPoint(start, x + 3 * y / 4);
            }
          } else {
            if (i > start + len) {
              if (j == x + y / 4) {
                return new mxPoint(start + len, x + y / 4);
              }
              if (j == x + 3 * y / 4) {
                return new mxPoint(start + len, x + 3 * y / 4);
              }
            } else {
              if (i == start) {
                if (j < value) {
                  return new mxPoint(start, x + y / 4);
                }
                if (j > value) {
                  return new mxPoint(start, x + 3 * y / 4);
                }
              } else {
                if (i == start + len) {
                  if (j < value) {
                    return new mxPoint(start + len, x + y / 4);
                  }
                  if (j > value) {
                    return new mxPoint(start + len, x + 3 * y / 4);
                  }
                }
              }
            }
          }
        }
        if (j == x) {
          return new mxPoint(width, x);
        }
        if (j == x + y) {
          return new mxPoint(width, x + y);
        }
        if (i < width) {
          if (j > x + y / 4 && j < x + 3 * y / 4) {
            cell = new mxPoint(start, x);
            item = new mxPoint(start, x + y);
          } else {
            if (j < x + y / 4) {
              cell = new mxPoint(start - Math.floor(.5 * len), x + Math.floor(.5 * y));
              item = new mxPoint(start + len, x - Math.floor(.25 * y));
            } else {
              if (j > x + 3 * y / 4) {
                cell = new mxPoint(start - Math.floor(.5 * len), x + Math.floor(.5 * y));
                item = new mxPoint(start + len, x + Math.floor(1.25 * y));
              }
            }
          }
        } else {
          if (i > width) {
            if (j > x + y / 4 && j < x + 3 * y / 4) {
              cell = new mxPoint(start + len, x);
              item = new mxPoint(start + len, x + y);
            } else {
              if (j < x + y / 4) {
                cell = new mxPoint(start, x - Math.floor(.25 * y));
                item = new mxPoint(start + Math.floor(1.5 * len), x + Math.floor(.5 * y));
              } else {
                if (j > x + 3 * y / 4) {
                  cell = new mxPoint(start + Math.floor(1.5 * len), x + Math.floor(.5 * y));
                  item = new mxPoint(start, x + Math.floor(1.25 * y));
                }
              }
            }
          }
        }
      } else {
        if (j == value) {
          if (i <= start) {
            return new mxPoint(start, x + y / 2);
          }
          if (i >= start + len) {
            return new mxPoint(start + len, x + y / 2);
          }
        } else {
          if (j < x) {
            if (i == start + len / 4) {
              return new mxPoint(start + len / 4, x);
            }
            if (i == start + 3 * len / 4) {
              return new mxPoint(start + 3 * len / 4, x);
            }
          } else {
            if (j > x + y) {
              if (i == start + len / 4) {
                return new mxPoint(start + len / 4, x + y);
              }
              if (i == start + 3 * len / 4) {
                return new mxPoint(start + 3 * len / 4, x + y);
              }
            } else {
              if (j == x) {
                if (i < width) {
                  return new mxPoint(start + len / 4, x);
                }
                if (i > width) {
                  return new mxPoint(start + 3 * len / 4, x);
                }
              } else {
                if (j == x + y) {
                  if (i < width) {
                    return new mxPoint(start + len / 4, x + y);
                  }
                  if (j > value) {
                    return new mxPoint(start + 3 * len / 4, x + y);
                  }
                }
              }
            }
          }
        }
        if (i == start) {
          return new mxPoint(start, value);
        }
        if (i == start + len) {
          return new mxPoint(start + len, value);
        }
        if (j < value) {
          if (i > start + len / 4 && i < start + 3 * len / 4) {
            cell = new mxPoint(start, x);
            item = new mxPoint(start + len, x);
          } else {
            if (i < start + len / 4) {
              cell = new mxPoint(start - Math.floor(.25 * len), x + y);
              item = new mxPoint(start + Math.floor(.5 * len), x - Math.floor(.5 * y));
            } else {
              if (i > start + 3 * len / 4) {
                cell = new mxPoint(start + Math.floor(.5 * len), x - Math.floor(.5 * y));
                item = new mxPoint(start + Math.floor(1.25 * len), x + y);
              }
            }
          }
        } else {
          if (j > value) {
            if (i > start + len / 4 && i < start + 3 * len / 4) {
              cell = new mxPoint(start, x + y);
              item = new mxPoint(start + len, x + y);
            } else {
              if (i < start + len / 4) {
                cell = new mxPoint(start - Math.floor(.25 * len), x);
                item = new mxPoint(start + Math.floor(.5 * len), x + Math.floor(1.5 * y));
              } else {
                if (i > start + 3 * len / 4) {
                  cell = new mxPoint(start + Math.floor(.5 * len), x + Math.floor(1.5 * y));
                  item = new mxPoint(start + Math.floor(1.25 * len), x);
                }
              }
            }
          }
        }
      }
      data = width;
      /** @type {number} */
      index = value;
      if (i >= start && i <= start + len) {
        data = i;
        index = j < value ? x + y : x;
      } else {
        if (j >= x && j <= x + y) {
          index = j;
          data = i < width ? start + len : start;
        }
      }
      content = mxUtils.intersection(data, index, content.x, content.y, cell.x, cell.y, item.x, item.y);
    } else {
      if (t) {
        /** @type {number} */
        i = Math.atan2(y / 4, len / 2);
        if (index == i) {
          return new mxPoint(start + len, x + Math.floor(.25 * y));
        }
        if (index == max) {
          return new mxPoint(start + Math.floor(.5 * len), x);
        }
        if (index == length - i) {
          return new mxPoint(start, x + Math.floor(.25 * y));
        }
        if (index == -i) {
          return new mxPoint(start + len, x + Math.floor(.75 * y));
        }
        if (index == -max) {
          return new mxPoint(start + Math.floor(.5 * len), x + y);
        }
        if (index == -length + i) {
          return new mxPoint(start, x + Math.floor(.75 * y));
        }
        if (index < i && index > -i) {
          cell = new mxPoint(start + len, x);
          item = new mxPoint(start + len, x + y);
        } else {
          if (index > i && index < max) {
            cell = new mxPoint(start, x - Math.floor(.25 * y));
            item = new mxPoint(start + Math.floor(1.5 * len), x + Math.floor(.5 * y));
          } else {
            if (index > max && index < length - i) {
              cell = new mxPoint(start - Math.floor(.5 * len), x + Math.floor(.5 * y));
              item = new mxPoint(start + len, x - Math.floor(.25 * y));
            } else {
              if (index > length - i && index <= length || index < -length + i && index >= -length) {
                cell = new mxPoint(start, x);
                item = new mxPoint(start, x + y);
              } else {
                if (index < -i && index > -max) {
                  cell = new mxPoint(start + Math.floor(1.5 * len), x + Math.floor(.5 * y));
                  item = new mxPoint(start, x + Math.floor(1.25 * y));
                } else {
                  if (index < -max && index > -length + i) {
                    cell = new mxPoint(start - Math.floor(.5 * len), x + Math.floor(.5 * y));
                    item = new mxPoint(start + len, x + Math.floor(1.25 * y));
                  }
                }
              }
            }
          }
        }
      } else {
        /** @type {number} */
        i = Math.atan2(y / 2, len / 4);
        if (index == i) {
          return new mxPoint(start + Math.floor(.75 * len), x);
        }
        if (index == length - i) {
          return new mxPoint(start + Math.floor(.25 * len), x);
        }
        if (index == length || index == -length) {
          return new mxPoint(start, x + Math.floor(.5 * y));
        }
        if (0 == index) {
          return new mxPoint(start + len, x + Math.floor(.5 * y));
        }
        if (index == -i) {
          return new mxPoint(start + Math.floor(.75 * len), x + y);
        }
        if (index == -length + i) {
          return new mxPoint(start + Math.floor(.25 * len), x + y);
        }
        if (0 < index && index < i) {
          cell = new mxPoint(start + Math.floor(.5 * len), x - Math.floor(.5 * y));
          item = new mxPoint(start + Math.floor(1.25 * len), x + y);
        } else {
          if (index > i && index < length - i) {
            cell = new mxPoint(start, x);
            item = new mxPoint(start + len, x);
          } else {
            if (index > length - i && index < length) {
              cell = new mxPoint(start - Math.floor(.25 * len), x + y);
              item = new mxPoint(start + Math.floor(.5 * len), x - Math.floor(.5 * y));
            } else {
              if (0 > index && index > -i) {
                cell = new mxPoint(start + Math.floor(.5 * len), x + Math.floor(1.5 * y));
                item = new mxPoint(start + Math.floor(1.25 * len), x);
              } else {
                if (index < -i && index > -length + i) {
                  cell = new mxPoint(start, x + y);
                  item = new mxPoint(start + len, x + y);
                } else {
                  if (index < -length + i && index > -length) {
                    cell = new mxPoint(start - Math.floor(.25 * len), x);
                    item = new mxPoint(start + Math.floor(.5 * len), x + Math.floor(1.5 * y));
                  }
                }
              }
            }
          }
        }
      }
      content = mxUtils.intersection(width, value, content.x, content.y, cell.x, cell.y, item.x, item.y);
    }
    return null == content ? new mxPoint(width, value) : content;
  }
};
/**
 * @param {!Object} graph
 * @param {number} type
 * @param {number} coords
 * @param {number} data
 * @param {number} story
 * @param {number} name
 * @param {string} value
 * @param {string} title
 * @param {?} annoations
 * @return {undefined}
 */
function mxPrintPreview(graph, type, coords, data, story, name, value, title, annoations) {
  /** @type {!Object} */
  this.graph = graph;
  this.scale = null != type ? type : 1 / graph.pageScale;
  this.border = null != data ? data : 0;
  this.pageFormat = mxRectangle.fromRectangle(null != coords ? coords : graph.pageFormat);
  this.title = null != title ? title : "Printer-friendly version";
  this.x0 = null != story ? story : 0;
  this.y0 = null != name ? name : 0;
  /** @type {string} */
  this.borderColor = value;
  this.pageSelector = null != annoations ? annoations : true;
}
/** @type {null} */
mxPrintPreview.prototype.graph = null;
/** @type {null} */
mxPrintPreview.prototype.pageFormat = null;
/** @type {null} */
mxPrintPreview.prototype.scale = null;
/** @type {number} */
mxPrintPreview.prototype.border = 0;
/** @type {number} */
mxPrintPreview.prototype.marginTop = 0;
/** @type {number} */
mxPrintPreview.prototype.marginBottom = 0;
/** @type {number} */
mxPrintPreview.prototype.x0 = 0;
/** @type {number} */
mxPrintPreview.prototype.y0 = 0;
/** @type {boolean} */
mxPrintPreview.prototype.autoOrigin = true;
/** @type {boolean} */
mxPrintPreview.prototype.printOverlays = false;
/** @type {boolean} */
mxPrintPreview.prototype.printControls = false;
/** @type {boolean} */
mxPrintPreview.prototype.printBackgroundImage = false;
/** @type {string} */
mxPrintPreview.prototype.backgroundColor = "#ffffff";
/** @type {null} */
mxPrintPreview.prototype.borderColor = null;
/** @type {null} */
mxPrintPreview.prototype.title = null;
/** @type {null} */
mxPrintPreview.prototype.pageSelector = null;
/** @type {null} */
mxPrintPreview.prototype.wnd = null;
/** @type {null} */
mxPrintPreview.prototype.targetWindow = null;
/** @type {number} */
mxPrintPreview.prototype.pageCount = 0;
/** @type {boolean} */
mxPrintPreview.prototype.clipping = true;
/**
 * @return {?}
 */
mxPrintPreview.prototype.getWindow = function() {
  return this.wnd;
};
/**
 * @return {?}
 */
mxPrintPreview.prototype.getDoctype = function() {
  /** @type {string} */
  var doctype = "";
  if (5 == document.documentMode) {
    /** @type {string} */
    doctype = '<meta http-equiv="X-UA-Compatible" content="IE=5">';
  } else {
    if (8 == document.documentMode) {
      /** @type {string} */
      doctype = '<meta http-equiv="X-UA-Compatible" content="IE=8">';
    } else {
      if (8 < document.documentMode) {
        /** @type {string} */
        doctype = '\x3c!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--\x3e';
      }
    }
  }
  return doctype;
};
/**
 * @param {!Object} graph
 * @param {number} container
 * @param {number} count
 * @param {number} value
 * @param {?} buttons
 * @param {?} closeButton
 * @return {undefined}
 */
mxPrintPreview.prototype.appendGraph = function(graph, container, count, value, buttons, closeButton) {
  /** @type {!Object} */
  this.graph = graph;
  this.scale = null != container ? container : 1 / graph.pageScale;
  /** @type {number} */
  this.x0 = count;
  /** @type {number} */
  this.y0 = value;
  this.open(null, null, buttons, closeButton);
};
/**
 * @param {number} y
 * @param {!Object} parent
 * @param {?} buttons
 * @param {?} closeButton
 * @return {?}
 */
mxPrintPreview.prototype.open = function(y, parent, buttons, closeButton) {
  var e = this.graph.cellRenderer.initializeOverlay;
  /** @type {null} */
  var cm = null;
  try {
    if (this.printOverlays) {
      /**
       * @param {!Object} g
       * @param {!Object} b
       * @return {undefined}
       */
      this.graph.cellRenderer.initializeOverlay = function(g, b) {
        b.init(g.view.getDrawPane());
      };
    }
    if (this.printControls) {
      /**
       * @param {!Object} state
       * @param {!Object} control
       * @param {boolean} handleEvents
       * @param {?} clickHandler
       * @return {undefined}
       */
      this.graph.cellRenderer.initControl = function(state, control, handleEvents, clickHandler) {
        control.dialect = state.view.graph.dialect;
        control.init(state.view.getDrawPane());
      };
    }
    this.wnd = null != parent ? parent : this.wnd;
    /** @type {boolean} */
    var is_document = false;
    if (null == this.wnd) {
      /** @type {boolean} */
      is_document = true;
      /** @type {(Window|null)} */
      this.wnd = window.open();
    }
    var doc = this.wnd.document;
    if (is_document) {
      var e = this.getDoctype();
      if (null != e && 0 < e.length) {
        doc.writeln(e);
      }
      if (mxClient.IS_VML) {
        doc.writeln('<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office">');
      } else {
        if ("CSS1Compat" === document.compatMode) {
          doc.writeln("<!DOCTYPE html>");
        }
        doc.writeln("<html>");
      }
      doc.writeln("<head>");
      this.writeHead(doc, y);
      doc.writeln("</head>");
      doc.writeln('<body class="mxPage">');
    }
    var box = this.graph.getGraphBounds().clone();
    var width = this.graph.getView().getScale();
    /** @type {number} */
    var zoom = width / this.scale;
    var point = this.graph.getView().getTranslate();
    if (!this.autoOrigin) {
      this.x0 -= point.x * this.scale;
      this.y0 -= point.y * this.scale;
      box.width += box.x;
      box.height += box.y;
      /** @type {number} */
      box.x = 0;
      /** @type {number} */
      this.border = box.y = 0;
    }
    /** @type {number} */
    var size = this.pageFormat.width - 2 * this.border;
    /** @type {number} */
    var texPerChild = this.pageFormat.height - 2 * this.border;
    this.pageFormat.height += this.marginTop + this.marginBottom;
    box.width /= zoom;
    box.height /= zoom;
    /** @type {number} */
    var height = Math.max(1, Math.ceil((box.width + this.x0) / size));
    /** @type {number} */
    var c = Math.max(1, Math.ceil((box.height + this.y0) / texPerChild));
    /** @type {number} */
    this.pageCount = height * c;
    var updateCalendarWidth = mxUtils.bind(this, function() {
      if (this.pageSelector && (1 < c || 1 < height)) {
        var a = this.createPageSelector(c, height);
        doc.body.appendChild(a);
        if (mxClient.IS_IE && null == doc.documentMode || 5 == doc.documentMode || 8 == doc.documentMode || 7 == doc.documentMode) {
          /** @type {string} */
          a.style.position = "absolute";
          /**
           * @return {undefined}
           */
          var check = function() {
            /** @type {string} */
            a.style.top = (doc.body.scrollTop || doc.documentElement.scrollTop) + 10 + "px";
          };
          mxEvent.addListener(this.wnd, "scroll", function(a) {
            check();
          });
          mxEvent.addListener(this.wnd, "resize", function(a) {
            check();
          });
        }
      }
    });
    var parseInt = mxUtils.bind(this, function(e, OK) {
      if (null != this.borderColor) {
        e.style.borderColor = this.borderColor;
        /** @type {string} */
        e.style.borderStyle = "solid";
        /** @type {string} */
        e.style.borderWidth = "1px";
      }
      e.style.background = this.backgroundColor;
      if (buttons || OK) {
        /** @type {string} */
        e.style.pageBreakAfter = "always";
      }
      if (is_document && (mxClient.IS_IE || 11 <= document.documentMode || mxClient.IS_EDGE)) {
        doc.writeln(e.outerHTML);
        e.parentNode.removeChild(e);
      } else {
        if (mxClient.IS_IE || 11 <= document.documentMode || mxClient.IS_EDGE) {
          var div = doc.createElement("div");
          div.innerHTML = e.outerHTML;
          div = div.getElementsByTagName("div")[0];
          doc.body.appendChild(div);
          e.parentNode.removeChild(e);
        } else {
          e.parentNode.removeChild(e);
          doc.body.appendChild(e);
        }
      }
      if (buttons || OK) {
        this.addPageBreak(doc);
      }
    });
    var enmlHash = this.getCoverPages(this.pageFormat.width, this.pageFormat.height);
    if (null != enmlHash) {
      /** @type {number} */
      var i = 0;
      for (; i < enmlHash.length; i++) {
        parseInt(enmlHash[i], true);
      }
    }
    var number = this.getAppendices(this.pageFormat.width, this.pageFormat.height);
    /** @type {number} */
    i = 0;
    for (; i < c; i++) {
      /** @type {number} */
      var hex = i * texPerChild / this.scale - this.y0 / this.scale + (box.y - point.y * width) / width;
      /** @type {number} */
      y = 0;
      for (; y < height; y++) {
        if (null == this.wnd) {
          return null;
        }
        /** @type {number} */
        var msgB = y * size / this.scale - this.x0 / this.scale + (box.x - point.x * width) / width;
        /** @type {number} */
        var txt = i * height + y + 1;
        var b = new mxRectangle(msgB, hex, size, texPerChild);
        cm = this.renderPage(this.pageFormat.width, this.pageFormat.height, 0, 0, mxUtils.bind(this, function(requestedFont) {
          this.addGraphFragment(-msgB, -hex, this.scale, txt, requestedFont, b);
          if (this.printBackgroundImage) {
            this.insertBackgroundImage(requestedFont, -msgB, -hex);
          }
        }), txt);
        cm.setAttribute("id", "mxPage-" + txt);
        parseInt(cm, null != number || i < c - 1 || y < height - 1);
      }
    }
    if (null != number) {
      /** @type {number} */
      i = 0;
      for (; i < number.length; i++) {
        parseInt(number[i], i < number.length - 1);
      }
    }
    if (is_document && !closeButton) {
      this.closeDocument();
      updateCalendarWidth();
    }
    this.wnd.focus();
  } catch (E) {
    if (null != cm && null != cm.parentNode) {
      cm.parentNode.removeChild(cm);
    }
  } finally {
    this.graph.cellRenderer.initializeOverlay = e;
  }
  return this.wnd;
};
/**
 * @param {!Object} doc
 * @return {undefined}
 */
mxPrintPreview.prototype.addPageBreak = function(doc) {
  var separator = doc.createElement("hr");
  /** @type {string} */
  separator.className = "mxPageBreak";
  doc.body.appendChild(separator);
};
/**
 * @return {undefined}
 */
mxPrintPreview.prototype.closeDocument = function() {
  try {
    if (null != this.wnd && null != this.wnd.document) {
      var iframeDocument = this.wnd.document;
      this.writePostfix(iframeDocument);
      iframeDocument.writeln("</body>");
      iframeDocument.writeln("</html>");
      iframeDocument.close();
      mxEvent.release(iframeDocument.body);
    }
  } catch (b) {
  }
};
/**
 * @param {!Object} target
 * @param {?} s
 * @return {undefined}
 */
mxPrintPreview.prototype.writeHead = function(target, s) {
  if (null != this.title) {
    target.writeln("<title>" + this.title + "</title>");
  }
  if (mxClient.IS_VML) {
    target.writeln('<style type="text/css">v\\:*{behavior:url(#default#VML)}o\\:*{behavior:url(#default#VML)}</style>');
  }
  mxClient.link("stylesheet", mxClient.basePath + "/css/common.css", target);
  target.writeln('<style type="text/css">');
  target.writeln("@media print {");
  target.writeln("  * { -webkit-print-color-adjust: exact; }");
  target.writeln("  table.mxPageSelector { display: none; }");
  target.writeln("  hr.mxPageBreak { display: none; }");
  target.writeln("}");
  target.writeln("@media screen {");
  target.writeln("  table.mxPageSelector { position: fixed; right: 10px; top: 10px;font-family: Arial; font-size:10pt; border: solid 1px darkgray;background: white; border-collapse:collapse; }");
  target.writeln("  table.mxPageSelector td { border: solid 1px gray; padding:4px; }");
  target.writeln("  body.mxPage { background: gray; }");
  target.writeln("}");
  if (null != s) {
    target.writeln(s);
  }
  target.writeln("</style>");
};
/**
 * @param {?} object
 * @return {undefined}
 */
mxPrintPreview.prototype.writePostfix = function(object) {
};
/**
 * @param {number} n
 * @param {number} p
 * @return {?}
 */
mxPrintPreview.prototype.createPageSelector = function(n, p) {
  var document = this.wnd.document;
  var element = document.createElement("table");
  /** @type {string} */
  element.className = "mxPageSelector";
  element.setAttribute("border", "0");
  var body = document.createElement("tbody");
  /** @type {number} */
  var start = 0;
  for (; start < n; start++) {
    var g = document.createElement("tr");
    /** @type {number} */
    var startAngle = 0;
    for (; startAngle < p; startAngle++) {
      /** @type {number} */
      var value = start * p + startAngle + 1;
      var m = document.createElement("td");
      var link = document.createElement("a");
      link.setAttribute("href", "#mxPage-" + value);
      if (!(!mxClient.IS_NS || mxClient.IS_SF || mxClient.IS_GC)) {
        link.setAttribute("onclick", "var page = document.getElementById('mxPage-" + value + "');page.scrollIntoView(true);event.preventDefault();");
      }
      mxUtils.write(link, value, document);
      m.appendChild(link);
      g.appendChild(m);
    }
    body.appendChild(g);
  }
  element.appendChild(body);
  return element;
};
/**
 * @param {number} value
 * @param {number} position
 * @param {number} delta
 * @param {number} path
 * @param {?} template
 * @param {!Object} type
 * @return {?}
 */
mxPrintPreview.prototype.renderPage = function(value, position, delta, path, template, type) {
  type = this.wnd.document;
  /** @type {!Element} */
  var d = document.createElement("div");
  /** @type {null} */
  var content = null;
  try {
    if (0 != delta || 0 != path) {
      /** @type {string} */
      d.style.position = "relative";
      /** @type {string} */
      d.style.width = value + "px";
      /** @type {string} */
      d.style.height = position + "px";
      /** @type {string} */
      d.style.pageBreakInside = "avoid";
      /** @type {!Element} */
      var container = document.createElement("div");
      /** @type {string} */
      container.style.position = "relative";
      /** @type {string} */
      container.style.top = this.border + "px";
      /** @type {string} */
      container.style.left = this.border + "px";
      /** @type {string} */
      container.style.width = value - 2 * this.border + "px";
      /** @type {string} */
      container.style.height = position - 2 * this.border + "px";
      /** @type {string} */
      container.style.overflow = "hidden";
      /** @type {!Element} */
      var label = document.createElement("div");
      /** @type {string} */
      label.style.position = "relative";
      /** @type {string} */
      label.style.marginLeft = delta + "px";
      /** @type {string} */
      label.style.marginTop = path + "px";
      if (8 == type.documentMode) {
        /** @type {string} */
        container.style.position = "absolute";
        /** @type {string} */
        label.style.position = "absolute";
      }
      if (10 == type.documentMode) {
        /** @type {string} */
        label.style.width = "100%";
        /** @type {string} */
        label.style.height = "100%";
      }
      container.appendChild(label);
      d.appendChild(container);
      document.body.appendChild(d);
      /** @type {!Element} */
      content = label;
    } else {
      /** @type {string} */
      d.style.width = value + "px";
      /** @type {string} */
      d.style.height = position + "px";
      /** @type {string} */
      d.style.overflow = "hidden";
      /** @type {string} */
      d.style.pageBreakInside = "avoid";
      if (8 == type.documentMode) {
        /** @type {string} */
        d.style.position = "relative";
      }
      /** @type {!Element} */
      container = document.createElement("div");
      /** @type {string} */
      container.style.width = value - 2 * this.border + "px";
      /** @type {string} */
      container.style.height = position - 2 * this.border + "px";
      /** @type {string} */
      container.style.overflow = "hidden";
      if (!mxClient.IS_IE || null != type.documentMode && 5 != type.documentMode && 8 != type.documentMode && 7 != type.documentMode) {
        /** @type {string} */
        container.style.top = this.border + "px";
        /** @type {string} */
        container.style.left = this.border + "px";
      } else {
        /** @type {string} */
        container.style.marginTop = this.border + "px";
        /** @type {string} */
        container.style.marginLeft = this.border + "px";
      }
      if (this.graph.dialect == mxConstants.DIALECT_VML) {
        /** @type {string} */
        container.style.position = "absolute";
      }
      d.appendChild(container);
      document.body.appendChild(d);
      /** @type {!Element} */
      content = container;
    }
  } catch (path1) {
    throw d.parentNode.removeChild(d), path1;
  }
  template(content);
  return d;
};
/**
 * @return {?}
 */
mxPrintPreview.prototype.getRoot = function() {
  var result = this.graph.view.currentRoot;
  if (null == result) {
    result = this.graph.getModel().getRoot();
  }
  return result;
};
/**
 * @return {?}
 */
mxPrintPreview.prototype.useCssTransforms = function() {
  return !mxClient.NO_FO && !mxClient.IS_SF;
};
/**
 * @param {!Object} s
 * @param {string} h
 * @param {!Object} t
 * @param {!Object} value
 * @param {!Object} node
 * @param {!Object} a
 * @return {undefined}
 */
mxPrintPreview.prototype.addGraphFragment = function(s, h, t, value, node, a) {
  var self = this.graph.getView();
  value = this.graph.container;
  /** @type {!Object} */
  this.graph.container = node;
  var width = self.getCanvas();
  var tickZoom = self.getBackgroundPane();
  var updateSynchronously = self.getDrawPane();
  var hpaDasUrl = self.getOverlayPane();
  /** @type {!Object} */
  var p = t;
  if (this.graph.dialect == mxConstants.DIALECT_SVG) {
    if (self.createSvg(), this.useCssTransforms()) {
      var inner = self.getDrawPane().parentNode;
      inner.getAttribute("transform");
      inner.setAttribute("transformOrigin", "0 0");
      inner.setAttribute("transform", "scale(" + t + "," + t + ")translate(" + s + "," + h + ")");
      /** @type {number} */
      t = 1;
      /** @type {number} */
      h = s = 0;
    }
  } else {
    if (this.graph.dialect == mxConstants.DIALECT_VML) {
      self.createVml();
    } else {
      self.createHtml();
    }
  }
  inner = self.isEventsEnabled();
  self.setEventsEnabled(false);
  var name = this.graph.isEnabled();
  this.graph.setEnabled(false);
  var translate = self.getTranslate();
  self.translate = new mxPoint(s, h);
  var redraw = this.graph.cellRenderer.redraw;
  var graph = self.states;
  s = self.scale;
  if (this.clipping) {
    var tmp = new mxRectangle((a.x + translate.x) * s, (a.y + translate.y) * s, a.width * s / p, a.height * s / p);
    /**
     * @param {?} item
     * @param {boolean} force
     * @param {?} event
     * @return {undefined}
     */
    this.graph.cellRenderer.redraw = function(item, force, event) {
      if (null != item) {
        var value = graph.get(item.cell);
        if (null != value && (value = self.getBoundingBox(value, false), null != value && 0 < value.width && 0 < value.height && !mxUtils.intersects(tmp, value))) {
          return;
        }
      }
      redraw.apply(this, arguments);
    };
  }
  /** @type {null} */
  s = null;
  try {
    /** @type {!Array} */
    var r = [this.getRoot()];
    s = new mxTemporaryCellStates(self, t, r, null, mxUtils.bind(this, function(column_reordering_1_1) {
      return this.getLinkForCellState(column_reordering_1_1);
    }));
  } finally {
    if (mxClient.IS_IE) {
      /** @type {string} */
      self.overlayPane.innerHTML = "";
      /** @type {string} */
      self.canvas.style.overflow = "hidden";
      /** @type {string} */
      self.canvas.style.position = "relative";
      /** @type {string} */
      self.canvas.style.top = this.marginTop + "px";
      /** @type {string} */
      self.canvas.style.width = a.width + "px";
      /** @type {string} */
      self.canvas.style.height = a.height + "px";
    } else {
      t = node.firstChild;
      for (; null != t;) {
        r = t.nextSibling;
        h = t.nodeName.toLowerCase();
        if ("svg" == h) {
          /** @type {string} */
          t.style.overflow = "hidden";
          /** @type {string} */
          t.style.position = "relative";
          /** @type {string} */
          t.style.top = this.marginTop + "px";
          t.setAttribute("width", a.width);
          t.setAttribute("height", a.height);
          /** @type {string} */
          t.style.width = "";
          /** @type {string} */
          t.style.height = "";
        } else {
          if ("default" != t.style.cursor && "div" != h) {
            t.parentNode.removeChild(t);
          }
        }
        t = r;
      }
    }
    if (this.printBackgroundImage) {
      node = node.getElementsByTagName("svg");
      if (0 < node.length) {
        /** @type {string} */
        node[0].style.position = "absolute";
      }
    }
    self.overlayPane.parentNode.removeChild(self.overlayPane);
    this.graph.setEnabled(name);
    /** @type {!Object} */
    this.graph.container = value;
    this.graph.cellRenderer.redraw = redraw;
    self.canvas = width;
    self.backgroundPane = tickZoom;
    self.drawPane = updateSynchronously;
    self.overlayPane = hpaDasUrl;
    self.translate = translate;
    s.destroy();
    self.setEventsEnabled(inner);
  }
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxPrintPreview.prototype.getLinkForCellState = function(state) {
  return this.graph.getLinkForCell(state.cell);
};
/**
 * @param {!Node} elem
 * @param {number} width
 * @param {number} x
 * @return {undefined}
 */
mxPrintPreview.prototype.insertBackgroundImage = function(elem, width, x) {
  var picture = this.graph.backgroundImage;
  if (null != picture) {
    /** @type {!Element} */
    var img = document.createElement("img");
    /** @type {string} */
    img.style.position = "absolute";
    /** @type {string} */
    img.style.marginLeft = Math.round(width * this.scale) + "px";
    /** @type {string} */
    img.style.marginTop = Math.round(x * this.scale) + "px";
    img.setAttribute("width", Math.round(this.scale * picture.width));
    img.setAttribute("height", Math.round(this.scale * picture.height));
    img.src = picture.src;
    elem.insertBefore(img, elem.firstChild);
  }
};
/**
 * @return {?}
 */
mxPrintPreview.prototype.getCoverPages = function() {
  return null;
};
/**
 * @return {?}
 */
mxPrintPreview.prototype.getAppendices = function() {
  return null;
};
/**
 * @param {!Object} x
 * @return {undefined}
 */
mxPrintPreview.prototype.print = function(x) {
  x = this.open(x);
  if (null != x) {
    x.print();
  }
};
/**
 * @return {undefined}
 */
mxPrintPreview.prototype.close = function() {
  if (null != this.wnd) {
    this.wnd.close();
    /** @type {null} */
    this.wnd = null;
  }
};
/**
 * @return {undefined}
 */
function mxStylesheet() {
  this.styles = {};
  this.putDefaultVertexStyle(this.createDefaultVertexStyle());
  this.putDefaultEdgeStyle(this.createDefaultEdgeStyle());
}
/**
 * @return {?}
 */
mxStylesheet.prototype.createDefaultVertexStyle = function() {
  var style = {};
  style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
  style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;
  style[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;
  style[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
  /** @type {string} */
  style[mxConstants.STYLE_FILLCOLOR] = "#C3D9FF";
  /** @type {string} */
  style[mxConstants.STYLE_STROKECOLOR] = "#6482B9";
  /** @type {string} */
  style[mxConstants.STYLE_FONTCOLOR] = "#774400";
  return style;
};
/**
 * @return {?}
 */
mxStylesheet.prototype.createDefaultEdgeStyle = function() {
  var style = {};
  style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_CONNECTOR;
  style[mxConstants.STYLE_ENDARROW] = mxConstants.ARROW_CLASSIC;
  style[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;
  style[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
  /** @type {string} */
  style[mxConstants.STYLE_STROKECOLOR] = "#6482B9";
  /** @type {string} */
  style[mxConstants.STYLE_FONTCOLOR] = "#446299";
  return style;
};
/**
 * @param {!Object} childCompute
 * @return {undefined}
 */
mxStylesheet.prototype.putDefaultVertexStyle = function(childCompute) {
  this.putCellStyle("defaultVertex", childCompute);
};
/**
 * @param {!Object} childCompute
 * @return {undefined}
 */
mxStylesheet.prototype.putDefaultEdgeStyle = function(childCompute) {
  this.putCellStyle("defaultEdge", childCompute);
};
/**
 * @return {?}
 */
mxStylesheet.prototype.getDefaultVertexStyle = function() {
  return this.styles.defaultVertex;
};
/**
 * @return {?}
 */
mxStylesheet.prototype.getDefaultEdgeStyle = function() {
  return this.styles.defaultEdge;
};
/**
 * @param {string} name
 * @param {!Object} value
 * @return {undefined}
 */
mxStylesheet.prototype.putCellStyle = function(name, value) {
  /** @type {!Object} */
  this.styles[name] = value;
};
/**
 * @param {!Object} path
 * @param {!Function} size
 * @return {?}
 */
mxStylesheet.prototype.getCellStyle = function(path, size) {
  /** @type {!Function} */
  var result = size;
  if (null != path && 0 < path.length) {
    var enumValue = path.split(";");
    result = null != result && ";" != path.charAt(0) ? mxUtils.clone(result) : {};
    /** @type {number} */
    var j = 0;
    for (; j < enumValue.length; j++) {
      var v = enumValue[j];
      var offset = v.indexOf("=");
      if (0 <= offset) {
        var i = v.substring(0, offset);
        v = v.substring(offset + 1);
        if (v == mxConstants.NONE) {
          delete result[i];
        } else {
          if (mxUtils.isNumeric(v)) {
            /** @type {number} */
            result[i] = parseFloat(v);
          } else {
            result[i] = v;
          }
        }
      } else {
        if (v = this.styles[v], null != v) {
          for (i in v) {
            result[i] = v[i];
          }
        }
      }
    }
  }
  return result;
};
/**
 * @param {string} view
 * @param {?} cell
 * @param {!Object} style
 * @return {undefined}
 */
function mxCellState(view, cell, style) {
  /** @type {string} */
  this.view = view;
  this.cell = cell;
  this.style = null != style ? style : {};
  this.origin = new mxPoint;
  this.absoluteOffset = new mxPoint;
}
mxCellState.prototype = new mxRectangle;
/** @type {function(string, ?, !Object): undefined} */
mxCellState.prototype.constructor = mxCellState;
/** @type {null} */
mxCellState.prototype.view = null;
/** @type {null} */
mxCellState.prototype.cell = null;
/** @type {null} */
mxCellState.prototype.style = null;
/** @type {boolean} */
mxCellState.prototype.invalidStyle = false;
/** @type {boolean} */
mxCellState.prototype.invalid = true;
/** @type {null} */
mxCellState.prototype.origin = null;
/** @type {null} */
mxCellState.prototype.absolutePoints = null;
/** @type {null} */
mxCellState.prototype.absoluteOffset = null;
/** @type {null} */
mxCellState.prototype.visibleSourceState = null;
/** @type {null} */
mxCellState.prototype.visibleTargetState = null;
/** @type {number} */
mxCellState.prototype.terminalDistance = 0;
/** @type {number} */
mxCellState.prototype.length = 0;
/** @type {null} */
mxCellState.prototype.segments = null;
/** @type {null} */
mxCellState.prototype.shape = null;
/** @type {null} */
mxCellState.prototype.text = null;
/** @type {null} */
mxCellState.prototype.unscaledWidth = null;
/** @type {null} */
mxCellState.prototype.unscaledHeight = null;
/**
 * @param {string} s
 * @param {number} position
 * @return {?}
 */
mxCellState.prototype.getPerimeterBounds = function(s, position) {
  s = s || 0;
  position = null != position ? position : new mxRectangle(this.x, this.y, this.width, this.height);
  if (null != this.shape && null != this.shape.stencil && "fixed" == this.shape.stencil.aspect) {
    var rect = this.shape.stencil.computeAspect(this.style, position.x, position.y, position.width, position.height);
    position.x = rect.x;
    position.y = rect.y;
    /** @type {number} */
    position.width = this.shape.stencil.w0 * rect.width;
    /** @type {number} */
    position.height = this.shape.stencil.h0 * rect.height;
  }
  if (0 != s) {
    position.grow(s);
  }
  return position;
};
/**
 * @param {!Object} a
 * @param {boolean} b
 * @return {undefined}
 */
mxCellState.prototype.setAbsoluteTerminalPoint = function(a, b) {
  if (b) {
    if (null == this.absolutePoints) {
      /** @type {!Array} */
      this.absolutePoints = [];
    }
    if (0 == this.absolutePoints.length) {
      this.absolutePoints.push(a);
    } else {
      /** @type {!Object} */
      this.absolutePoints[0] = a;
    }
  } else {
    if (null == this.absolutePoints) {
      /** @type {!Array} */
      this.absolutePoints = [];
      this.absolutePoints.push(null);
      this.absolutePoints.push(a);
    } else {
      if (1 == this.absolutePoints.length) {
        this.absolutePoints.push(a);
      } else {
        /** @type {!Object} */
        this.absolutePoints[this.absolutePoints.length - 1] = a;
      }
    }
  }
};
/**
 * @param {string} line
 * @return {undefined}
 */
mxCellState.prototype.setCursor = function(line) {
  if (null != this.shape) {
    this.shape.setCursor(line);
  }
  if (null != this.text) {
    this.text.setCursor(line);
  }
};
/**
 * @param {?} o
 * @return {?}
 */
mxCellState.prototype.getVisibleTerminal = function(o) {
  o = this.getVisibleTerminalState(o);
  return null != o ? o.cell : null;
};
/**
 * @param {boolean} array1
 * @return {?}
 */
mxCellState.prototype.getVisibleTerminalState = function(array1) {
  return array1 ? this.visibleSourceState : this.visibleTargetState;
};
/**
 * @param {!Object} value
 * @param {boolean} expectedTriggered
 * @return {undefined}
 */
mxCellState.prototype.setVisibleTerminalState = function(value, expectedTriggered) {
  if (expectedTriggered) {
    /** @type {!Object} */
    this.visibleSourceState = value;
  } else {
    /** @type {!Object} */
    this.visibleTargetState = value;
  }
};
/**
 * @return {?}
 */
mxCellState.prototype.getCellBounds = function() {
  return this.cellBounds;
};
/**
 * @return {?}
 */
mxCellState.prototype.getPaintBounds = function() {
  return this.paintBounds;
};
/**
 * @return {undefined}
 */
mxCellState.prototype.updateCachedBounds = function() {
  var t = this.view.translate;
  var scale = this.view.scale;
  this.cellBounds = new mxRectangle(this.x / scale - t.x, this.y / scale - t.y, this.width / scale, this.height / scale);
  this.paintBounds = mxRectangle.fromRectangle(this.cellBounds);
  if (null != this.shape && this.shape.isPaintBoundsInverted()) {
    this.paintBounds.rotate90();
  }
};
/**
 * @param {!Object} options
 * @return {undefined}
 */
mxCellState.prototype.setState = function(options) {
  this.view = options.view;
  this.cell = options.cell;
  this.style = options.style;
  this.absolutePoints = options.absolutePoints;
  this.origin = options.origin;
  this.absoluteOffset = options.absoluteOffset;
  this.boundingBox = options.boundingBox;
  this.terminalDistance = options.terminalDistance;
  this.segments = options.segments;
  this.length = options.length;
  this.x = options.x;
  this.y = options.y;
  this.width = options.width;
  this.height = options.height;
  this.unscaledWidth = options.unscaledWidth;
  this.unscaledHeight = options.unscaledHeight;
};
/**
 * @return {?}
 */
mxCellState.prototype.clone = function() {
  var c = new mxCellState(this.view, this.cell, this.style);
  if (null != this.absolutePoints) {
    /** @type {!Array} */
    c.absolutePoints = [];
    /** @type {number} */
    var i = 0;
    for (; i < this.absolutePoints.length; i++) {
      c.absolutePoints[i] = this.absolutePoints[i].clone();
    }
  }
  if (null != this.origin) {
    c.origin = this.origin.clone();
  }
  if (null != this.absoluteOffset) {
    c.absoluteOffset = this.absoluteOffset.clone();
  }
  if (null != this.boundingBox) {
    c.boundingBox = this.boundingBox.clone();
  }
  c.terminalDistance = this.terminalDistance;
  c.segments = this.segments;
  c.length = this.length;
  c.x = this.x;
  c.y = this.y;
  c.width = this.width;
  c.height = this.height;
  c.unscaledWidth = this.unscaledWidth;
  c.unscaledHeight = this.unscaledHeight;
  return c;
};
/**
 * @return {undefined}
 */
mxCellState.prototype.destroy = function() {
  this.view.graph.cellRenderer.destroy(this);
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxGraphSelectionModel(targetGraph) {
  /** @type {!Object} */
  this.graph = targetGraph;
  /** @type {!Array} */
  this.cells = [];
}
mxGraphSelectionModel.prototype = new mxEventSource;
/** @type {function(!Object): undefined} */
mxGraphSelectionModel.prototype.constructor = mxGraphSelectionModel;
/** @type {string} */
mxGraphSelectionModel.prototype.doneResource = "none" != mxClient.language ? "done" : "";
/** @type {string} */
mxGraphSelectionModel.prototype.updatingSelectionResource = "none" != mxClient.language ? "updatingSelection" : "";
/** @type {null} */
mxGraphSelectionModel.prototype.graph = null;
/** @type {boolean} */
mxGraphSelectionModel.prototype.singleSelection = false;
/**
 * @return {?}
 */
mxGraphSelectionModel.prototype.isSingleSelection = function() {
  return this.singleSelection;
};
/**
 * @param {boolean} val
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.setSingleSelection = function(val) {
  /** @type {boolean} */
  this.singleSelection = val;
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxGraphSelectionModel.prototype.isSelected = function(value) {
  return null != value ? 0 <= mxUtils.indexOf(this.cells, value) : false;
};
/**
 * @return {?}
 */
mxGraphSelectionModel.prototype.isEmpty = function() {
  return 0 == this.cells.length;
};
/**
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.clear = function() {
  this.changeSelection(null, this.cells);
};
/**
 * @param {string} opt_value
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.setCell = function(opt_value) {
  if (null != opt_value) {
    this.setCells([opt_value]);
  }
};
/**
 * @param {!Object} cells
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.setCells = function(cells) {
  if (null != cells) {
    if (this.singleSelection) {
      /** @type {!Array} */
      cells = [this.getFirstSelectableCell(cells)];
    }
    /** @type {!Array} */
    var cellsUpdated = [];
    /** @type {number} */
    var i = 0;
    for (; i < cells.length; i++) {
      if (this.graph.isCellSelectable(cells[i])) {
        cellsUpdated.push(cells[i]);
      }
    }
    this.changeSelection(cellsUpdated, this.cells);
  }
};
/**
 * @param {!Object} cells
 * @return {?}
 */
mxGraphSelectionModel.prototype.getFirstSelectableCell = function(cells) {
  if (null != cells) {
    /** @type {number} */
    var i = 0;
    for (; i < cells.length; i++) {
      if (this.graph.isCellSelectable(cells[i])) {
        return cells[i];
      }
    }
  }
  return null;
};
/**
 * @param {string} x
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.addCell = function(x) {
  if (null != x) {
    this.addCells([x]);
  }
};
/**
 * @param {!Object} cells
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.addCells = function(cells) {
  if (null != cells) {
    /** @type {null} */
    var e = null;
    if (this.singleSelection) {
      e = this.cells;
      /** @type {!Array} */
      cells = [this.getFirstSelectableCell(cells)];
    }
    /** @type {!Array} */
    var cellsUpdated = [];
    /** @type {number} */
    var i = 0;
    for (; i < cells.length; i++) {
      if (!this.isSelected(cells[i]) && this.graph.isCellSelectable(cells[i])) {
        cellsUpdated.push(cells[i]);
      }
    }
    this.changeSelection(cellsUpdated, e);
  }
};
/**
 * @param {?} index
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.removeCell = function(index) {
  if (null != index) {
    this.removeCells([index]);
  }
};
/**
 * @param {!Object} id
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.removeCells = function(id) {
  if (null != id) {
    /** @type {!Array} */
    var e = [];
    /** @type {number} */
    var i = 0;
    for (; i < id.length; i++) {
      if (this.isSelected(id[i])) {
        e.push(id[i]);
      }
    }
    this.changeSelection(null, e);
  }
};
/**
 * @param {!Object} a
 * @param {!Object} b
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.changeSelection = function(a, b) {
  if (null != a && 0 < a.length && null != a[0] || null != b && 0 < b.length && null != b[0]) {
    var list = new mxSelectionChange(this, a, b);
    list.execute();
    var tbc = new mxUndoableEdit(this, false);
    tbc.add(list);
    this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", tbc));
  }
};
/**
 * @param {!Object} cell
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.cellAdded = function(cell) {
  if (!(null == cell || this.isSelected(cell))) {
    this.cells.push(cell);
  }
};
/**
 * @param {number} i
 * @return {undefined}
 */
mxGraphSelectionModel.prototype.cellRemoved = function(i) {
  if (null != i) {
    i = mxUtils.indexOf(this.cells, i);
    if (0 <= i) {
      this.cells.splice(i, 1);
    }
  }
};
/**
 * @param {boolean} is_key
 * @param {string} indent
 * @param {string} type
 * @return {undefined}
 */
function mxSelectionChange(is_key, indent, type) {
  /** @type {boolean} */
  this.selectionModel = is_key;
  this.added = null != indent ? indent.slice() : null;
  this.removed = null != type ? type.slice() : null;
}
/**
 * @return {undefined}
 */
mxSelectionChange.prototype.execute = function() {
  var left = mxLog.enter("mxSelectionChange.execute");
  window.status = mxResources.get(this.selectionModel.updatingSelectionResource) || this.selectionModel.updatingSelectionResource;
  if (null != this.removed) {
    /** @type {number} */
    var i = 0;
    for (; i < this.removed.length; i++) {
      this.selectionModel.cellRemoved(this.removed[i]);
    }
  }
  if (null != this.added) {
    /** @type {number} */
    i = 0;
    for (; i < this.added.length; i++) {
      this.selectionModel.cellAdded(this.added[i]);
    }
  }
  i = this.added;
  this.added = this.removed;
  this.removed = i;
  window.status = mxResources.get(this.selectionModel.doneResource) || this.selectionModel.doneResource;
  mxLog.leave("mxSelectionChange.execute", left);
  this.selectionModel.fireEvent(new mxEventObject(mxEvent.CHANGE, "added", this.added, "removed", this.removed));
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxCellEditor(targetGraph) {
  /** @type {!Object} */
  this.graph = targetGraph;
  this.zoomHandler = mxUtils.bind(this, function() {
    if (this.graph.isEditing()) {
      this.resize();
    }
  });
  this.graph.view.addListener(mxEvent.SCALE, this.zoomHandler);
  this.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.zoomHandler);
  this.changeHandler = mxUtils.bind(this, function(a) {
    if (null != this.editingCell && null == this.graph.getView().getState(this.editingCell)) {
      this.stopEditing(true);
    }
  });
  this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
}
/** @type {null} */
mxCellEditor.prototype.graph = null;
/** @type {null} */
mxCellEditor.prototype.textarea = null;
/** @type {null} */
mxCellEditor.prototype.editingCell = null;
/** @type {null} */
mxCellEditor.prototype.trigger = null;
/** @type {boolean} */
mxCellEditor.prototype.modified = false;
/** @type {boolean} */
mxCellEditor.prototype.autoSize = true;
/** @type {boolean} */
mxCellEditor.prototype.selectText = true;
/** @type {string} */
mxCellEditor.prototype.emptyLabelText = mxClient.IS_FF ? "<br>" : "";
/** @type {boolean} */
mxCellEditor.prototype.escapeCancelsEditing = true;
/** @type {string} */
mxCellEditor.prototype.textNode = "";
/** @type {number} */
mxCellEditor.prototype.zIndex = 5;
mxCellEditor.prototype.minResize = new mxRectangle(0, 20);
/** @type {number} */
mxCellEditor.prototype.wordWrapPadding = mxClient.IS_QUIRKS ? 2 : mxClient.IS_IE11 ? 0 : 1;
/** @type {boolean} */
mxCellEditor.prototype.blurEnabled = false;
/** @type {null} */
mxCellEditor.prototype.initialValue = null;
/** @type {null} */
mxCellEditor.prototype.align = null;
/**
 * @return {undefined}
 */
mxCellEditor.prototype.init = function() {
  /** @type {!Element} */
  this.textarea = document.createElement("div");
  /** @type {string} */
  this.textarea.className = "mxCellEditor mxPlainTextEditor";
  /** @type {boolean} */
  this.textarea.contentEditable = true;
  if (mxClient.IS_GC) {
    /** @type {string} */
    this.textarea.style.minHeight = "1em";
  }
  /** @type {string} */
  this.textarea.style.position = this.isLegacyEditor() ? "absolute" : "relative";
  this.installListeners(this.textarea);
};
/**
 * @param {!Object} state
 * @param {string} value
 * @return {undefined}
 */
mxCellEditor.prototype.applyValue = function(state, value) {
  this.graph.labelChanged(state.cell, value, this.trigger);
};
/**
 * @param {string} align
 * @return {undefined}
 */
mxCellEditor.prototype.setAlign = function(align) {
  if (null != this.textarea) {
    /** @type {string} */
    this.textarea.style.textAlign = align;
  }
  /** @type {string} */
  this.align = align;
  this.resize();
};
/**
 * @param {?} state
 * @param {!Object} value
 * @return {?}
 */
mxCellEditor.prototype.getInitialValue = function(state, value) {
  var styleString = mxUtils.htmlEntities(this.graph.getEditingValue(state.cell, value), false);
  if (!(mxClient.IS_QUIRKS || 8 == document.documentMode || 9 == document.documentMode || 10 == document.documentMode)) {
    styleString = mxUtils.replaceTrailingNewlines(styleString, "<div><br></div>");
  }
  return styleString.replace(/\n/g, "<br>");
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxCellEditor.prototype.getCurrentValue = function(value) {
  return mxUtils.extractTextWithWhitespace(this.textarea.childNodes);
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxCellEditor.prototype.isCancelEditingKeyEvent = function(evt) {
  return this.escapeCancelsEditing || mxEvent.isShiftDown(evt) || mxEvent.isControlDown(evt) || mxEvent.isMetaDown(evt);
};
/**
 * @param {!Object} link
 * @return {undefined}
 */
mxCellEditor.prototype.installListeners = function(link) {
  mxEvent.addListener(link, "dragstart", mxUtils.bind(this, function(e) {
    this.graph.stopEditing(false);
    mxEvent.consume(e);
  }));
  mxEvent.addListener(link, "blur", mxUtils.bind(this, function(a) {
    if (this.blurEnabled) {
      this.focusLost(a);
    }
  }));
  mxEvent.addListener(link, "keydown", mxUtils.bind(this, function(evt) {
    if (!mxEvent.isConsumed(evt)) {
      if (this.isStopEditingEvent(evt)) {
        this.graph.stopEditing(false);
        mxEvent.consume(evt);
      } else {
        if (27 == evt.keyCode) {
          this.graph.stopEditing(this.isCancelEditingKeyEvent(evt));
          mxEvent.consume(evt);
        }
      }
    }
  }));
  var type = mxUtils.bind(this, function(event) {
    if (null != this.editingCell && this.clearOnChange && link.innerHTML == this.getEmptyLabelText() && (!mxClient.IS_FF || 8 != event.keyCode && 46 != event.keyCode)) {
      /** @type {boolean} */
      this.clearOnChange = false;
      /** @type {string} */
      link.innerHTML = "";
    }
  });
  mxEvent.addListener(link, "keypress", type);
  mxEvent.addListener(link, "paste", type);
  type = mxUtils.bind(this, function(a) {
    if (null != this.editingCell) {
      if (0 == this.textarea.innerHTML.length || "<br>" == this.textarea.innerHTML) {
        this.textarea.innerHTML = this.getEmptyLabelText();
        /** @type {boolean} */
        this.clearOnChange = 0 < this.textarea.innerHTML.length;
      } else {
        /** @type {boolean} */
        this.clearOnChange = false;
      }
    }
  });
  mxEvent.addListener(link, mxClient.IS_IE11 || mxClient.IS_IE ? "keyup" : "input", type);
  mxEvent.addListener(link, "cut", type);
  mxEvent.addListener(link, "paste", type);
  /** @type {string} */
  type = mxClient.IS_IE11 || mxClient.IS_IE ? "keydown" : "input";
  var textEditing = mxUtils.bind(this, function(evt) {
    if (null != this.editingCell && this.autoSize && !mxEvent.isConsumed(evt)) {
      if (null != this.resizeThread) {
        window.clearTimeout(this.resizeThread);
      }
      this.resizeThread = window.setTimeout(mxUtils.bind(this, function() {
        /** @type {null} */
        this.resizeThread = null;
        this.resize();
      }), 0);
    }
  });
  mxEvent.addListener(link, type, textEditing);
  mxEvent.addListener(window, "resize", textEditing);
  if (9 <= document.documentMode) {
    mxEvent.addListener(link, "DOMNodeRemoved", textEditing);
    mxEvent.addListener(link, "DOMNodeInserted", textEditing);
  } else {
    mxEvent.addListener(link, "cut", textEditing);
    mxEvent.addListener(link, "paste", textEditing);
  }
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxCellEditor.prototype.isStopEditingEvent = function(evt) {
  return 113 == evt.keyCode || this.graph.isEnterStopsCellEditing() && 13 == evt.keyCode && !mxEvent.isControlDown(evt) && !mxEvent.isShiftDown(evt);
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxCellEditor.prototype.isEventSource = function(e) {
  return mxEvent.getSource(e) == this.textarea;
};
/**
 * @return {undefined}
 */
mxCellEditor.prototype.resize = function() {
  var p = this.graph.getView().getState(this.editingCell);
  if (null == p) {
    this.stopEditing(true);
  } else {
    if (null != this.textarea) {
      var pos = this.graph.getModel().isEdge(p.cell);
      var scale = this.graph.getView().scale;
      /** @type {null} */
      var b = null;
      if (this.autoSize && "fill" != p.style[mxConstants.STYLE_OVERFLOW]) {
        var width = mxUtils.getValue(p.style, mxConstants.STYLE_LABEL_WIDTH, null);
        b = null != p.text && null == this.align ? p.text.margin : null;
        if (null == b) {
          b = mxUtils.getAlignmentAsPoint(this.align || mxUtils.getValue(p.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER), mxUtils.getValue(p.style, mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE));
        }
        if (pos) {
          this.bounds = new mxRectangle(p.absoluteOffset.x, p.absoluteOffset.y, 0, 0);
          if (null != width) {
            /** @type {number} */
            width = (parseFloat(width) + 2) * scale;
            /** @type {number} */
            this.bounds.width = width;
            this.bounds.x += b.x * width;
          }
        } else {
          pos = mxRectangle.fromRectangle(p);
          var align = mxUtils.getValue(p.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
          var valign = mxUtils.getValue(p.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
          pos = null != p.shape && align == mxConstants.ALIGN_CENTER && valign == mxConstants.ALIGN_MIDDLE ? p.shape.getLabelBounds(pos) : pos;
          if (null != width) {
            /** @type {number} */
            pos.width = parseFloat(width) * scale;
          }
          if (!p.view.graph.cellRenderer.legacySpacing || "width" != p.style[mxConstants.STYLE_OVERFLOW]) {
            /** @type {number} */
            align = parseInt(p.style[mxConstants.STYLE_SPACING] || 2) * scale;
            /** @type {number} */
            var lineWidth = (parseInt(p.style[mxConstants.STYLE_SPACING_TOP] || 0) + mxText.prototype.baseSpacingTop) * scale + align;
            /** @type {number} */
            var ids_str = (parseInt(p.style[mxConstants.STYLE_SPACING_RIGHT] || 0) + mxText.prototype.baseSpacingRight) * scale + align;
            /** @type {number} */
            var childWidth = (parseInt(p.style[mxConstants.STYLE_SPACING_BOTTOM] || 0) + mxText.prototype.baseSpacingBottom) * scale + align;
            /** @type {number} */
            var dx0 = (parseInt(p.style[mxConstants.STYLE_SPACING_LEFT] || 0) + mxText.prototype.baseSpacingLeft) * scale + align;
            align = mxUtils.getValue(p.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
            valign = mxUtils.getValue(p.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
            pos = new mxRectangle(pos.x + dx0, pos.y + lineWidth, pos.width - (align == mxConstants.ALIGN_CENTER && null == width ? dx0 + ids_str : 0), pos.height - (valign == mxConstants.ALIGN_MIDDLE ? lineWidth + childWidth : 0));
          }
          this.bounds = new mxRectangle(pos.x + p.absoluteOffset.x, pos.y + p.absoluteOffset.y, pos.width, pos.height);
        }
        if (this.graph.isWrapping(p.cell) && (2 <= this.bounds.width || 2 <= this.bounds.height) && this.textarea.innerHTML != this.getEmptyLabelText()) {
          this.textarea.style.wordWrap = mxConstants.WORD_WRAP;
          /** @type {string} */
          this.textarea.style.whiteSpace = "normal";
          width = Math.round(this.bounds.width / scale) + this.wordWrapPadding;
          if ("relative" != this.textarea.style.position) {
            /** @type {string} */
            this.textarea.style.width = width + "px";
            if (this.textarea.scrollWidth > width) {
              /** @type {string} */
              this.textarea.style.width = this.textarea.scrollWidth + "px";
            }
          } else {
            /** @type {string} */
            this.textarea.style.maxWidth = width + "px";
          }
        } else {
          /** @type {string} */
          this.textarea.style.whiteSpace = "nowrap";
          /** @type {string} */
          this.textarea.style.width = "";
        }
        if (8 == document.documentMode) {
          /** @type {string} */
          this.textarea.style.zoom = "1";
          /** @type {string} */
          this.textarea.style.height = "auto";
        }
        p = this.textarea.scrollWidth;
        width = this.textarea.scrollHeight;
        if (8 == document.documentMode) {
          /** @type {string} */
          this.textarea.style.left = Math.max(0, Math.ceil((this.bounds.x - b.x * (this.bounds.width - (p + 1) * scale) + p * (scale - 1) * 0 + 2 * (b.x + .5)) / scale)) + "px";
          /** @type {string} */
          this.textarea.style.top = Math.max(0, Math.ceil((this.bounds.y - b.y * (this.bounds.height - (width + .5) * scale) + width * (scale - 1) * 0 + 1 * Math.abs(b.y + .5)) / scale)) + "px";
          /** @type {string} */
          this.textarea.style.width = Math.round(p * scale) + "px";
          /** @type {string} */
          this.textarea.style.height = Math.round(width * scale) + "px";
        } else {
          if (mxClient.IS_QUIRKS) {
            /** @type {string} */
            this.textarea.style.left = Math.max(0, Math.ceil(this.bounds.x - b.x * (this.bounds.width - (p + 1) * scale) + p * (scale - 1) * 0 + 2 * (b.x + .5))) + "px";
            /** @type {string} */
            this.textarea.style.top = Math.max(0, Math.ceil(this.bounds.y - b.y * (this.bounds.height - (width + .5) * scale) + width * (scale - 1) * 0 + 1 * Math.abs(b.y + .5))) + "px";
          } else {
            /** @type {string} */
            this.textarea.style.left = Math.max(0, Math.round(this.bounds.x - b.x * (this.bounds.width - 2)) + 1) + "px";
            /** @type {string} */
            this.textarea.style.top = Math.max(0, Math.round(this.bounds.y - b.y * (this.bounds.height - 4) + (-1 == b.y ? 3 : 0)) + 1) + "px";
          }
        }
      } else {
        this.bounds = this.getEditorBounds(p);
        /** @type {string} */
        this.textarea.style.width = Math.round(this.bounds.width / scale) + "px";
        /** @type {string} */
        this.textarea.style.height = Math.round(this.bounds.height / scale) + "px";
        if (8 == document.documentMode || mxClient.IS_QUIRKS) {
          /** @type {string} */
          this.textarea.style.left = Math.round(this.bounds.x) + "px";
          /** @type {string} */
          this.textarea.style.top = Math.round(this.bounds.y) + "px";
        } else {
          /** @type {string} */
          this.textarea.style.left = Math.max(0, Math.round(this.bounds.x + 1)) + "px";
          /** @type {string} */
          this.textarea.style.top = Math.max(0, Math.round(this.bounds.y + 1)) + "px";
        }
        if (this.graph.isWrapping(p.cell) && (2 <= this.bounds.width || 2 <= this.bounds.height) && this.textarea.innerHTML != this.getEmptyLabelText()) {
          this.textarea.style.wordWrap = mxConstants.WORD_WRAP;
          /** @type {string} */
          this.textarea.style.whiteSpace = "normal";
          if ("fill" != p.style[mxConstants.STYLE_OVERFLOW]) {
            /** @type {string} */
            this.textarea.style.width = Math.round(this.bounds.width / scale) + this.wordWrapPadding + "px";
          }
        } else {
          /** @type {string} */
          this.textarea.style.whiteSpace = "nowrap";
          if ("fill" != p.style[mxConstants.STYLE_OVERFLOW]) {
            /** @type {string} */
            this.textarea.style.width = "";
          }
        }
      }
      if (mxClient.IS_VML) {
        this.textarea.style.zoom = scale;
      } else {
        mxUtils.setPrefixedStyle(this.textarea.style, "transformOrigin", "0px 0px");
        mxUtils.setPrefixedStyle(this.textarea.style, "transform", "scale(" + scale + "," + scale + ")" + (null == b ? "" : " translate(" + 100 * b.x + "%," + 100 * b.y + "%)"));
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxCellEditor.prototype.focusLost = function() {
  this.stopEditing(!this.graph.isInvokesStopCellEditing());
};
/**
 * @param {?} data
 * @return {?}
 */
mxCellEditor.prototype.getBackgroundColor = function(data) {
  return null;
};
/**
 * @return {?}
 */
mxCellEditor.prototype.isLegacyEditor = function() {
  if (mxClient.IS_VML) {
    return true;
  }
  /** @type {boolean} */
  var a = false;
  if (mxClient.IS_SVG) {
    var e = this.graph.view.getDrawPane().ownerSVGElement;
    if (null != e) {
      e = mxUtils.getCurrentStyle(e);
      if (null != e) {
        /** @type {boolean} */
        a = "absolute" == e.position;
      }
    }
  }
  return !a;
};
/**
 * @param {!Object} cell
 * @param {!Object} data
 * @return {undefined}
 */
mxCellEditor.prototype.startEditing = function(cell, data) {
  this.stopEditing(true);
  /** @type {null} */
  this.align = null;
  if (null == this.textarea) {
    this.init();
  }
  if (null != this.graph.tooltipHandler) {
    this.graph.tooltipHandler.hideTooltip();
  }
  var state = this.graph.getView().getState(cell);
  if (null != state) {
    this.graph.getView();
    var s = mxUtils.getValue(state.style, mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE);
    var val = mxUtils.getValue(state.style, mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY);
    var mainTextColor = mxUtils.getValue(state.style, mxConstants.STYLE_FONTCOLOR, "black");
    var value = mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_LEFT);
    /** @type {boolean} */
    var bold = (mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD;
    /** @type {boolean} */
    var textItalic = (mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC;
    /** @type {!Array} */
    var textDecorations = [];
    if ((mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
      textDecorations.push("underline");
    }
    if ((mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
      textDecorations.push("line-through");
    }
    this.textarea.style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? Math.round(s * mxConstants.LINE_HEIGHT) + "px" : mxConstants.LINE_HEIGHT;
    this.textarea.style.backgroundColor = this.getBackgroundColor(state);
    /** @type {string} */
    this.textarea.style.textDecoration = textDecorations.join(" ");
    /** @type {string} */
    this.textarea.style.fontWeight = bold ? "bold" : "normal";
    /** @type {string} */
    this.textarea.style.fontStyle = textItalic ? "italic" : "";
    /** @type {string} */
    this.textarea.style.fontSize = Math.round(s) + "px";
    this.textarea.style.zIndex = this.zIndex;
    this.textarea.style.fontFamily = val;
    this.textarea.style.textAlign = value;
    /** @type {string} */
    this.textarea.style.outline = "none";
    this.textarea.style.color = mainTextColor;
    s = this.textDirection = mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);
    if (s == mxConstants.TEXT_DIRECTION_AUTO) {
      if (!(null == state || null == state.text || state.text.dialect == mxConstants.DIALECT_STRICTHTML || mxUtils.isNode(state.text.value))) {
        s = state.text.getAutoDirection();
      }
    }
    if (s == mxConstants.TEXT_DIRECTION_LTR || s == mxConstants.TEXT_DIRECTION_RTL) {
      this.textarea.setAttribute("dir", s);
    } else {
      this.textarea.removeAttribute("dir");
    }
    this.textarea.innerHTML = this.getInitialValue(state, data) || "";
    this.initialValue = this.textarea.innerHTML;
    if (0 == this.textarea.innerHTML.length || "<br>" == this.textarea.innerHTML) {
      this.textarea.innerHTML = this.getEmptyLabelText();
      /** @type {boolean} */
      this.clearOnChange = true;
    } else {
      /** @type {boolean} */
      this.clearOnChange = this.textarea.innerHTML == this.getEmptyLabelText();
    }
    this.graph.container.appendChild(this.textarea);
    /** @type {!Object} */
    this.editingCell = cell;
    /** @type {!Object} */
    this.trigger = data;
    /** @type {null} */
    this.textNode = null;
    if (null != state.text && this.isHideLabel(state)) {
      this.textNode = state.text.node;
      /** @type {string} */
      this.textNode.style.visibility = "hidden";
    }
    if (this.autoSize && (this.graph.model.isEdge(state.cell) || "fill" != state.style[mxConstants.STYLE_OVERFLOW])) {
      window.setTimeout(mxUtils.bind(this, function() {
        this.resize();
      }), 0);
    }
    this.resize();
    try {
      this.textarea.focus();
      if (this.isSelectText() && 0 < this.textarea.innerHTML.length && (this.textarea.innerHTML != this.getEmptyLabelText() || !this.clearOnChange)) {
        document.execCommand("selectAll", false, null);
      }
    } catch (n) {
    }
  }
};
/**
 * @return {?}
 */
mxCellEditor.prototype.isSelectText = function() {
  return this.selectText;
};
/**
 * @return {undefined}
 */
mxCellEditor.prototype.clearSelection = function() {
  /** @type {null} */
  var selection = null;
  if (window.getSelection) {
    /** @type {(Selection|null)} */
    selection = window.getSelection();
  } else {
    if (document.selection) {
      /** @type {!Selection} */
      selection = document.selection;
    }
  }
  if (null != selection) {
    if (selection.empty) {
      selection.empty();
    } else {
      if (selection.removeAllRanges) {
        selection.removeAllRanges();
      }
    }
  }
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxCellEditor.prototype.stopEditing = function(value) {
  if (null != this.editingCell) {
    if (null != this.textNode) {
      /** @type {string} */
      this.textNode.style.visibility = "visible";
      /** @type {null} */
      this.textNode = null;
    }
    value = value ? null : this.graph.view.getState(this.editingCell);
    var content = this.initialValue;
    /** @type {null} */
    this.bounds = this.trigger = this.editingCell = this.initialValue = null;
    this.textarea.blur();
    this.clearSelection();
    if (null != this.textarea.parentNode) {
      this.textarea.parentNode.removeChild(this.textarea);
    }
    if (this.clearOnChange && this.textarea.innerHTML == this.getEmptyLabelText()) {
      /** @type {string} */
      this.textarea.innerHTML = "";
      /** @type {boolean} */
      this.clearOnChange = false;
    }
    if (null != value && (this.textarea.innerHTML != content || null != this.align)) {
      this.prepareTextarea();
      content = this.getCurrentValue(value);
      this.graph.getModel().beginUpdate();
      try {
        if (null != content) {
          this.applyValue(value, content);
        }
        if (null != this.align) {
          this.graph.setCellStyles(mxConstants.STYLE_ALIGN, this.align, [value.cell]);
        }
      } finally {
        this.graph.getModel().endUpdate();
      }
    }
    mxEvent.release(this.textarea);
    /** @type {null} */
    this.align = this.textarea = null;
  }
};
/**
 * @return {undefined}
 */
mxCellEditor.prototype.prepareTextarea = function() {
  if (null != this.textarea.lastChild && "BR" == this.textarea.lastChild.nodeName) {
    this.textarea.removeChild(this.textarea.lastChild);
  }
};
/**
 * @param {?} basecolumn
 * @return {?}
 */
mxCellEditor.prototype.isHideLabel = function(basecolumn) {
  return true;
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxCellEditor.prototype.getMinimumSize = function(e) {
  var scale = this.graph.getView().scale;
  return new mxRectangle(0, 0, null == e.text ? 30 : e.text.size * scale + 20, "left" == this.textarea.style.textAlign ? 120 : 40);
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxCellEditor.prototype.getEditorBounds = function(e) {
  var valign = this.graph.getModel().isEdge(e.cell);
  var pos = this.graph.getView().scale;
  var w = this.getMinimumSize(e);
  var maxWidth = w.width;
  w = w.height;
  if (!valign && e.view.graph.cellRenderer.legacySpacing && "fill" == e.style[mxConstants.STYLE_OVERFLOW]) {
    pos = e.shape.getLabelBounds(mxRectangle.fromRectangle(e));
  } else {
    /** @type {number} */
    var px = parseInt(e.style[mxConstants.STYLE_SPACING] || 0) * pos;
    /** @type {number} */
    var y = (parseInt(e.style[mxConstants.STYLE_SPACING_TOP] || 0) + mxText.prototype.baseSpacingTop) * pos + px;
    /** @type {number} */
    var ox = (parseInt(e.style[mxConstants.STYLE_SPACING_RIGHT] || 0) + mxText.prototype.baseSpacingRight) * pos + px;
    /** @type {number} */
    var width = (parseInt(e.style[mxConstants.STYLE_SPACING_BOTTOM] || 0) + mxText.prototype.baseSpacingBottom) * pos + px;
    /** @type {number} */
    px = (parseInt(e.style[mxConstants.STYLE_SPACING_LEFT] || 0) + mxText.prototype.baseSpacingLeft) * pos + px;
    pos = new mxRectangle(e.x, e.y, Math.max(maxWidth, e.width - px - ox), Math.max(w, e.height - y - width));
    ox = mxUtils.getValue(e.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
    width = mxUtils.getValue(e.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
    pos = null != e.shape && ox == mxConstants.ALIGN_CENTER && width == mxConstants.ALIGN_MIDDLE ? e.shape.getLabelBounds(pos) : pos;
    if (valign) {
      pos.x = e.absoluteOffset.x;
      pos.y = e.absoluteOffset.y;
      if (null != e.text && null != e.text.boundingBox) {
        if (0 < e.text.boundingBox.x) {
          pos.x = e.text.boundingBox.x;
        }
        if (0 < e.text.boundingBox.y) {
          pos.y = e.text.boundingBox.y;
        }
      }
    } else {
      if (null != e.text && null != e.text.boundingBox) {
        /** @type {number} */
        pos.x = Math.min(pos.x, e.text.boundingBox.x);
        /** @type {number} */
        pos.y = Math.min(pos.y, e.text.boundingBox.y);
      }
    }
    pos.x += px;
    pos.y += y;
    if (null != e.text && null != e.text.boundingBox) {
      if (valign) {
        /** @type {number} */
        pos.width = Math.max(maxWidth, e.text.boundingBox.width);
        /** @type {number} */
        pos.height = Math.max(w, e.text.boundingBox.height);
      } else {
        /** @type {number} */
        pos.width = Math.max(pos.width, e.text.boundingBox.width);
        /** @type {number} */
        pos.height = Math.max(pos.height, e.text.boundingBox.height);
      }
    }
    if (this.graph.getModel().isVertex(e.cell)) {
      valign = mxUtils.getValue(e.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
      if (valign == mxConstants.ALIGN_LEFT) {
        pos.x -= e.width;
      } else {
        if (valign == mxConstants.ALIGN_RIGHT) {
          pos.x += e.width;
        }
      }
      valign = mxUtils.getValue(e.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
      if (valign == mxConstants.ALIGN_TOP) {
        pos.y -= e.height;
      } else {
        if (valign == mxConstants.ALIGN_BOTTOM) {
          pos.y += e.height;
        }
      }
    }
  }
  return new mxRectangle(Math.round(pos.x), Math.round(pos.y), Math.round(pos.width), Math.round(pos.height));
};
/**
 * @param {?} a
 * @return {?}
 */
mxCellEditor.prototype.getEmptyLabelText = function(a) {
  return this.emptyLabelText;
};
/**
 * @return {?}
 */
mxCellEditor.prototype.getEditingCell = function() {
  return this.editingCell;
};
/**
 * @return {undefined}
 */
mxCellEditor.prototype.destroy = function() {
  if (null != this.textarea) {
    mxEvent.release(this.textarea);
    if (null != this.textarea.parentNode) {
      this.textarea.parentNode.removeChild(this.textarea);
    }
    /** @type {null} */
    this.textarea = null;
  }
  if (null != this.changeHandler) {
    this.graph.getModel().removeListener(this.changeHandler);
    /** @type {null} */
    this.changeHandler = null;
  }
  if (this.zoomHandler) {
    this.graph.view.removeListener(this.zoomHandler);
    /** @type {null} */
    this.zoomHandler = null;
  }
};
/**
 * @return {undefined}
 */
function mxCellRenderer() {
}
mxCellRenderer.defaultShapes = {};
/** @type {function(?, ?, ?): undefined} */
mxCellRenderer.prototype.defaultEdgeShape = mxConnector;
/** @type {function(!Object, string, !Object, number): undefined} */
mxCellRenderer.prototype.defaultVertexShape = mxRectangleShape;
/** @type {function(!Object, !Object, string, string, string, string, number, string, number, number, number, number, number, ?, string, ?, string, string, string, number, ?): undefined} */
mxCellRenderer.prototype.defaultTextShape = mxText;
/** @type {boolean} */
mxCellRenderer.prototype.legacyControlPosition = true;
/** @type {boolean} */
mxCellRenderer.prototype.legacySpacing = true;
/** @type {boolean} */
mxCellRenderer.prototype.antiAlias = true;
/** @type {number} */
mxCellRenderer.prototype.minSvgStrokeWidth = 1;
/** @type {boolean} */
mxCellRenderer.prototype.forceControlClickHandler = false;
/**
 * @param {string} javascriptName
 * @param {!Function} jsonName
 * @return {undefined}
 */
mxCellRenderer.registerShape = function(javascriptName, jsonName) {
  /** @type {!Function} */
  mxCellRenderer.defaultShapes[javascriptName] = jsonName;
};
mxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);
mxCellRenderer.registerShape(mxConstants.SHAPE_ELLIPSE, mxEllipse);
mxCellRenderer.registerShape(mxConstants.SHAPE_RHOMBUS, mxRhombus);
mxCellRenderer.registerShape(mxConstants.SHAPE_CYLINDER, mxCylinder);
mxCellRenderer.registerShape(mxConstants.SHAPE_CONNECTOR, mxConnector);
mxCellRenderer.registerShape(mxConstants.SHAPE_ACTOR, mxActor);
mxCellRenderer.registerShape(mxConstants.SHAPE_TRIANGLE, mxTriangle);
mxCellRenderer.registerShape(mxConstants.SHAPE_HEXAGON, mxHexagon);
mxCellRenderer.registerShape(mxConstants.SHAPE_CLOUD, mxCloud);
mxCellRenderer.registerShape(mxConstants.SHAPE_LINE, mxLine);
mxCellRenderer.registerShape(mxConstants.SHAPE_ARROW, mxArrow);
mxCellRenderer.registerShape(mxConstants.SHAPE_ARROW_CONNECTOR, mxArrowConnector);
mxCellRenderer.registerShape(mxConstants.SHAPE_DOUBLE_ELLIPSE, mxDoubleEllipse);
mxCellRenderer.registerShape(mxConstants.SHAPE_SWIMLANE, mxSwimlane);
mxCellRenderer.registerShape(mxConstants.SHAPE_IMAGE, mxImageShape);
mxCellRenderer.registerShape(mxConstants.SHAPE_LABEL, mxLabel);
/**
 * @param {!Object} self
 * @return {undefined}
 */
mxCellRenderer.prototype.initializeShape = function(self) {
  self.shape.dialect = self.view.graph.dialect;
  this.configureShape(self);
  self.shape.init(self.view.getDrawPane());
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxCellRenderer.prototype.createShape = function(state) {
  /** @type {null} */
  var shape = null;
  if (null != state.style) {
    shape = mxStencilRegistry.getStencil(state.style[mxConstants.STYLE_SHAPE]);
    shape = null != shape ? new mxShape(shape) : new (this.getShapeConstructor(state));
  }
  return shape;
};
/**
 * @param {!Object} block
 * @return {undefined}
 */
mxCellRenderer.prototype.createIndicatorShape = function(block) {
  block.shape.indicatorShape = this.getShape(block.view.graph.getIndicatorShape(block));
};
/**
 * @param {?} pKey
 * @return {?}
 */
mxCellRenderer.prototype.getShape = function(pKey) {
  return null != pKey ? mxCellRenderer.defaultShapes[pKey] : null;
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxCellRenderer.prototype.getShapeConstructor = function(state) {
  var shape = this.getShape(state.style[mxConstants.STYLE_SHAPE]);
  if (null == shape) {
    shape = state.view.graph.getModel().isEdge(state.cell) ? this.defaultEdgeShape : this.defaultVertexShape;
  }
  return shape;
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxCellRenderer.prototype.configureShape = function(data) {
  data.shape.apply(data);
  data.shape.image = data.view.graph.getImage(data);
  data.shape.indicatorColor = data.view.graph.getIndicatorColor(data);
  data.shape.indicatorStrokeColor = data.style[mxConstants.STYLE_INDICATOR_STROKECOLOR];
  data.shape.indicatorGradientColor = data.view.graph.getIndicatorGradientColor(data);
  data.shape.indicatorDirection = data.style[mxConstants.STYLE_INDICATOR_DIRECTION];
  data.shape.indicatorImage = data.view.graph.getIndicatorImage(data);
  this.postConfigureShape(data);
};
/**
 * @param {!Object} a
 * @return {undefined}
 */
mxCellRenderer.prototype.postConfigureShape = function(a) {
  if (null != a.shape) {
    this.resolveColor(a, "indicatorGradientColor", mxConstants.STYLE_GRADIENTCOLOR);
    this.resolveColor(a, "indicatorColor", mxConstants.STYLE_FILLCOLOR);
    this.resolveColor(a, "gradient", mxConstants.STYLE_GRADIENTCOLOR);
    this.resolveColor(a, "stroke", mxConstants.STYLE_STROKECOLOR);
    this.resolveColor(a, "fill", mxConstants.STYLE_FILLCOLOR);
  }
};
/**
 * @param {!Object} a
 * @return {?}
 */
mxCellRenderer.prototype.checkPlaceholderStyles = function(a) {
  if (null != a.style) {
    /** @type {!Array} */
    var str = ["inherit", "swimlane", "indicated"];
    /** @type {!Array} */
    var battrs = [mxConstants.STYLE_FILLCOLOR, mxConstants.STYLE_STROKECOLOR, mxConstants.STYLE_GRADIENTCOLOR, mxConstants.STYLE_FONTCOLOR];
    /** @type {number} */
    var i = 0;
    for (; i < battrs.length; i++) {
      if (0 <= mxUtils.indexOf(str, a.style[battrs[i]])) {
        return true;
      }
    }
  }
  return false;
};
/**
 * @param {!Object} state
 * @param {string} name
 * @param {string} type
 * @return {undefined}
 */
mxCellRenderer.prototype.resolveColor = function(state, name, type) {
  var elem = type == mxConstants.STYLE_FONTCOLOR ? state.text : state.shape;
  if (null != elem) {
    var node = state.view.graph;
    var id = elem[name];
    /** @type {null} */
    var key = null;
    if ("inherit" == id) {
      key = node.model.getParent(state.cell);
    } else {
      if ("swimlane" == id) {
        /** @type {string} */
        elem[name] = type == mxConstants.STYLE_STROKECOLOR || type == mxConstants.STYLE_FONTCOLOR ? "#000000" : "#ffffff";
        key = null != node.model.getTerminal(state.cell, false) ? node.model.getTerminal(state.cell, false) : state.cell;
        key = node.getSwimlane(key);
        type = node.swimlaneIndicatorColorAttribute;
      } else {
        if ("indicated" == id && null != state.shape) {
          elem[name] = state.shape.indicatorColor;
        } else {
          if (type != mxConstants.STYLE_FILLCOLOR && id == mxConstants.STYLE_FILLCOLOR && null != state.shape) {
            elem[name] = state.style[mxConstants.STYLE_FILLCOLOR];
          } else {
            if (type != mxConstants.STYLE_STROKECOLOR && id == mxConstants.STYLE_STROKECOLOR && null != state.shape) {
              elem[name] = state.style[mxConstants.STYLE_STROKECOLOR];
            }
          }
        }
      }
    }
    if (null != key) {
      state = node.getView().getState(key);
      /** @type {null} */
      elem[name] = null;
      if (null != state) {
        node = type == mxConstants.STYLE_FONTCOLOR ? state.text : state.shape;
        elem[name] = null != node && "indicatorColor" != name ? node[name] : state.style[type];
      }
    }
  }
};
/**
 * @param {!Object} self
 * @return {?}
 */
mxCellRenderer.prototype.getLabelValue = function(self) {
  return self.view.graph.getLabel(self.cell);
};
/**
 * @param {!Object} state
 * @param {!Object} node
 * @return {undefined}
 */
mxCellRenderer.prototype.createLabel = function(state, node) {
  var graph = state.view.graph;
  graph.getModel().isEdge(state.cell);
  if (0 < state.style[mxConstants.STYLE_FONTSIZE] || null == state.style[mxConstants.STYLE_FONTSIZE]) {
    var ls = graph.isHtmlLabel(state.cell) || null != node && mxUtils.isNode(node);
    state.text = new this.defaultTextShape(node, new mxRectangle, state.style[mxConstants.STYLE_ALIGN] || mxConstants.ALIGN_CENTER, graph.getVerticalAlign(state), state.style[mxConstants.STYLE_FONTCOLOR], state.style[mxConstants.STYLE_FONTFAMILY], state.style[mxConstants.STYLE_FONTSIZE], state.style[mxConstants.STYLE_FONTSTYLE], state.style[mxConstants.STYLE_SPACING], state.style[mxConstants.STYLE_SPACING_TOP], state.style[mxConstants.STYLE_SPACING_RIGHT], state.style[mxConstants.STYLE_SPACING_BOTTOM], 
    state.style[mxConstants.STYLE_SPACING_LEFT], state.style[mxConstants.STYLE_HORIZONTAL], state.style[mxConstants.STYLE_LABEL_BACKGROUNDCOLOR], state.style[mxConstants.STYLE_LABEL_BORDERCOLOR], graph.isWrapping(state.cell) && graph.isHtmlLabel(state.cell), graph.isLabelClipped(state.cell), state.style[mxConstants.STYLE_OVERFLOW], state.style[mxConstants.STYLE_LABEL_PADDING], mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION));
    state.text.opacity = mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_OPACITY, 100);
    state.text.dialect = ls ? mxConstants.DIALECT_STRICTHTML : state.view.graph.dialect;
    state.text.style = state.style;
    /** @type {!Object} */
    state.text.state = state;
    this.initializeLabel(state, state.text);
    /** @type {boolean} */
    var e = false;
    /**
     * @param {number} e
     * @return {?}
     */
    var error = function(e) {
      /** @type {!Object} */
      var value = state;
      if (mxClient.IS_TOUCH || e) {
        value = mxEvent.getClientX(e);
        e = mxEvent.getClientY(e);
        e = mxUtils.convertPoint(graph.container, value, e);
        value = graph.view.getState(graph.getCellAt(e.x, e.y));
      }
      return value;
    };
    mxEvent.addGestureListeners(state.text.node, mxUtils.bind(this, function(evt) {
      if (this.isLabelEvent(state, evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));
        /** @type {boolean} */
        e = graph.dialect != mxConstants.DIALECT_SVG && "IMG" == mxEvent.getSource(evt).nodeName;
      }
    }), mxUtils.bind(this, function(evt) {
      if (this.isLabelEvent(state, evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, error(evt)));
      }
    }), mxUtils.bind(this, function(evt) {
      if (this.isLabelEvent(state, evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, error(evt)));
        /** @type {boolean} */
        e = false;
      }
    }));
    if (graph.nativeDblClickEnabled) {
      mxEvent.addListener(state.text.node, "dblclick", mxUtils.bind(this, function(e) {
        if (this.isLabelEvent(state, e)) {
          graph.dblClick(e, state.cell);
          mxEvent.consume(e);
        }
      }));
    }
  }
};
/**
 * @param {!Object} data
 * @param {!Object} graph
 * @return {undefined}
 */
mxCellRenderer.prototype.initializeLabel = function(data, graph) {
  if (mxClient.IS_SVG && mxClient.NO_FO && graph.dialect != mxConstants.DIALECT_SVG) {
    graph.init(data.view.graph.container);
  } else {
    graph.init(data.view.getDrawPane());
  }
};
/**
 * @param {!Object} result
 * @return {undefined}
 */
mxCellRenderer.prototype.createCellOverlays = function(result) {
  var data = result.view.graph.getCellOverlays(result.cell);
  /** @type {null} */
  var o = null;
  if (null != data) {
    o = new mxDictionary;
    /** @type {number} */
    var i = 0;
    for (; i < data.length; i++) {
      var options = null != result.overlays ? result.overlays.remove(data[i]) : null;
      if (null == options) {
        options = new mxImageShape(new mxRectangle, data[i].image.src);
        options.dialect = result.view.graph.dialect;
        /** @type {boolean} */
        options.preserveImageAspect = false;
        options.overlay = data[i];
        this.initializeOverlay(result, options);
        this.installCellOverlayListeners(result, data[i], options);
        if (null != data[i].cursor) {
          options.node.style.cursor = data[i].cursor;
        }
      }
      o.put(data[i], options);
    }
  }
  if (null != result.overlays) {
    result.overlays.visit(function(a, anAlertDialog) {
      anAlertDialog.destroy();
    });
  }
  result.overlays = o;
};
/**
 * @param {!Object} g
 * @param {!Object} b
 * @return {undefined}
 */
mxCellRenderer.prototype.initializeOverlay = function(g, b) {
  b.init(g.view.getOverlayPane());
};
/**
 * @param {!Object} state
 * @param {!Object} win
 * @param {!Object} method
 * @return {undefined}
 */
mxCellRenderer.prototype.installCellOverlayListeners = function(state, win, method) {
  var graph = state.view.graph;
  mxEvent.addListener(method.node, "click", function(edit) {
    if (graph.isEditing()) {
      graph.stopEditing(!graph.isInvokesStopCellEditing());
    }
    win.fireEvent(new mxEventObject(mxEvent.CLICK, "event", edit, "cell", state.cell));
  });
  mxEvent.addGestureListeners(method.node, function(e) {
    mxEvent.consume(e);
  }, function(evt) {
    graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, state));
  });
  if (mxClient.IS_TOUCH) {
    mxEvent.addListener(method.node, "touchend", function(edit) {
      win.fireEvent(new mxEventObject(mxEvent.CLICK, "event", edit, "cell", state.cell));
    });
  }
};
/**
 * @param {!Object} self
 * @return {undefined}
 */
mxCellRenderer.prototype.createControl = function(self) {
  var graph = self.view.graph;
  var table = graph.getFoldingImage(self);
  if (graph.foldingEnabled && null != table) {
    if (null == self.control) {
      var size = new mxRectangle(0, 0, table.width, table.height);
      self.control = new mxImageShape(size, table.src);
      /** @type {boolean} */
      self.control.preserveImageAspect = false;
      self.control.dialect = graph.dialect;
      this.initControl(self, self.control, true, this.createControlClickHandler(self));
    }
  } else {
    if (null != self.control) {
      self.control.destroy();
      /** @type {null} */
      self.control = null;
    }
  }
};
/**
 * @param {!Object} n
 * @return {?}
 */
mxCellRenderer.prototype.createControlClickHandler = function(n) {
  var graph = n.view.graph;
  return mxUtils.bind(this, function(evt) {
    if (this.forceControlClickHandler || graph.isEnabled()) {
      /** @type {boolean} */
      var realVal = !graph.isCellCollapsed(n.cell);
      graph.foldCells(realVal, false, [n.cell], null, evt);
      mxEvent.consume(evt);
    }
  });
};
/**
 * @param {!Object} state
 * @param {!Object} control
 * @param {boolean} handleEvents
 * @param {?} clickHandler
 * @return {?}
 */
mxCellRenderer.prototype.initControl = function(state, control, handleEvents, clickHandler) {
  var graph = state.view.graph;
  if (graph.isHtmlLabel(state.cell) && mxClient.NO_FO && graph.dialect == mxConstants.DIALECT_SVG) {
    control.dialect = mxConstants.DIALECT_PREFERHTML;
    control.init(graph.container);
    /** @type {number} */
    control.node.style.zIndex = 1;
  } else {
    control.init(state.view.getOverlayPane());
  }
  control = control.innerNode || control.node;
  if (!(null == clickHandler || mxClient.IS_IOS)) {
    if (graph.isEnabled()) {
      /** @type {string} */
      control.style.cursor = "pointer";
    }
    mxEvent.addListener(control, "click", clickHandler);
  }
  if (handleEvents) {
    /** @type {null} */
    var first = null;
    mxEvent.addGestureListeners(control, function(evt) {
      first = new mxPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt));
      graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));
      mxEvent.consume(evt);
    }, function(evt) {
      graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, state));
    }, function(evt) {
      graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, state));
      mxEvent.consume(evt);
    });
    if (null != clickHandler && mxClient.IS_IOS) {
      control.addEventListener("touchend", function(evt) {
        if (null != first) {
          var tol = graph.tolerance;
          if (Math.abs(first.x - mxEvent.getClientX(evt)) < tol && Math.abs(first.y - mxEvent.getClientY(evt)) < tol) {
            clickHandler.call(clickHandler, evt);
            mxEvent.consume(evt);
          }
        }
      }, true);
    }
  }
  return control;
};
/**
 * @param {!Object} rows
 * @param {!Object} e
 * @return {?}
 */
mxCellRenderer.prototype.isShapeEvent = function(rows, e) {
  return true;
};
/**
 * @param {!Object} rows
 * @param {string} e
 * @return {?}
 */
mxCellRenderer.prototype.isLabelEvent = function(rows, e) {
  return true;
};
/**
 * @param {!Object} state
 * @return {undefined}
 */
mxCellRenderer.prototype.installListeners = function(state) {
  var graph = state.view.graph;
  /**
   * @param {!Array} e
   * @return {?}
   */
  var process = function(e) {
    /** @type {!Object} */
    var value = state;
    if (graph.dialect != mxConstants.DIALECT_SVG && "IMG" == mxEvent.getSource(e).nodeName || mxClient.IS_TOUCH) {
      value = mxEvent.getClientX(e);
      e = mxEvent.getClientY(e);
      e = mxUtils.convertPoint(graph.container, value, e);
      value = graph.view.getState(graph.getCellAt(e.x, e.y));
    }
    return value;
  };
  mxEvent.addGestureListeners(state.shape.node, mxUtils.bind(this, function(evt) {
    if (this.isShapeEvent(state, evt)) {
      graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));
    }
  }), mxUtils.bind(this, function(evt) {
    if (this.isShapeEvent(state, evt)) {
      graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, process(evt)));
    }
  }), mxUtils.bind(this, function(evt) {
    if (this.isShapeEvent(state, evt)) {
      graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, process(evt)));
    }
  }));
  if (graph.nativeDblClickEnabled) {
    mxEvent.addListener(state.shape.node, "dblclick", mxUtils.bind(this, function(e) {
      if (this.isShapeEvent(state, e)) {
        graph.dblClick(e, state.cell);
        mxEvent.consume(e);
      }
    }));
  }
};
/**
 * @param {!Object} state
 * @param {string} force
 * @return {undefined}
 */
mxCellRenderer.prototype.redrawLabel = function(state, force) {
  var data = state.view.graph;
  var value = this.getLabelValue(state);
  var undefined = data.isWrapping(state.cell);
  var change = data.isLabelClipped(state.cell);
  var dialect = state.view.graph.isHtmlLabel(state.cell) || null != value && mxUtils.isNode(value) ? mxConstants.DIALECT_STRICTHTML : state.view.graph.dialect;
  var overflow = state.style[mxConstants.STYLE_OVERFLOW] || "visible";
  if (!(null == state.text || state.text.wrap == undefined && state.text.clipped == change && state.text.overflow == overflow && state.text.dialect == dialect)) {
    state.text.destroy();
    /** @type {null} */
    state.text = null;
  }
  if (null == state.text && null != value && (mxUtils.isNode(value) || 0 < value.length)) {
    this.createLabel(state, value);
  } else {
    if (!(null == state.text || null != value && 0 != value.length)) {
      state.text.destroy();
      /** @type {null} */
      state.text = null;
    }
  }
  if (null != state.text) {
    if (force) {
      if (null != state.text.lastValue && this.isTextShapeInvalid(state, state.text)) {
        /** @type {null} */
        state.text.lastValue = null;
      }
      state.text.resetStyles();
      state.text.apply(state);
      state.text.valign = data.getVerticalAlign(state);
    }
    data = this.getLabelBounds(state);
    var scale = this.getTextScale(state);
    this.resolveColor(state, "color", mxConstants.STYLE_FONTCOLOR);
    if (force || state.text.value != value || state.text.isWrapping != undefined || state.text.overflow != overflow || state.text.isClipping != change || state.text.scale != scale || state.text.dialect != dialect || null == state.text.bounds || !state.text.bounds.equals(data)) {
      state.text.dialect = dialect;
      state.text.value = value;
      state.text.bounds = data;
      state.text.scale = scale;
      state.text.wrap = undefined;
      state.text.clipped = change;
      state.text.overflow = overflow;
      value = state.text.node.style.visibility;
      this.redrawLabelShape(state.text);
      state.text.node.style.visibility = value;
    }
  }
};
/**
 * @param {!Object} state
 * @param {!Object} result
 * @return {?}
 */
mxCellRenderer.prototype.isTextShapeInvalid = function(state, result) {
  /**
   * @param {string} name
   * @param {string} key
   * @param {?} fn
   * @return {?}
   */
  function $(name, key, fn) {
    return "spacingTop" == key || "spacingRight" == key || "spacingBottom" == key || "spacingLeft" == key ? parseFloat(result[name]) - parseFloat(result.spacing) != (state.style[key] || fn) : result[name] != (state.style[key] || fn);
  }
  return $("fontStyle", mxConstants.STYLE_FONTSTYLE, mxConstants.DEFAULT_FONTSTYLE) || $("family", mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY) || $("size", mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE) || $("color", mxConstants.STYLE_FONTCOLOR, "black") || $("align", mxConstants.STYLE_ALIGN, "") || $("valign", mxConstants.STYLE_VERTICAL_ALIGN, "") || $("spacing", mxConstants.STYLE_SPACING, 2) || $("spacingTop", mxConstants.STYLE_SPACING_TOP, 0) || $("spacingRight", mxConstants.STYLE_SPACING_RIGHT, 
  0) || $("spacingBottom", mxConstants.STYLE_SPACING_BOTTOM, 0) || $("spacingLeft", mxConstants.STYLE_SPACING_LEFT, 0) || $("horizontal", mxConstants.STYLE_HORIZONTAL, true) || $("background", mxConstants.STYLE_LABEL_BACKGROUNDCOLOR) || $("border", mxConstants.STYLE_LABEL_BORDERCOLOR) || $("opacity", mxConstants.STYLE_TEXT_OPACITY, 100) || $("textDirection", mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);
};
/**
 * @param {!Object} year_selector_service
 * @return {undefined}
 */
mxCellRenderer.prototype.redrawLabelShape = function(year_selector_service) {
  year_selector_service.redraw();
};
/**
 * @param {!Object} event
 * @return {?}
 */
mxCellRenderer.prototype.getTextScale = function(event) {
  return event.view.scale;
};
/**
 * @param {!Object} s
 * @return {?}
 */
mxCellRenderer.prototype.getLabelBounds = function(s) {
  var w = s.view.graph;
  var scale = s.view.scale;
  var d = w.getModel().isEdge(s.cell);
  var p = new mxRectangle(s.absoluteOffset.x, s.absoluteOffset.y);
  if (d) {
    var d = s.text.getSpacing();
    p.x += d.x * scale;
    p.y += d.y * scale;
    w = w.getCellGeometry(s.cell);
    if (null != w) {
      /** @type {number} */
      p.width = Math.max(0, w.width * scale);
      /** @type {number} */
      p.height = Math.max(0, w.height * scale);
    }
  } else {
    if (s.text.isPaintBoundsInverted()) {
      w = p.x;
      p.x = p.y;
      p.y = w;
    }
    p.x += s.x;
    p.y += s.y;
    /** @type {number} */
    p.width = Math.max(1, s.width);
    /** @type {number} */
    p.height = Math.max(1, s.height);
  }
  if (s.text.isPaintBoundsInverted()) {
    /** @type {number} */
    w = (s.width - s.height) / 2;
    p.x += w;
    p.y -= w;
    w = p.width;
    p.width = p.height;
    p.height = w;
  }
  if (null != s.shape) {
    w = mxUtils.getValue(s.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
    d = mxUtils.getValue(s.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
    if (w == mxConstants.ALIGN_CENTER && d == mxConstants.ALIGN_MIDDLE) {
      p = s.shape.getLabelBounds(p);
    }
  }
  w = mxUtils.getValue(s.style, mxConstants.STYLE_LABEL_WIDTH, null);
  if (null != w) {
    /** @type {number} */
    p.width = parseFloat(w) * scale;
  }
  if (!d) {
    this.rotateLabelBounds(s, p);
  }
  return p;
};
/**
 * @param {!Object} self
 * @param {!Object} c
 * @return {undefined}
 */
mxCellRenderer.prototype.rotateLabelBounds = function(self, c) {
  c.y -= self.text.margin.y * c.height;
  c.x -= self.text.margin.x * c.width;
  if (!this.legacySpacing || "fill" != self.style[mxConstants.STYLE_OVERFLOW] && "width" != self.style[mxConstants.STYLE_OVERFLOW]) {
    var x = self.view.scale;
    var y = self.text.getSpacing();
    c.x += y.x * x;
    c.y += y.y * x;
    y = mxUtils.getValue(self.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
    var e = mxUtils.getValue(self.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
    var bottom = mxUtils.getValue(self.style, mxConstants.STYLE_LABEL_WIDTH, null);
    /** @type {number} */
    c.width = Math.max(0, c.width - (y == mxConstants.ALIGN_CENTER && null == bottom ? self.text.spacingLeft * x + self.text.spacingRight * x : 0));
    /** @type {number} */
    c.height = Math.max(0, c.height - (e == mxConstants.ALIGN_MIDDLE ? self.text.spacingTop * x + self.text.spacingBottom * x : 0));
  }
  e = self.text.getTextRotation();
  if (0 != e && null != self && self.view.graph.model.isVertex(self.cell) && (x = self.getCenterX(), y = self.getCenterY(), c.x != x || c.y != y)) {
    /** @type {number} */
    e = e * (Math.PI / 180);
    x = mxUtils.getRotatedPoint(new mxPoint(c.x, c.y), Math.cos(e), Math.sin(e), new mxPoint(x, y));
    c.x = x.x;
    c.y = x.y;
  }
};
/**
 * @param {!Object} self
 * @param {string} newState
 * @return {undefined}
 */
mxCellRenderer.prototype.redrawCellOverlays = function(self, newState) {
  this.createCellOverlays(self);
  if (null != self.overlays) {
    var rotation = mxUtils.mod(mxUtils.getValue(self.style, mxConstants.STYLE_ROTATION, 0), 90);
    var alpha = mxUtils.toRadians(rotation);
    /** @type {number} */
    var cos = Math.cos(alpha);
    /** @type {number} */
    var sin = Math.sin(alpha);
    self.overlays.visit(function(canCreateDiscussions, that) {
      var s = that.overlay.getBounds(self);
      if (!self.view.graph.getModel().isEdge(self.cell) && null != self.shape && 0 != rotation) {
        var width = s.getCenterX();
        var bottom = s.getCenterY();
        bottom = mxUtils.getRotatedPoint(new mxPoint(width, bottom), cos, sin, new mxPoint(self.getCenterX(), self.getCenterY()));
        width = bottom.x;
        bottom = bottom.y;
        /** @type {number} */
        s.x = Math.round(width - s.width / 2);
        /** @type {number} */
        s.y = Math.round(bottom - s.height / 2);
      }
      if (newState || null == that.bounds || that.scale != self.view.scale || !that.bounds.equals(s)) {
        that.bounds = s;
        that.scale = self.view.scale;
        that.redraw();
      }
    });
  }
};
/**
 * @param {!Object} self
 * @param {string} newState
 * @return {undefined}
 */
mxCellRenderer.prototype.redrawControl = function(self, newState) {
  var value = self.view.graph.getFoldingImage(self);
  if (null != self.control && null != value) {
    value = this.getControlBounds(self, value.width, value.height);
    var val = this.legacyControlPosition ? mxUtils.getValue(self.style, mxConstants.STYLE_ROTATION, 0) : self.shape.getTextRotation();
    var scale = self.view.scale;
    if (newState || self.control.scale != scale || !self.control.bounds.equals(value) || self.control.rotation != val) {
      self.control.rotation = val;
      self.control.bounds = value;
      self.control.scale = scale;
      self.control.redraw();
    }
  }
};
/**
 * @param {!Object} self
 * @param {number} delta
 * @param {number} deltaX
 * @return {?}
 */
mxCellRenderer.prototype.getControlBounds = function(self, delta, deltaX) {
  if (null != self.control) {
    var i = self.view.scale;
    var t = self.getCenterX();
    var n = self.getCenterY();
    if (!self.view.graph.getModel().isEdge(self.cell) && (t = self.x + delta * i, n = self.y + deltaX * i, null != self.shape)) {
      var value = self.shape.getShapeRotation();
      if (this.legacyControlPosition) {
        value = mxUtils.getValue(self.style, mxConstants.STYLE_ROTATION, 0);
      } else {
        if (self.shape.isPaintBoundsInverted()) {
          /** @type {number} */
          var i = (self.width - self.height) / 2;
          t = t + i;
          /** @type {number} */
          n = n - i;
        }
      }
      if (0 != value) {
        i = mxUtils.toRadians(value);
        /** @type {number} */
        value = Math.cos(i);
        /** @type {number} */
        i = Math.sin(i);
        n = mxUtils.getRotatedPoint(new mxPoint(t, n), value, i, new mxPoint(self.getCenterX(), self.getCenterY()));
        t = n.x;
        n = n.y;
      }
    }
    return self.view.graph.getModel().isEdge(self.cell), new mxRectangle(Math.round(t - delta / 2 * i), Math.round(n - deltaX / 2 * i), Math.round(delta * i), Math.round(deltaX * i));
  }
  return null;
};
/**
 * @param {!Object} graph
 * @param {string} node
 * @param {string} defs
 * @return {?}
 */
mxCellRenderer.prototype.insertStateAfter = function(graph, node, defs) {
  var cells = this.getShapesForState(graph);
  /** @type {number} */
  var i = 0;
  for (; i < cells.length; i++) {
    if (null != cells[i] && null != cells[i].node) {
      /** @type {boolean} */
      var list = cells[i].node.parentNode != graph.view.getDrawPane() && cells[i].node.parentNode != graph.view.getOverlayPane();
      var target = list ? defs : node;
      if (null != target && target.nextSibling != cells[i].node) {
        if (null == target.nextSibling) {
          target.parentNode.appendChild(cells[i].node);
        } else {
          target.parentNode.insertBefore(cells[i].node, target.nextSibling);
        }
      } else {
        if (null == target) {
          if (cells[i].node.parentNode == graph.view.graph.container) {
            target = graph.view.canvas;
            for (; null != target && target.parentNode != graph.view.graph.container;) {
              target = target.parentNode;
            }
            if (null != target && null != target.nextSibling) {
              if (target.nextSibling != cells[i].node) {
                cells[i].node.parentNode.insertBefore(cells[i].node, target.nextSibling);
              }
            } else {
              cells[i].node.parentNode.appendChild(cells[i].node);
            }
          } else {
            if (null != cells[i].node.parentNode && null != cells[i].node.parentNode.firstChild && cells[i].node.parentNode.firstChild != cells[i].node) {
              cells[i].node.parentNode.insertBefore(cells[i].node, cells[i].node.parentNode.firstChild);
            }
          }
        }
      }
      if (list) {
        defs = cells[i].node;
      } else {
        node = cells[i].node;
      }
    }
  }
  return [node, defs];
};
/**
 * @param {!Object} options
 * @return {?}
 */
mxCellRenderer.prototype.getShapesForState = function(options) {
  return [options.shape, options.text, options.control];
};
/**
 * @param {!Object} el
 * @param {string} value
 * @param {?} e
 * @return {undefined}
 */
mxCellRenderer.prototype.redraw = function(el, value, e) {
  value = this.redrawShape(el, value, e);
  if (!(null == el.shape || null != e && !e)) {
    this.redrawLabel(el, value);
    this.redrawCellOverlays(el, value);
    this.redrawControl(el, value);
  }
};
/**
 * @param {!Object} self
 * @param {string} v
 * @param {?} ebits
 * @return {?}
 */
mxCellRenderer.prototype.redrawShape = function(self, v, ebits) {
  var data = self.view.graph.model;
  /** @type {boolean} */
  var e = false;
  if (null != self.shape && null != self.shape.style && null != self.style && self.shape.style[mxConstants.STYLE_SHAPE] != self.style[mxConstants.STYLE_SHAPE]) {
    self.shape.destroy();
    /** @type {null} */
    self.shape = null;
  }
  if (null == self.shape && null != self.view.graph.container && self.cell != self.view.currentRoot && (data.isVertex(self.cell) || data.isEdge(self.cell))) {
    self.shape = this.createShape(self);
    if (null != self.shape) {
      self.shape.minSvgStrokeWidth = this.minSvgStrokeWidth;
      self.shape.antiAlias = this.antiAlias;
      this.createIndicatorShape(self);
      this.initializeShape(self);
      this.createCellOverlays(self);
      this.installListeners(self);
      self.view.graph.selectionCellsHandler.updateHandler(self);
    }
  } else {
    if (!(v || null == self.shape || mxUtils.equalEntries(self.shape.style, self.style) && !this.checkPlaceholderStyles(self))) {
      self.shape.resetStyles();
      this.configureShape(self);
      self.view.graph.selectionCellsHandler.updateHandler(self);
      /** @type {boolean} */
      v = true;
    }
  }
  if (null != self.shape && self.shape.indicatorShape != this.getShape(self.view.graph.getIndicatorShape(self))) {
    if (null != self.shape.indicator) {
      self.shape.indicator.destroy();
      /** @type {null} */
      self.shape.indicator = null;
    }
    this.createIndicatorShape(self);
    if (null != self.shape.indicatorShape) {
      self.shape.indicator = new self.shape.indicatorShape;
      self.shape.indicator.dialect = self.shape.dialect;
      self.shape.indicator.init(self.node);
      /** @type {boolean} */
      v = true;
    }
  }
  if (null != self.shape && (this.createControl(self), v || this.isShapeInvalid(self, self.shape))) {
    if (null != self.absolutePoints) {
      self.shape.points = self.absolutePoints.slice();
      /** @type {null} */
      self.shape.bounds = null;
    } else {
      /** @type {null} */
      self.shape.points = null;
      self.shape.bounds = new mxRectangle(self.x, self.y, self.width, self.height);
    }
    self.shape.scale = self.view.scale;
    if (null == ebits || ebits) {
      this.doRedrawShape(self);
    } else {
      self.shape.updateBoundingBox();
    }
    /** @type {boolean} */
    e = true;
  }
  return e;
};
/**
 * @param {!Object} view
 * @return {undefined}
 */
mxCellRenderer.prototype.doRedrawShape = function(view) {
  view.shape.redraw();
};
/**
 * @param {!Object} action
 * @param {!Object} obj
 * @return {?}
 */
mxCellRenderer.prototype.isShapeInvalid = function(action, obj) {
  return null == obj.bounds || obj.scale != action.view.scale || null == action.absolutePoints && !obj.bounds.equals(action) || null != action.absolutePoints && !mxUtils.equalPoints(obj.points, action.absolutePoints);
};
/**
 * @param {!Object} self
 * @return {undefined}
 */
mxCellRenderer.prototype.destroy = function(self) {
  if (null != self.shape) {
    if (null != self.text) {
      self.text.destroy();
      /** @type {null} */
      self.text = null;
    }
    if (null != self.overlays) {
      self.overlays.visit(function(a, anAlertDialog) {
        anAlertDialog.destroy();
      });
      /** @type {null} */
      self.overlays = null;
    }
    if (null != self.control) {
      self.control.destroy();
      /** @type {null} */
      self.control = null;
    }
    self.shape.destroy();
    /** @type {null} */
    self.shape = null;
  }
};
var mxEdgeStyle = {
  EntityRelation : function(s, r, c, x, data) {
    var node = s.view;
    var a = node.graph;
    /** @type {number} */
    x = mxUtils.getValue(s.style, mxConstants.STYLE_SEGMENT, mxConstants.ENTITY_SEGMENT) * node.scale;
    var p = s.absolutePoints;
    var value = p[0];
    var t = p[p.length - 1];
    /** @type {boolean} */
    p = false;
    if (null != r) {
      var position = a.getCellGeometry(r.cell);
      if (position.relative) {
        /** @type {boolean} */
        p = .5 >= position.x;
      } else {
        if (null != c) {
          /** @type {boolean} */
          p = (null != t ? t.x : c.x + c.width) < (null != value ? value.x : r.x);
        }
      }
    }
    if (null != value) {
      r = new mxCellState;
      r.x = value.x;
      r.y = value.y;
    } else {
      if (null != r) {
        var f = mxUtils.getPortConstraints(r, s, true, mxConstants.DIRECTION_MASK_NONE);
        if (f != mxConstants.DIRECTION_MASK_NONE && f != mxConstants.DIRECTION_MASK_WEST + mxConstants.DIRECTION_MASK_EAST) {
          /** @type {boolean} */
          p = f == mxConstants.DIRECTION_MASK_WEST;
        }
      } else {
        return;
      }
    }
    /** @type {boolean} */
    position = true;
    if (null != c) {
      a = a.getCellGeometry(c.cell);
      if (a.relative) {
        /** @type {boolean} */
        position = .5 >= a.x;
      } else {
        if (null != r) {
          /** @type {boolean} */
          position = (null != value ? value.x : r.x + r.width) < (null != t ? t.x : c.x);
        }
      }
    }
    if (null != t) {
      c = new mxCellState;
      c.x = t.x;
      c.y = t.y;
    } else {
      if (null != c) {
        f = mxUtils.getPortConstraints(c, s, false, mxConstants.DIRECTION_MASK_NONE);
        if (f != mxConstants.DIRECTION_MASK_NONE && f != mxConstants.DIRECTION_MASK_WEST + mxConstants.DIRECTION_MASK_EAST) {
          /** @type {boolean} */
          position = f == mxConstants.DIRECTION_MASK_WEST;
        }
      }
    }
    if (null != r && null != c) {
      s = p ? r.x : r.x + r.width;
      r = node.getRoutingCenterY(r);
      value = position ? c.x : c.x + c.width;
      c = node.getRoutingCenterY(c);
      node = new mxPoint(s + (p ? -x : x), r);
      a = new mxPoint(value + (position ? -x : x), c);
      if (p == position) {
        /** @type {number} */
        x = p ? Math.min(s, value) - x : Math.max(s, value) + x;
        data.push(new mxPoint(x, r));
        data.push(new mxPoint(x, c));
      } else {
        if (node.x < a.x == p) {
          x = r + (c - r) / 2;
          data.push(node);
          data.push(new mxPoint(node.x, x));
          data.push(new mxPoint(a.x, x));
        } else {
          data.push(node);
        }
        data.push(a);
      }
    }
  },
  Loop : function(s, r, o, n, state) {
    o = s.absolutePoints;
    var f = o[o.length - 1];
    if (null != o[0] && null != f) {
      if (null != n && 0 < n.length) {
        /** @type {number} */
        r = 0;
        for (; r < n.length; r++) {
          o = n[r];
          o = s.view.transformControlPoint(s, o);
          state.push(new mxPoint(o.x, o.y));
        }
      }
    } else {
      if (null != r) {
        f = s.view;
        var value = f.graph;
        o = null != n && 0 < n.length ? n[0] : null;
        if (null != o) {
          o = f.transformControlPoint(s, o);
          if (mxUtils.contains(r, o.x, o.y)) {
            /** @type {null} */
            o = null;
          }
        }
        /** @type {number} */
        var h = n = 0;
        /** @type {number} */
        var y = 0;
        /** @type {number} */
        var size = 0;
        /** @type {number} */
        value = mxUtils.getValue(s.style, mxConstants.STYLE_SEGMENT, value.gridSize) * f.scale;
        s = mxUtils.getValue(s.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_WEST);
        if (s == mxConstants.DIRECTION_NORTH || s == mxConstants.DIRECTION_SOUTH) {
          n = f.getRoutingCenterX(r);
          /** @type {number} */
          h = value;
        } else {
          y = f.getRoutingCenterY(r);
          /** @type {number} */
          size = value;
        }
        if (null == o || o.x < r.x || o.x > r.x + r.width) {
          if (null != o) {
            n = o.x;
            /** @type {number} */
            size = Math.max(Math.abs(y - o.y), size);
          } else {
            if (s == mxConstants.DIRECTION_NORTH) {
              /** @type {number} */
              y = r.y - 2 * h;
            } else {
              if (s == mxConstants.DIRECTION_SOUTH) {
                y = r.y + r.height + 2 * h;
              } else {
                n = s == mxConstants.DIRECTION_EAST ? r.x - 2 * size : r.x + r.width + 2 * size;
              }
            }
          }
        } else {
          if (null != o) {
            n = f.getRoutingCenterX(r);
            /** @type {number} */
            h = Math.max(Math.abs(n - o.x), size);
            y = o.y;
            /** @type {number} */
            size = 0;
          }
        }
        state.push(new mxPoint(n - h, y - size));
        state.push(new mxPoint(n + h, y + size));
      }
    }
  },
  ElbowConnector : function(state, a, b, m, options) {
    var t = null != m && 0 < m.length ? m[0] : null;
    /** @type {boolean} */
    var maxprop = false;
    /** @type {boolean} */
    var bigword = false;
    if (null != a && null != b) {
      if (null != t) {
        /** @type {number} */
        var val = Math.min(a.x, b.x);
        /** @type {number} */
        var max = Math.max(a.x + a.width, b.x + b.width);
        /** @type {number} */
        bigword = Math.min(a.y, b.y);
        /** @type {number} */
        var W = Math.max(a.y + a.height, b.y + b.height);
        t = state.view.transformControlPoint(state, t);
        /** @type {boolean} */
        maxprop = t.y < bigword || t.y > W;
        /** @type {boolean} */
        bigword = t.x < val || t.x > max;
      } else {
        /** @type {number} */
        val = Math.max(a.x, b.x);
        /** @type {number} */
        max = Math.min(a.x + a.width, b.x + b.width);
        /** @type {boolean} */
        maxprop = val == max;
        if (!maxprop) {
          /** @type {number} */
          bigword = Math.max(a.y, b.y);
          /** @type {number} */
          W = Math.min(a.y + a.height, b.y + b.height);
          /** @type {boolean} */
          bigword = bigword == W;
        }
      }
    }
    if (bigword || !maxprop && state.style[mxConstants.STYLE_ELBOW] != mxConstants.ELBOW_VERTICAL) {
      mxEdgeStyle.SideToSide(state, a, b, m, options);
    } else {
      mxEdgeStyle.TopToBottom(state, a, b, m, options);
    }
  },
  SideToSide : function(a, d, data, p, obj) {
    var b = a.view;
    p = null != p && 0 < p.length ? p[0] : null;
    var c = a.absolutePoints;
    var x = c[0];
    c = c[c.length - 1];
    if (null != p) {
      p = b.transformControlPoint(a, p);
    }
    if (null != x) {
      d = new mxCellState;
      d.x = x.x;
      d.y = x.y;
    }
    if (null != c) {
      data = new mxCellState;
      data.x = c.x;
      data.y = c.y;
    }
    if (null != d && null != data) {
      /** @type {number} */
      a = Math.max(d.x, data.x);
      /** @type {number} */
      x = Math.min(d.x + d.width, data.x + data.width);
      a = null != p ? p.x : Math.round(x + (a - x) / 2);
      x = b.getRoutingCenterY(d);
      b = b.getRoutingCenterY(data);
      if (null != p) {
        if (p.y >= d.y && p.y <= d.y + d.height) {
          x = p.y;
        }
        if (p.y >= data.y && p.y <= data.y + data.height) {
          b = p.y;
        }
      }
      if (!(mxUtils.contains(data, a, x) || mxUtils.contains(d, a, x))) {
        obj.push(new mxPoint(a, x));
      }
      if (!(mxUtils.contains(data, a, b) || mxUtils.contains(d, a, b))) {
        obj.push(new mxPoint(a, b));
      }
      if (1 == obj.length) {
        if (null != p) {
          if (!(mxUtils.contains(data, a, p.y) || mxUtils.contains(d, a, p.y))) {
            obj.push(new mxPoint(a, p.y));
          }
        } else {
          /** @type {number} */
          b = Math.max(d.y, data.y);
          obj.push(new mxPoint(a, b + (Math.min(d.y + d.height, data.y + data.height) - b) / 2));
        }
      }
    }
  },
  TopToBottom : function(b, a, e, p, parent) {
    var v = b.view;
    p = null != p && 0 < p.length ? p[0] : null;
    var t = b.absolutePoints;
    var obj = t[0];
    t = t[t.length - 1];
    if (null != p) {
      p = v.transformControlPoint(b, p);
    }
    if (null != obj) {
      a = new mxCellState;
      a.x = obj.x;
      a.y = obj.y;
    }
    if (null != t) {
      e = new mxCellState;
      e.x = t.x;
      e.y = t.y;
    }
    if (null != a && null != e) {
      /** @type {number} */
      obj = Math.max(a.y, e.y);
      /** @type {number} */
      t = Math.min(a.y + a.height, e.y + e.height);
      b = v.getRoutingCenterX(a);
      if (null != p && p.x >= a.x && p.x <= a.x + a.width) {
        b = p.x;
      }
      obj = null != p ? p.y : Math.round(t + (obj - t) / 2);
      if (!(mxUtils.contains(e, b, obj) || mxUtils.contains(a, b, obj))) {
        parent.push(new mxPoint(b, obj));
      }
      b = null != p && p.x >= e.x && p.x <= e.x + e.width ? p.x : v.getRoutingCenterX(e);
      if (!(mxUtils.contains(e, b, obj) || mxUtils.contains(a, b, obj))) {
        parent.push(new mxPoint(b, obj));
      }
      if (1 == parent.length) {
        if (null != p && 1 == parent.length) {
          if (!(mxUtils.contains(e, p.x, obj) || mxUtils.contains(a, p.x, obj))) {
            parent.push(new mxPoint(p.x, obj));
          }
        } else {
          /** @type {number} */
          v = Math.max(a.x, e.x);
          parent.push(new mxPoint(v + (Math.min(a.x + a.width, e.x + e.width) - v) / 2, obj));
        }
      }
    }
  },
  SegmentConnector : function(o, node, e, item, path) {
    /**
     * @param {number} item
     * @return {?}
     */
    function f(item) {
      /** @type {number} */
      item.x = Math.round(item.x * o.view.scale * 10) / 10;
      /** @type {number} */
      item.y = Math.round(item.y * o.view.scale * 10) / 10;
      if (null == c || 1 <= Math.abs(c.x - item.x) || Math.abs(c.y - item.y) >= Math.max(1, o.view.scale)) {
        path.push(item);
        /** @type {number} */
        c = item;
      }
      return c;
    }
    var ref = mxEdgeStyle.scalePointArray(o.absolutePoints, o.view.scale);
    node = mxEdgeStyle.scaleCellState(node, o.view.scale);
    e = mxEdgeStyle.scaleCellState(e, o.view.scale);
    var c = 0 < path.length ? path[0] : null;
    /** @type {boolean} */
    var dir = true;
    /** @type {null} */
    var a = null;
    var b = ref[0];
    if (null == b && null != node) {
      b = new mxPoint(o.view.getRoutingCenterX(node), o.view.getRoutingCenterY(node));
    } else {
      if (null != b) {
        b = b.clone();
      }
    }
    /** @type {number} */
    var j = ref.length - 1;
    if (null != item && 0 < item.length) {
      /** @type {!Array} */
      var points = [];
      /** @type {number} */
      var i = 0;
      for (; i < item.length; i++) {
        var r = o.view.transformControlPoint(o, item[i], true);
        if (null != r) {
          points.push(r);
        }
      }
      if (0 == points.length) {
        return;
      }
      if (null != b && null != points[0]) {
        if (1 > Math.abs(points[0].x - b.x)) {
          points[0].x = b.x;
        }
        if (1 > Math.abs(points[0].y - b.y)) {
          points[0].y = b.y;
        }
      }
      r = ref[j];
      if (null != r && null != points[points.length - 1]) {
        if (1 > Math.abs(points[points.length - 1].x - r.x)) {
          points[points.length - 1].x = r.x;
        }
        if (1 > Math.abs(points[points.length - 1].y - r.y)) {
          points[points.length - 1].y = r.y;
        }
      }
      a = points[0];
      /** @type {!Object} */
      var el = node;
      item = ref[0];
      /** @type {boolean} */
      var x = false;
      /** @type {boolean} */
      var y = false;
      x = a;
      if (null != item) {
        /** @type {null} */
        el = null;
      }
      /** @type {number} */
      i = 0;
      for (; 2 > i; i++) {
        /** @type {boolean} */
        var gutterTop = null != item && item.x == x.x;
        /** @type {boolean} */
        var gutterLeft = null != item && item.y == x.y;
        /** @type {boolean} */
        var results = null != el && x.y >= el.y && x.y <= el.y + el.height;
        /** @type {boolean} */
        el = null != el && x.x >= el.x && x.x <= el.x + el.width;
        /** @type {boolean} */
        x = gutterLeft || null == item && results;
        /** @type {boolean} */
        y = gutterTop || null == item && el;
        if (0 != i || !(x && y || gutterTop && gutterLeft)) {
          if (null != item && !gutterLeft && !gutterTop && (results || el)) {
            /** @type {boolean} */
            dir = results ? false : true;
            break;
          }
          if (y || x) {
            /** @type {boolean} */
            dir = x;
            if (1 == i) {
              /** @type {boolean} */
              dir = 0 == points.length % 2 ? x : y;
            }
            break;
          }
        }
        /** @type {!Object} */
        el = e;
        item = ref[j];
        if (null != item) {
          /** @type {null} */
          el = null;
        }
        x = points[points.length - 1];
        if (gutterTop && gutterLeft) {
          /** @type {!Array<?>} */
          points = points.slice(1);
        }
      }
      if (dir && (null != ref[0] && ref[0].y != a.y || null == ref[0] && null != node && (a.y < node.y || a.y > node.y + node.height))) {
        f(new mxPoint(b.x, a.y));
      } else {
        if (!dir && (null != ref[0] && ref[0].x != a.x || null == ref[0] && null != node && (a.x < node.x || a.x > node.x + node.width))) {
          f(new mxPoint(a.x, b.y));
        }
      }
      if (dir) {
        b.y = a.y;
      } else {
        b.x = a.x;
      }
      /** @type {number} */
      i = 0;
      for (; i < points.length; i++) {
        /** @type {boolean} */
        dir = !dir;
        a = points[i];
        if (dir) {
          b.y = a.y;
        } else {
          b.x = a.x;
        }
        f(b.clone());
      }
    } else {
      a = b;
      /** @type {boolean} */
      dir = true;
    }
    b = ref[j];
    if (null == b && null != e) {
      b = new mxPoint(o.view.getRoutingCenterX(e), o.view.getRoutingCenterY(e));
    }
    if (null != b && null != a) {
      if (dir && (null != ref[j] && ref[j].y != a.y || null == ref[j] && null != e && (a.y < e.y || a.y > e.y + e.height))) {
        f(new mxPoint(b.x, a.y));
      } else {
        if (!dir && (null != ref[j] && ref[j].x != a.x || null == ref[j] && null != e && (a.x < e.x || a.x > e.x + e.width))) {
          f(new mxPoint(a.x, b.y));
        }
      }
    }
    if (null == ref[0] && null != node) {
      for (; 1 < path.length && null != path[1] && mxUtils.contains(node, path[1].x, path[1].y);) {
        path.splice(1, 1);
      }
    }
    if (null == ref[j] && null != e) {
      for (; 1 < path.length && null != path[path.length - 1] && mxUtils.contains(e, path[path.length - 1].x, path[path.length - 1].y);) {
        path.splice(path.length - 1, 1);
      }
    }
    if (null != r && null != path[path.length - 1] && 1 >= Math.abs(r.x - path[path.length - 1].x) && 1 >= Math.abs(r.y - path[path.length - 1].y)) {
      path.splice(path.length - 1, 1);
      if (null != path[path.length - 1]) {
        if (1 > Math.abs(path[path.length - 1].x - r.x)) {
          path[path.length - 1].x = r.x;
        }
        if (1 > Math.abs(path[path.length - 1].y - r.y)) {
          path[path.length - 1].y = r.y;
        }
      }
    }
  },
  orthBuffer : 10,
  orthPointsFallback : true,
  dirVectors : [[-1, 0], [0, -1], [1, 0], [0, 1], [-1, 0], [0, -1], [1, 0]],
  wayPoints1 : [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
  routePatterns : [[[513, 2308, 2081, 2562], [513, 1090, 514, 2184, 2114, 2561], [513, 1090, 514, 2564, 2184, 2562], [513, 2308, 2561, 1090, 514, 2568, 2308]], [[514, 1057, 513, 2308, 2081, 2562], [514, 2184, 2114, 2561], [514, 2184, 2562, 1057, 513, 2564, 2184], [514, 1057, 513, 2568, 2308, 2561]], [[1090, 514, 1057, 513, 2308, 2081, 2562], [2114, 2561], [1090, 2562, 1057, 513, 2564, 2184], [1090, 514, 1057, 513, 2308, 2561, 2568]], [[2081, 2562], [1057, 513, 1090, 514, 2184, 2114, 2561], [1057, 
  513, 1090, 514, 2184, 2562, 2564], [1057, 2561, 1090, 514, 2568, 2308]]],
  inlineRoutePatterns : [[null, [2114, 2568], null, null], [null, [514, 2081, 2114, 2568], null, null], [null, [2114, 2561], null, null], [[2081, 2562], [1057, 2114, 2568], [2184, 2562], null]],
  vertexSeperations : [],
  limits : [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]],
  LEFT_MASK : 32,
  TOP_MASK : 64,
  RIGHT_MASK : 128,
  BOTTOM_MASK : 256,
  LEFT : 1,
  TOP : 2,
  RIGHT : 4,
  BOTTOM : 8,
  SIDE_MASK : 480,
  CENTER_MASK : 512,
  SOURCE_MASK : 1024,
  TARGET_MASK : 2048,
  VERTEX_MASK : 3072,
  getJettySize : function(cell, animate) {
    var value = mxUtils.getValue(cell.style, animate ? mxConstants.STYLE_SOURCE_JETTY_SIZE : mxConstants.STYLE_TARGET_JETTY_SIZE, mxUtils.getValue(cell.style, mxConstants.STYLE_JETTY_SIZE, mxEdgeStyle.orthBuffer));
    if ("auto" == value) {
      if (mxUtils.getValue(cell.style, animate ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE) {
        value = mxUtils.getNumber(cell.style, animate ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE);
        /** @type {number} */
        value = Math.max(2, Math.ceil((value + mxEdgeStyle.orthBuffer) / mxEdgeStyle.orthBuffer)) * mxEdgeStyle.orthBuffer;
      } else {
        /** @type {number} */
        value = 2 * mxEdgeStyle.orthBuffer;
      }
    }
    return value;
  },
  scalePointArray : function(bundle, len) {
    /** @type {!Array} */
    var trajectoryStep = [];
    if (null != bundle) {
      /** @type {number} */
      var i = 0;
      for (; i < bundle.length; i++) {
        if (null != bundle[i]) {
          var pt = new mxPoint(Math.round(bundle[i].x / len * 10) / 10, Math.round(bundle[i].y / len * 10) / 10);
          trajectoryStep[i] = pt;
        } else {
          /** @type {null} */
          trajectoryStep[i] = null;
        }
      }
    } else {
      /** @type {null} */
      trajectoryStep = null;
    }
    return trajectoryStep;
  },
  scaleCellState : function(item, scale) {
    var surface;
    if (null != item) {
      surface = item.clone();
      surface.setRect(Math.round(item.x / scale * 10) / 10, Math.round(item.y / scale * 10) / 10, Math.round(item.width / scale * 10) / 10, Math.round(item.height / scale * 10) / 10);
    } else {
      /** @type {null} */
      surface = null;
    }
    return surface;
  },
  OrthConnector : function(b, item, data, on, a) {
    var c = b.view.graph;
    var screenSmallerThanEditor = null == tmp ? false : c.getModel().isEdge(tmp.cell);
    var adjustHeight = null == cell ? false : c.getModel().isEdge(cell.cell);
    c = mxEdgeStyle.scalePointArray(b.absolutePoints, b.view.scale);
    var tmp = mxEdgeStyle.scaleCellState(item, b.view.scale);
    var cell = mxEdgeStyle.scaleCellState(data, b.view.scale);
    var p = c[0];
    var w = c[c.length - 1];
    var a = null != tmp ? tmp.x : p.x;
    var t = null != tmp ? tmp.y : p.y;
    var h = null != tmp ? tmp.width : 0;
    var key = null != tmp ? tmp.height : 0;
    var value = null != cell ? cell.x : w.x;
    var v = null != cell ? cell.y : w.y;
    var minWidth = null != cell ? cell.width : 0;
    var minHeight = null != cell ? cell.height : 0;
    c = mxEdgeStyle.getJettySize(b, true);
    var r = mxEdgeStyle.getJettySize(b, false);
    if (null != tmp && cell == tmp) {
      /** @type {number} */
      c = r = Math.max(c, r);
    }
    var y = r + c;
    /** @type {boolean} */
    var i = false;
    if (null != p && null != w) {
      /** @type {number} */
      i = w.x - p.x;
      /** @type {number} */
      var j = w.y - p.y;
      /** @type {boolean} */
      i = i * i + j * j < y * y;
    }
    if (i || mxEdgeStyle.orthPointsFallback && null != on && 0 < on.length || screenSmallerThanEditor || adjustHeight) {
      mxEdgeStyle.SegmentConnector(b, item, data, on, a);
    } else {
      /** @type {!Array} */
      data = [mxConstants.DIRECTION_MASK_ALL, mxConstants.DIRECTION_MASK_ALL];
      if (null != tmp) {
        data[0] = mxUtils.getPortConstraints(tmp, b, true, mxConstants.DIRECTION_MASK_ALL);
        item = mxUtils.getValue(tmp.style, mxConstants.STYLE_ROTATION, 0);
        if (0 != item) {
          item = mxUtils.getBoundingBox(new mxRectangle(a, t, h, key), item);
          a = item.x;
          t = item.y;
          h = item.width;
          key = item.height;
        }
      }
      if (null != cell) {
        data[1] = mxUtils.getPortConstraints(cell, b, false, mxConstants.DIRECTION_MASK_ALL);
        item = mxUtils.getValue(cell.style, mxConstants.STYLE_ROTATION, 0);
        if (0 != item) {
          item = mxUtils.getBoundingBox(new mxRectangle(value, v, minWidth, minHeight), item);
          value = item.x;
          v = item.y;
          minWidth = item.width;
          minHeight = item.height;
        }
      }
      /** @type {!Array} */
      item = [0, 0];
      /** @type {!Array} */
      a = [[a, t, h, key], [value, v, minWidth, minHeight]];
      /** @type {!Array} */
      r = [c, r];
      /** @type {number} */
      i = 0;
      for (; 2 > i; i++) {
        /** @type {number} */
        mxEdgeStyle.limits[i][1] = a[i][0] - r[i];
        /** @type {number} */
        mxEdgeStyle.limits[i][2] = a[i][1] - r[i];
        mxEdgeStyle.limits[i][4] = a[i][0] + a[i][2] + r[i];
        mxEdgeStyle.limits[i][8] = a[i][1] + a[i][3] + r[i];
      }
      r = a[0][1] + a[0][3] / 2;
      t = a[1][1] + a[1][3] / 2;
      /** @type {number} */
      i = a[0][0] + a[0][2] / 2 - (a[1][0] + a[1][2] / 2);
      /** @type {number} */
      j = r - t;
      /** @type {number} */
      r = 0;
      if (0 > i) {
        /** @type {number} */
        r = 0 > j ? 2 : 1;
      } else {
        if (0 >= j) {
          /** @type {number} */
          r = 3;
          if (0 == i) {
            /** @type {number} */
            r = 2;
          }
        }
      }
      /** @type {null} */
      t = null;
      if (null != tmp) {
        t = p;
      }
      /** @type {!Array} */
      tmp = [[.5, .5], [.5, .5]];
      /** @type {number} */
      i = 0;
      for (; 2 > i; i++) {
        if (null != t) {
          /** @type {number} */
          tmp[i][0] = (t.x - a[i][0]) / a[i][2];
          if (1 >= Math.abs(t.x - a[i][0])) {
            item[i] = mxConstants.DIRECTION_MASK_WEST;
          } else {
            if (1 >= Math.abs(t.x - a[i][0] - a[i][2])) {
              item[i] = mxConstants.DIRECTION_MASK_EAST;
            }
          }
          /** @type {number} */
          tmp[i][1] = (t.y - a[i][1]) / a[i][3];
          if (1 >= Math.abs(t.y - a[i][1])) {
            item[i] = mxConstants.DIRECTION_MASK_NORTH;
          } else {
            if (1 >= Math.abs(t.y - a[i][1] - a[i][3])) {
              item[i] = mxConstants.DIRECTION_MASK_SOUTH;
            }
          }
        }
        /** @type {null} */
        t = null;
        if (null != cell) {
          t = w;
        }
      }
      /** @type {number} */
      i = a[0][1] - (a[1][1] + a[1][3]);
      /** @type {number} */
      w = a[0][0] - (a[1][0] + a[1][2]);
      /** @type {number} */
      t = a[1][1] - (a[0][1] + a[0][3]);
      /** @type {number} */
      h = a[1][0] - (a[0][0] + a[0][2]);
      /** @type {number} */
      mxEdgeStyle.vertexSeperations[1] = Math.max(w - y, 0);
      /** @type {number} */
      mxEdgeStyle.vertexSeperations[2] = Math.max(i - y, 0);
      /** @type {number} */
      mxEdgeStyle.vertexSeperations[4] = Math.max(t - y, 0);
      /** @type {number} */
      mxEdgeStyle.vertexSeperations[3] = Math.max(h - y, 0);
      /** @type {!Array} */
      y = [];
      /** @type {!Array} */
      cell = [];
      /** @type {!Array} */
      p = [];
      cell[0] = w >= h ? mxConstants.DIRECTION_MASK_WEST : mxConstants.DIRECTION_MASK_EAST;
      p[0] = i >= t ? mxConstants.DIRECTION_MASK_NORTH : mxConstants.DIRECTION_MASK_SOUTH;
      cell[1] = mxUtils.reversePortConstraints(cell[0]);
      p[1] = mxUtils.reversePortConstraints(p[0]);
      /** @type {number} */
      w = w >= h ? w : h;
      /** @type {number} */
      t = i >= t ? i : t;
      /** @type {!Array} */
      h = [[0, 0], [0, 0]];
      /** @type {boolean} */
      key = false;
      /** @type {number} */
      i = 0;
      for (; 2 > i; i++) {
        if (0 == item[i]) {
          if (0 == (cell[i] & data[i])) {
            cell[i] = mxUtils.reversePortConstraints(cell[i]);
          }
          if (0 == (p[i] & data[i])) {
            p[i] = mxUtils.reversePortConstraints(p[i]);
          }
          h[i][0] = p[i];
          h[i][1] = cell[i];
        }
      }
      if (0 < t && 0 < w) {
        if (0 < (cell[0] & data[0]) && 0 < (p[1] & data[1])) {
          h[0][0] = cell[0];
          h[0][1] = p[0];
          h[1][0] = p[1];
          h[1][1] = cell[1];
          /** @type {boolean} */
          key = true;
        } else {
          if (0 < (p[0] & data[0]) && 0 < (cell[1] & data[1])) {
            h[0][0] = p[0];
            h[0][1] = cell[0];
            h[1][0] = cell[1];
            h[1][1] = p[1];
            /** @type {boolean} */
            key = true;
          }
        }
      }
      if (0 < t && !key) {
        h[0][0] = p[0];
        h[0][1] = cell[0];
        h[1][0] = p[1];
        h[1][1] = cell[1];
        /** @type {boolean} */
        key = true;
      }
      if (0 < w && !key) {
        h[0][0] = cell[0];
        h[0][1] = p[0];
        h[1][0] = cell[1];
        h[1][1] = p[1];
      }
      /** @type {number} */
      i = 0;
      for (; 2 > i; i++) {
        if (0 == item[i] && (0 == (h[i][0] & data[i]) && (h[i][0] = h[i][1]), y[i] = h[i][0] & data[i], y[i] |= (h[i][1] & data[i]) << 8, y[i] |= (h[1 - i][i] & data[i]) << 16, y[i] |= (h[1 - i][1 - i] & data[i]) << 24, 0 == (y[i] & 15) && (y[i] <<= 8), 0 == (y[i] & 3840) && (y[i] = y[i] & 15 | y[i] >> 8), 0 == (y[i] & 983040) && (y[i] = y[i] & 65535 | (y[i] & 251658240) >> 8), item[i] = y[i] & 15, data[i] == mxConstants.DIRECTION_MASK_WEST || data[i] == mxConstants.DIRECTION_MASK_NORTH || data[i] == 
        mxConstants.DIRECTION_MASK_EAST || data[i] == mxConstants.DIRECTION_MASK_SOUTH)) {
          item[i] = data[i];
        }
      }
      data = item[0] == mxConstants.DIRECTION_MASK_EAST ? 3 : item[0];
      y = item[1] == mxConstants.DIRECTION_MASK_EAST ? 3 : item[1];
      /** @type {number} */
      data = data - r;
      /** @type {number} */
      y = y - r;
      if (1 > data) {
        data = data + 4;
      }
      if (1 > y) {
        y = y + 4;
      }
      data = mxEdgeStyle.routePatterns[data - 1][y - 1];
      mxEdgeStyle.wayPoints1[0][0] = a[0][0];
      mxEdgeStyle.wayPoints1[0][1] = a[0][1];
      switch(item[0]) {
        case mxConstants.DIRECTION_MASK_WEST:
          mxEdgeStyle.wayPoints1[0][0] -= c;
          mxEdgeStyle.wayPoints1[0][1] += tmp[0][1] * a[0][3];
          break;
        case mxConstants.DIRECTION_MASK_SOUTH:
          mxEdgeStyle.wayPoints1[0][0] += tmp[0][0] * a[0][2];
          mxEdgeStyle.wayPoints1[0][1] += a[0][3] + c;
          break;
        case mxConstants.DIRECTION_MASK_EAST:
          mxEdgeStyle.wayPoints1[0][0] += a[0][2] + c;
          mxEdgeStyle.wayPoints1[0][1] += tmp[0][1] * a[0][3];
          break;
        case mxConstants.DIRECTION_MASK_NORTH:
          mxEdgeStyle.wayPoints1[0][0] += tmp[0][0] * a[0][2];
          mxEdgeStyle.wayPoints1[0][1] -= c;
      }
      /** @type {number} */
      c = 0;
      /** @type {number} */
      cell = y = 0 < (item[0] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) ? 0 : 1;
      /** @type {number} */
      i = 0;
      for (; i < data.length; i++) {
        /** @type {number} */
        p = data[i] & 15;
        /** @type {number} */
        key = p == mxConstants.DIRECTION_MASK_EAST ? 3 : p;
        /** @type {number} */
        key = key + r;
        if (4 < key) {
          /** @type {number} */
          key = key - 4;
        }
        w = mxEdgeStyle.dirVectors[key - 1];
        /** @type {number} */
        p = 0 < key % 2 ? 0 : 1;
        if (p != y) {
          c++;
          mxEdgeStyle.wayPoints1[c][0] = mxEdgeStyle.wayPoints1[c - 1][0];
          mxEdgeStyle.wayPoints1[c][1] = mxEdgeStyle.wayPoints1[c - 1][1];
        }
        /** @type {boolean} */
        value = 0 < (data[i] & mxEdgeStyle.TARGET_MASK);
        /** @type {boolean} */
        v = 0 < (data[i] & mxEdgeStyle.SOURCE_MASK);
        /** @type {number} */
        t = (data[i] & mxEdgeStyle.SIDE_MASK) >> 5;
        /** @type {number} */
        t = t << r;
        if (15 < t) {
          /** @type {number} */
          t = t >> 4;
        }
        /** @type {boolean} */
        h = 0 < (data[i] & mxEdgeStyle.CENTER_MASK);
        if ((v || value) && 9 > t) {
          /** @type {number} */
          key = v ? 0 : 1;
          t = h && 0 == p ? a[key][0] + tmp[key][0] * a[key][2] : h ? a[key][1] + tmp[key][1] * a[key][3] : mxEdgeStyle.limits[key][t];
          if (0 == p) {
            /** @type {number} */
            t = (t - mxEdgeStyle.wayPoints1[c][0]) * w[0];
            if (0 < t) {
              mxEdgeStyle.wayPoints1[c][0] += w[0] * t;
            }
          } else {
            /** @type {number} */
            t = (t - mxEdgeStyle.wayPoints1[c][1]) * w[1];
            if (0 < t) {
              mxEdgeStyle.wayPoints1[c][1] += w[1] * t;
            }
          }
        } else {
          if (h) {
            mxEdgeStyle.wayPoints1[c][0] += w[0] * Math.abs(mxEdgeStyle.vertexSeperations[key] / 2);
            mxEdgeStyle.wayPoints1[c][1] += w[1] * Math.abs(mxEdgeStyle.vertexSeperations[key] / 2);
          }
        }
        if (0 < c && mxEdgeStyle.wayPoints1[c][p] == mxEdgeStyle.wayPoints1[c - 1][p]) {
          c--;
        } else {
          /** @type {number} */
          y = p;
        }
      }
      /** @type {number} */
      i = 0;
      for (; i <= c && (i != c || ((0 < (item[1] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) ? 0 : 1) == cell ? 0 : 1) == (c + 1) % 2); i++) {
        a.push(new mxPoint(Math.round(mxEdgeStyle.wayPoints1[i][0] * b.view.scale * 10) / 10, Math.round(mxEdgeStyle.wayPoints1[i][1] * b.view.scale * 10) / 10));
      }
      /** @type {number} */
      b = 1;
      for (; b < a.length;) {
        if (null == a[b - 1] || null == a[b] || a[b - 1].x != a[b].x || a[b - 1].y != a[b].y) {
          b++;
        } else {
          a.splice(b, 1);
        }
      }
    }
  },
  getRoutePattern : function(index, length, latSidePrev, lonSidePrev) {
    var newEnd = index[0] == mxConstants.DIRECTION_MASK_EAST ? 3 : index[0];
    index = index[1] == mxConstants.DIRECTION_MASK_EAST ? 3 : index[1];
    /** @type {number} */
    newEnd = newEnd - length;
    /** @type {number} */
    index = index - length;
    if (1 > newEnd) {
      newEnd = newEnd + 4;
    }
    if (1 > index) {
      index = index + 4;
    }
    length = routePatterns[newEnd - 1][index - 1];
    if (!(0 != latSidePrev && 0 != lonSidePrev || null == inlineRoutePatterns[newEnd - 1][index - 1])) {
      length = inlineRoutePatterns[newEnd - 1][index - 1];
    }
    return length;
  }
};
var mxStyleRegistry = {
  values : [],
  putValue : function(index, value) {
    /** @type {!Object} */
    mxStyleRegistry.values[index] = value;
  },
  getValue : function(o) {
    return mxStyleRegistry.values[o];
  },
  getName : function(value) {
    var name;
    for (name in mxStyleRegistry.values) {
      if (mxStyleRegistry.values[name] == value) {
        return name;
      }
    }
    return null;
  }
};
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ELBOW, mxEdgeStyle.ElbowConnector);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ENTITY_RELATION, mxEdgeStyle.EntityRelation);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_LOOP, mxEdgeStyle.Loop);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_SIDETOSIDE, mxEdgeStyle.SideToSide);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_TOPTOBOTTOM, mxEdgeStyle.TopToBottom);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ORTHOGONAL, mxEdgeStyle.OrthConnector);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_SEGMENT, mxEdgeStyle.SegmentConnector);
mxStyleRegistry.putValue(mxConstants.PERIMETER_ELLIPSE, mxPerimeter.EllipsePerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_RECTANGLE, mxPerimeter.RectanglePerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_RHOMBUS, mxPerimeter.RhombusPerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_TRIANGLE, mxPerimeter.TrianglePerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_HEXAGON, mxPerimeter.HexagonPerimeter);
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxGraphView(targetGraph) {
  /** @type {!Object} */
  this.graph = targetGraph;
  this.translate = new mxPoint;
  this.graphBounds = new mxRectangle;
  this.states = new mxDictionary;
}
mxGraphView.prototype = new mxEventSource;
/** @type {function(!Object): undefined} */
mxGraphView.prototype.constructor = mxGraphView;
mxGraphView.prototype.EMPTY_POINT = new mxPoint;
/** @type {string} */
mxGraphView.prototype.doneResource = "none" != mxClient.language ? "done" : "";
/** @type {string} */
mxGraphView.prototype.updatingDocumentResource = "none" != mxClient.language ? "updatingDocument" : "";
/** @type {boolean} */
mxGraphView.prototype.allowEval = false;
/** @type {boolean} */
mxGraphView.prototype.captureDocumentGesture = true;
/** @type {boolean} */
mxGraphView.prototype.optimizeVmlReflows = true;
/** @type {boolean} */
mxGraphView.prototype.rendering = true;
/** @type {null} */
mxGraphView.prototype.graph = null;
/** @type {null} */
mxGraphView.prototype.currentRoot = null;
/** @type {null} */
mxGraphView.prototype.graphBounds = null;
/** @type {number} */
mxGraphView.prototype.scale = 1;
/** @type {null} */
mxGraphView.prototype.translate = null;
/** @type {null} */
mxGraphView.prototype.states = null;
/** @type {boolean} */
mxGraphView.prototype.updateStyle = false;
/** @type {null} */
mxGraphView.prototype.lastNode = null;
/** @type {null} */
mxGraphView.prototype.lastHtmlNode = null;
/** @type {null} */
mxGraphView.prototype.lastForegroundNode = null;
/** @type {null} */
mxGraphView.prototype.lastForegroundHtmlNode = null;
/**
 * @return {?}
 */
mxGraphView.prototype.getGraphBounds = function() {
  return this.graphBounds;
};
/**
 * @param {!AudioNode} a
 * @return {undefined}
 */
mxGraphView.prototype.setGraphBounds = function(a) {
  /** @type {!AudioNode} */
  this.graphBounds = a;
};
/**
 * @param {!Object} b
 * @return {?}
 */
mxGraphView.prototype.getBounds = function(b) {
  /** @type {null} */
  var bounds = null;
  if (null != b && 0 < b.length) {
    var V = this.graph.getModel();
    /** @type {number} */
    var i = 0;
    for (; i < b.length; i++) {
      if (V.isVertex(b[i]) || V.isEdge(b[i])) {
        var current = this.getState(b[i]);
        if (null != current) {
          if (null == bounds) {
            bounds = mxRectangle.fromRectangle(current);
          } else {
            bounds.add(current);
          }
        }
      }
    }
  }
  return bounds;
};
/**
 * @param {string} data
 * @return {?}
 */
mxGraphView.prototype.setCurrentRoot = function(data) {
  if (this.currentRoot != data) {
    var j = new mxCurrentRootChange(this, data);
    j.execute();
    var vLinks = new mxUndoableEdit(this, true);
    vLinks.add(j);
    this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", vLinks));
    this.graph.sizeDidChange();
  }
  return data;
};
/**
 * @param {string} data
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxGraphView.prototype.scaleAndTranslate = function(data, x, y) {
  var backupScale = this.scale;
  var ct = new mxPoint(this.translate.x, this.translate.y);
  if (this.scale != data || this.translate.x != x || this.translate.y != y) {
    /** @type {string} */
    this.scale = data;
    /** @type {number} */
    this.translate.x = x;
    /** @type {number} */
    this.translate.y = y;
    if (this.isEventsEnabled()) {
      this.viewStateChanged();
    }
  }
  this.fireEvent(new mxEventObject(mxEvent.SCALE_AND_TRANSLATE, "scale", data, "previousScale", backupScale, "translate", this.translate, "previousTranslate", ct));
};
/**
 * @return {?}
 */
mxGraphView.prototype.getScale = function() {
  return this.scale;
};
/**
 * @param {number} val
 * @return {undefined}
 */
mxGraphView.prototype.setScale = function(val) {
  var backupScale = this.scale;
  if (this.scale != val) {
    /** @type {number} */
    this.scale = val;
    if (this.isEventsEnabled()) {
      this.viewStateChanged();
    }
  }
  this.fireEvent(new mxEventObject(mxEvent.SCALE, "scale", val, "previousScale", backupScale));
};
/**
 * @return {?}
 */
mxGraphView.prototype.getTranslate = function() {
  return this.translate;
};
/**
 * @param {number} x
 * @param {number} value
 * @return {undefined}
 */
mxGraphView.prototype.setTranslate = function(x, value) {
  var ct = new mxPoint(this.translate.x, this.translate.y);
  if (this.translate.x != x || this.translate.y != value) {
    /** @type {number} */
    this.translate.x = x;
    /** @type {number} */
    this.translate.y = value;
    if (this.isEventsEnabled()) {
      this.viewStateChanged();
    }
  }
  this.fireEvent(new mxEventObject(mxEvent.TRANSLATE, "translate", this.translate, "previousTranslate", ct));
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.viewStateChanged = function() {
  this.revalidate();
  this.graph.sizeDidChange();
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.refresh = function() {
  if (null != this.currentRoot) {
    this.clear();
  }
  this.revalidate();
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.revalidate = function() {
  this.invalidate();
  this.validate();
};
/**
 * @param {string} index
 * @param {string} height
 * @param {number} position
 * @return {undefined}
 */
mxGraphView.prototype.clear = function(index, height, position) {
  var self = this.graph.getModel();
  index = index || self.getRoot();
  height = null != height ? height : false;
  position = null != position ? position : true;
  this.removeState(index);
  if (position && (height || index != this.currentRoot)) {
    position = self.getChildCount(index);
    /** @type {number} */
    var i = 0;
    for (; i < position; i++) {
      this.clear(self.getChildAt(index, i), height);
    }
  } else {
    this.invalidate(index);
  }
};
/**
 * @param {!Object} x
 * @param {?} y
 * @param {?} data
 * @return {undefined}
 */
mxGraphView.prototype.invalidate = function(x, y, data) {
  var self = this.graph.getModel();
  x = x || self.getRoot();
  y = null != y ? y : true;
  data = null != data ? data : true;
  var i = this.getState(x);
  if (null != i) {
    /** @type {boolean} */
    i.invalid = true;
  }
  if (!x.invalidating) {
    /** @type {boolean} */
    x.invalidating = true;
    if (y) {
      var f = self.getChildCount(x);
      /** @type {number} */
      i = 0;
      for (; i < f; i++) {
        var idx = self.getChildAt(x, i);
        this.invalidate(idx, y, data);
      }
    }
    if (data) {
      f = self.getEdgeCount(x);
      /** @type {number} */
      i = 0;
      for (; i < f; i++) {
        this.invalidate(self.getEdgeAt(x, i), y, data);
      }
    }
    delete x.invalidating;
  }
};
/**
 * @param {string} returnTuples
 * @return {undefined}
 */
mxGraphView.prototype.validate = function(returnTuples) {
  var left = mxLog.enter("mxGraphView.validate");
  window.status = mxResources.get(this.updatingDocumentResource) || this.updatingDocumentResource;
  this.resetValidationState();
  /** @type {null} */
  var display = null;
  if (this.optimizeVmlReflows && null != this.canvas && null == this.textDiv && (8 == document.documentMode && !mxClient.IS_EM || mxClient.IS_QUIRKS)) {
    /** @type {!Element} */
    this.placeholder = document.createElement("div");
    /** @type {string} */
    this.placeholder.style.position = "absolute";
    /** @type {string} */
    this.placeholder.style.width = this.canvas.clientWidth + "px";
    /** @type {string} */
    this.placeholder.style.height = this.canvas.clientHeight + "px";
    this.canvas.parentNode.appendChild(this.placeholder);
    display = this.drawPane.style.display;
    /** @type {string} */
    this.canvas.style.display = "none";
    /** @type {!Element} */
    this.textDiv = document.createElement("div");
    /** @type {string} */
    this.textDiv.style.position = "absolute";
    /** @type {string} */
    this.textDiv.style.whiteSpace = "nowrap";
    /** @type {string} */
    this.textDiv.style.visibility = "hidden";
    /** @type {string} */
    this.textDiv.style.display = mxClient.IS_QUIRKS ? "inline" : "inline-block";
    /** @type {string} */
    this.textDiv.style.zoom = "1";
    document.body.appendChild(this.textDiv);
  }
  returnTuples = this.getBoundingBox(this.validateCellState(this.validateCell(returnTuples || (null != this.currentRoot ? this.currentRoot : this.graph.getModel().getRoot()))));
  this.setGraphBounds(null != returnTuples ? returnTuples : this.getEmptyBounds());
  this.validateBackground();
  if (null != display) {
    this.canvas.style.display = display;
    this.textDiv.parentNode.removeChild(this.textDiv);
    if (null != this.placeholder) {
      this.placeholder.parentNode.removeChild(this.placeholder);
    }
    /** @type {null} */
    this.textDiv = null;
  }
  this.resetValidationState();
  window.status = mxResources.get(this.doneResource) || this.doneResource;
  mxLog.leave("mxGraphView.validate", left);
};
/**
 * @return {?}
 */
mxGraphView.prototype.getEmptyBounds = function() {
  return new mxRectangle(this.translate.x * this.scale, this.translate.y * this.scale);
};
/**
 * @param {!Object} o
 * @param {?} type
 * @return {?}
 */
mxGraphView.prototype.getBoundingBox = function(o, type) {
  type = null != type ? type : true;
  /** @type {null} */
  var box = null;
  if (null != o && (null != o.shape && null != o.shape.boundingBox && (box = o.shape.boundingBox.clone()), null != o.text && null != o.text.boundingBox && (null != box ? box.add(o.text.boundingBox) : box = o.text.boundingBox.clone()), type)) {
    var node = this.graph.getModel();
    var cell_amount = node.getChildCount(o.cell);
    /** @type {number} */
    var i = 0;
    for (; i < cell_amount; i++) {
      var b = this.getBoundingBox(this.getState(node.getChildAt(o.cell, i)));
      if (null != b) {
        if (null == box) {
          box = b;
        } else {
          box.add(b);
        }
      }
    }
  }
  return box;
};
/**
 * @param {string} bounds
 * @return {?}
 */
mxGraphView.prototype.createBackgroundPageShape = function(bounds) {
  return new mxRectangleShape(bounds, "white", "black");
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.validateBackground = function() {
  this.validateBackgroundImage();
  this.validateBackgroundPage();
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.validateBackgroundImage = function() {
  var bg = this.graph.getBackgroundImage();
  if (null != bg) {
    if (null == this.backgroundImage || this.backgroundImage.image != bg.src) {
      if (null != this.backgroundImage) {
        this.backgroundImage.destroy();
      }
      var bounds = new mxRectangle(0, 0, 1, 1);
      this.backgroundImage = new mxImageShape(bounds, bg.src);
      this.backgroundImage.dialect = this.graph.dialect;
      this.backgroundImage.init(this.backgroundPane);
      this.backgroundImage.redraw();
      if (!(8 != document.documentMode || mxClient.IS_EM)) {
        mxEvent.addGestureListeners(this.backgroundImage.node, mxUtils.bind(this, function(evt) {
          this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
        }), mxUtils.bind(this, function(evt) {
          this.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
        }), mxUtils.bind(this, function(evt) {
          this.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
        }));
      }
    }
    this.redrawBackgroundImage(this.backgroundImage, bg);
  } else {
    if (null != this.backgroundImage) {
      this.backgroundImage.destroy();
      /** @type {null} */
      this.backgroundImage = null;
    }
  }
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.validateBackgroundPage = function() {
  if (this.graph.pageVisible) {
    var bounds = this.getBackgroundPageBounds();
    if (null == this.backgroundPageShape) {
      this.backgroundPageShape = this.createBackgroundPageShape(bounds);
      this.backgroundPageShape.scale = this.scale;
      /** @type {boolean} */
      this.backgroundPageShape.isShadow = true;
      this.backgroundPageShape.dialect = this.graph.dialect;
      this.backgroundPageShape.init(this.backgroundPane);
      this.backgroundPageShape.redraw();
      if (this.graph.nativeDblClickEnabled) {
        mxEvent.addListener(this.backgroundPageShape.node, "dblclick", mxUtils.bind(this, function(evt) {
          this.graph.dblClick(evt);
        }));
      }
      mxEvent.addGestureListeners(this.backgroundPageShape.node, mxUtils.bind(this, function(evt) {
        this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
      }), mxUtils.bind(this, function(evt) {
        if (null != this.graph.tooltipHandler && this.graph.tooltipHandler.isHideOnHover()) {
          this.graph.tooltipHandler.hide();
        }
        if (this.graph.isMouseDown && !mxEvent.isConsumed(evt)) {
          this.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
        }
      }), mxUtils.bind(this, function(evt) {
        this.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
      }));
    } else {
      this.backgroundPageShape.scale = this.scale;
      this.backgroundPageShape.bounds = bounds;
      this.backgroundPageShape.redraw();
    }
  } else {
    if (null != this.backgroundPageShape) {
      this.backgroundPageShape.destroy();
      /** @type {null} */
      this.backgroundPageShape = null;
    }
  }
};
/**
 * @return {?}
 */
mxGraphView.prototype.getBackgroundPageBounds = function() {
  var fmt = this.graph.pageFormat;
  /** @type {number} */
  var ps = this.scale * this.graph.pageScale;
  return new mxRectangle(this.scale * this.translate.x, this.scale * this.translate.y, fmt.width * ps, fmt.height * ps);
};
/**
 * @param {!Object} group
 * @param {!Object} img
 * @return {undefined}
 */
mxGraphView.prototype.redrawBackgroundImage = function(group, img) {
  group.scale = this.scale;
  /** @type {number} */
  group.bounds.x = this.scale * this.translate.x;
  /** @type {number} */
  group.bounds.y = this.scale * this.translate.y;
  /** @type {number} */
  group.bounds.width = this.scale * img.width;
  /** @type {number} */
  group.bounds.height = this.scale * img.height;
  group.redraw();
};
/**
 * @param {(Object|string)} cell
 * @param {?} value
 * @return {?}
 */
mxGraphView.prototype.validateCell = function(cell, value) {
  if (null != cell) {
    if (value = (null != value ? value : true) && this.graph.isCellVisible(cell), null == this.getState(cell, value) || value) {
      var self = this.graph.getModel();
      var childCount = self.getChildCount(cell);
      /** @type {number} */
      var i = 0;
      for (; i < childCount; i++) {
        this.validateCell(self.getChildAt(cell, i), value && (!this.isCellCollapsed(cell) || cell == this.currentRoot));
      }
    } else {
      this.removeState(cell);
    }
  }
  return cell;
};
/**
 * @param {string} i
 * @param {?} count
 * @return {?}
 */
mxGraphView.prototype.validateCellState = function(i, count) {
  count = null != count ? count : true;
  /** @type {null} */
  var data = null;
  if (null != i && (data = this.getState(i), null != data)) {
    var menu = this.graph.getModel();
    if (data.invalid) {
      /** @type {boolean} */
      data.invalid = false;
      if (null == data.style || data.invalidStyle) {
        data.style = this.graph.getCellStyle(data.cell);
        /** @type {boolean} */
        data.invalidStyle = false;
      }
      if (i != this.currentRoot) {
        this.validateCellState(menu.getParent(i), false);
      }
      data.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(i, true), false), true);
      data.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(i, false), false), false);
      this.updateCellState(data);
      if (!(i == this.currentRoot || data.invalid)) {
        this.graph.cellRenderer.redraw(data, false, this.isRendering());
        data.updateCachedBounds();
      }
    }
    if (count && !data.invalid) {
      if (null != data.shape) {
        this.stateValidated(data);
      }
      var $sendIcon = menu.getChildCount(i);
      /** @type {number} */
      var y = 0;
      for (; y < $sendIcon; y++) {
        this.validateCellState(menu.getChildAt(i, y));
      }
    }
  }
  return data;
};
/**
 * @param {!Object} node
 * @return {undefined}
 */
mxGraphView.prototype.updateCellState = function(node) {
  /** @type {number} */
  node.absoluteOffset.x = 0;
  /** @type {number} */
  node.absoluteOffset.y = 0;
  /** @type {number} */
  node.origin.x = 0;
  /** @type {number} */
  node.origin.y = 0;
  /** @type {number} */
  node.length = 0;
  if (node.cell != this.currentRoot) {
    var exports = this.graph.getModel();
    var t = this.getState(exports.getParent(node.cell));
    if (null != t && t.cell != this.currentRoot) {
      node.origin.x += t.origin.x;
      node.origin.y += t.origin.y;
    }
    var point = this.graph.getChildOffsetForCell(node.cell);
    if (null != point) {
      node.origin.x += point.x;
      node.origin.y += point.y;
    }
    var b = this.graph.getCellGeometry(node.cell);
    if (null != b) {
      if (!exports.isEdge(node.cell)) {
        point = null != b.offset ? b.offset : this.EMPTY_POINT;
        if (b.relative && null != t) {
          if (exports.isEdge(t.cell)) {
            point = this.getPoint(t, b);
            if (null != point) {
              node.origin.x += point.x / this.scale - t.origin.x - this.translate.x;
              node.origin.y += point.y / this.scale - t.origin.y - this.translate.y;
            }
          } else {
            node.origin.x += b.x * t.unscaledWidth + point.x;
            node.origin.y += b.y * t.unscaledHeight + point.y;
          }
        } else {
          /** @type {number} */
          node.absoluteOffset.x = this.scale * point.x;
          /** @type {number} */
          node.absoluteOffset.y = this.scale * point.y;
          node.origin.x += b.x;
          node.origin.y += b.y;
        }
      }
      /** @type {number} */
      node.x = this.scale * (this.translate.x + node.origin.x);
      /** @type {number} */
      node.y = this.scale * (this.translate.y + node.origin.y);
      /** @type {number} */
      node.width = this.scale * b.width;
      node.unscaledWidth = b.width;
      /** @type {number} */
      node.height = this.scale * b.height;
      node.unscaledHeight = b.height;
      if (exports.isVertex(node.cell)) {
        this.updateVertexState(node, b);
      }
      if (exports.isEdge(node.cell)) {
        this.updateEdgeState(node, b);
      }
    }
  }
  node.updateCachedBounds();
};
/**
 * @param {!Object} obj
 * @return {?}
 */
mxGraphView.prototype.isCellCollapsed = function(obj) {
  return this.graph.isCellCollapsed(obj);
};
/**
 * @param {!Object} self
 * @param {!Map} c
 * @return {undefined}
 */
mxGraphView.prototype.updateVertexState = function(self, c) {
  var data = this.graph.getModel();
  var s = this.getState(data.getParent(self.cell));
  if (c.relative && null != s && !data.isEdge(s.cell)) {
    var i = mxUtils.toRadians(s.style[mxConstants.STYLE_ROTATION] || "0");
    if (0 != i) {
      /** @type {number} */
      data = Math.cos(i);
      /** @type {number} */
      i = Math.sin(i);
      var pt = new mxPoint(self.getCenterX(), self.getCenterY());
      s = new mxPoint(s.getCenterX(), s.getCenterY());
      s = mxUtils.getRotatedPoint(pt, data, i, s);
      /** @type {number} */
      self.x = s.x - self.width / 2;
      /** @type {number} */
      self.y = s.y - self.height / 2;
    }
  }
  this.updateVertexLabelOffset(self);
};
/**
 * @param {!Object} e
 * @param {!Object} key
 * @return {undefined}
 */
mxGraphView.prototype.updateEdgeState = function(e, key) {
  var c = e.getVisibleTerminalState(true);
  var d = e.getVisibleTerminalState(false);
  if (null != this.graph.model.getTerminal(e.cell, true) && null == c || null == c && null == key.getTerminalPoint(true) || null != this.graph.model.getTerminal(e.cell, false) && null == d || null == d && null == key.getTerminalPoint(false)) {
    this.clear(e.cell, true);
  } else {
    this.updateFixedTerminalPoints(e, c, d);
    this.updatePoints(e, key.points, c, d);
    this.updateFloatingTerminalPoints(e, c, d);
    c = e.absolutePoints;
    if (e.cell != this.currentRoot && (null == c || 2 > c.length || null == c[0] || null == c[c.length - 1])) {
      this.clear(e.cell, true);
    } else {
      this.updateEdgeBounds(e);
      this.updateEdgeLabelOffset(e);
    }
  }
};
/**
 * @param {!Object} options
 * @return {undefined}
 */
mxGraphView.prototype.updateVertexLabelOffset = function(options) {
  var align = mxUtils.getValue(options.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
  if (align == mxConstants.ALIGN_LEFT) {
    align = mxUtils.getValue(options.style, mxConstants.STYLE_LABEL_WIDTH, null);
    align = null != align ? align * this.scale : options.width;
    options.absoluteOffset.x -= align;
  } else {
    if (align == mxConstants.ALIGN_RIGHT) {
      options.absoluteOffset.x += options.width;
    } else {
      if (align == mxConstants.ALIGN_CENTER && (align = mxUtils.getValue(options.style, mxConstants.STYLE_LABEL_WIDTH, null), null != align)) {
        var align = mxUtils.getValue(options.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER);
        /** @type {number} */
        var delta = 0;
        if (align == mxConstants.ALIGN_CENTER) {
          /** @type {number} */
          delta = .5;
        } else {
          if (align == mxConstants.ALIGN_RIGHT) {
            /** @type {number} */
            delta = 1;
          }
        }
        if (0 != delta) {
          options.absoluteOffset.x -= (align * this.scale - options.width) * delta;
        }
      }
    }
  }
  align = mxUtils.getValue(options.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
  if (align == mxConstants.ALIGN_TOP) {
    options.absoluteOffset.y -= options.height;
  } else {
    if (align == mxConstants.ALIGN_BOTTOM) {
      options.absoluteOffset.y += options.height;
    }
  }
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.resetValidationState = function() {
  /** @type {null} */
  this.lastForegroundHtmlNode = this.lastForegroundNode = this.lastHtmlNode = this.lastNode = null;
};
/**
 * @param {!Object} tmp
 * @return {undefined}
 */
mxGraphView.prototype.stateValidated = function(tmp) {
  var b = this.graph.getModel().isEdge(tmp.cell) && this.graph.keepEdgesInForeground || this.graph.getModel().isVertex(tmp.cell) && this.graph.keepEdgesInBackground;
  tmp = this.graph.cellRenderer.insertStateAfter(tmp, b ? this.lastForegroundNode || this.lastNode : this.lastNode, b ? this.lastForegroundHtmlNode || this.lastHtmlNode : this.lastHtmlNode);
  if (b) {
    this.lastForegroundHtmlNode = tmp[1];
    this.lastForegroundNode = tmp[0];
  } else {
    this.lastHtmlNode = tmp[1];
    this.lastNode = tmp[0];
  }
};
/**
 * @param {!Object} el
 * @param {(Object|string)} value
 * @param {(Object|string)} label
 * @return {undefined}
 */
mxGraphView.prototype.updateFixedTerminalPoints = function(el, value, label) {
  this.updateFixedTerminalPoint(el, value, true, this.graph.getConnectionConstraint(el, value, true));
  this.updateFixedTerminalPoint(el, label, false, this.graph.getConnectionConstraint(el, label, false));
};
/**
 * @param {!Object} a
 * @param {?} val
 * @param {boolean} x
 * @param {!Object} key
 * @return {undefined}
 */
mxGraphView.prototype.updateFixedTerminalPoint = function(a, val, x, key) {
  a.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(a, val, x, key), x);
};
/**
 * @param {!Object} data
 * @param {!Object} name
 * @param {boolean} url
 * @param {!Object} t
 * @return {?}
 */
mxGraphView.prototype.getFixedTerminalPoint = function(data, name, url, t) {
  /** @type {null} */
  var s = null;
  if (null != t) {
    s = this.graph.getConnectionPoint(name, t, false);
  }
  if (null == s && null == name) {
    name = this.scale;
    t = this.translate;
    var position = data.origin;
    s = this.graph.getCellGeometry(data.cell).getTerminalPoint(url);
    if (null != s) {
      s = new mxPoint(name * (t.x + s.x + position.x), name * (t.y + s.y + position.y));
    }
  }
  return s;
};
/**
 * @param {!Object} rect
 * @return {?}
 */
mxGraphView.prototype.updateBoundsFromStencil = function(rect) {
  /** @type {null} */
  var blackrects = null;
  if (null != rect && null != rect.shape && null != rect.shape.stencil && "fixed" == rect.shape.stencil.aspect) {
    blackrects = mxRectangle.fromRectangle(rect);
    var startPosition = rect.shape.stencil.computeAspect(rect.style, rect.x, rect.y, rect.width, rect.height);
    rect.setRect(startPosition.x, startPosition.y, rect.shape.stencil.w0 * startPosition.width, rect.shape.stencil.h0 * startPosition.height);
  }
  return blackrects;
};
/**
 * @param {!Object} o
 * @param {!Object} value
 * @param {?} c
 * @param {!Object} s
 * @return {undefined}
 */
mxGraphView.prototype.updatePoints = function(o, value, c, s) {
  if (null != o) {
    /** @type {!Array} */
    var result = [];
    result.push(o.absolutePoints[0]);
    var i = this.getEdgeStyle(o, value, c, s);
    if (null != i) {
      c = this.getTerminalPort(o, c, true);
      s = this.getTerminalPort(o, s, false);
      var b = this.updateBoundsFromStencil(c);
      var p = this.updateBoundsFromStencil(s);
      i(o, c, s, value, result);
      if (null != b) {
        c.setRect(b.x, b.y, b.width, b.height);
      }
      if (null != p) {
        s.setRect(p.x, p.y, p.width, p.height);
      }
    } else {
      if (null != value) {
        /** @type {number} */
        i = 0;
        for (; i < value.length; i++) {
          if (null != value[i]) {
            c = mxUtils.clone(value[i]);
            result.push(this.transformControlPoint(o, c));
          }
        }
      }
    }
    value = o.absolutePoints;
    result.push(value[value.length - 1]);
    /** @type {!Array} */
    o.absolutePoints = result;
  }
};
/**
 * @param {!Object} a
 * @param {!Object} b
 * @param {number} o
 * @return {?}
 */
mxGraphView.prototype.transformControlPoint = function(a, b, o) {
  return null != a && null != b ? (a = a.origin, o = o ? 1 : this.scale, new mxPoint(o * (b.x + this.translate.x + a.x), o * (b.y + this.translate.y + a.y))) : null;
};
/**
 * @param {!Object} s
 * @param {string} t
 * @param {!Object} i
 * @param {!Object} value
 * @return {?}
 */
mxGraphView.prototype.isLoopStyleEnabled = function(s, t, i, value) {
  var center = this.graph.getConnectionConstraint(s, i, true);
  var r = this.graph.getConnectionConstraint(s, value, false);
  return !(null == t || 2 > t.length) || mxUtils.getValue(s.style, mxConstants.STYLE_ORTHOGONAL_LOOP, false) && (null != center && null != center.point || null != r && null != r.point) ? false : null != i && i == value;
};
/**
 * @param {!Object} n
 * @param {string} s
 * @param {!Object} k
 * @param {!Object} d
 * @return {?}
 */
mxGraphView.prototype.getEdgeStyle = function(n, s, k, d) {
  n = this.isLoopStyleEnabled(n, s, k, d) ? mxUtils.getValue(n.style, mxConstants.STYLE_LOOP, this.graph.defaultLoopStyle) : mxUtils.getValue(n.style, mxConstants.STYLE_NOEDGESTYLE, false) ? null : n.style[mxConstants.STYLE_EDGE];
  if ("string" == typeof n) {
    s = mxStyleRegistry.getValue(n);
    if (null == s && this.isAllowEval()) {
      s = mxUtils.eval(n);
    }
    /** @type {string} */
    n = s;
  }
  return "function" == typeof n ? n : null;
};
/**
 * @param {!Object} props
 * @param {number} input
 * @param {number} x
 * @return {undefined}
 */
mxGraphView.prototype.updateFloatingTerminalPoints = function(props, input, x) {
  var values = props.absolutePoints;
  var notes_mac = values[0];
  if (null == values[values.length - 1] && null != x) {
    this.updateFloatingTerminalPoint(props, x, input, false);
  }
  if (null == notes_mac && null != input) {
    this.updateFloatingTerminalPoint(props, input, x, true);
  }
};
/**
 * @param {!Object} a
 * @param {number} v
 * @param {number} n
 * @param {boolean} t
 * @return {undefined}
 */
mxGraphView.prototype.updateFloatingTerminalPoint = function(a, v, n, t) {
  a.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(a, v, n, t), t);
};
/**
 * @param {!Object} result
 * @param {!Object} state
 * @param {number} r
 * @param {boolean} s
 * @return {?}
 */
mxGraphView.prototype.getFloatingTerminalPoint = function(result, state, r, s) {
  state = this.getTerminalPort(result, state, s);
  var pt = this.getNextPoint(result, r, s);
  var resultCmp = this.graph.isOrthogonal(result);
  r = mxUtils.toRadians(Number(state.style[mxConstants.STYLE_ROTATION] || "0"));
  var ct = new mxPoint(state.getCenterX(), state.getCenterY());
  if (0 != r) {
    /** @type {number} */
    var i = Math.cos(-r);
    /** @type {number} */
    var sin = Math.sin(-r);
    pt = mxUtils.getRotatedPoint(pt, i, sin, ct);
  }
  /** @type {number} */
  i = parseFloat(result.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);
  /** @type {number} */
  i = i + parseFloat(result.style[s ? mxConstants.STYLE_SOURCE_PERIMETER_SPACING : mxConstants.STYLE_TARGET_PERIMETER_SPACING] || 0);
  result = this.getPerimeterPoint(state, pt, 0 == r && resultCmp, i);
  if (0 != r) {
    /** @type {number} */
    i = Math.cos(r);
    /** @type {number} */
    sin = Math.sin(r);
    result = mxUtils.getRotatedPoint(result, i, sin, ct);
  }
  return result;
};
/**
 * @param {!Object} o
 * @param {!Object} label
 * @param {boolean} service
 * @return {?}
 */
mxGraphView.prototype.getTerminalPort = function(o, label, service) {
  o = mxUtils.getValue(o.style, service ? mxConstants.STYLE_SOURCE_PORT : mxConstants.STYLE_TARGET_PORT);
  if (null != o) {
    o = this.getState(this.graph.getModel().getCell(o));
    if (null != o) {
      /** @type {!Object} */
      label = o;
    }
  }
  return label;
};
/**
 * @param {!Object} s
 * @param {!Object} point
 * @param {boolean} options
 * @param {number} val
 * @return {?}
 */
mxGraphView.prototype.getPerimeterPoint = function(s, point, options, val) {
  /** @type {null} */
  var res = null;
  if (null != s) {
    var parse = this.getPerimeterFunction(s);
    if (null != parse && null != point && (val = this.getPerimeterBounds(s, val), 0 < val.width || 0 < val.height)) {
      res = new mxPoint(point.x, point.y);
      /** @type {boolean} */
      var r = point = false;
      if (this.graph.model.isVertex(s.cell)) {
        /** @type {boolean} */
        point = 1 == mxUtils.getValue(s.style, mxConstants.STYLE_FLIPH, 0);
        /** @type {boolean} */
        r = 1 == mxUtils.getValue(s.style, mxConstants.STYLE_FLIPV, 0);
        if (null != s.shape && null != s.shape.stencil) {
          /** @type {boolean} */
          point = 1 == mxUtils.getValue(s.style, "stencilFlipH", 0) || point;
          /** @type {boolean} */
          r = 1 == mxUtils.getValue(s.style, "stencilFlipV", 0) || r;
        }
        if (point) {
          /** @type {number} */
          res.x = 2 * val.getCenterX() - res.x;
        }
        if (r) {
          /** @type {number} */
          res.y = 2 * val.getCenterY() - res.y;
        }
      }
      res = parse(val, s, res, options);
      if (null != res) {
        if (point) {
          /** @type {number} */
          res.x = 2 * val.getCenterX() - res.x;
        }
        if (r) {
          /** @type {number} */
          res.y = 2 * val.getCenterY() - res.y;
        }
      }
    }
    if (null == res) {
      res = this.getPoint(s);
    }
  }
  return res;
};
/**
 * @param {!Object} p
 * @return {?}
 */
mxGraphView.prototype.getRoutingCenterX = function(p) {
  /** @type {number} */
  var sx = null != p.style ? parseFloat(p.style[mxConstants.STYLE_ROUTING_CENTER_X]) || 0 : 0;
  return p.getCenterX() + sx * p.width;
};
/**
 * @param {!Object} a
 * @return {?}
 */
mxGraphView.prototype.getRoutingCenterY = function(a) {
  /** @type {number} */
  var row = null != a.style ? parseFloat(a.style[mxConstants.STYLE_ROUTING_CENTER_Y]) || 0 : 0;
  return a.getCenterY() + row * a.height;
};
/**
 * @param {!Object} s
 * @param {number} i
 * @return {?}
 */
mxGraphView.prototype.getPerimeterBounds = function(s, i) {
  i = null != i ? i : 0;
  if (null != s) {
    i = i + parseFloat(s.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);
  }
  return s.getPerimeterBounds(i * this.scale);
};
/**
 * @param {!Object} n
 * @return {?}
 */
mxGraphView.prototype.getPerimeterFunction = function(n) {
  n = n.style[mxConstants.STYLE_PERIMETER];
  if ("string" == typeof n) {
    var x = mxStyleRegistry.getValue(n);
    if (null == x && this.isAllowEval()) {
      x = mxUtils.eval(n);
    }
    n = x;
  }
  return "function" == typeof n ? n : null;
};
/**
 * @param {!Object} t
 * @param {number} point
 * @param {boolean} offset
 * @return {?}
 */
mxGraphView.prototype.getNextPoint = function(t, point, offset) {
  t = t.absolutePoints;
  /** @type {null} */
  var start = null;
  if (null != t && 2 <= t.length) {
    start = t.length;
    start = t[offset ? Math.min(1, start - 1) : Math.max(0, start - 2)];
  }
  if (null == start && null != point) {
    start = new mxPoint(point.getCenterX(), point.getCenterY());
  }
  return start;
};
/**
 * @param {string} b
 * @param {boolean} a
 * @return {?}
 */
mxGraphView.prototype.getVisibleTerminal = function(b, a) {
  var self = this.graph.getModel();
  var e = self.getTerminal(b, a);
  var element = e;
  for (; null != e && e != this.currentRoot;) {
    if (!this.graph.isCellVisible(element) || this.isCellCollapsed(e)) {
      element = e;
    }
    e = self.getParent(e);
  }
  if (!(null == element || self.contains(element) && self.getParent(element) != self.getRoot() && element != this.currentRoot)) {
    /** @type {null} */
    element = null;
  }
  return element;
};
/**
 * @param {!Object} t
 * @return {undefined}
 */
mxGraphView.prototype.updateEdgeBounds = function(t) {
  var list = t.absolutePoints;
  var start = list[0];
  var end = list[list.length - 1];
  if (start.x != end.x || start.y != end.y) {
    /** @type {number} */
    var f = end.x - start.x;
    /** @type {number} */
    var e = end.y - start.y;
    /** @type {number} */
    t.terminalDistance = Math.sqrt(f * f + e * e);
  } else {
    /** @type {number} */
    t.terminalDistance = 0;
  }
  /** @type {number} */
  end = 0;
  /** @type {!Array} */
  var result = [];
  e = start;
  if (null != e) {
    start = e.x;
    var h = e.y;
    var last = start;
    var height = h;
    /** @type {number} */
    var i = 1;
    for (; i < list.length; i++) {
      var t = list[i];
      if (null != t) {
        /** @type {number} */
        f = e.x - t.x;
        /** @type {number} */
        e = e.y - t.y;
        /** @type {number} */
        f = Math.sqrt(f * f + e * e);
        result.push(f);
        /** @type {number} */
        end = end + f;
        e = t;
        /** @type {number} */
        start = Math.min(e.x, start);
        /** @type {number} */
        h = Math.min(e.y, h);
        /** @type {number} */
        last = Math.max(e.x, last);
        /** @type {number} */
        height = Math.max(e.y, height);
      }
    }
    /** @type {number} */
    t.length = end;
    /** @type {!Array} */
    t.segments = result;
    t.x = start;
    t.y = h;
    /** @type {number} */
    t.width = Math.max(1, last - start);
    /** @type {number} */
    t.height = Math.max(1, height - h);
  }
};
/**
 * @param {!Object} self
 * @param {!Object} a
 * @return {?}
 */
mxGraphView.prototype.getPoint = function(self, a) {
  var right = self.getCenterX();
  var d = self.getCenterY();
  if (null == self.segments || null != a && !a.relative) {
    if (null != a) {
      size = a.offset;
      if (null != size) {
        right = right + size.x;
        d = d + size.y;
      }
    }
  } else {
    var width = self.absolutePoints.length;
    /** @type {number} */
    var offset = Math.round(((null != a ? a.x / 2 : 0) + .5) * self.length);
    var h = self.segments[0];
    /** @type {number} */
    var top = 0;
    /** @type {number} */
    var i = 1;
    for (; offset >= Math.round(top + h) && i < width - 1;) {
      top = top + h;
      h = self.segments[i++];
    }
    /** @type {number} */
    width = 0 == h ? 0 : (offset - top) / h;
    offset = self.absolutePoints[i - 1];
    i = self.absolutePoints[i];
    if (null != offset && null != i) {
      /** @type {number} */
      top = right = d = 0;
      if (null != a) {
        d = a.y;
        var size = a.offset;
        if (null != size) {
          right = size.x;
          top = size.y;
        }
      }
      /** @type {number} */
      size = i.x - offset.x;
      /** @type {number} */
      i = i.y - offset.y;
      right = offset.x + size * width + ((0 == h ? 0 : i / h) * d + right) * this.scale;
      /** @type {number} */
      d = offset.y + i * width - ((0 == h ? 0 : size / h) * d - top) * this.scale;
    }
  }
  return new mxPoint(right, d);
};
/**
 * @param {number} b
 * @param {number} x
 * @param {number} y
 * @return {?}
 */
mxGraphView.prototype.getRelativePoint = function(b, x, y) {
  var d = this.graph.getModel().getGeometry(b.cell);
  if (null != d) {
    var t = b.absolutePoints.length;
    if (d.relative && 1 < t) {
      d = b.length;
      var r = b.segments;
      var c = b.absolutePoints[0];
      var l = b.absolutePoints[1];
      var i = mxUtils.ptSegDistSq(c.x, c.y, l.x, l.y, x, y);
      /** @type {number} */
      var a = 0;
      /** @type {number} */
      var v = 0;
      /** @type {number} */
      var g = 0;
      /** @type {number} */
      var k = 2;
      for (; k < t; k++) {
        v = v + r[k - 2];
        l = b.absolutePoints[k];
        c = mxUtils.ptSegDistSq(c.x, c.y, l.x, l.y, x, y);
        if (c <= i) {
          i = c;
          /** @type {number} */
          a = k - 1;
          g = v;
        }
        c = l;
      }
      t = r[a];
      c = b.absolutePoints[a];
      l = b.absolutePoints[a + 1];
      i = l.x;
      r = l.y;
      /** @type {number} */
      b = c.x - i;
      /** @type {number} */
      a = c.y - r;
      /** @type {number} */
      i = b - (x - i);
      /** @type {number} */
      r = a - (y - r);
      /** @type {number} */
      r = i * b + r * a;
      /** @type {number} */
      b = Math.sqrt(0 >= r ? 0 : r * r / (b * b + a * a));
      if (b > t) {
        b = t;
      }
      /** @type {number} */
      t = Math.sqrt(mxUtils.ptSegDistSq(c.x, c.y, l.x, l.y, x, y));
      if (-1 == mxUtils.relativeCcw(c.x, c.y, l.x, l.y, x, y)) {
        /** @type {number} */
        t = -t;
      }
      return new mxPoint((d / 2 - g - b) / d * -2, t / this.scale);
    }
  }
  return new mxPoint;
};
/**
 * @param {!Object} s
 * @return {undefined}
 */
mxGraphView.prototype.updateEdgeLabelOffset = function(s) {
  var a = s.absolutePoints;
  s.absoluteOffset.x = s.getCenterX();
  s.absoluteOffset.y = s.getCenterY();
  if (null != a && 0 < a.length && null != s.segments) {
    var value = this.graph.getCellGeometry(s.cell);
    if (value.relative) {
      var p = this.getPoint(s, value);
      if (null != p) {
        s.absoluteOffset = p;
      }
    } else {
      p = a[0];
      var b = a[a.length - 1];
      if (null != p && null != b) {
        /** @type {number} */
        a = b.x - p.x;
        /** @type {number} */
        var height = b.y - p.y;
        /** @type {number} */
        var y = b = 0;
        value = value.offset;
        if (null != value) {
          b = value.x;
          y = value.y;
        }
        value = p.y + height / 2 + y * this.scale;
        s.absoluteOffset.x = p.x + a / 2 + b * this.scale;
        s.absoluteOffset.y = value;
      }
    }
  }
};
/**
 * @param {!Object} name
 * @param {boolean} obj
 * @return {?}
 */
mxGraphView.prototype.getState = function(name, obj) {
  obj = obj || false;
  /** @type {null} */
  var value = null;
  if (null != name) {
    value = this.states.get(name);
    if (obj && (null == value || this.updateStyle) && this.graph.isCellVisible(name)) {
      if (null == value) {
        value = this.createState(name);
        this.states.put(name, value);
      } else {
        value.style = this.graph.getCellStyle(name);
      }
    }
  }
  return value;
};
/**
 * @return {?}
 */
mxGraphView.prototype.isRendering = function() {
  return this.rendering;
};
/**
 * @param {boolean} renderingType
 * @return {undefined}
 */
mxGraphView.prototype.setRendering = function(renderingType) {
  /** @type {boolean} */
  this.rendering = renderingType;
};
/**
 * @return {?}
 */
mxGraphView.prototype.isAllowEval = function() {
  return this.allowEval;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraphView.prototype.setAllowEval = function(a) {
  /** @type {boolean} */
  this.allowEval = a;
};
/**
 * @return {?}
 */
mxGraphView.prototype.getStates = function() {
  return this.states;
};
/**
 * @param {!Object} states
 * @return {undefined}
 */
mxGraphView.prototype.setStates = function(states) {
  /** @type {!Object} */
  this.states = states;
};
/**
 * @param {string} idArr
 * @return {?}
 */
mxGraphView.prototype.getCellStates = function(idArr) {
  if (null == idArr) {
    return this.states;
  }
  /** @type {!Array} */
  var stdout = [];
  /** @type {number} */
  var i = 0;
  for (; i < idArr.length; i++) {
    var Locale = this.getState(idArr[i]);
    if (null != Locale) {
      stdout.push(Locale);
    }
  }
  return stdout;
};
/**
 * @param {?} index
 * @return {?}
 */
mxGraphView.prototype.removeState = function(index) {
  /** @type {null} */
  var form = null;
  if (null != index) {
    form = this.states.remove(index);
    if (null != form) {
      this.graph.cellRenderer.destroy(form);
      /** @type {boolean} */
      form.invalid = true;
      form.destroy();
    }
  }
  return form;
};
/**
 * @param {!Object} edge
 * @return {?}
 */
mxGraphView.prototype.createState = function(edge) {
  return new mxCellState(this, edge, this.graph.getCellStyle(edge));
};
/**
 * @return {?}
 */
mxGraphView.prototype.getCanvas = function() {
  return this.canvas;
};
/**
 * @return {?}
 */
mxGraphView.prototype.getBackgroundPane = function() {
  return this.backgroundPane;
};
/**
 * @return {?}
 */
mxGraphView.prototype.getDrawPane = function() {
  return this.drawPane;
};
/**
 * @return {?}
 */
mxGraphView.prototype.getOverlayPane = function() {
  return this.overlayPane;
};
/**
 * @return {?}
 */
mxGraphView.prototype.getDecoratorPane = function() {
  return this.decoratorPane;
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxGraphView.prototype.isContainerEvent = function(e) {
  e = mxEvent.getSource(e);
  return e == this.graph.container || e.parentNode == this.backgroundPane || null != e.parentNode && e.parentNode.parentNode == this.backgroundPane || e == this.canvas.parentNode || e == this.canvas || e == this.backgroundPane || e == this.drawPane || e == this.overlayPane || e == this.decoratorPane;
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxGraphView.prototype.isScrollEvent = function(e) {
  var offset = mxUtils.getOffset(this.graph.container);
  e = new mxPoint(e.clientX - offset.x, e.clientY - offset.y);
  offset = this.graph.container.offsetWidth;
  var top = this.graph.container.clientWidth;
  if (offset > top && e.x > top + 2 && e.x <= offset) {
    return true;
  }
  offset = this.graph.container.offsetHeight;
  top = this.graph.container.clientHeight;
  return offset > top && e.y > top + 2 && e.y <= offset ? true : false;
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.init = function() {
  this.installListeners();
  var graph = this.graph;
  if (graph.dialect == mxConstants.DIALECT_SVG) {
    this.createSvg();
  } else {
    if (graph.dialect == mxConstants.DIALECT_VML) {
      this.createVml();
    } else {
      this.createHtml();
    }
  }
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.installListeners = function() {
  var graph = this.graph;
  var node = graph.container;
  if (null != node) {
    if (mxClient.IS_TOUCH) {
      mxEvent.addListener(node, "gesturestart", mxUtils.bind(this, function(evt) {
        graph.fireGestureEvent(evt);
        mxEvent.consume(evt);
      }));
      mxEvent.addListener(node, "gesturechange", mxUtils.bind(this, function(evt) {
        graph.fireGestureEvent(evt);
        mxEvent.consume(evt);
      }));
      mxEvent.addListener(node, "gestureend", mxUtils.bind(this, function(evt) {
        graph.fireGestureEvent(evt);
        mxEvent.consume(evt);
      }));
    }
    /** @type {null} */
    var pointerId = null;
    mxEvent.addGestureListeners(node, mxUtils.bind(this, function(evt) {
      if (!(!this.isContainerEvent(evt) || (mxClient.IS_IE || mxClient.IS_IE11 || mxClient.IS_GC || mxClient.IS_OP || mxClient.IS_SF) && this.isScrollEvent(evt))) {
        graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
        pointerId = evt.pointerId;
      }
    }), mxUtils.bind(this, function(evt) {
      if (!(!this.isContainerEvent(evt) || null != pointerId && evt.pointerId != pointerId)) {
        graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
      }
    }), mxUtils.bind(this, function(evt) {
      if (this.isContainerEvent(evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
      }
      /** @type {null} */
      pointerId = null;
    }));
    mxEvent.addListener(node, "dblclick", mxUtils.bind(this, function(e) {
      if (this.isContainerEvent(e)) {
        graph.dblClick(e);
      }
    }));
    /**
     * @param {number} e
     * @return {?}
     */
    var moveHandler = function(e) {
      /** @type {null} */
      var value = null;
      if (mxClient.IS_TOUCH) {
        value = mxEvent.getClientX(e);
        e = mxEvent.getClientY(e);
        e = mxUtils.convertPoint(node, value, e);
        value = graph.view.getState(graph.getCellAt(e.x, e.y));
      }
      return value;
    };
    graph.addMouseListener({
      mouseDown : function(e, editor) {
        graph.popupMenuHandler.hideMenu();
      },
      mouseMove : function() {
      },
      mouseUp : function() {
      }
    });
    this.moveHandler = mxUtils.bind(this, function(evt) {
      if (null != graph.tooltipHandler && graph.tooltipHandler.isHideOnHover()) {
        graph.tooltipHandler.hide();
      }
      if (this.captureDocumentGesture && graph.isMouseDown && null != graph.container && !this.isContainerEvent(evt) && "none" != graph.container.style.display && "hidden" != graph.container.style.visibility && !mxEvent.isConsumed(evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, moveHandler(evt)));
      }
    });
    this.endHandler = mxUtils.bind(this, function(evt) {
      if (this.captureDocumentGesture && graph.isMouseDown && null != graph.container && !this.isContainerEvent(evt) && "none" != graph.container.style.display && "hidden" != graph.container.style.visibility) {
        graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
      }
    });
    mxEvent.addGestureListeners(document, null, this.moveHandler, this.endHandler);
  }
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.createHtml = function() {
  var update = this.graph.container;
  if (null != update) {
    this.canvas = this.createHtmlPane("100%", "100%");
    /** @type {string} */
    this.canvas.style.overflow = "hidden";
    this.backgroundPane = this.createHtmlPane("1px", "1px");
    this.drawPane = this.createHtmlPane("1px", "1px");
    this.overlayPane = this.createHtmlPane("1px", "1px");
    this.decoratorPane = this.createHtmlPane("1px", "1px");
    this.canvas.appendChild(this.backgroundPane);
    this.canvas.appendChild(this.drawPane);
    this.canvas.appendChild(this.overlayPane);
    this.canvas.appendChild(this.decoratorPane);
    update.appendChild(this.canvas);
    this.updateContainerStyle(update);
    if (mxClient.IS_QUIRKS) {
      update = mxUtils.bind(this, function(xObject) {
        xObject = this.getGraphBounds();
        this.updateHtmlCanvasSize(xObject.x + xObject.width + this.graph.border, xObject.y + xObject.height + this.graph.border);
      });
      mxEvent.addListener(window, "resize", update);
    }
  }
};
/**
 * @param {number} width
 * @param {number} y0
 * @return {undefined}
 */
mxGraphView.prototype.updateHtmlCanvasSize = function(width, y0) {
  if (null != this.graph.container) {
    var scrollPosition = this.graph.container.offsetHeight;
    /** @type {string} */
    this.canvas.style.width = this.graph.container.offsetWidth < width ? width + "px" : "100%";
    /** @type {string} */
    this.canvas.style.height = scrollPosition < y0 ? y0 + "px" : "100%";
  }
};
/**
 * @param {string} a
 * @param {string} b
 * @return {?}
 */
mxGraphView.prototype.createHtmlPane = function(a, b) {
  /** @type {!Element} */
  var vline = document.createElement("DIV");
  if (null != a && null != b) {
    /** @type {string} */
    vline.style.position = "absolute";
    /** @type {string} */
    vline.style.left = "0px";
    /** @type {string} */
    vline.style.top = "0px";
    /** @type {string} */
    vline.style.width = a;
    /** @type {string} */
    vline.style.height = b;
  } else {
    /** @type {string} */
    vline.style.position = "relative";
  }
  return vline;
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.createVml = function() {
  var container = this.graph.container;
  if (null != container) {
    var width = container.offsetWidth;
    var height = container.offsetHeight;
    this.canvas = this.createVmlPane(width, height);
    /** @type {string} */
    this.canvas.style.overflow = "hidden";
    this.backgroundPane = this.createVmlPane(width, height);
    this.drawPane = this.createVmlPane(width, height);
    this.overlayPane = this.createVmlPane(width, height);
    this.decoratorPane = this.createVmlPane(width, height);
    this.canvas.appendChild(this.backgroundPane);
    this.canvas.appendChild(this.drawPane);
    this.canvas.appendChild(this.overlayPane);
    this.canvas.appendChild(this.decoratorPane);
    container.appendChild(this.canvas);
  }
};
/**
 * @param {string} width
 * @param {string} height
 * @return {?}
 */
mxGraphView.prototype.createVmlPane = function(width, height) {
  /** @type {!Element} */
  var path = document.createElement(mxClient.VML_PREFIX + ":group");
  /** @type {string} */
  path.style.position = "absolute";
  /** @type {string} */
  path.style.left = "0px";
  /** @type {string} */
  path.style.top = "0px";
  /** @type {string} */
  path.style.width = width + "px";
  /** @type {string} */
  path.style.height = height + "px";
  path.setAttribute("coordsize", width + "," + height);
  path.setAttribute("coordorigin", "0,0");
  return path;
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.createSvg = function() {
  var style = this.graph.container;
  /** @type {!Element} */
  this.canvas = document.createElementNS(mxConstants.NS_SVG, "g");
  /** @type {!Element} */
  this.backgroundPane = document.createElementNS(mxConstants.NS_SVG, "g");
  this.canvas.appendChild(this.backgroundPane);
  /** @type {!Element} */
  this.drawPane = document.createElementNS(mxConstants.NS_SVG, "g");
  this.canvas.appendChild(this.drawPane);
  /** @type {!Element} */
  this.overlayPane = document.createElementNS(mxConstants.NS_SVG, "g");
  this.canvas.appendChild(this.overlayPane);
  /** @type {!Element} */
  this.decoratorPane = document.createElementNS(mxConstants.NS_SVG, "g");
  this.canvas.appendChild(this.decoratorPane);
  /** @type {!Element} */
  var node = document.createElementNS(mxConstants.NS_SVG, "svg");
  /** @type {string} */
  node.style.left = "0px";
  /** @type {string} */
  node.style.top = "0px";
  /** @type {string} */
  node.style.width = "100%";
  /** @type {string} */
  node.style.height = "100%";
  /** @type {string} */
  node.style.display = "block";
  node.appendChild(this.canvas);
  if (mxClient.IS_IE || mxClient.IS_IE11) {
    /** @type {string} */
    node.style.overflow = "hidden";
  }
  if (null != style) {
    style.appendChild(node);
    this.updateContainerStyle(style);
  }
};
/**
 * @param {!Element} e
 * @return {undefined}
 */
mxGraphView.prototype.updateContainerStyle = function(e) {
  var edgeLabel = mxUtils.getCurrentStyle(e);
  if (null != edgeLabel && "static" == edgeLabel.position) {
    /** @type {string} */
    e.style.position = "relative";
  }
  if (mxClient.IS_POINTER) {
    /** @type {string} */
    e.style.touchAction = "none";
  }
};
/**
 * @return {undefined}
 */
mxGraphView.prototype.destroy = function() {
  var elem = null != this.canvas ? this.canvas.ownerSVGElement : null;
  if (null == elem) {
    elem = this.canvas;
  }
  if (null != elem && null != elem.parentNode) {
    this.clear(this.currentRoot, true);
    mxEvent.removeGestureListeners(document, null, this.moveHandler, this.endHandler);
    mxEvent.release(this.graph.container);
    elem.parentNode.removeChild(elem);
    /** @type {null} */
    this.decoratorPane = this.overlayPane = this.drawPane = this.backgroundPane = this.canvas = this.endHandler = this.moveHandler = null;
  }
};
/**
 * @param {string} view
 * @param {string} w
 * @return {undefined}
 */
function mxCurrentRootChange(view, w) {
  /** @type {string} */
  this.view = view;
  this.previous = this.root = w;
  /** @type {boolean} */
  this.isUp = null == w;
  if (!this.isUp) {
    var item = this.view.currentRoot;
    var sourceCode = this.view.graph.getModel();
    for (; null != item;) {
      if (item == w) {
        /** @type {boolean} */
        this.isUp = true;
        break;
      }
      item = sourceCode.getParent(item);
    }
  }
}
/**
 * @return {undefined}
 */
mxCurrentRootChange.prototype.execute = function() {
  var value = this.view.currentRoot;
  this.view.currentRoot = this.previous;
  this.previous = value;
  value = this.view.graph.getTranslateForRoot(this.view.currentRoot);
  if (null != value) {
    this.view.translate = new mxPoint(-value.x, -value.y);
  }
  if (this.isUp) {
    this.view.clear(this.view.currentRoot, true);
    this.view.validate();
  } else {
    this.view.refresh();
  }
  this.view.fireEvent(new mxEventObject(this.isUp ? mxEvent.UP : mxEvent.DOWN, "root", this.view.currentRoot, "previous", this.previous));
  /** @type {boolean} */
  this.isUp = !this.isUp;
};
/**
 * @param {string} s
 * @param {string} v
 * @param {!AudioNode} elbow
 * @param {string} position
 * @return {undefined}
 */
function mxGraph(s, v, elbow, position) {
  /** @type {null} */
  this.mouseListeners = null;
  /** @type {!AudioNode} */
  this.renderHint = elbow;
  this.dialect = mxClient.IS_SVG ? mxConstants.DIALECT_SVG : elbow == mxConstants.RENDERING_HINT_EXACT && mxClient.IS_VML ? mxConstants.DIALECT_VML : elbow == mxConstants.RENDERING_HINT_FASTEST ? mxConstants.DIALECT_STRICTHTML : elbow == mxConstants.RENDERING_HINT_FASTER ? mxConstants.DIALECT_PREFERHTML : mxConstants.DIALECT_MIXEDHTML;
  this.model = null != v ? v : new mxGraphModel;
  /** @type {!Array} */
  this.multiplicities = [];
  /** @type {!Array} */
  this.imageBundles = [];
  this.cellRenderer = this.createCellRenderer();
  this.setSelectionModel(this.createSelectionModel());
  this.setStylesheet(null != position ? position : this.createStylesheet());
  this.view = this.createGraphView();
  this.graphModelChangeListener = mxUtils.bind(this, function(a, link) {
    this.graphModelChanged(link.getProperty("edit").changes);
  });
  this.model.addListener(mxEvent.CHANGE, this.graphModelChangeListener);
  this.createHandlers();
  if (null != s) {
    this.init(s);
  }
  this.view.revalidate();
}
if (mxLoadResources) {
  mxResources.add(mxClient.basePath + "/resources/graph");
} else {
  mxClient.defaultBundles.push(mxClient.basePath + "/resources/graph");
}
mxGraph.prototype = new mxEventSource;
/** @type {function(string, string, !AudioNode, string): undefined} */
mxGraph.prototype.constructor = mxGraph;
/** @type {null} */
mxGraph.prototype.mouseListeners = null;
/** @type {boolean} */
mxGraph.prototype.isMouseDown = false;
/** @type {null} */
mxGraph.prototype.model = null;
/** @type {null} */
mxGraph.prototype.view = null;
/** @type {null} */
mxGraph.prototype.stylesheet = null;
/** @type {null} */
mxGraph.prototype.selectionModel = null;
/** @type {null} */
mxGraph.prototype.cellEditor = null;
/** @type {null} */
mxGraph.prototype.cellRenderer = null;
/** @type {null} */
mxGraph.prototype.multiplicities = null;
/** @type {null} */
mxGraph.prototype.renderHint = null;
/** @type {null} */
mxGraph.prototype.dialect = null;
/** @type {number} */
mxGraph.prototype.gridSize = 10;
/** @type {boolean} */
mxGraph.prototype.gridEnabled = true;
/** @type {boolean} */
mxGraph.prototype.portsEnabled = true;
/** @type {boolean} */
mxGraph.prototype.nativeDblClickEnabled = true;
/** @type {boolean} */
mxGraph.prototype.doubleTapEnabled = true;
/** @type {number} */
mxGraph.prototype.doubleTapTimeout = 500;
/** @type {number} */
mxGraph.prototype.doubleTapTolerance = 25;
/** @type {number} */
mxGraph.prototype.lastTouchY = 0;
/** @type {number} */
mxGraph.prototype.lastTouchY = 0;
/** @type {number} */
mxGraph.prototype.lastTouchTime = 0;
/** @type {boolean} */
mxGraph.prototype.tapAndHoldEnabled = true;
/** @type {number} */
mxGraph.prototype.tapAndHoldDelay = 500;
/** @type {boolean} */
mxGraph.prototype.tapAndHoldInProgress = false;
/** @type {boolean} */
mxGraph.prototype.tapAndHoldValid = false;
/** @type {number} */
mxGraph.prototype.initialTouchX = 0;
/** @type {number} */
mxGraph.prototype.initialTouchY = 0;
/** @type {number} */
mxGraph.prototype.tolerance = 4;
/** @type {number} */
mxGraph.prototype.defaultOverlap = .5;
/** @type {null} */
mxGraph.prototype.defaultParent = null;
/** @type {null} */
mxGraph.prototype.alternateEdgeStyle = null;
/** @type {null} */
mxGraph.prototype.backgroundImage = null;
/** @type {boolean} */
mxGraph.prototype.pageVisible = false;
/** @type {boolean} */
mxGraph.prototype.pageBreaksVisible = false;
/** @type {string} */
mxGraph.prototype.pageBreakColor = "gray";
/** @type {boolean} */
mxGraph.prototype.pageBreakDashed = true;
/** @type {number} */
mxGraph.prototype.minPageBreakDist = 20;
/** @type {boolean} */
mxGraph.prototype.preferPageSize = false;
mxGraph.prototype.pageFormat = mxConstants.PAGE_FORMAT_A4_PORTRAIT;
/** @type {number} */
mxGraph.prototype.pageScale = 1.5;
/** @type {boolean} */
mxGraph.prototype.enabled = true;
/** @type {boolean} */
mxGraph.prototype.escapeEnabled = true;
/** @type {boolean} */
mxGraph.prototype.invokesStopCellEditing = true;
/** @type {boolean} */
mxGraph.prototype.enterStopsCellEditing = false;
/** @type {boolean} */
mxGraph.prototype.useScrollbarsForPanning = true;
/** @type {boolean} */
mxGraph.prototype.exportEnabled = true;
/** @type {boolean} */
mxGraph.prototype.importEnabled = true;
/** @type {boolean} */
mxGraph.prototype.cellsLocked = false;
/** @type {boolean} */
mxGraph.prototype.cellsCloneable = true;
/** @type {boolean} */
mxGraph.prototype.foldingEnabled = true;
/** @type {boolean} */
mxGraph.prototype.cellsEditable = true;
/** @type {boolean} */
mxGraph.prototype.cellsDeletable = true;
/** @type {boolean} */
mxGraph.prototype.cellsMovable = true;
/** @type {boolean} */
mxGraph.prototype.edgeLabelsMovable = true;
/** @type {boolean} */
mxGraph.prototype.vertexLabelsMovable = false;
/** @type {boolean} */
mxGraph.prototype.dropEnabled = false;
/** @type {boolean} */
mxGraph.prototype.splitEnabled = true;
/** @type {boolean} */
mxGraph.prototype.cellsResizable = true;
/** @type {boolean} */
mxGraph.prototype.cellsBendable = true;
/** @type {boolean} */
mxGraph.prototype.cellsSelectable = true;
/** @type {boolean} */
mxGraph.prototype.cellsDisconnectable = true;
/** @type {boolean} */
mxGraph.prototype.autoSizeCells = false;
/** @type {boolean} */
mxGraph.prototype.autoSizeCellsOnAdd = false;
/** @type {boolean} */
mxGraph.prototype.autoScroll = true;
/** @type {boolean} */
mxGraph.prototype.ignoreScrollbars = false;
/** @type {boolean} */
mxGraph.prototype.translateToScrollPosition = false;
/** @type {boolean} */
mxGraph.prototype.timerAutoScroll = false;
/** @type {boolean} */
mxGraph.prototype.allowAutoPanning = false;
/** @type {boolean} */
mxGraph.prototype.autoExtend = true;
/** @type {null} */
mxGraph.prototype.maximumGraphBounds = null;
/** @type {null} */
mxGraph.prototype.minimumGraphSize = null;
/** @type {null} */
mxGraph.prototype.minimumContainerSize = null;
/** @type {null} */
mxGraph.prototype.maximumContainerSize = null;
/** @type {boolean} */
mxGraph.prototype.resizeContainer = false;
/** @type {number} */
mxGraph.prototype.border = 0;
/** @type {boolean} */
mxGraph.prototype.keepEdgesInForeground = false;
/** @type {boolean} */
mxGraph.prototype.keepEdgesInBackground = false;
/** @type {boolean} */
mxGraph.prototype.allowNegativeCoordinates = true;
/** @type {boolean} */
mxGraph.prototype.constrainChildren = true;
/** @type {boolean} */
mxGraph.prototype.constrainRelativeChildren = false;
/** @type {boolean} */
mxGraph.prototype.extendParents = true;
/** @type {boolean} */
mxGraph.prototype.extendParentsOnAdd = true;
/** @type {boolean} */
mxGraph.prototype.extendParentsOnMove = false;
/** @type {boolean} */
mxGraph.prototype.recursiveResize = false;
/** @type {boolean} */
mxGraph.prototype.collapseToPreferredSize = true;
/** @type {number} */
mxGraph.prototype.zoomFactor = 1.2;
/** @type {boolean} */
mxGraph.prototype.keepSelectionVisibleOnZoom = false;
/** @type {boolean} */
mxGraph.prototype.centerZoom = true;
/** @type {boolean} */
mxGraph.prototype.resetViewOnRootChange = true;
/** @type {boolean} */
mxGraph.prototype.resetEdgesOnResize = false;
/** @type {boolean} */
mxGraph.prototype.resetEdgesOnMove = false;
/** @type {boolean} */
mxGraph.prototype.resetEdgesOnConnect = true;
/** @type {boolean} */
mxGraph.prototype.allowLoops = false;
/** @type {function(!Object, number, !Object, number, !Array): undefined} */
mxGraph.prototype.defaultLoopStyle = mxEdgeStyle.Loop;
/** @type {boolean} */
mxGraph.prototype.multigraph = true;
/** @type {boolean} */
mxGraph.prototype.connectableEdges = false;
/** @type {boolean} */
mxGraph.prototype.allowDanglingEdges = true;
/** @type {boolean} */
mxGraph.prototype.cloneInvalidEdges = false;
/** @type {boolean} */
mxGraph.prototype.disconnectOnMove = true;
/** @type {boolean} */
mxGraph.prototype.labelsVisible = true;
/** @type {boolean} */
mxGraph.prototype.htmlLabels = false;
/** @type {boolean} */
mxGraph.prototype.swimlaneSelectionEnabled = true;
/** @type {boolean} */
mxGraph.prototype.swimlaneNesting = true;
/** @type {string} */
mxGraph.prototype.swimlaneIndicatorColorAttribute = mxConstants.STYLE_FILLCOLOR;
/** @type {null} */
mxGraph.prototype.imageBundles = null;
/** @type {number} */
mxGraph.prototype.minFitScale = .1;
/** @type {number} */
mxGraph.prototype.maxFitScale = 8;
/** @type {number} */
mxGraph.prototype.panDx = 0;
/** @type {number} */
mxGraph.prototype.panDy = 0;
mxGraph.prototype.collapsedImage = new mxImage(mxClient.imageBasePath + "/collapsed.gif", 9, 9);
mxGraph.prototype.expandedImage = new mxImage(mxClient.imageBasePath + "/expanded.gif", 9, 9);
mxGraph.prototype.warningImage = new mxImage(mxClient.imageBasePath + "/warning" + (mxClient.IS_MAC ? ".png" : ".gif"), 16, 16);
/** @type {string} */
mxGraph.prototype.alreadyConnectedResource = "none" != mxClient.language ? "alreadyConnected" : "";
/** @type {string} */
mxGraph.prototype.containsValidationErrorsResource = "none" != mxClient.language ? "containsValidationErrors" : "";
/** @type {string} */
mxGraph.prototype.collapseExpandResource = "none" != mxClient.language ? "collapse-expand" : "";
/**
 * @param {!HTMLElement} node
 * @return {undefined}
 */
mxGraph.prototype.init = function(node) {
  /** @type {!HTMLElement} */
  this.container = node;
  this.cellEditor = this.createCellEditor();
  this.view.init();
  this.sizeDidChange();
  mxEvent.addListener(node, "mouseleave", mxUtils.bind(this, function(event) {
    if (null != this.tooltipHandler && null != this.tooltipHandler.div && this.tooltipHandler.div != event.relatedTarget) {
      this.tooltipHandler.hide();
    }
  }));
  if (mxClient.IS_IE) {
    mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
      this.destroy();
    }));
    mxEvent.addListener(node, "selectstart", mxUtils.bind(this, function(evt) {
      return this.isEditing() || !this.isMouseDown && !mxEvent.isShiftDown(evt);
    }));
  }
  if (8 == document.documentMode) {
    node.insertAdjacentHTML("beforeend", "<" + mxClient.VML_PREFIX + ':group style="DISPLAY: none;"></' + mxClient.VML_PREFIX + ":group>");
  }
};
/**
 * @return {undefined}
 */
mxGraph.prototype.createHandlers = function() {
  this.tooltipHandler = this.createTooltipHandler();
  this.tooltipHandler.setEnabled(false);
  this.selectionCellsHandler = this.createSelectionCellsHandler();
  this.connectionHandler = this.createConnectionHandler();
  this.connectionHandler.setEnabled(false);
  this.graphHandler = this.createGraphHandler();
  this.panningHandler = this.createPanningHandler();
  /** @type {boolean} */
  this.panningHandler.panningEnabled = false;
  this.popupMenuHandler = this.createPopupMenuHandler();
};
/**
 * @return {?}
 */
mxGraph.prototype.createTooltipHandler = function() {
  return new mxTooltipHandler(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createSelectionCellsHandler = function() {
  return new mxSelectionCellsHandler(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createConnectionHandler = function() {
  return new mxConnectionHandler(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createGraphHandler = function() {
  return new mxGraphHandler(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createPanningHandler = function() {
  return new mxPanningHandler(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createPopupMenuHandler = function() {
  return new mxPopupMenuHandler(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createSelectionModel = function() {
  return new mxGraphSelectionModel(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createStylesheet = function() {
  return new mxStylesheet;
};
/**
 * @return {?}
 */
mxGraph.prototype.createGraphView = function() {
  return new mxGraphView(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.createCellRenderer = function() {
  return new mxCellRenderer;
};
/**
 * @return {?}
 */
mxGraph.prototype.createCellEditor = function() {
  return new mxCellEditor(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.getModel = function() {
  return this.model;
};
/**
 * @return {?}
 */
mxGraph.prototype.getView = function() {
  return this.view;
};
/**
 * @return {?}
 */
mxGraph.prototype.getStylesheet = function() {
  return this.stylesheet;
};
/**
 * @param {!AudioNode} stylesheet
 * @return {undefined}
 */
mxGraph.prototype.setStylesheet = function(stylesheet) {
  /** @type {!AudioNode} */
  this.stylesheet = stylesheet;
};
/**
 * @return {?}
 */
mxGraph.prototype.getSelectionModel = function() {
  return this.selectionModel;
};
/**
 * @param {boolean} model
 * @return {undefined}
 */
mxGraph.prototype.setSelectionModel = function(model) {
  /** @type {boolean} */
  this.selectionModel = model;
};
/**
 * @param {!NodeList} changes
 * @param {string} callback
 * @return {?}
 */
mxGraph.prototype.getSelectionCellsForChanges = function(changes, callback) {
  var row = new mxDictionary;
  /** @type {!Array} */
  var team_array = [];
  var equal = mxUtils.bind(this, function(cell) {
    if (!row.get(cell) && this.model.contains(cell)) {
      if (this.model.isEdge(cell) || this.model.isVertex(cell)) {
        row.put(cell, true);
        team_array.push(cell);
      } else {
        var childCount = this.model.getChildCount(cell);
        /** @type {number} */
        var i = 0;
        for (; i < childCount; i++) {
          equal(this.model.getChildAt(cell, i));
        }
      }
    }
  });
  /** @type {number} */
  var i = 0;
  for (; i < changes.length; i++) {
    var change = changes[i];
    if (change.constructor != mxRootChange && (null == callback || !callback(change))) {
      /** @type {null} */
      var _ref = null;
      if (change instanceof mxChildChange) {
        _ref = change.child;
      } else {
        if (null != change.cell && change.cell instanceof mxCell) {
          _ref = change.cell;
        }
      }
      if (null != _ref) {
        equal(_ref);
      }
    }
  }
  return team_array;
};
/**
 * @param {!NodeList} changes
 * @return {undefined}
 */
mxGraph.prototype.graphModelChanged = function(changes) {
  /** @type {number} */
  var i = 0;
  for (; i < changes.length; i++) {
    this.processChange(changes[i]);
  }
  this.updateSelection();
  this.view.validate();
  this.sizeDidChange();
};
/**
 * @return {undefined}
 */
mxGraph.prototype.updateSelection = function() {
  var cells = this.getSelectionCells();
  /** @type {!Array} */
  var c = [];
  /** @type {number} */
  var i = 0;
  for (; i < cells.length; i++) {
    if (this.model.contains(cells[i]) && this.isCellVisible(cells[i])) {
      var item = this.model.getParent(cells[i]);
      for (; null != item && item != this.view.currentRoot;) {
        if (this.isCellCollapsed(item) || !this.isCellVisible(item)) {
          c.push(cells[i]);
          break;
        }
        item = this.model.getParent(item);
      }
    } else {
      c.push(cells[i]);
    }
  }
  this.removeSelectionCells(c);
};
/**
 * @param {!Object} change
 * @return {undefined}
 */
mxGraph.prototype.processChange = function(change) {
  if (change instanceof mxRootChange) {
    this.clearSelection();
    this.setDefaultParent(null);
    this.removeStateForCell(change.previous);
    if (this.resetViewOnRootChange) {
      /** @type {number} */
      this.view.scale = 1;
      /** @type {number} */
      this.view.translate.x = 0;
      /** @type {number} */
      this.view.translate.y = 0;
    }
    this.fireEvent(new mxEventObject(mxEvent.ROOT));
  } else {
    if (change instanceof mxChildChange) {
      var path = this.model.getParent(change.child);
      this.view.invalidate(change.child, true, true);
      if (!this.model.contains(path) || this.isCellCollapsed(path)) {
        this.view.invalidate(change.child, true, true);
        this.removeStateForCell(change.child);
        if (this.view.currentRoot == change.child) {
          this.home();
        }
      }
      if (path != change.previous) {
        if (null != path) {
          this.view.invalidate(path, false, false);
        }
        if (null != change.previous) {
          this.view.invalidate(change.previous, false, false);
        }
      }
    } else {
      if (change instanceof mxTerminalChange || change instanceof mxGeometryChange) {
        if (change instanceof mxTerminalChange || null == change.previous && null != change.geometry || null != change.previous && !change.previous.equals(change.geometry)) {
          this.view.invalidate(change.cell);
        }
      } else {
        if (change instanceof mxValueChange) {
          this.view.invalidate(change.cell, false, false);
        } else {
          if (change instanceof mxStyleChange) {
            this.view.invalidate(change.cell, true, true);
            change = this.view.getState(change.cell);
            if (null != change) {
              /** @type {boolean} */
              change.invalidStyle = true;
            }
          } else {
            if (null != change.cell && change.cell instanceof mxCell) {
              this.removeStateForCell(change.cell);
            }
          }
        }
      }
    }
  }
};
/**
 * @param {undefined} index
 * @return {undefined}
 */
mxGraph.prototype.removeStateForCell = function(index) {
  var b = this.model.getChildCount(index);
  /** @type {number} */
  var y = 0;
  for (; y < b; y++) {
    this.removeStateForCell(this.model.getChildAt(index, y));
  }
  this.view.invalidate(index, false, true);
  this.view.removeState(index);
};
/**
 * @param {!Object} element
 * @param {!Object} percentage
 * @return {?}
 */
mxGraph.prototype.addCellOverlay = function(element, percentage) {
  if (null == element.overlays) {
    /** @type {!Array} */
    element.overlays = [];
  }
  element.overlays.push(percentage);
  var rect = this.view.getState(element);
  if (null != rect) {
    this.cellRenderer.redraw(rect);
  }
  this.fireEvent(new mxEventObject(mxEvent.ADD_OVERLAY, "cell", element, "overlay", percentage));
  return percentage;
};
/**
 * @param {!Object} viewer
 * @return {?}
 */
mxGraph.prototype.getCellOverlays = function(viewer) {
  return viewer.overlays;
};
/**
 * @param {!Object} state
 * @param {!Object} value
 * @return {?}
 */
mxGraph.prototype.removeCellOverlay = function(state, value) {
  if (null == value) {
    this.removeCellOverlays(state);
  } else {
    var item = mxUtils.indexOf(state.overlays, value);
    if (0 <= item) {
      state.overlays.splice(item, 1);
      if (0 == state.overlays.length) {
        /** @type {null} */
        state.overlays = null;
      }
      item = this.view.getState(state);
      if (null != item) {
        this.cellRenderer.redraw(item);
      }
      this.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY, "cell", state, "overlay", value));
    } else {
      /** @type {null} */
      value = null;
    }
  }
  return value;
};
/**
 * @param {!Object} el
 * @return {?}
 */
mxGraph.prototype.removeCellOverlays = function(el) {
  var cs = el.overlays;
  if (null != cs) {
    /** @type {null} */
    el.overlays = null;
    var target = this.view.getState(el);
    if (null != target) {
      this.cellRenderer.redraw(target);
    }
    /** @type {number} */
    target = 0;
    for (; target < cs.length; target++) {
      this.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY, "cell", el, "overlay", cs[target]));
    }
  }
  return cs;
};
/**
 * @param {!Object} parent
 * @return {undefined}
 */
mxGraph.prototype.clearCellOverlays = function(parent) {
  parent = null != parent ? parent : this.model.getRoot();
  this.removeCellOverlays(parent);
  var newParentTag = this.model.getChildCount(parent);
  /** @type {number} */
  var i = 0;
  for (; i < newParentTag; i++) {
    var d = this.model.getChildAt(parent, i);
    this.clearCellOverlays(d);
  }
};
/**
 * @param {undefined} el
 * @param {!Object} o
 * @param {string} r
 * @param {?} agumentsArr
 * @return {?}
 */
mxGraph.prototype.setCellWarning = function(el, o, r, agumentsArr) {
  if (null != o && 0 < o.length) {
    return r = null != r ? r : this.warningImage, o = new mxCellOverlay(r, "<font color=red>" + o + "</font>"), agumentsArr && o.addListener(mxEvent.CLICK, mxUtils.bind(this, function(b, canCreateDiscussions) {
      if (this.isEnabled()) {
        this.setSelectionCell(el);
      }
    })), this.addCellOverlay(el, o);
  }
  this.removeCellOverlays(el);
  return null;
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxGraph.prototype.startEditing = function(value) {
  this.startEditingAtCell(null, value);
};
/**
 * @param {string} node
 * @param {string} value
 * @return {undefined}
 */
mxGraph.prototype.startEditingAtCell = function(node, value) {
  if (!(null != value && mxEvent.isMultiTouchEvent(value))) {
    if (null == node) {
      node = this.getSelectionCell();
      if (!(null == node || this.isCellEditable(node))) {
        /** @type {null} */
        node = null;
      }
    }
    if (null != node) {
      this.fireEvent(new mxEventObject(mxEvent.START_EDITING, "cell", node, "event", value));
      this.cellEditor.startEditing(node, value);
      this.fireEvent(new mxEventObject(mxEvent.EDITING_STARTED, "cell", node, "event", value));
    }
  }
};
/**
 * @param {!Object} cell
 * @param {!Object} loop
 * @return {?}
 */
mxGraph.prototype.getEditingValue = function(cell, loop) {
  return this.convertValueToString(cell);
};
/**
 * @param {string} a
 * @return {undefined}
 */
mxGraph.prototype.stopEditing = function(a) {
  this.cellEditor.stopEditing(a);
  this.fireEvent(new mxEventObject(mxEvent.EDITING_STOPPED, "cancel", a));
};
/**
 * @param {string} cell
 * @param {string} newValue
 * @param {number} evt
 * @return {?}
 */
mxGraph.prototype.labelChanged = function(cell, newValue, evt) {
  this.model.beginUpdate();
  try {
    var tuple = cell.value;
    this.cellLabelChanged(cell, newValue, this.isAutoSizeCell(cell));
    this.fireEvent(new mxEventObject(mxEvent.LABEL_CHANGED, "cell", cell, "value", newValue, "old", tuple, "event", evt));
  } finally {
    this.model.endUpdate();
  }
  return cell;
};
/**
 * @param {!Object} cell
 * @param {!Object} value
 * @param {?} autoSize
 * @return {undefined}
 */
mxGraph.prototype.cellLabelChanged = function(cell, value, autoSize) {
  this.model.beginUpdate();
  try {
    this.model.setValue(cell, value);
    if (autoSize) {
      this.cellSizeUpdated(cell, false);
    }
  } finally {
    this.model.endUpdate();
  }
};
/**
 * @param {!Function} string
 * @return {undefined}
 */
mxGraph.prototype.escape = function(string) {
  this.fireEvent(new mxEventObject(mxEvent.ESCAPE, "event", string));
};
/**
 * @param {!Object} me
 * @return {undefined}
 */
mxGraph.prototype.click = function(me) {
  var e = me.getEvent();
  var element = me.getCell();
  var name = new mxEventObject(mxEvent.CLICK, "event", e, "cell", element);
  if (me.isConsumed()) {
    name.consume();
  }
  this.fireEvent(name);
  if (this.isEnabled() && !mxEvent.isConsumed(e) && !name.isConsumed()) {
    if (null != element) {
      if (this.isTransparentClickEvent(e)) {
        /** @type {boolean} */
        var hasDataToSync = false;
        me = this.getCellAt(me.graphX, me.graphY, null, null, null, mxUtils.bind(this, function(event) {
          var hasAttempts = this.isCellSelected(event.cell);
          hasDataToSync = hasDataToSync || hasAttempts;
          return !hasDataToSync || hasAttempts || event.cell != element && this.model.isAncestor(event.cell, element);
        }));
        if (null != me) {
          /** @type {!Object} */
          element = me;
        }
      }
    } else {
      if (this.isSwimlaneSelectionEnabled() && (element = this.getSwimlaneAt(me.getGraphX(), me.getGraphY()), !(null == element || this.isToggleEvent(e) && mxEvent.isAltDown(e)))) {
        name = element;
        /** @type {!Array} */
        me = [];
        for (; null != name;) {
          name = this.model.getParent(name);
          var LOADED = this.view.getState(name);
          if (this.isSwimlane(name) && null != LOADED) {
            me.push(name);
          }
        }
        if (0 < me.length) {
          /** @type {!Array} */
          me = me.reverse();
          me.splice(0, 0, element);
          me.push(element);
          /** @type {number} */
          name = 0;
          for (; name < me.length - 1; name++) {
            if (this.isCellSelected(me[name])) {
              element = me[this.isToggleEvent(e) ? name : name + 1];
            }
          }
        }
      }
    }
    if (null != element) {
      this.selectCellForEvent(element, e);
    } else {
      if (!this.isToggleEvent(e)) {
        this.clearSelection();
      }
    }
  }
};
/**
 * @param {!Array} key
 * @return {?}
 */
mxGraph.prototype.isSiblingSelected = function(key) {
  var self = this.model;
  var cell = self.getParent(key);
  var childCount = self.getChildCount(cell);
  /** @type {number} */
  var i = 0;
  for (; i < childCount; i++) {
    var value = self.getChildAt(cell, i);
    if (key != value && this.isCellSelected(value)) {
      return true;
    }
  }
  return false;
};
/**
 * @param {string} e
 * @param {string} target
 * @return {undefined}
 */
mxGraph.prototype.dblClick = function(e, target) {
  var event = new mxEventObject(mxEvent.DOUBLE_CLICK, "event", e, "cell", target);
  this.fireEvent(event);
  if (!(!this.isEnabled() || mxEvent.isConsumed(e) || event.isConsumed() || null == target || !this.isCellEditable(target) || this.isEditing(target))) {
    this.startEditingAtCell(target, e);
    mxEvent.consume(e);
  }
};
/**
 * @param {!Object} me
 * @return {undefined}
 */
mxGraph.prototype.tapAndHold = function(me) {
  var e = me.getEvent();
  var event = new mxEventObject(mxEvent.TAP_AND_HOLD, "event", e, "cell", me.getCell());
  this.fireEvent(event);
  if (event.isConsumed()) {
    /** @type {boolean} */
    this.panningHandler.panningTrigger = false;
  }
  if (this.isEnabled() && !mxEvent.isConsumed(e) && !event.isConsumed() && this.connectionHandler.isEnabled()) {
    e = this.view.getState(this.connectionHandler.marker.getCell(me));
    if (null != e) {
      this.connectionHandler.marker.currentColor = this.connectionHandler.marker.validColor;
      this.connectionHandler.marker.markedState = e;
      this.connectionHandler.marker.mark();
      this.connectionHandler.first = new mxPoint(me.getGraphX(), me.getGraphY());
      this.connectionHandler.edgeState = this.connectionHandler.createEdgeState(me);
      this.connectionHandler.previous = e;
      this.connectionHandler.fireEvent(new mxEventObject(mxEvent.START, "state", this.connectionHandler.previous));
    }
  }
};
/**
 * @param {number} left
 * @param {number} top
 * @param {boolean} text
 * @param {number} y
 * @return {undefined}
 */
mxGraph.prototype.scrollPointToVisible = function(left, top, text, y) {
  if (this.timerAutoScroll || !this.ignoreScrollbars && !mxUtils.hasScrollbars(this.container)) {
    if (this.allowAutoPanning && !this.panningHandler.isActive()) {
      if (null == this.panningManager) {
        this.panningManager = this.createPanningManager();
      }
      this.panningManager.panTo(left + this.panDx, top + this.panDy);
    }
  } else {
    var element = this.container;
    y = null != y ? y : 20;
    if (left >= element.scrollLeft && top >= element.scrollTop && left <= element.scrollLeft + element.clientWidth && top <= element.scrollTop + element.clientHeight) {
      /** @type {number} */
      var bottom = element.scrollLeft + element.clientWidth - left;
      if (bottom < y) {
        if (left = element.scrollLeft, element.scrollLeft += y - bottom, text && left == element.scrollLeft) {
          if (this.dialect == mxConstants.DIALECT_SVG) {
            left = this.view.getDrawPane().ownerSVGElement;
            /** @type {number} */
            var height = this.container.scrollWidth + y - bottom;
          } else {
            /** @type {number} */
            height = Math.max(element.clientWidth, element.scrollWidth) + y - bottom;
            left = this.view.getCanvas();
          }
          /** @type {string} */
          left.style.width = height + "px";
          element.scrollLeft += y - bottom;
        }
      } else {
        /** @type {number} */
        bottom = left - element.scrollLeft;
        if (bottom < y) {
          element.scrollLeft -= y - bottom;
        }
      }
      /** @type {number} */
      bottom = element.scrollTop + element.clientHeight - top;
      if (bottom < y) {
        left = element.scrollTop;
        element.scrollTop += y - bottom;
        if (left == element.scrollTop && text) {
          if (this.dialect == mxConstants.DIALECT_SVG) {
            left = this.view.getDrawPane().ownerSVGElement;
            /** @type {number} */
            top = this.container.scrollHeight + y - bottom;
          } else {
            /** @type {number} */
            top = Math.max(element.clientHeight, element.scrollHeight) + y - bottom;
            left = this.view.getCanvas();
          }
          /** @type {string} */
          left.style.height = top + "px";
          element.scrollTop += y - bottom;
        }
      } else {
        /** @type {number} */
        bottom = top - element.scrollTop;
        if (bottom < y) {
          element.scrollTop -= y - bottom;
        }
      }
    }
  }
};
/**
 * @return {?}
 */
mxGraph.prototype.createPanningManager = function() {
  return new mxPanningManager(this);
};
/**
 * @return {?}
 */
mxGraph.prototype.getBorderSizes = function() {
  var s = mxUtils.getCurrentStyle(this.container);
  return new mxRectangle(mxUtils.parseCssNumber(s.paddingLeft) + ("none" != s.borderLeftStyle ? mxUtils.parseCssNumber(s.borderLeftWidth) : 0), mxUtils.parseCssNumber(s.paddingTop) + ("none" != s.borderTopStyle ? mxUtils.parseCssNumber(s.borderTopWidth) : 0), mxUtils.parseCssNumber(s.paddingRight) + ("none" != s.borderRightStyle ? mxUtils.parseCssNumber(s.borderRightWidth) : 0), mxUtils.parseCssNumber(s.paddingBottom) + ("none" != s.borderBottomStyle ? mxUtils.parseCssNumber(s.borderBottomWidth) : 
  0));
};
/**
 * @param {!Object} bounds
 * @param {number} width
 * @param {number} height
 * @return {?}
 */
mxGraph.prototype.getPreferredPageSize = function(bounds, width, height) {
  bounds = this.view.translate;
  var box = this.pageFormat;
  var multiplier = this.pageScale;
  box = new mxRectangle(0, 0, Math.ceil(box.width * multiplier), Math.ceil(box.height * multiplier));
  return new mxRectangle(0, 0, (this.pageBreaksVisible ? Math.ceil(width / box.width) : 1) * box.width + 2 + bounds.x, (this.pageBreaksVisible ? Math.ceil(height / box.height) : 1) * box.height + 2 + bounds.y);
};
/**
 * @param {number} options
 * @param {string} callback
 * @param {number} name
 * @param {?} timeout
 * @param {?} value
 * @param {?} v
 * @param {?} bounds
 * @return {?}
 */
mxGraph.prototype.fit = function(options, callback, name, timeout, value, v, bounds) {
  if (null != this.container) {
    options = null != options ? options : this.getBorder();
    callback = null != callback ? callback : false;
    name = null != name ? name : 0;
    timeout = null != timeout ? timeout : true;
    value = null != value ? value : false;
    v = null != v ? v : false;
    var scale = this.getBorderSizes();
    /** @type {number} */
    var w = this.container.offsetWidth - scale.x - scale.width - 1;
    var h = null != bounds ? bounds : this.container.offsetHeight - scale.y - scale.height - 1;
    bounds = this.view.getGraphBounds();
    if (0 < bounds.width && 0 < bounds.height) {
      if (callback && null != bounds.x && null != bounds.y) {
        bounds = bounds.clone();
        bounds.width += bounds.x;
        bounds.height += bounds.y;
        /** @type {number} */
        bounds.x = 0;
        /** @type {number} */
        bounds.y = 0;
      }
      scale = this.view.scale;
      /** @type {number} */
      var width = bounds.width / scale;
      /** @type {number} */
      var height = bounds.height / scale;
      if (null != this.backgroundImage) {
        /** @type {number} */
        width = Math.max(width, this.backgroundImage.width - bounds.x / scale);
        /** @type {number} */
        height = Math.max(height, this.backgroundImage.height - bounds.y / scale);
      }
      var lw = (callback ? options : 2 * options) + name + 1;
      /** @type {number} */
      w = w - lw;
      /** @type {number} */
      h = h - lw;
      /** @type {number} */
      value = value ? h / height : v ? w / width : Math.min(w / width, h / height);
      if (null != this.minFitScale) {
        /** @type {number} */
        value = Math.max(value, this.minFitScale);
      }
      if (null != this.maxFitScale) {
        /** @type {number} */
        value = Math.min(value, this.maxFitScale);
      }
      if (timeout) {
        if (callback) {
          if (this.view.scale != value) {
            this.view.setScale(value);
          }
        } else {
          if (mxUtils.hasScrollbars(this.container)) {
            this.view.setScale(value);
            options = this.getGraphBounds();
            if (null != options.x) {
              this.container.scrollLeft = options.x;
            }
            if (null != options.y) {
              this.container.scrollTop = options.y;
            }
          } else {
            this.view.scaleAndTranslate(value, null != bounds.x ? Math.floor(this.view.translate.x - bounds.x / scale + options / value + name / 2) : options, null != bounds.y ? Math.floor(this.view.translate.y - bounds.y / scale + options / value + name / 2) : options);
          }
        }
      } else {
        return value;
      }
    }
  }
  return this.view.scale;
};
/**
 * @return {undefined}
 */
mxGraph.prototype.sizeDidChange = function() {
  var bounds = this.getGraphBounds();
  if (null != this.container) {
    var width = this.getBorder();
    var left = Math.max(0, bounds.x) + bounds.width + 2 * width;
    width = Math.max(0, bounds.y) + bounds.height + 2 * width;
    if (null != this.minimumContainerSize) {
      /** @type {number} */
      left = Math.max(left, this.minimumContainerSize.width);
      /** @type {number} */
      width = Math.max(width, this.minimumContainerSize.height);
    }
    if (this.resizeContainer) {
      this.doResizeContainer(left, width);
    }
    if (this.preferPageSize || !mxClient.IS_IE && this.pageVisible) {
      var layer = this.getPreferredPageSize(bounds, Math.max(1, left), Math.max(1, width));
      if (null != layer) {
        /** @type {number} */
        left = layer.width * this.view.scale;
        /** @type {number} */
        width = layer.height * this.view.scale;
      }
    }
    if (null != this.minimumGraphSize) {
      /** @type {number} */
      left = Math.max(left, this.minimumGraphSize.width * this.view.scale);
      /** @type {number} */
      width = Math.max(width, this.minimumGraphSize.height * this.view.scale);
    }
    /** @type {number} */
    left = Math.ceil(left);
    /** @type {number} */
    width = Math.ceil(width);
    if (this.dialect == mxConstants.DIALECT_SVG) {
      layer = this.view.getDrawPane().ownerSVGElement;
      if (null != layer) {
        /** @type {string} */
        layer.style.minWidth = Math.max(1, left) + "px";
        /** @type {string} */
        layer.style.minHeight = Math.max(1, width) + "px";
        /** @type {string} */
        layer.style.width = "100%";
        /** @type {string} */
        layer.style.height = "100%";
      }
    } else {
      if (mxClient.IS_QUIRKS) {
        this.view.updateHtmlCanvasSize(Math.max(1, left), Math.max(1, width));
      } else {
        /** @type {string} */
        this.view.canvas.style.minWidth = Math.max(1, left) + "px";
        /** @type {string} */
        this.view.canvas.style.minHeight = Math.max(1, width) + "px";
      }
    }
    this.updatePageBreaks(this.pageBreaksVisible, left, width);
  }
  this.fireEvent(new mxEventObject(mxEvent.SIZE, "bounds", bounds));
};
/**
 * @param {number} val
 * @param {number} i
 * @return {undefined}
 */
mxGraph.prototype.doResizeContainer = function(val, i) {
  if (null != this.maximumContainerSize) {
    /** @type {number} */
    val = Math.min(this.maximumContainerSize.width, val);
    /** @type {number} */
    i = Math.min(this.maximumContainerSize.height, i);
  }
  /** @type {string} */
  this.container.style.width = Math.ceil(val) + "px";
  /** @type {string} */
  this.container.style.height = Math.ceil(i) + "px";
};
/**
 * @param {boolean} range
 * @param {!Audio} scale
 * @param {!Object} point
 * @return {undefined}
 */
mxGraph.prototype.updatePageBreaks = function(range, scale, point) {
  scale = this.view.scale;
  point = this.view.translate;
  var event = this.pageFormat;
  /** @type {number} */
  var ps = scale * this.pageScale;
  var bounds = new mxRectangle(0, 0, event.width * ps, event.height * ps);
  event = mxRectangle.fromRectangle(this.getGraphBounds());
  /** @type {number} */
  event.width = Math.max(1, event.width);
  /** @type {number} */
  event.height = Math.max(1, event.height);
  /** @type {number} */
  bounds.x = Math.floor((event.x - point.x * scale) / bounds.width) * bounds.width + point.x * scale;
  /** @type {number} */
  bounds.y = Math.floor((event.y - point.y * scale) / bounds.height) * bounds.height + point.y * scale;
  /** @type {number} */
  event.width = Math.ceil((event.width + (event.x - bounds.x)) / bounds.width) * bounds.width;
  /** @type {number} */
  event.height = Math.ceil((event.height + (event.y - bounds.y)) / bounds.height) * bounds.height;
  /** @type {number} */
  var ratio = (range = range && Math.min(bounds.width, bounds.height) > this.minPageBreakDist) ? Math.ceil(event.height / bounds.height) + 1 : 0;
  /** @type {number} */
  var count = range ? Math.ceil(event.width / bounds.width) + 1 : 0;
  /** @type {number} */
  var offsetX = (count - 1) * bounds.width;
  /** @type {number} */
  var offsetY = (ratio - 1) * bounds.height;
  if (null == this.horizontalPageBreaks && 0 < ratio) {
    /** @type {!Array} */
    this.horizontalPageBreaks = [];
  }
  if (null == this.verticalPageBreaks && 0 < count) {
    /** @type {!Array} */
    this.verticalPageBreaks = [];
  }
  range = mxUtils.bind(this, function(b) {
    if (null != b) {
      /** @type {number} */
      var end = b == this.horizontalPageBreaks ? ratio : count;
      /** @type {number} */
      var i = 0;
      for (; i <= end; i++) {
        /** @type {!Array} */
        var pageBreak = b == this.horizontalPageBreaks ? [new mxPoint(Math.round(bounds.x), Math.round(bounds.y + i * bounds.height)), new mxPoint(Math.round(bounds.x + offsetX), Math.round(bounds.y + i * bounds.height))] : [new mxPoint(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y)), new mxPoint(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y + offsetY))];
        if (null != b[i]) {
          /** @type {!Array} */
          b[i].points = pageBreak;
          b[i].redraw();
        } else {
          pageBreak = new mxPolyline(pageBreak, this.pageBreakColor);
          pageBreak.dialect = this.dialect;
          /** @type {boolean} */
          pageBreak.pointerEvents = false;
          pageBreak.isDashed = this.pageBreakDashed;
          pageBreak.init(this.view.backgroundPane);
          pageBreak.redraw();
          b[i] = pageBreak;
        }
      }
      /** @type {number} */
      i = end;
      for (; i < b.length; i++) {
        b[i].destroy();
      }
      b.splice(end, b.length - end);
    }
  });
  range(this.horizontalPageBreaks);
  range(this.verticalPageBreaks);
};
/**
 * @param {!Object} x
 * @param {boolean} f
 * @return {?}
 */
mxGraph.prototype.getCurrentCellStyle = function(x, f) {
  var col = f ? null : this.view.getState(x);
  return null != col ? col.style : this.getCellStyle(x);
};
/**
 * @param {!Object} cell
 * @return {?}
 */
mxGraph.prototype.getCellStyle = function(cell) {
  var edge = this.model.getStyle(cell);
  cell = this.model.isEdge(cell) ? this.stylesheet.getDefaultEdgeStyle() : this.stylesheet.getDefaultVertexStyle();
  if (null != edge) {
    cell = this.postProcessCellStyle(this.stylesheet.getCellStyle(edge, cell));
  }
  if (null == cell) {
    cell = {};
  }
  return cell;
};
/**
 * @param {?} from
 * @return {?}
 */
mxGraph.prototype.postProcessCellStyle = function(from) {
  if (null != from) {
    var i = from[mxConstants.STYLE_IMAGE];
    var key = this.getImageFromBundles(i);
    if (null != key) {
      from[mxConstants.STYLE_IMAGE] = key;
    } else {
      key = i;
    }
    if (null != key && "data:image/" == key.substring(0, 11)) {
      if ("data:image/svg+xml,<" == key.substring(0, 20)) {
        key = key.substring(0, 19) + encodeURIComponent(key.substring(19));
      } else {
        if ("data:image/svg+xml,%3C" != key.substring(0, 22)) {
          i = key.indexOf(",");
          if (0 < i && ";base64," != key.substring(i - 7, i + 1)) {
            key = key.substring(0, i) + ";base64," + key.substring(i + 1);
          }
        }
      }
      from[mxConstants.STYLE_IMAGE] = key;
    }
  }
  return from;
};
/**
 * @param {undefined} position
 * @param {number} matches
 * @return {undefined}
 */
mxGraph.prototype.setCellStyle = function(position, matches) {
  matches = matches || this.getSelectionCells();
  if (null != matches) {
    this.model.beginUpdate();
    try {
      /** @type {number} */
      var i = 0;
      for (; i < matches.length; i++) {
        this.model.setStyle(matches[i], position);
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {string} tweenType
 * @param {?} node
 * @param {?} callback
 * @return {?}
 */
mxGraph.prototype.toggleCellStyle = function(tweenType, node, callback) {
  callback = callback || this.getSelectionCell();
  return this.toggleCellStyles(tweenType, node, [callback]);
};
/**
 * @param {string} name
 * @param {?} data
 * @param {!Object} props
 * @return {?}
 */
mxGraph.prototype.toggleCellStyles = function(name, data, props) {
  data = null != data ? data : false;
  props = props || this.getSelectionCells();
  /** @type {null} */
  var value = null;
  if (null != props && 0 < props.length) {
    value = this.getCurrentCellStyle(props[0]);
    /** @type {number} */
    value = mxUtils.getValue(value, name, data) ? 0 : 1;
    this.setCellStyles(name, value, props);
  }
  return value;
};
/**
 * @param {?} opacity
 * @param {string} position
 * @param {!Array} value
 * @return {undefined}
 */
mxGraph.prototype.setCellStyles = function(opacity, position, value) {
  value = value || this.getSelectionCells();
  mxUtils.setCellStyles(this.model, value, opacity, position);
};
/**
 * @param {!Object} m
 * @param {string} format
 * @param {undefined} value
 * @return {undefined}
 */
mxGraph.prototype.toggleCellStyleFlags = function(m, format, value) {
  this.setCellStyleFlags(m, format, null, value);
};
/**
 * @param {!Object} i
 * @param {string} name
 * @param {!Object} offset
 * @param {string} value
 * @return {undefined}
 */
mxGraph.prototype.setCellStyleFlags = function(i, name, offset, value) {
  value = value || this.getSelectionCells();
  if (null != value && 0 < value.length) {
    if (null == offset) {
      offset = this.getCurrentCellStyle(value[0]);
      /** @type {boolean} */
      offset = (parseInt(offset[i] || 0) & name) != name;
    }
    mxUtils.setCellStyleFlags(this.model, value, i, name, offset);
  }
};
/**
 * @param {number} valign
 * @param {string} id
 * @param {number} x
 * @return {?}
 */
mxGraph.prototype.alignCells = function(valign, id, x) {
  if (null == id) {
    id = this.getSelectionCells();
  }
  if (null != id && 1 < id.length) {
    if (null == x) {
      /** @type {number} */
      var i = 0;
      for (; i < id.length; i++) {
        var that = this.view.getState(id[i]);
        if (null != that && !this.model.isEdge(id[i])) {
          if (null == x) {
            if (valign == mxConstants.ALIGN_CENTER) {
              x = that.x + that.width / 2;
              break;
            } else {
              if (valign == mxConstants.ALIGN_RIGHT) {
                x = that.x + that.width;
              } else {
                if (valign == mxConstants.ALIGN_TOP) {
                  x = that.y;
                } else {
                  if (valign == mxConstants.ALIGN_MIDDLE) {
                    x = that.y + that.height / 2;
                    break;
                  } else {
                    x = valign == mxConstants.ALIGN_BOTTOM ? that.y + that.height : that.x;
                  }
                }
              }
            }
          } else {
            /** @type {number} */
            x = valign == mxConstants.ALIGN_RIGHT ? Math.max(x, that.x + that.width) : valign == mxConstants.ALIGN_TOP ? Math.min(x, that.y) : valign == mxConstants.ALIGN_BOTTOM ? Math.max(x, that.y + that.height) : Math.min(x, that.x);
          }
        }
      }
    }
    if (null != x) {
      var h = this.view.scale;
      this.model.beginUpdate();
      try {
        /** @type {number} */
        i = 0;
        for (; i < id.length; i++) {
          if (that = this.view.getState(id[i]), null != that) {
            var item = this.getCellGeometry(id[i]);
            if (!(null == item || this.model.isEdge(id[i]))) {
              item = item.clone();
              if (valign == mxConstants.ALIGN_CENTER) {
                item.x += (x - that.x - that.width / 2) / h;
              } else {
                if (valign == mxConstants.ALIGN_RIGHT) {
                  item.x += (x - that.x - that.width) / h;
                } else {
                  if (valign == mxConstants.ALIGN_TOP) {
                    item.y += (x - that.y) / h;
                  } else {
                    if (valign == mxConstants.ALIGN_MIDDLE) {
                      item.y += (x - that.y - that.height / 2) / h;
                    } else {
                      if (valign == mxConstants.ALIGN_BOTTOM) {
                        item.y += (x - that.y - that.height) / h;
                      } else {
                        item.x += (x - that.x) / h;
                      }
                    }
                  }
                }
              }
              this.resizeCell(id[i], item);
            }
          }
        }
        this.fireEvent(new mxEventObject(mxEvent.ALIGN_CELLS, "align", valign, "cells", id));
      } finally {
        this.model.endUpdate();
      }
    }
  }
  return id;
};
/**
 * @param {string} property
 * @return {?}
 */
mxGraph.prototype.flipEdge = function(property) {
  if (null != property && null != this.alternateEdgeStyle) {
    this.model.beginUpdate();
    try {
      var instanceFillValue = this.model.getStyle(property);
      if (null == instanceFillValue || 0 == instanceFillValue.length) {
        this.model.setStyle(property, this.alternateEdgeStyle);
      } else {
        this.model.setStyle(property, null);
      }
      this.resetEdge(property);
      this.fireEvent(new mxEventObject(mxEvent.FLIP_EDGE, "edge", property));
    } finally {
      this.model.endUpdate();
    }
  }
  return property;
};
/**
 * @param {?} bone_in
 * @return {undefined}
 */
mxGraph.prototype.addImageBundle = function(bone_in) {
  this.imageBundles.push(bone_in);
};
/**
 * @param {?} charVal
 * @return {undefined}
 */
mxGraph.prototype.removeImageBundle = function(charVal) {
  /** @type {!Array} */
  var sortedSelection = [];
  /** @type {number} */
  var i = 0;
  for (; i < this.imageBundles.length; i++) {
    if (this.imageBundles[i] != charVal) {
      sortedSelection.push(this.imageBundles[i]);
    }
  }
  /** @type {!Array} */
  this.imageBundles = sortedSelection;
};
/**
 * @param {!Object} key
 * @return {?}
 */
mxGraph.prototype.getImageFromBundles = function(key) {
  if (null != key) {
    /** @type {number} */
    var i = 0;
    for (; i < this.imageBundles.length; i++) {
      var encodedKeyOrRange = this.imageBundles[i].getImage(key);
      if (null != encodedKeyOrRange) {
        return encodedKeyOrRange;
      }
    }
  }
  return null;
};
/**
 * @param {string} edit
 * @param {string} text
 * @return {?}
 */
mxGraph.prototype.orderCells = function(edit, text) {
  if (null == text) {
    text = mxUtils.sortCells(this.getSelectionCells(), true);
  }
  this.model.beginUpdate();
  try {
    this.cellsOrdered(text, edit);
    this.fireEvent(new mxEventObject(mxEvent.ORDER_CELLS, "back", edit, "cells", text));
  } finally {
    this.model.endUpdate();
  }
  return text;
};
/**
 * @param {string} children
 * @param {string} mode
 * @return {undefined}
 */
mxGraph.prototype.cellsOrdered = function(children, mode) {
  if (null != children) {
    this.model.beginUpdate();
    try {
      /** @type {number} */
      var i = 0;
      for (; i < children.length; i++) {
        var parent = this.model.getParent(children[i]);
        if (mode) {
          this.model.add(parent, children[i], i);
        } else {
          this.model.add(parent, children[i], this.model.getChildCount(parent) - 1);
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_ORDERED, "back", mode, "cells", children));
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {string} node
 * @param {number} parent
 * @param {string} children
 * @return {?}
 */
mxGraph.prototype.groupCells = function(node, parent, children) {
  if (null == children) {
    children = mxUtils.sortCells(this.getSelectionCells(), true);
  }
  children = this.getCellsForGroup(children);
  if (null == node) {
    node = this.createGroupCell(children);
  }
  var newNode = this.getBoundsForGroup(node, children, parent);
  if (1 < children.length && null != newNode) {
    var start = this.model.getParent(node);
    if (null == start) {
      start = this.model.getParent(children[0]);
    }
    this.model.beginUpdate();
    try {
      if (null == this.getCellGeometry(node)) {
        this.model.setGeometry(node, new mxGeometry);
      }
      var result = this.model.getChildCount(start);
      this.cellsAdded([node], start, result, null, null, false, false, false);
      result = this.model.getChildCount(node);
      this.cellsAdded(children, node, result, null, null, false, false, false);
      this.cellsMoved(children, -newNode.x, -newNode.y, false, false, false);
      this.cellsResized([node], [newNode], false);
      this.fireEvent(new mxEventObject(mxEvent.GROUP_CELLS, "group", node, "border", parent, "cells", children));
    } finally {
      this.model.endUpdate();
    }
  }
  return node;
};
/**
 * @param {string} children
 * @return {?}
 */
mxGraph.prototype.getCellsForGroup = function(children) {
  /** @type {!Array} */
  var childleftbehind = [];
  if (null != children && 0 < children.length) {
    var c = this.model.getParent(children[0]);
    childleftbehind.push(children[0]);
    /** @type {number} */
    var i = 1;
    for (; i < children.length; i++) {
      if (this.model.getParent(children[i]) == c) {
        childleftbehind.push(children[i]);
      }
    }
  }
  return childleftbehind;
};
/**
 * @param {!Object} options
 * @param {!Object} node
 * @param {number} x
 * @return {?}
 */
mxGraph.prototype.getBoundsForGroup = function(options, node, x) {
  node = this.getBoundingBoxFromGeometry(node, true);
  if (null != node) {
    if (this.isSwimlane(options)) {
      options = this.getStartSize(options);
      node.x -= options.width;
      node.y -= options.height;
      node.width += options.width;
      node.height += options.height;
    }
    if (null != x) {
      node.x -= x;
      node.y -= x;
      node.width += 2 * x;
      node.height += 2 * x;
    }
  }
  return node;
};
/**
 * @param {string} group
 * @return {?}
 */
mxGraph.prototype.createGroupCell = function(group) {
  group = new mxCell("");
  group.setVertex(true);
  group.setConnectable(false);
  return group;
};
/**
 * @param {!Object} matches
 * @return {?}
 */
mxGraph.prototype.ungroupCells = function(matches) {
  /** @type {!Array} */
  var chain = [];
  if (null == matches) {
    matches = this.getCellsForUngroup();
  }
  if (null != matches && 0 < matches.length) {
    this.model.beginUpdate();
    try {
      /** @type {number} */
      var j = 0;
      for (; j < matches.length; j++) {
        var children = this.model.getChildren(matches[j]);
        if (null != children && 0 < children.length) {
          children = children.slice();
          var parent = this.model.getParent(matches[j]);
          var currentSubViewArray = this.model.getChildCount(parent);
          this.cellsAdded(children, parent, currentSubViewArray, null, null, true);
          /** @type {!Array<?>} */
          chain = chain.concat(children);
          /** @type {number} */
          var i = 0;
          for (; i < children.length; i++) {
            var anchorBounds = this.view.getState(children[i]);
            var path = this.getCellGeometry(children[i]);
            if (null != anchorBounds && null != path && path.relative) {
              path = path.clone();
              path.x = anchorBounds.origin.x;
              path.y = anchorBounds.origin.y;
              /** @type {boolean} */
              path.relative = false;
              this.model.setGeometry(children[i], path);
            }
          }
        }
      }
      this.removeCellsAfterUngroup(matches);
      this.fireEvent(new mxEventObject(mxEvent.UNGROUP_CELLS, "cells", matches));
    } finally {
      this.model.endUpdate();
    }
  }
  return chain;
};
/**
 * @return {?}
 */
mxGraph.prototype.getCellsForUngroup = function() {
  var cells = this.getSelectionCells();
  /** @type {!Array} */
  var cellsUpdated = [];
  /** @type {number} */
  var i = 0;
  for (; i < cells.length; i++) {
    if (this.model.isVertex(cells[i]) && 0 < this.model.getChildCount(cells[i])) {
      cellsUpdated.push(cells[i]);
    }
  }
  return cellsUpdated;
};
/**
 * @param {boolean} props
 * @return {undefined}
 */
mxGraph.prototype.removeCellsAfterUngroup = function(props) {
  this.cellsRemoved(this.addAllEdges(props));
};
/**
 * @param {string} a
 * @return {?}
 */
mxGraph.prototype.removeCellsFromParent = function(a) {
  if (null == a) {
    a = this.getSelectionCells();
  }
  this.model.beginUpdate();
  try {
    var parent = this.getDefaultParent();
    var currentSubViewArray = this.model.getChildCount(parent);
    this.cellsAdded(a, parent, currentSubViewArray, null, null, true);
    this.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS_FROM_PARENT, "cells", a));
  } finally {
    this.model.endUpdate();
  }
  return a;
};
/**
 * @param {!Object} list
 * @param {number} pos
 * @param {string} data
 * @param {number} width
 * @param {number} space
 * @param {number} offset
 * @param {number} v
 * @return {?}
 */
mxGraph.prototype.updateGroupBounds = function(list, pos, data, width, space, offset, v) {
  if (null == list) {
    list = this.getSelectionCells();
  }
  pos = null != pos ? pos : 0;
  data = null != data ? data : false;
  width = null != width ? width : 0;
  space = null != space ? space : 0;
  offset = null != offset ? offset : 0;
  v = null != v ? v : 0;
  this.model.beginUpdate();
  try {
    /** @type {number} */
    var i = list.length - 1;
    for (; 0 <= i; i--) {
      var line = this.getCellGeometry(list[i]);
      if (null != line) {
        var string = this.getChildCells(list[i]);
        if (null != string && 0 < string.length) {
          var that = this.getBoundingBoxFromGeometry(string, true);
          if (null != that && 0 < that.width && 0 < that.height) {
            var item = this.isSwimlane(list[i]) ? this.getActualStartSize(list[i], true) : new mxRectangle;
            line = line.clone();
            if (data) {
              /** @type {number} */
              line.x = Math.round(line.x + that.x - pos - item.x - v);
              /** @type {number} */
              line.y = Math.round(line.y + that.y - pos - item.y - width);
            }
            /** @type {number} */
            line.width = Math.round(that.width + 2 * pos + item.x + v + space + item.width);
            /** @type {number} */
            line.height = Math.round(that.height + 2 * pos + item.y + width + offset + item.height);
            this.model.setGeometry(list[i], line);
            this.moveCells(string, pos + item.x - that.x + v, pos + item.y - that.y + width);
          }
        }
      }
    }
  } finally {
    this.model.endUpdate();
  }
  return list;
};
/**
 * @param {!Object} o
 * @return {?}
 */
mxGraph.prototype.getBoundingBox = function(o) {
  /** @type {null} */
  var res = null;
  if (null != o && 0 < o.length) {
    /** @type {number} */
    var i = 0;
    for (; i < o.length; i++) {
      if (this.model.isVertex(o[i]) || this.model.isEdge(o[i])) {
        var d = this.view.getBoundingBox(this.view.getState(o[i]), true);
        if (null != d) {
          if (null == res) {
            res = mxRectangle.fromRectangle(d);
          } else {
            res.add(d);
          }
        }
      }
    }
  }
  return res;
};
/**
 * @param {string} s
 * @param {?} salt
 * @param {undefined} id
 * @param {boolean} toX
 * @return {?}
 */
mxGraph.prototype.cloneCell = function(s, salt, id, toX) {
  return this.cloneCells([s], salt, id, toX)[0];
};
/**
 * @param {!Object} cells
 * @param {?} data
 * @param {number} value
 * @param {boolean} valid
 * @return {?}
 */
mxGraph.prototype.cloneCells = function(cells, data, value, valid) {
  data = null != data ? data : true;
  /** @type {null} */
  var result = null;
  if (null != cells) {
    var c = new mxDictionary;
    /** @type {!Array} */
    result = [];
    /** @type {number} */
    var i = 0;
    for (; i < cells.length; i++) {
      c.put(cells[i], true);
      result.push(cells[i]);
    }
    if (0 < result.length) {
      var scale = this.view.scale;
      var t = this.view.translate;
      result = this.model.cloneCells(cells, true, value);
      /** @type {number} */
      i = 0;
      for (; i < cells.length; i++) {
        if (!data && this.model.isEdge(result[i]) && null != this.getEdgeValidationError(result[i], this.model.getTerminal(result[i], true), this.model.getTerminal(result[i], false))) {
          /** @type {null} */
          result[i] = null;
        } else {
          var p = this.model.getGeometry(result[i]);
          if (null != p) {
            var pos = this.view.getState(cells[i]);
            var s = this.view.getState(this.model.getParent(cells[i]));
            if (null != pos && null != s) {
              if (value = valid ? 0 : s.origin.x, s = valid ? 0 : s.origin.y, this.model.isEdge(result[i])) {
                if (pos = pos.absolutePoints, null != pos) {
                  var d = this.model.getTerminal(cells[i], true);
                  for (; null != d && !c.get(d);) {
                    d = this.model.getParent(d);
                  }
                  if (null == d && null != pos[0]) {
                    p.setTerminalPoint(new mxPoint(pos[0].x / scale - t.x, pos[0].y / scale - t.y), true);
                  }
                  d = this.model.getTerminal(cells[i], false);
                  for (; null != d && !c.get(d);) {
                    d = this.model.getParent(d);
                  }
                  /** @type {number} */
                  var j = pos.length - 1;
                  if (null == d && null != pos[j]) {
                    p.setTerminalPoint(new mxPoint(pos[j].x / scale - t.x, pos[j].y / scale - t.y), false);
                  }
                  p = p.points;
                  if (null != p) {
                    /** @type {number} */
                    pos = 0;
                    for (; pos < p.length; pos++) {
                      p[pos].x += value;
                      p[pos].y += s;
                    }
                  }
                }
              } else {
                p.translate(value, s);
              }
            }
          }
        }
      }
    } else {
      /** @type {!Array} */
      result = [];
    }
  }
  return result;
};
/**
 * @param {undefined} index
 * @param {string} i
 * @param {!Object} end
 * @param {number} str
 * @param {?} e
 * @param {boolean} id
 * @param {?} vertex
 * @param {!Function} start
 * @param {string} step
 * @return {?}
 */
mxGraph.prototype.insertVertex = function(index, i, end, str, e, id, vertex, start, step) {
  i = this.createVertex(index, i, end, str, e, id, vertex, start, step);
  return this.addCell(i, index);
};
/**
 * @param {string} result
 * @param {string} id
 * @param {!Object} label
 * @param {?} x
 * @param {boolean} y
 * @param {boolean} color
 * @param {boolean} name
 * @param {!Function} options
 * @param {string} value
 * @return {?}
 */
mxGraph.prototype.createVertex = function(result, id, label, x, y, color, name, options, value) {
  result = new mxGeometry(x, y, color, name);
  result.relative = null != value ? value : false;
  label = new mxCell(label, result, options);
  label.setId(id);
  label.setVertex(true);
  label.setConnectable(true);
  return label;
};
/**
 * @param {string} target
 * @param {string} node
 * @param {string} type
 * @param {string} value
 * @param {string} parent
 * @param {!Object} id
 * @return {?}
 */
mxGraph.prototype.insertEdge = function(target, node, type, value, parent, id) {
  node = this.createEdge(target, node, type, value, parent, id);
  return this.addEdge(node, target, value, parent);
};
/**
 * @param {!Object} a
 * @param {string} id
 * @param {string} name
 * @param {string} attr
 * @param {string} value
 * @param {!Object} type
 * @return {?}
 */
mxGraph.prototype.createEdge = function(a, id, name, attr, value, type) {
  a = new mxCell(name, new mxGeometry, type);
  a.setId(id);
  a.setEdge(true);
  /** @type {boolean} */
  a.geometry.relative = true;
  return a;
};
/**
 * @param {string} from
 * @param {string} to
 * @param {!Object} item
 * @param {!Object} e
 * @param {?} value
 * @return {?}
 */
mxGraph.prototype.addEdge = function(from, to, item, e, value) {
  return this.addCell(from, to, value, item, e);
};
/**
 * @param {string} index
 * @param {?} key
 * @param {?} item
 * @param {!Object} x
 * @param {!Object} text
 * @return {?}
 */
mxGraph.prototype.addCell = function(index, key, item, x, text) {
  return this.addCells([index], key, item, x, text)[0];
};
/**
 * @param {string} items
 * @param {number} start
 * @param {number} data
 * @param {boolean} event
 * @param {boolean} type
 * @param {string} skipFormulaReparse
 * @return {?}
 */
mxGraph.prototype.addCells = function(items, start, data, event, type, skipFormulaReparse) {
  if (null == start) {
    start = this.getDefaultParent();
  }
  if (null == data) {
    data = this.model.getChildCount(start);
  }
  this.model.beginUpdate();
  try {
    this.cellsAdded(items, start, data, event, type, null != skipFormulaReparse ? skipFormulaReparse : false, true);
    this.fireEvent(new mxEventObject(mxEvent.ADD_CELLS, "cells", items, "parent", start, "index", data, "source", event, "target", type));
  } finally {
    this.model.endUpdate();
  }
  return items;
};
/**
 * @param {string} list
 * @param {number} name
 * @param {number} subs
 * @param {number} result
 * @param {boolean} actual
 * @param {string} r
 * @param {string} success
 * @param {string} status
 * @return {undefined}
 */
mxGraph.prototype.cellsAdded = function(list, name, subs, result, actual, r, success, status) {
  if (null != list && null != name && null != subs) {
    this.model.beginUpdate();
    try {
      var i = r ? this.view.getState(name) : null;
      var Cpoints = null != i ? i.origin : null;
      var label = new mxPoint(0, 0);
      /** @type {number} */
      i = 0;
      for (; i < list.length; i++) {
        if (null == list[i]) {
          subs--;
        } else {
          var type = this.model.getParent(list[i]);
          if (null != Cpoints && list[i] != name && name != type) {
            var html = this.view.getState(type);
            var point = null != html ? html.origin : label;
            var to = this.model.getGeometry(list[i]);
            if (null != to) {
              /** @type {number} */
              var m = point.x - Cpoints.x;
              /** @type {number} */
              var value = point.y - Cpoints.y;
              to = to.clone();
              to.translate(m, value);
              if (!(to.relative || !this.model.isVertex(list[i]) || this.isAllowNegativeCoordinates())) {
                /** @type {number} */
                to.x = Math.max(0, to.x);
                /** @type {number} */
                to.y = Math.max(0, to.y);
              }
              this.model.setGeometry(list[i], to);
            }
          }
          if (name == type && subs + i > this.model.getChildCount(name)) {
            subs--;
          }
          this.model.add(name, list[i], subs + i);
          if (this.autoSizeCellsOnAdd) {
            this.autoSizeCell(list[i], true);
          }
          if ((null == status || status) && this.isExtendParentsOnAdd(list[i]) && this.isExtendParent(list[i])) {
            this.extendParent(list[i]);
          }
          if (null == success || success) {
            this.constrainChild(list[i]);
          }
          if (null != result) {
            this.cellConnected(list[i], result, true);
          }
          if (null != actual) {
            this.cellConnected(list[i], actual, false);
          }
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_ADDED, "cells", list, "parent", name, "index", subs, "source", result, "target", actual, "absolute", r));
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {undefined} cell
 * @param {number} is_resize
 * @return {undefined}
 */
mxGraph.prototype.autoSizeCell = function(cell, is_resize) {
  if (null != is_resize ? is_resize : 1) {
    var childCount = this.model.getChildCount(cell);
    /** @type {number} */
    var i = 0;
    for (; i < childCount; i++) {
      this.autoSizeCell(this.model.getChildAt(cell, i));
    }
  }
  if (this.getModel().isVertex(cell) && this.isAutoSizeCell(cell)) {
    this.updateCellSize(cell);
  }
};
/**
 * @param {string} a
 * @param {!Object} v
 * @return {?}
 */
mxGraph.prototype.removeCells = function(a, v) {
  v = null != v ? v : true;
  if (null == a) {
    a = this.getDeletableCells(this.getSelectionCells());
  }
  if (v) {
    a = this.getDeletableCells(this.addAllEdges(a));
  } else {
    a = a.slice();
    var nodes = this.getDeletableCells(this.getAllEdges(a));
    var r = new mxDictionary;
    /** @type {number} */
    var i = 0;
    for (; i < a.length; i++) {
      r.put(a[i], true);
    }
    /** @type {number} */
    i = 0;
    for (; i < nodes.length; i++) {
      if (!(null != this.view.getState(nodes[i]) || r.get(nodes[i]))) {
        r.put(nodes[i], true);
        a.push(nodes[i]);
      }
    }
  }
  this.model.beginUpdate();
  try {
    this.cellsRemoved(a);
    this.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS, "cells", a, "includeEdges", v));
  } finally {
    this.model.endUpdate();
  }
  return a;
};
/**
 * @param {!Object} names
 * @return {undefined}
 */
mxGraph.prototype.cellsRemoved = function(names) {
  if (null != names && 0 < names.length) {
    var scale = this.view.scale;
    var t = this.view.translate;
    this.model.beginUpdate();
    try {
      var r = new mxDictionary;
      /** @type {number} */
      var i = 0;
      for (; i < names.length; i++) {
        r.put(names[i], true);
      }
      /** @type {number} */
      i = 0;
      for (; i < names.length; i++) {
        var a = this.getAllEdges([names[i]]);
        var g = mxUtils.bind(this, function(id, options) {
          var y = this.model.getGeometry(id);
          if (null != y) {
            var x = this.model.getTerminal(id, options);
            /** @type {boolean} */
            var e = false;
            var name = x;
            for (; null != name;) {
              if (names[i] == name) {
                /** @type {boolean} */
                e = true;
                break;
              }
              name = this.model.getParent(name);
            }
            if (e) {
              y = y.clone();
              e = this.view.getState(id);
              if (null != e && null != e.absolutePoints) {
                x = e.absolutePoints;
                /** @type {number} */
                name = options ? 0 : x.length - 1;
                y.setTerminalPoint(new mxPoint(x[name].x / scale - t.x - e.origin.x, x[name].y / scale - t.y - e.origin.y), options);
              } else {
                x = this.view.getState(x);
                if (null != x) {
                  y.setTerminalPoint(new mxPoint(x.getCenterX() / scale - t.x, x.getCenterY() / scale - t.y), options);
                }
              }
              this.model.setGeometry(id, y);
              this.model.setTerminal(id, null, options);
            }
          }
        });
        /** @type {number} */
        var j = 0;
        for (; j < a.length; j++) {
          if (!r.get(a[j])) {
            r.put(a[j], true);
            g(a[j], true);
            g(a[j], false);
          }
        }
        this.model.remove(names[i]);
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_REMOVED, "cells", names));
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {string} key
 * @param {string} e
 * @param {number} cell
 * @param {number} x
 * @param {boolean} i
 * @param {number} map
 * @param {?} nodes
 * @param {number} parent
 * @return {?}
 */
mxGraph.prototype.splitEdge = function(key, e, cell, x, i, map, nodes, parent) {
  x = x || 0;
  i = i || 0;
  parent = null != parent ? parent : this.model.getParent(key);
  map = this.model.getTerminal(key, true);
  this.model.beginUpdate();
  try {
    if (null == cell) {
      cell = this.cloneCell(key);
      var style = this.view.getState(key);
      var geo = this.getCellGeometry(cell);
      if (null != geo && null != geo.points && null != style) {
        var p = this.view.translate;
        var s = this.view.scale;
        var m = mxUtils.findNearestSegment(style, (x + p.x) * s, (i + p.y) * s);
        geo.points = geo.points.slice(0, m);
        geo = this.getCellGeometry(key);
        if (null != geo && null != geo.points) {
          geo = geo.clone();
          geo.points = geo.points.slice(m);
          this.model.setGeometry(key, geo);
        }
      }
    }
    this.cellsMoved(e, x, i, false, false);
    this.cellsAdded(e, parent, this.model.getChildCount(parent), null, null, true);
    this.cellsAdded([cell], parent, this.model.getChildCount(parent), map, e[0], false);
    this.cellConnected(key, e[0], true);
    this.fireEvent(new mxEventObject(mxEvent.SPLIT_EDGE, "edge", key, "cells", e, "newEdge", cell, "dx", x, "dy", i));
  } finally {
    this.model.endUpdate();
  }
  return cell;
};
/**
 * @param {string} date
 * @param {string} f
 * @param {string} _clusterMode
 * @return {?}
 */
mxGraph.prototype.toggleCells = function(date, f, _clusterMode) {
  if (null == f) {
    f = this.getSelectionCells();
  }
  if (_clusterMode) {
    f = this.addAllEdges(f);
  }
  this.model.beginUpdate();
  try {
    this.cellsToggled(f, date);
    this.fireEvent(new mxEventObject(mxEvent.TOGGLE_CELLS, "show", date, "cells", f, "includeEdges", _clusterMode));
  } finally {
    this.model.endUpdate();
  }
  return f;
};
/**
 * @param {string} filters
 * @param {!Object} type
 * @return {undefined}
 */
mxGraph.prototype.cellsToggled = function(filters, type) {
  if (null != filters && 0 < filters.length) {
    this.model.beginUpdate();
    try {
      /** @type {number} */
      var i = 0;
      for (; i < filters.length; i++) {
        this.model.setVisible(filters[i], type);
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {string} value
 * @param {string} max
 * @param {string} msg
 * @param {!Object} wrap
 * @param {!Object} p
 * @return {?}
 */
mxGraph.prototype.foldCells = function(value, max, msg, wrap, p) {
  max = null != max ? max : false;
  if (null == msg) {
    msg = this.getFoldableCells(this.getSelectionCells(), value);
  }
  this.stopEditing(false);
  this.model.beginUpdate();
  try {
    this.cellsFolded(msg, value, max, wrap);
    this.fireEvent(new mxEventObject(mxEvent.FOLD_CELLS, "collapse", value, "recurse", max, "cells", msg));
  } finally {
    this.model.endUpdate();
  }
  return msg;
};
/**
 * @param {string} children
 * @param {string} collapsed
 * @param {string} rect
 * @param {!Object} node
 * @return {undefined}
 */
mxGraph.prototype.cellsFolded = function(children, collapsed, rect, node) {
  if (null != children && 0 < children.length) {
    this.model.beginUpdate();
    try {
      /** @type {number} */
      var i = 0;
      for (; i < children.length; i++) {
        if ((!node || this.isCellFoldable(children[i], collapsed)) && collapsed != this.isCellCollapsed(children[i])) {
          this.model.setCollapsed(children[i], collapsed);
          this.swapBounds(children[i], collapsed);
          if (this.isExtendParent(children[i])) {
            this.extendParent(children[i]);
          }
          if (rect) {
            var detailNodes = this.model.getChildren(children[i]);
            this.cellsFolded(detailNodes, collapsed, rect);
          }
          this.constrainChild(children[i]);
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_FOLDED, "cells", children, "collapse", collapsed, "recurse", rect));
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {?} p
 * @param {?} value
 * @return {undefined}
 */
mxGraph.prototype.swapBounds = function(p, value) {
  if (null != p) {
    var y = this.model.getGeometry(p);
    if (null != y) {
      y = y.clone();
      this.updateAlternateBounds(p, y, value);
      y.swap();
      this.model.setGeometry(p, y);
    }
  }
};
/**
 * @param {number} i
 * @param {number} point
 * @param {number} d
 * @return {undefined}
 */
mxGraph.prototype.updateAlternateBounds = function(i, point, d) {
  if (null != i && null != point) {
    d = this.getCurrentCellStyle(i);
    if (null == point.alternateBounds) {
      /** @type {number} */
      var s = point;
      if (this.collapseToPreferredSize) {
        i = this.getPreferredSizeForCell(i);
        if (null != i) {
          /** @type {number} */
          s = i;
          i = mxUtils.getValue(d, mxConstants.STYLE_STARTSIZE);
          if (0 < i) {
            /** @type {number} */
            s.height = Math.max(s.height, i);
          }
        }
      }
      point.alternateBounds = new mxRectangle(0, 0, s.width, s.height);
    }
    if (null != point.alternateBounds) {
      point.alternateBounds.x = point.x;
      point.alternateBounds.y = point.y;
      var j = mxUtils.toRadians(d[mxConstants.STYLE_ROTATION] || 0);
      if (0 != j) {
        /** @type {number} */
        d = point.alternateBounds.getCenterX() - point.getCenterX();
        /** @type {number} */
        s = point.alternateBounds.getCenterY() - point.getCenterY();
        /** @type {number} */
        i = Math.cos(j);
        /** @type {number} */
        j = Math.sin(j);
        point.alternateBounds.x += i * d - j * s - d;
        point.alternateBounds.y += j * d + i * s - s;
      }
    }
  }
};
/**
 * @param {string} src
 * @return {?}
 */
mxGraph.prototype.addAllEdges = function(src) {
  var cmd = src.slice();
  return mxUtils.removeDuplicates(cmd.concat(this.getAllEdges(src)));
};
/**
 * @param {!Object} children
 * @return {?}
 */
mxGraph.prototype.getAllEdges = function(children) {
  /** @type {!Array} */
  var arr = [];
  if (null != children) {
    /** @type {number} */
    var i = 0;
    for (; i < children.length; i++) {
      var p = this.model.getEdgeCount(children[i]);
      /** @type {number} */
      var e = 0;
      for (; e < p; e++) {
        arr.push(this.model.getEdgeAt(children[i], e));
      }
      p = this.model.getChildren(children[i]);
      /** @type {!Array<?>} */
      arr = arr.concat(this.getAllEdges(p));
    }
  }
  return arr;
};
/**
 * @param {string} parentNode
 * @param {string} args
 * @return {?}
 */
mxGraph.prototype.updateCellSize = function(parentNode, args) {
  args = null != args ? args : false;
  this.model.beginUpdate();
  try {
    this.cellSizeUpdated(parentNode, args);
    this.fireEvent(new mxEventObject(mxEvent.UPDATE_CELL_SIZE, "cell", parentNode, "ignoreChildren", args));
  } finally {
    this.model.endUpdate();
  }
  return parentNode;
};
/**
 * @param {!Object} cell
 * @param {string} elements
 * @return {undefined}
 */
mxGraph.prototype.cellSizeUpdated = function(cell, elements) {
  if (null != cell) {
    this.model.beginUpdate();
    try {
      var p = this.getPreferredSizeForCell(cell);
      var c = this.model.getGeometry(cell);
      if (null != p && null != c) {
        var droppedDate = this.isCellCollapsed(cell);
        c = c.clone();
        if (this.isSwimlane(cell)) {
          var style = this.getCellStyle(cell);
          var value = this.model.getStyle(cell);
          if (null == value) {
            /** @type {string} */
            value = "";
          }
          if (mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true)) {
            value = mxUtils.setStyle(value, mxConstants.STYLE_STARTSIZE, p.height + 8);
            if (droppedDate) {
              c.height = p.height + 8;
            }
            c.width = p.width;
          } else {
            value = mxUtils.setStyle(value, mxConstants.STYLE_STARTSIZE, p.width + 8);
            if (droppedDate) {
              c.width = p.width + 8;
            }
            c.height = p.height;
          }
          this.model.setStyle(cell, value);
        } else {
          var state = this.view.createState(cell);
          var align = state.style[mxConstants.STYLE_ALIGN] || mxConstants.ALIGN_CENTER;
          if (align == mxConstants.ALIGN_RIGHT) {
            c.x += c.width - p.width;
          } else {
            if (align == mxConstants.ALIGN_CENTER) {
              c.x += Math.round((c.width - p.width) / 2);
            }
          }
          var valign = this.getVerticalAlign(state);
          if (valign == mxConstants.ALIGN_BOTTOM) {
            c.y += c.height - p.height;
          } else {
            if (valign == mxConstants.ALIGN_MIDDLE) {
              c.y += Math.round((c.height - p.height) / 2);
            }
          }
          c.width = p.width;
          c.height = p.height;
        }
        if (!elements && !droppedDate) {
          var locPSRect = this.view.getBounds(this.model.getChildren(cell));
          if (null != locPSRect) {
            var t = this.view.translate;
            var scale = this.view.scale;
            /** @type {number} */
            var height = (locPSRect.y + locPSRect.height) / scale - c.y - t.y;
            /** @type {number} */
            c.width = Math.max(c.width, (locPSRect.x + locPSRect.width) / scale - c.x - t.x);
            /** @type {number} */
            c.height = Math.max(c.height, height);
          }
        }
        this.cellsResized([cell], [c], false);
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {?} source
 * @param {string} b
 * @return {?}
 */
mxGraph.prototype.getPreferredSizeForCell = function(source, b) {
  /** @type {null} */
  var result = null;
  if (null != source) {
    var value = this.view.createState(source);
    var style = value.style;
    if (!this.model.isEdge(source)) {
      var g = style[mxConstants.STYLE_FONTSIZE] || mxConstants.DEFAULT_FONTSIZE;
      /** @type {number} */
      var c = 0;
      /** @type {number} */
      result = 0;
      if (!(null == this.getImage(value) && null == style[mxConstants.STYLE_IMAGE] || style[mxConstants.STYLE_SHAPE] != mxConstants.SHAPE_LABEL)) {
        if (style[mxConstants.STYLE_VERTICAL_ALIGN] == mxConstants.ALIGN_MIDDLE) {
          /** @type {number} */
          c = c + (parseFloat(style[mxConstants.STYLE_IMAGE_WIDTH]) || mxLabel.prototype.imageSize);
        }
        if (style[mxConstants.STYLE_ALIGN] != mxConstants.ALIGN_CENTER) {
          /** @type {number} */
          result = result + (parseFloat(style[mxConstants.STYLE_IMAGE_HEIGHT]) || mxLabel.prototype.imageSize);
        }
      }
      /** @type {number} */
      c = c + 2 * (style[mxConstants.STYLE_SPACING] || 0);
      c = c + (style[mxConstants.STYLE_SPACING_LEFT] || 0);
      c = c + (style[mxConstants.STYLE_SPACING_RIGHT] || 0);
      /** @type {number} */
      result = result + 2 * (style[mxConstants.STYLE_SPACING] || 0);
      result = result + (style[mxConstants.STYLE_SPACING_TOP] || 0);
      result = result + (style[mxConstants.STYLE_SPACING_BOTTOM] || 0);
      var s = this.getFoldingImage(value);
      if (null != s) {
        c = c + (s.width + 8);
      }
      s = this.cellRenderer.getLabelValue(value);
      if (null != s && 0 < s.length) {
        if (!this.isHtmlLabel(value.cell)) {
          s = mxUtils.htmlEntities(s, false);
        }
        s = s.replace(/\n/g, "<br>");
        g = mxUtils.getSizeForString(s, g, style[mxConstants.STYLE_FONTFAMILY], b, style[mxConstants.STYLE_FONTSTYLE]);
        value = g.width + c;
        result = g.height + result;
        if (!mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true)) {
          style = result;
          result = value;
          value = style;
        }
        if (this.gridEnabled) {
          value = this.snap(value + this.gridSize / 2);
          result = this.snap(result + this.gridSize / 2);
        }
        result = new mxRectangle(0, 0, value, result);
      } else {
        /** @type {number} */
        style = 4 * this.gridSize;
        result = new mxRectangle(0, 0, style, style);
      }
    }
  }
  return result;
};
/**
 * @param {string} height
 * @param {?} width
 * @param {!Function} index
 * @return {?}
 */
mxGraph.prototype.resizeCell = function(height, width, index) {
  return this.resizeCells([height], [width], index)[0];
};
/**
 * @param {string} height
 * @param {number} width
 * @param {string} e
 * @return {?}
 */
mxGraph.prototype.resizeCells = function(height, width, e) {
  e = null != e ? e : this.isRecursiveResize();
  this.model.beginUpdate();
  try {
    var f = this.cellsResized(height, width, e);
    this.fireEvent(new mxEventObject(mxEvent.RESIZE_CELLS, "cells", height, "bounds", width, "previous", f));
  } finally {
    this.model.endUpdate();
  }
  return height;
};
/**
 * @param {string} a
 * @param {number} b
 * @param {string} c
 * @return {?}
 */
mxGraph.prototype.cellsResized = function(a, b, c) {
  c = null != c ? c : false;
  /** @type {!Array} */
  var join = [];
  if (null != a && null != b && a.length == b.length) {
    this.model.beginUpdate();
    try {
      /** @type {number} */
      var i = 0;
      for (; i < a.length; i++) {
        join.push(this.cellResized(a[i], b[i], false, c));
        if (this.isExtendParent(a[i])) {
          this.extendParent(a[i]);
        }
        this.constrainChild(a[i]);
      }
      if (this.resetEdgesOnResize) {
        this.resetEdges(a);
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_RESIZED, "cells", a, "bounds", b, "previous", join));
    } finally {
      this.model.endUpdate();
    }
  }
  return join;
};
/**
 * @param {!Object} element
 * @param {!Object} a
 * @param {number} d
 * @param {string} prefix
 * @return {?}
 */
mxGraph.prototype.cellResized = function(element, a, d, prefix) {
  var params = this.model.getGeometry(element);
  if (null != params && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height)) {
    var c = params.clone();
    if (!d && c.relative) {
      d = c.offset;
      if (null != d) {
        d.x += a.x - c.x;
        d.y += a.y - c.y;
      }
    } else {
      c.x = a.x;
      c.y = a.y;
    }
    c.width = a.width;
    c.height = a.height;
    if (!(c.relative || !this.model.isVertex(element) || this.isAllowNegativeCoordinates())) {
      /** @type {number} */
      c.x = Math.max(0, c.x);
      /** @type {number} */
      c.y = Math.max(0, c.y);
    }
    this.model.beginUpdate();
    try {
      if (prefix) {
        this.resizeChildCells(element, c);
      }
      this.model.setGeometry(element, c);
      this.constrainChildCells(element);
    } finally {
      this.model.endUpdate();
    }
  }
  return params;
};
/**
 * @param {!Object} cell
 * @param {!Object} b
 * @return {undefined}
 */
mxGraph.prototype.resizeChildCells = function(cell, b) {
  var a = this.model.getGeometry(cell);
  /** @type {number} */
  var verticalrailid = 0 != a.width ? b.width / a.width : 1;
  /** @type {number} */
  a = 0 != a.height ? b.height / a.height : 1;
  var childCount = this.model.getChildCount(cell);
  /** @type {number} */
  var i = 0;
  for (; i < childCount; i++) {
    this.scaleCell(this.model.getChildAt(cell, i), verticalrailid, a, true);
  }
};
/**
 * @param {!Object} parent
 * @return {undefined}
 */
mxGraph.prototype.constrainChildCells = function(parent) {
  var newParentTag = this.model.getChildCount(parent);
  /** @type {number} */
  var i = 0;
  for (; i < newParentTag; i++) {
    this.constrainChild(this.model.getChildAt(parent, i));
  }
};
/**
 * @param {!Object} element
 * @param {number} s
 * @param {undefined} p
 * @param {string} i
 * @return {undefined}
 */
mxGraph.prototype.scaleCell = function(element, s, p, i) {
  var v = this.model.getGeometry(element);
  if (null != v) {
    var style = this.getCurrentCellStyle(element);
    v = v.clone();
    var dx = v.x;
    var y = v.y;
    var size = v.width;
    var height = v.height;
    v.scale(s, p, "fixed" == style[mxConstants.STYLE_ASPECT]);
    if ("1" == style[mxConstants.STYLE_RESIZE_WIDTH]) {
      /** @type {number} */
      v.width = size * s;
    } else {
      if ("0" == style[mxConstants.STYLE_RESIZE_WIDTH]) {
        v.width = size;
      }
    }
    if ("1" == style[mxConstants.STYLE_RESIZE_HEIGHT]) {
      /** @type {number} */
      v.height = height * p;
    } else {
      if ("0" == style[mxConstants.STYLE_RESIZE_HEIGHT]) {
        v.height = height;
      }
    }
    if (!this.isCellMovable(element)) {
      v.x = dx;
      v.y = y;
    }
    if (!this.isCellResizable(element)) {
      v.width = size;
      v.height = height;
    }
    if (this.model.isVertex(element)) {
      this.cellResized(element, v, true, i);
    } else {
      this.model.setGeometry(element, v);
    }
  }
};
/**
 * @param {!Object} target
 * @return {undefined}
 */
mxGraph.prototype.extendParent = function(target) {
  if (null != target) {
    var b = this.model.getParent(target);
    var a = this.getCellGeometry(b);
    if (!(null == b || null == a || this.isCellCollapsed(b))) {
      target = this.getCellGeometry(target);
      if (null != target && !target.relative && (a.width < target.x + target.width || a.height < target.y + target.height)) {
        a = a.clone();
        /** @type {number} */
        a.width = Math.max(a.width, target.x + target.width);
        /** @type {number} */
        a.height = Math.max(a.height, target.y + target.height);
        this.cellsResized([b], [a], false);
      }
    }
  }
};
/**
 * @param {!Array} cells
 * @param {number} type
 * @param {number} s
 * @param {undefined} parent
 * @param {string} start
 * @param {undefined} data
 * @return {?}
 */
mxGraph.prototype.importCells = function(cells, type, s, parent, start, data) {
  return this.moveCells(cells, type, s, true, parent, start, data);
};
/**
 * @param {string} cells
 * @param {number} data
 * @param {number} path
 * @param {number} target
 * @param {number} parent
 * @param {string} e
 * @param {number} h
 * @return {?}
 */
mxGraph.prototype.moveCells = function(cells, data, path, target, parent, e, h) {
  data = null != data ? data : 0;
  path = null != path ? path : 0;
  target = null != target ? target : false;
  if (null != cells && (0 != data || 0 != path || target || null != parent)) {
    var existingSels = cells = this.model.getTopmostCells(cells);
    this.model.beginUpdate();
    try {
      var c = new mxDictionary;
      /** @type {number} */
      var i = 0;
      for (; i < cells.length; i++) {
        c.put(cells[i], true);
      }
      var isUndefined = mxUtils.bind(this, function(d) {
        for (; null != d;) {
          if (c.get(d)) {
            return true;
          }
          d = this.model.getParent(d);
        }
        return false;
      });
      /** @type {!Array} */
      var _ = [];
      /** @type {number} */
      i = 0;
      for (; i < cells.length; i++) {
        var geo = this.getCellGeometry(cells[i]);
        var cell = this.model.getParent(cells[i]);
        if (!(null != geo && geo.relative && this.model.isEdge(cell) && (isUndefined(this.model.getTerminal(cell, true)) || isUndefined(this.model.getTerminal(cell, false))))) {
          _.push(cells[i]);
        }
      }
      /** @type {!Array} */
      cells = _;
      if (target) {
        cells = this.cloneCells(cells, this.isCloneInvalidEdges(), h);
        if (null == parent) {
          parent = this.getDefaultParent();
        }
      }
      var 1 = this.isAllowNegativeCoordinates();
      if (null != parent) {
        this.setAllowNegativeCoordinates(true);
      }
      this.cellsMoved(cells, data, path, !target && this.isDisconnectOnMove() && this.isAllowDanglingEdges(), null == parent, this.isExtendParentsOnMove() && null == parent);
      this.setAllowNegativeCoordinates(1);
      if (null != parent) {
        var currentSubViewArray = this.model.getChildCount(parent);
        this.cellsAdded(cells, parent, currentSubViewArray, null, null, true);
        if (target) {
          /** @type {number} */
          i = 0;
          for (; i < cells.length; i++) {
            geo = this.getCellGeometry(cells[i]);
            cell = this.model.getParent(existingSels[i]);
            if (null != geo && geo.relative && this.model.isEdge(cell) && this.model.contains(cell)) {
              this.model.add(cell, cells[i]);
            }
          }
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.MOVE_CELLS, "cells", cells, "dx", data, "dy", path, "clone", target, "target", parent, "event", e));
    } finally {
      this.model.endUpdate();
    }
  }
  return cells;
};
/**
 * @param {string} obj
 * @param {string} h
 * @param {number} p
 * @param {number} r
 * @param {boolean} provider
 * @param {string} e
 * @return {undefined}
 */
mxGraph.prototype.cellsMoved = function(obj, h, p, r, provider, e) {
  if (null != obj && (0 != h || 0 != p)) {
    e = null != e ? e : false;
    this.model.beginUpdate();
    try {
      if (r) {
        this.disconnectGraph(obj);
      }
      /** @type {number} */
      var i = 0;
      for (; i < obj.length; i++) {
        this.translateCell(obj[i], h, p);
        if (e && this.isExtendParent(obj[i])) {
          this.extendParent(obj[i]);
        } else {
          if (provider) {
            this.constrainChild(obj[i]);
          }
        }
      }
      if (this.resetEdgesOnMove) {
        this.resetEdges(obj);
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_MOVED, "cells", obj, "dx", h, "dy", p, "disconnect", r));
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {undefined} cell
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxGraph.prototype.translateCell = function(cell, x, y) {
  var a = this.model.getGeometry(cell);
  if (null != a) {
    /** @type {number} */
    x = parseFloat(x);
    /** @type {number} */
    y = parseFloat(y);
    a = a.clone();
    a.translate(x, y);
    if (!(a.relative || !this.model.isVertex(cell) || this.isAllowNegativeCoordinates())) {
      /** @type {number} */
      a.x = Math.max(0, parseFloat(a.x));
      /** @type {number} */
      a.y = Math.max(0, parseFloat(a.y));
    }
    if (a.relative && !this.model.isEdge(cell)) {
      var value = this.model.getParent(cell);
      /** @type {number} */
      var c = 0;
      if (this.model.isVertex(value)) {
        value = this.getCurrentCellStyle(value);
        c = mxUtils.getValue(value, mxConstants.STYLE_ROTATION, 0);
      }
      if (0 != c) {
        c = mxUtils.toRadians(-c);
        /** @type {number} */
        value = Math.cos(c);
        /** @type {number} */
        c = Math.sin(c);
        y = mxUtils.getRotatedPoint(new mxPoint(x, y), value, c, new mxPoint(0, 0));
        x = y.x;
        y = y.y;
      }
      if (null == a.offset) {
        a.offset = new mxPoint(x, y);
      } else {
        a.offset.x = parseFloat(a.offset.x) + x;
        a.offset.y = parseFloat(a.offset.y) + y;
      }
    }
    this.model.setGeometry(cell, a);
  }
};
/**
 * @param {string} n
 * @return {?}
 */
mxGraph.prototype.getCellContainmentArea = function(n) {
  if (null != n && !this.model.isEdge(n)) {
    var i = this.model.getParent(n);
    if (null != i && i != this.getDefaultParent()) {
      var size = this.model.getGeometry(i);
      if (null != size) {
        /** @type {number} */
        var g = n = 0;
        var width = size.width;
        size = size.height;
        if (this.isSwimlane(i)) {
          var r = this.getStartSize(i);
          var node = this.getCurrentCellStyle(i);
          i = mxUtils.getValue(node, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
          /** @type {boolean} */
          var isQuad = 1 == mxUtils.getValue(node, mxConstants.STYLE_FLIPH, 0);
          /** @type {boolean} */
          node = 1 == mxUtils.getValue(node, mxConstants.STYLE_FLIPV, 0);
          if (i == mxConstants.DIRECTION_SOUTH || i == mxConstants.DIRECTION_NORTH) {
            var n = r.width;
            r.width = r.height;
            r.height = n;
          }
          if (i == mxConstants.DIRECTION_EAST && !node || i == mxConstants.DIRECTION_NORTH && !isQuad || i == mxConstants.DIRECTION_WEST && node || i == mxConstants.DIRECTION_SOUTH && isQuad) {
            n = r.width;
            g = r.height;
          }
          /** @type {number} */
          width = width - r.width;
          /** @type {number} */
          size = size - r.height;
        }
        return new mxRectangle(n, g, width, size);
      }
    }
  }
  return null;
};
/**
 * @return {?}
 */
mxGraph.prototype.getMaximumGraphBounds = function() {
  return this.maximumGraphBounds;
};
/**
 * @param {!Object} x
 * @param {?} miniBatchSize
 * @return {undefined}
 */
mxGraph.prototype.constrainChild = function(x, miniBatchSize) {
  if (null != x) {
    var self = this.getCellGeometry(x);
    if (null != self && (this.isConstrainRelativeChildren() || !self.relative)) {
      var rect = this.model.getParent(x);
      this.getCellGeometry(rect);
      var bounds = this.getMaximumGraphBounds();
      if (null != bounds) {
        rect = this.getBoundingBoxFromGeometry([rect], false);
        if (null != rect) {
          bounds = mxRectangle.fromRectangle(bounds);
          bounds.x -= rect.x;
          bounds.y -= rect.y;
        }
      }
      if (this.isConstrainChild(x) && (rect = this.getCellContainmentArea(x), null != rect)) {
        var s = this.getOverlap(x);
        if (0 < s) {
          rect = mxRectangle.fromRectangle(rect);
          rect.x -= rect.width * s;
          rect.y -= rect.height * s;
          rect.width += 2 * rect.width * s;
          rect.height += 2 * rect.height * s;
        }
        if (null == bounds) {
          bounds = rect;
        } else {
          bounds = mxRectangle.fromRectangle(bounds);
          bounds.intersect(rect);
        }
      }
      if (null != bounds) {
        /** @type {!Array} */
        rect = [x];
        if (!this.isCellCollapsed(x)) {
          s = this.model.getDescendants(x);
          /** @type {number} */
          var d = 0;
          for (; d < s.length; d++) {
            if (this.isCellVisible(s[d])) {
              rect.push(s[d]);
            }
          }
        }
        rect = this.getBoundingBoxFromGeometry(rect, false);
        if (null != rect) {
          self = self.clone();
          /** @type {number} */
          s = 0;
          if (self.width > bounds.width) {
            /** @type {number} */
            s = self.width - bounds.width;
            self.width -= s;
          }
          if (rect.x + rect.width > bounds.x + bounds.width) {
            /** @type {number} */
            s = s - (rect.x + rect.width - bounds.x - bounds.width - s);
          }
          /** @type {number} */
          d = 0;
          if (self.height > bounds.height) {
            /** @type {number} */
            d = self.height - bounds.height;
            self.height -= d;
          }
          if (rect.y + rect.height > bounds.y + bounds.height) {
            /** @type {number} */
            d = d - (rect.y + rect.height - bounds.y - bounds.height - d);
          }
          if (rect.x < bounds.x) {
            /** @type {number} */
            s = s - (rect.x - bounds.x);
          }
          if (rect.y < bounds.y) {
            /** @type {number} */
            d = d - (rect.y - bounds.y);
          }
          if (0 != s || 0 != d) {
            if (self.relative) {
              if (null == self.offset) {
                self.offset = new mxPoint;
              }
              self.offset.x += s;
              self.offset.y += d;
            } else {
              self.x += s;
              self.y += d;
            }
          }
          this.model.setGeometry(x, self);
        }
      }
    }
  }
};
/**
 * @param {string} args
 * @return {undefined}
 */
mxGraph.prototype.resetEdges = function(args) {
  if (null != args) {
    var b = new mxDictionary;
    /** @type {number} */
    var i = 0;
    for (; i < args.length; i++) {
      b.put(args[i], true);
    }
    this.model.beginUpdate();
    try {
      /** @type {number} */
      i = 0;
      for (; i < args.length; i++) {
        var rels = this.model.getEdges(args[i]);
        if (null != rels) {
          /** @type {number} */
          var i = 0;
          for (; i < rels.length; i++) {
            var f = this.view.getState(rels[i]);
            var g = null != f ? f.getVisibleTerminal(true) : this.view.getVisibleTerminal(rels[i], true);
            var k = null != f ? f.getVisibleTerminal(false) : this.view.getVisibleTerminal(rels[i], false);
            if (!(b.get(g) && b.get(k))) {
              this.resetEdge(rels[i]);
            }
          }
        }
        this.resetEdges(this.model.getChildren(args[i]));
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {!Object} element
 * @return {?}
 */
mxGraph.prototype.resetEdge = function(element) {
  var geo = this.model.getGeometry(element);
  if (null != geo && null != geo.points && 0 < geo.points.length) {
    geo = geo.clone();
    /** @type {!Array} */
    geo.points = [];
    this.model.setGeometry(element, geo);
  }
  return element;
};
/**
 * @param {number} result
 * @param {!Object} state
 * @param {!Object} o
 * @return {?}
 */
mxGraph.prototype.getOutlineConstraint = function(result, state, o) {
  if (null != state.shape) {
    o = this.view.getPerimeterBounds(state);
    var align = state.style[mxConstants.STYLE_DIRECTION];
    if (align == mxConstants.DIRECTION_NORTH || align == mxConstants.DIRECTION_SOUTH) {
      o.x += o.width / 2 - o.height / 2;
      o.y += o.height / 2 - o.width / 2;
      var value = o.width;
      o.width = o.height;
      o.height = value;
    }
    var z = mxUtils.toRadians(state.shape.getShapeRotation());
    if (0 != z) {
      /** @type {number} */
      value = Math.cos(-z);
      /** @type {number} */
      z = Math.sin(-z);
      var ct = new mxPoint(o.getCenterX(), o.getCenterY());
      result = mxUtils.getRotatedPoint(result, value, z, ct);
    }
    /** @type {number} */
    ct = z = 1;
    /** @type {number} */
    var x = 0;
    /** @type {number} */
    var y = 0;
    if (this.getModel().isVertex(state.cell)) {
      var field = state.style[mxConstants.STYLE_FLIPH];
      var frequency = state.style[mxConstants.STYLE_FLIPV];
      if (null != state.shape && null != state.shape.stencil) {
        field = 1 == mxUtils.getValue(state.style, "stencilFlipH", 0) || field;
        frequency = 1 == mxUtils.getValue(state.style, "stencilFlipV", 0) || frequency;
      }
      if (align == mxConstants.DIRECTION_NORTH || align == mxConstants.DIRECTION_SOUTH) {
        value = field;
        field = frequency;
        frequency = value;
      }
      if (field) {
        /** @type {number} */
        z = -1;
        /** @type {number} */
        x = -o.width;
      }
      if (frequency) {
        /** @type {number} */
        ct = -1;
        /** @type {number} */
        y = -o.height;
      }
    }
    result = new mxPoint((result.x - o.x) * z - x + o.x, (result.y - o.y) * ct - y + o.y);
    return new mxConnectionConstraint(new mxPoint(0 == o.width ? 0 : Math.round(1E3 * (result.x - o.x) / o.width) / 1E3, 0 == o.height ? 0 : Math.round(1E3 * (result.y - o.y) / o.height) / 1E3), false);
  }
  return null;
};
/**
 * @param {!Object} source
 * @param {number} b
 * @return {?}
 */
mxGraph.prototype.getAllConnectionConstraints = function(source, b) {
  return null != source && null != source.shape && null != source.shape.stencil ? source.shape.stencil.constraints : null;
};
/**
 * @param {!Object} s
 * @param {!Object} index
 * @param {boolean} v
 * @return {?}
 */
mxGraph.prototype.getConnectionConstraint = function(s, index, v) {
  /** @type {null} */
  index = null;
  var fltScore = s.style[v ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X];
  if (null != fltScore) {
    var size = s.style[v ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y];
    if (null != size) {
      index = new mxPoint(parseFloat(fltScore), parseFloat(size));
    }
  }
  /** @type {boolean} */
  fltScore = false;
  /** @type {number} */
  var ret = size = 0;
  if (null != index) {
    fltScore = mxUtils.getValue(s.style, v ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, true);
    /** @type {number} */
    size = parseFloat(s.style[v ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX]);
    /** @type {number} */
    ret = parseFloat(s.style[v ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY]);
    /** @type {number} */
    size = isFinite(size) ? size : 0;
    /** @type {number} */
    ret = isFinite(ret) ? ret : 0;
  }
  return new mxConnectionConstraint(index, fltScore, null, size, ret);
};
/**
 * @param {string} a
 * @param {string} b
 * @param {string} c
 * @param {!Object} d
 * @return {undefined}
 */
mxGraph.prototype.setConnectionConstraint = function(a, b, c, d) {
  if (null != d) {
    this.model.beginUpdate();
    try {
      if (null == d || null == d.point) {
        this.setCellStyles(c ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X, null, [a]);
        this.setCellStyles(c ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y, null, [a]);
        this.setCellStyles(c ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX, null, [a]);
        this.setCellStyles(c ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY, null, [a]);
        this.setCellStyles(c ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, null, [a]);
      } else {
        if (null != d.point) {
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X, d.point.x, [a]);
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y, d.point.y, [a]);
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX, d.dx, [a]);
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY, d.dy, [a]);
          if (d.perimeter) {
            this.setCellStyles(c ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, null, [a]);
          } else {
            this.setCellStyles(c ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, "0", [a]);
          }
        }
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {!Object} state
 * @param {!Object} a
 * @param {?} v
 * @return {?}
 */
mxGraph.prototype.getConnectionPoint = function(state, a, v) {
  v = null != v ? v : true;
  /** @type {null} */
  var value = null;
  if (null != state && null != a.point) {
    var s = this.view.getPerimeterBounds(state);
    var ct = new mxPoint(s.getCenterX(), s.getCenterY());
    var o = state.style[mxConstants.STYLE_DIRECTION];
    /** @type {number} */
    var e = 0;
    if (null != o && 1 == mxUtils.getValue(state.style, mxConstants.STYLE_ANCHOR_POINT_DIRECTION, 1)) {
      if (o == mxConstants.DIRECTION_NORTH) {
        /** @type {number} */
        e = e + 270;
      } else {
        if (o == mxConstants.DIRECTION_WEST) {
          /** @type {number} */
          e = e + 180;
        } else {
          if (o == mxConstants.DIRECTION_SOUTH) {
            /** @type {number} */
            e = e + 90;
          }
        }
      }
      if (!(o != mxConstants.DIRECTION_NORTH && o != mxConstants.DIRECTION_SOUTH)) {
        s.rotate90();
      }
    }
    value = this.view.scale;
    value = new mxPoint(s.x + a.point.x * s.width + a.dx * value, s.y + a.point.y * s.height + a.dy * value);
    var result = state.style[mxConstants.STYLE_ROTATION] || 0;
    if (a.perimeter) {
      if (0 != e) {
        /** @type {number} */
        o = s = 0;
        if (90 == e) {
          /** @type {number} */
          o = 1;
        } else {
          if (180 == e) {
            /** @type {number} */
            s = -1;
          } else {
            if (270 == e) {
              /** @type {number} */
              o = -1;
            }
          }
        }
        value = mxUtils.getRotatedPoint(value, s, o, ct);
      }
      value = this.view.getPerimeterPoint(state, value, false);
    } else {
      if (result = result + e, this.getModel().isVertex(state.cell)) {
        /** @type {boolean} */
        e = 1 == state.style[mxConstants.STYLE_FLIPH];
        /** @type {boolean} */
        a = 1 == state.style[mxConstants.STYLE_FLIPV];
        if (null != state.shape && null != state.shape.stencil) {
          /** @type {boolean} */
          e = 1 == mxUtils.getValue(state.style, "stencilFlipH", 0) || e;
          /** @type {boolean} */
          a = 1 == mxUtils.getValue(state.style, "stencilFlipV", 0) || a;
        }
        if (o == mxConstants.DIRECTION_NORTH || o == mxConstants.DIRECTION_SOUTH) {
          /** @type {boolean} */
          state = e;
          /** @type {!Object} */
          e = a;
          /** @type {!Object} */
          a = state;
        }
        if (e) {
          /** @type {number} */
          value.x = 2 * s.getCenterX() - value.x;
        }
        if (a) {
          /** @type {number} */
          value.y = 2 * s.getCenterY() - value.y;
        }
      }
    }
    if (0 != result && null != value) {
      state = mxUtils.toRadians(result);
      /** @type {number} */
      s = Math.cos(state);
      /** @type {number} */
      o = Math.sin(state);
      value = mxUtils.getRotatedPoint(value, s, o, ct);
    }
  }
  if (v && null != value) {
    /** @type {number} */
    value.x = Math.round(value.x);
    /** @type {number} */
    value.y = Math.round(value.y);
  }
  return value;
};
/**
 * @param {string} source
 * @param {string} replacement
 * @param {string} start
 * @param {string} data
 * @return {?}
 */
mxGraph.prototype.connectCell = function(source, replacement, start, data) {
  this.model.beginUpdate();
  try {
    var matchs = this.model.getTerminal(source, start);
    this.cellConnected(source, replacement, start, data);
    this.fireEvent(new mxEventObject(mxEvent.CONNECT_CELL, "edge", source, "terminal", replacement, "source", start, "previous", matchs));
  } finally {
    this.model.endUpdate();
  }
  return source;
};
/**
 * @param {string} id
 * @param {string} node
 * @param {string} options
 * @param {string} value
 * @return {undefined}
 */
mxGraph.prototype.cellConnected = function(id, node, options, value) {
  if (null != id) {
    this.model.beginUpdate();
    try {
      var transformId = this.model.getTerminal(id, options);
      this.setConnectionConstraint(id, node, options, value);
      if (this.isPortsEnabled()) {
        /** @type {null} */
        value = null;
        if (this.isPort(node)) {
          value = node.getId();
          node = this.getTerminalForPort(node, options);
        }
        this.setCellStyles(options ? mxConstants.STYLE_SOURCE_PORT : mxConstants.STYLE_TARGET_PORT, value, [id]);
      }
      this.model.setTerminal(id, node, options);
      if (this.resetEdgesOnConnect) {
        this.resetEdge(id);
      }
      this.fireEvent(new mxEventObject(mxEvent.CELL_CONNECTED, "edge", id, "terminal", node, "source", options, "previous", transformId));
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @param {string} nodes
 * @return {undefined}
 */
mxGraph.prototype.disconnectGraph = function(nodes) {
  if (null != nodes) {
    this.model.beginUpdate();
    try {
      var scale = this.view.scale;
      var t = this.view.translate;
      var Dom = new mxDictionary;
      /** @type {number} */
      var i = 0;
      for (; i < nodes.length; i++) {
        Dom.put(nodes[i], true);
      }
      /** @type {number} */
      i = 0;
      for (; i < nodes.length; i++) {
        if (this.model.isEdge(nodes[i])) {
          var y = this.model.getGeometry(nodes[i]);
          if (null != y) {
            var r_chunk = this.view.getState(nodes[i]);
            var m = this.view.getState(this.model.getParent(nodes[i]));
            if (null != r_chunk && null != m) {
              y = y.clone();
              /** @type {number} */
              var sz = -m.origin.x;
              /** @type {number} */
              var th = -m.origin.y;
              var vertices = r_chunk.absolutePoints;
              var d = this.model.getTerminal(nodes[i], true);
              if (null != d && this.isCellDisconnectable(nodes[i], d, true)) {
                for (; null != d && !Dom.get(d);) {
                  d = this.model.getParent(d);
                }
                if (null == d) {
                  y.setTerminalPoint(new mxPoint(vertices[0].x / scale - t.x + sz, vertices[0].y / scale - t.y + th), true);
                  this.model.setTerminal(nodes[i], null, true);
                }
              }
              var name = this.model.getTerminal(nodes[i], false);
              if (null != name && this.isCellDisconnectable(nodes[i], name, false)) {
                for (; null != name && !Dom.get(name);) {
                  name = this.model.getParent(name);
                }
                if (null == name) {
                  /** @type {number} */
                  var minVertexIndex = vertices.length - 1;
                  y.setTerminalPoint(new mxPoint(vertices[minVertexIndex].x / scale - t.x + sz, vertices[minVertexIndex].y / scale - t.y + th), false);
                  this.model.setTerminal(nodes[i], null, false);
                }
              }
              this.model.setGeometry(nodes[i], y);
            }
          }
        }
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
/**
 * @return {?}
 */
mxGraph.prototype.getCurrentRoot = function() {
  return this.view.currentRoot;
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.getTranslateForRoot = function(a) {
  return null;
};
/**
 * @param {string} obj
 * @return {?}
 */
mxGraph.prototype.isPort = function(obj) {
  return false;
};
/**
 * @param {!Object} selector
 * @param {string} options
 * @return {?}
 */
mxGraph.prototype.getTerminalForPort = function(selector, options) {
  return this.model.getParent(selector);
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.getChildOffsetForCell = function(a) {
  return null;
};
/**
 * @param {string} event
 * @return {undefined}
 */
mxGraph.prototype.enterGroup = function(event) {
  event = event || this.getSelectionCell();
  if (null != event && this.isValidRoot(event)) {
    this.view.setCurrentRoot(event);
    this.clearSelection();
  }
};
/**
 * @return {undefined}
 */
mxGraph.prototype.exitGroup = function() {
  var undefined = this.model.getRoot();
  var type = this.getCurrentRoot();
  if (null != type) {
    var key = this.model.getParent(type);
    for (; key != undefined && !this.isValidRoot(key) && this.model.getParent(key) != undefined;) {
      key = this.model.getParent(key);
    }
    if (key == undefined || this.model.getParent(key) == undefined) {
      this.view.setCurrentRoot(null);
    } else {
      this.view.setCurrentRoot(key);
    }
    if (null != this.view.getState(type)) {
      this.setSelectionCell(type);
    }
  }
};
/**
 * @return {undefined}
 */
mxGraph.prototype.home = function() {
  var index = this.getCurrentRoot();
  if (null != index) {
    this.view.setCurrentRoot(null);
    if (null != this.view.getState(index)) {
      this.setSelectionCell(index);
    }
  }
};
/**
 * @param {!Object} jsonObj
 * @return {?}
 */
mxGraph.prototype.isValidRoot = function(jsonObj) {
  return null != jsonObj;
};
/**
 * @return {?}
 */
mxGraph.prototype.getGraphBounds = function() {
  return this.view.getGraphBounds();
};
/**
 * @param {?} cell
 * @param {?} col
 * @param {number} rowSpan
 * @return {?}
 */
mxGraph.prototype.getCellBounds = function(cell, col, rowSpan) {
  /** @type {!Array} */
  var data = [cell];
  if (col) {
    /** @type {!Array<?>} */
    data = data.concat(this.model.getEdges(cell));
  }
  data = this.view.getBounds(data);
  if (rowSpan) {
    rowSpan = this.model.getChildCount(cell);
    /** @type {number} */
    var i = 0;
    for (; i < rowSpan; i++) {
      var tmp = this.getCellBounds(this.model.getChildAt(cell, i), col, true);
      if (null != data) {
        data.add(tmp);
      } else {
        data = tmp;
      }
    }
  }
  return data;
};
/**
 * @param {!Object} node
 * @param {string} min
 * @return {?}
 */
mxGraph.prototype.getBoundingBoxFromGeometry = function(node, min) {
  min = null != min ? min : false;
  /** @type {null} */
  var pending = null;
  if (null != node) {
    /** @type {number} */
    var i = 0;
    for (; i < node.length; i++) {
      if (min || this.model.isVertex(node[i])) {
        var data = this.getCellGeometry(node[i]);
        if (null != data) {
          /** @type {null} */
          var offset = null;
          if (this.model.isEdge(node[i])) {
            /**
             * @param {!Object} dist
             * @return {undefined}
             */
            offset = function(dist) {
              if (null != dist) {
                if (null == options) {
                  options = new mxRectangle(dist.x, dist.y, 0, 0);
                } else {
                  options.add(new mxRectangle(dist.x, dist.y, 0, 0));
                }
              }
            };
            if (null == this.model.getTerminal(node[i], true)) {
              offset(data.getTerminalPoint(true));
            }
            if (null == this.model.getTerminal(node[i], false)) {
              offset(data.getTerminalPoint(false));
            }
            data = data.points;
            if (null != data && 0 < data.length) {
              var options = new mxRectangle(data[0].x, data[0].y, 0, 0);
              /** @type {number} */
              var index = 1;
              for (; index < data.length; index++) {
                offset(data[index]);
              }
            }
            offset = options;
          } else {
            index = this.model.getParent(node[i]);
            if (data.relative) {
              if (this.model.isVertex(index) && index != this.view.currentRoot) {
                options = this.getBoundingBoxFromGeometry([index], false);
                if (null != options) {
                  offset = new mxRectangle(data.x * options.width, data.y * options.height, data.width, data.height);
                  if (0 <= mxUtils.indexOf(node, index)) {
                    offset.x += options.x;
                    offset.y += options.y;
                  }
                }
              }
            } else {
              offset = mxRectangle.fromRectangle(data);
              if (this.model.isVertex(index) && 0 <= mxUtils.indexOf(node, index)) {
                options = this.getBoundingBoxFromGeometry([index], false);
                if (null != options) {
                  offset.x += options.x;
                  offset.y += options.y;
                }
              }
            }
            if (null != offset && null != data.offset) {
              offset.x += data.offset.x;
              offset.y += data.offset.y;
            }
            data = this.getCurrentCellStyle(node[i]);
            if (null != offset) {
              data = mxUtils.getValue(data, mxConstants.STYLE_ROTATION, 0);
              if (0 != data) {
                offset = mxUtils.getBoundingBox(offset, data);
              }
            }
          }
          if (null != offset) {
            if (null == pending) {
              pending = mxRectangle.fromRectangle(offset);
            } else {
              pending.add(offset);
            }
          }
        }
      }
    }
  }
  return pending;
};
/**
 * @param {string} a
 * @return {undefined}
 */
mxGraph.prototype.refresh = function(a) {
  this.view.clear(a, null == a);
  this.view.validate();
  this.sizeDidChange();
  this.fireEvent(new mxEventObject(mxEvent.REFRESH));
};
/**
 * @param {number} value
 * @return {?}
 */
mxGraph.prototype.snap = function(value) {
  if (this.gridEnabled) {
    /** @type {number} */
    value = Math.round(value / this.gridSize) * this.gridSize;
  }
  return value;
};
/**
 * @param {!Object} data
 * @param {number} offset
 * @param {number} delta
 * @param {number} i
 * @param {boolean} eof
 * @return {?}
 */
mxGraph.prototype.snapDelta = function(data, offset, delta, i, eof) {
  var t = this.view.translate;
  var scale = this.view.scale;
  if (!delta && this.gridEnabled) {
    /** @type {number} */
    delta = this.gridSize * scale * .5;
    if (!i) {
      /** @type {number} */
      i = offset.x - (this.snap(offset.x / scale - t.x) + t.x) * scale;
      /** @type {number} */
      data.x = Math.abs(data.x - i) < delta ? 0 : this.snap(data.x / scale) * scale - i;
    }
    if (!eof) {
      /** @type {number} */
      offset = offset.y - (this.snap(offset.y / scale - t.y) + t.y) * scale;
      /** @type {number} */
      data.y = Math.abs(data.y - offset) < delta ? 0 : this.snap(data.y / scale) * scale - offset;
    }
  } else {
    /** @type {number} */
    delta = .5 * scale;
    if (!i) {
      /** @type {number} */
      i = offset.x - (Math.round(offset.x / scale - t.x) + t.x) * scale;
      /** @type {number} */
      data.x = Math.abs(data.x - i) < delta ? 0 : Math.round(data.x / scale) * scale - i;
    }
    if (!eof) {
      /** @type {number} */
      offset = offset.y - (Math.round(offset.y / scale - t.y) + t.y) * scale;
      /** @type {number} */
      data.y = Math.abs(data.y - offset) < delta ? 0 : Math.round(data.y / scale) * scale - offset;
    }
  }
  return data;
};
/**
 * @param {number} dx
 * @param {number} dy
 * @return {undefined}
 */
mxGraph.prototype.panGraph = function(dx, dy) {
  if (this.useScrollbarsForPanning && mxUtils.hasScrollbars(this.container)) {
    /** @type {number} */
    this.container.scrollLeft = -dx;
    /** @type {number} */
    this.container.scrollTop = -dy;
  } else {
    var e = this.view.getCanvas();
    if (this.dialect == mxConstants.DIALECT_SVG) {
      if (0 == dx && 0 == dy) {
        if (mxClient.IS_IE ? e.setAttribute("transform", "translate(" + dx + "," + dy + ")") : e.removeAttribute("transform"), null != this.shiftPreview1) {
          var table = this.shiftPreview1.firstChild;
          for (; null != table;) {
            var row = table.nextSibling;
            this.container.appendChild(table);
            table = row;
          }
          if (null != this.shiftPreview1.parentNode) {
            this.shiftPreview1.parentNode.removeChild(this.shiftPreview1);
          }
          /** @type {null} */
          this.shiftPreview1 = null;
          this.container.appendChild(e.parentNode);
          table = this.shiftPreview2.firstChild;
          for (; null != table;) {
            row = table.nextSibling;
            this.container.appendChild(table);
            table = row;
          }
          if (null != this.shiftPreview2.parentNode) {
            this.shiftPreview2.parentNode.removeChild(this.shiftPreview2);
          }
          /** @type {null} */
          this.shiftPreview2 = null;
        }
      } else {
        e.setAttribute("transform", "translate(" + dx + "," + dy + ")");
        if (null == this.shiftPreview1) {
          /** @type {!Element} */
          this.shiftPreview1 = document.createElement("div");
          /** @type {string} */
          this.shiftPreview1.style.position = "absolute";
          /** @type {string} */
          this.shiftPreview1.style.overflow = "visible";
          /** @type {!Element} */
          this.shiftPreview2 = document.createElement("div");
          /** @type {string} */
          this.shiftPreview2.style.position = "absolute";
          /** @type {string} */
          this.shiftPreview2.style.overflow = "visible";
          /** @type {!Element} */
          var tableHolder = this.shiftPreview1;
          table = this.container.firstChild;
          for (; null != table;) {
            row = table.nextSibling;
            if (table != e.parentNode) {
              tableHolder.appendChild(table);
            } else {
              /** @type {!Element} */
              tableHolder = this.shiftPreview2;
            }
            table = row;
          }
          if (null != this.shiftPreview1.firstChild) {
            this.container.insertBefore(this.shiftPreview1, e.parentNode);
          }
          if (null != this.shiftPreview2.firstChild) {
            this.container.appendChild(this.shiftPreview2);
          }
        }
        /** @type {string} */
        this.shiftPreview1.style.left = dx + "px";
        /** @type {string} */
        this.shiftPreview1.style.top = dy + "px";
        /** @type {string} */
        this.shiftPreview2.style.left = dx + "px";
        /** @type {string} */
        this.shiftPreview2.style.top = dy + "px";
      }
    } else {
      /** @type {string} */
      e.style.left = dx + "px";
      /** @type {string} */
      e.style.top = dy + "px";
    }
    /** @type {number} */
    this.panDx = dx;
    /** @type {number} */
    this.panDy = dy;
    this.fireEvent(new mxEventObject(mxEvent.PAN));
  }
};
/**
 * @return {undefined}
 */
mxGraph.prototype.zoomIn = function() {
  this.zoom(this.zoomFactor);
};
/**
 * @return {undefined}
 */
mxGraph.prototype.zoomOut = function() {
  this.zoom(1 / this.zoomFactor);
};
/**
 * @return {undefined}
 */
mxGraph.prototype.zoomActual = function() {
  if (1 == this.view.scale) {
    this.view.setTranslate(0, 0);
  } else {
    /** @type {number} */
    this.view.translate.x = 0;
    /** @type {number} */
    this.view.translate.y = 0;
    this.view.setScale(1);
  }
};
/**
 * @param {number} zoom
 * @param {number} x
 * @return {undefined}
 */
mxGraph.prototype.zoomTo = function(zoom, x) {
  this.zoom(zoom / this.view.scale, x);
};
/**
 * @param {number} x
 * @param {number} y
 * @param {number} s
 * @param {number} e
 * @return {undefined}
 */
mxGraph.prototype.center = function(x, y, s, e) {
  x = null != x ? x : true;
  y = null != y ? y : true;
  s = null != s ? s : .5;
  e = null != e ? e : .5;
  var layoutFunc = mxUtils.hasScrollbars(this.container);
  /** @type {number} */
  var height = 2 * this.getBorder();
  /** @type {number} */
  var width = this.container.clientWidth - height;
  /** @type {number} */
  height = this.container.clientHeight - height;
  var bounds = this.getGraphBounds();
  var transform = this.view.translate;
  var scale = this.view.scale;
  /** @type {number} */
  var w = x ? width - bounds.width : 0;
  /** @type {number} */
  var h = y ? height - bounds.height : 0;
  if (layoutFunc) {
    bounds.x -= transform.x;
    bounds.y -= transform.y;
    x = this.container.scrollWidth;
    y = this.container.scrollHeight;
    if (x > width) {
      /** @type {number} */
      w = 0;
    }
    if (y > height) {
      /** @type {number} */
      h = 0;
    }
    this.view.setTranslate(Math.floor(w / 2 - bounds.x), Math.floor(h / 2 - bounds.y));
    /** @type {number} */
    this.container.scrollLeft = (x - width) / 2;
    /** @type {number} */
    this.container.scrollTop = (y - height) / 2;
  } else {
    this.view.setTranslate(x ? Math.floor(transform.x - bounds.x * scale + w * s / scale) : transform.x, y ? Math.floor(transform.y - bounds.y * scale + h * e / scale) : transform.y);
  }
};
/**
 * @param {number} y
 * @param {number} e
 * @return {undefined}
 */
mxGraph.prototype.zoom = function(y, e) {
  e = null != e ? e : this.centerZoom;
  /** @type {number} */
  var value = Math.round(this.view.scale * y * 100) / 100;
  var width = this.view.getState(this.getSelectionCell());
  /** @type {number} */
  y = value / this.view.scale;
  if (this.keepSelectionVisibleOnZoom && null != width) {
    width = new mxRectangle(width.x * y, width.y * y, width.width * y, width.height * y);
    /** @type {number} */
    this.view.scale = value;
    if (!this.scrollRectToVisible(width)) {
      this.view.revalidate();
      this.view.setScale(value);
    }
  } else {
    if (width = mxUtils.hasScrollbars(this.container), e && !width) {
      width = this.container.offsetWidth;
      var w = this.container.offsetHeight;
      if (1 < y) {
        /** @type {number} */
        var r = (y - 1) / (2 * value);
        /** @type {number} */
        width = width * -r;
        /** @type {number} */
        w = w * -r;
      } else {
        /** @type {number} */
        r = (1 / y - 1) / (2 * this.view.scale);
        /** @type {number} */
        width = width * r;
        /** @type {number} */
        w = w * r;
      }
      this.view.scaleAndTranslate(value, this.view.translate.x + width, this.view.translate.y + w);
    } else {
      r = this.view.translate.x;
      var dy = this.view.translate.y;
      var x = this.container.scrollLeft;
      var h = this.container.scrollTop;
      this.view.setScale(value);
      if (width) {
        /** @type {number} */
        w = width = 0;
        if (e) {
          /** @type {number} */
          width = this.container.offsetWidth * (y - 1) / 2;
          /** @type {number} */
          w = this.container.offsetHeight * (y - 1) / 2;
        }
        /** @type {number} */
        this.container.scrollLeft = (this.view.translate.x - r) * this.view.scale + Math.round(x * y + width);
        /** @type {number} */
        this.container.scrollTop = (this.view.translate.y - dy) * this.view.scale + Math.round(h * y + w);
      }
    }
  }
};
/**
 * @param {!Object} options
 * @return {undefined}
 */
mxGraph.prototype.zoomToRect = function(options) {
  /** @type {number} */
  var y = this.container.clientWidth / options.width / (this.container.clientHeight / options.height);
  /** @type {number} */
  options.x = Math.max(0, options.x);
  /** @type {number} */
  options.y = Math.max(0, options.y);
  /** @type {number} */
  var w = Math.min(this.container.scrollWidth, options.x + options.width);
  /** @type {number} */
  var top = Math.min(this.container.scrollHeight, options.y + options.height);
  /** @type {number} */
  options.width = w - options.x;
  /** @type {number} */
  options.height = top - options.y;
  if (1 > y) {
    /** @type {number} */
    y = options.height / y;
    /** @type {number} */
    w = (y - options.height) / 2;
    /** @type {number} */
    options.height = y;
    options.y -= Math.min(options.y, w);
    /** @type {number} */
    top = Math.min(this.container.scrollHeight, options.y + options.height);
    /** @type {number} */
    options.height = top - options.y;
  } else {
    /** @type {number} */
    y = y * options.width;
    /** @type {number} */
    w = (y - options.width) / 2;
    /** @type {number} */
    options.width = y;
    options.x -= Math.min(options.x, w);
    /** @type {number} */
    w = Math.min(this.container.scrollWidth, options.x + options.width);
    /** @type {number} */
    options.width = w - options.x;
  }
  /** @type {number} */
  y = this.container.clientWidth / options.width;
  /** @type {number} */
  w = this.view.scale * y;
  if (mxUtils.hasScrollbars(this.container)) {
    this.view.setScale(w);
    /** @type {number} */
    this.container.scrollLeft = Math.round(options.x * y);
    /** @type {number} */
    this.container.scrollTop = Math.round(options.y * y);
  } else {
    this.view.scaleAndTranslate(w, this.view.translate.x - options.x / this.view.scale, this.view.translate.y - options.y / this.view.scale);
  }
};
/**
 * @param {!Object} store
 * @param {boolean} createTime
 * @return {undefined}
 */
mxGraph.prototype.scrollCellToVisible = function(store, createTime) {
  /** @type {number} */
  var s = -this.view.translate.x;
  /** @type {number} */
  var x = -this.view.translate.y;
  var value = this.view.getState(store);
  if (null != value) {
    s = new mxRectangle(s + value.x, x + value.y, value.width, value.height);
    if (createTime && null != this.container) {
      x = this.container.clientWidth;
      value = this.container.clientHeight;
      /** @type {number} */
      s.x = s.getCenterX() - x / 2;
      s.width = x;
      /** @type {number} */
      s.y = s.getCenterY() - value / 2;
      s.height = value;
    }
    x = new mxPoint(this.view.translate.x, this.view.translate.y);
    if (this.scrollRectToVisible(s)) {
      s = new mxPoint(this.view.translate.x, this.view.translate.y);
      this.view.translate.x = x.x;
      this.view.translate.y = x.y;
      this.view.setTranslate(s.x, s.y);
    }
  }
};
/**
 * @param {?} offset
 * @return {?}
 */
mxGraph.prototype.scrollRectToVisible = function(offset) {
  /** @type {boolean} */
  var b = false;
  if (null != offset) {
    var w = this.container.offsetWidth;
    var h = this.container.offsetHeight;
    /** @type {number} */
    var width = Math.min(w, offset.width);
    /** @type {number} */
    var eh = Math.min(h, offset.height);
    if (mxUtils.hasScrollbars(this.container)) {
      w = this.container;
      offset.x += this.view.translate.x;
      offset.y += this.view.translate.y;
      /** @type {number} */
      var x = w.scrollLeft - offset.x;
      /** @type {number} */
      h = Math.max(x - w.scrollLeft, 0);
      if (0 < x) {
        w.scrollLeft -= x + 2;
      } else {
        /** @type {number} */
        x = offset.x + width - w.scrollLeft - w.clientWidth;
        if (0 < x) {
          w.scrollLeft += x + 2;
        }
      }
      /** @type {number} */
      width = w.scrollTop - offset.y;
      /** @type {number} */
      x = Math.max(0, width - w.scrollTop);
      if (0 < width) {
        w.scrollTop -= width + 2;
      } else {
        /** @type {number} */
        width = offset.y + eh - w.scrollTop - w.clientHeight;
        if (0 < width) {
          w.scrollTop += width + 2;
        }
      }
      if (!(this.useScrollbarsForPanning || 0 == h && 0 == x)) {
        this.view.setTranslate(h, x);
      }
    } else {
      /** @type {number} */
      x = -this.view.translate.x;
      /** @type {number} */
      var y = -this.view.translate.y;
      var factor = this.view.scale;
      if (offset.x + width > x + w) {
        this.view.translate.x -= (offset.x + width - w - x) / factor;
        /** @type {boolean} */
        b = true;
      }
      if (offset.y + eh > y + h) {
        this.view.translate.y -= (offset.y + eh - h - y) / factor;
        /** @type {boolean} */
        b = true;
      }
      if (offset.x < x) {
        this.view.translate.x += (x - offset.x) / factor;
        /** @type {boolean} */
        b = true;
      }
      if (offset.y < y) {
        this.view.translate.y += (y - offset.y) / factor;
        /** @type {boolean} */
        b = true;
      }
      if (b) {
        this.view.refresh();
        if (null != this.selectionCellsHandler) {
          this.selectionCellsHandler.refresh();
        }
      }
    }
  }
  return b;
};
/**
 * @param {?} target
 * @return {?}
 */
mxGraph.prototype.getCellGeometry = function(target) {
  return this.model.getGeometry(target);
};
/**
 * @param {!Object} element
 * @return {?}
 */
mxGraph.prototype.isCellVisible = function(element) {
  return this.model.isVisible(element);
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxGraph.prototype.isCellCollapsed = function(node) {
  return this.model.isCollapsed(node);
};
/**
 * @param {?} obj
 * @return {?}
 */
mxGraph.prototype.isCellConnectable = function(obj) {
  return this.model.isConnectable(obj);
};
/**
 * @param {!Object} i
 * @return {?}
 */
mxGraph.prototype.isOrthogonal = function(i) {
  var b = i.style[mxConstants.STYLE_ORTHOGONAL];
  if (null != b) {
    return b;
  }
  i = this.view.getEdgeStyle(i);
  return i == mxEdgeStyle.SegmentConnector || i == mxEdgeStyle.ElbowConnector || i == mxEdgeStyle.SideToSide || i == mxEdgeStyle.TopToBottom || i == mxEdgeStyle.EntityRelation || i == mxEdgeStyle.OrthConnector;
};
/**
 * @param {?} position
 * @return {?}
 */
mxGraph.prototype.isLoop = function(position) {
  var lastIndex = position.getVisibleTerminalState(true);
  position = position.getVisibleTerminalState(false);
  return null != lastIndex && lastIndex == position;
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxGraph.prototype.isCloneEvent = function(evt) {
  return mxEvent.isControlDown(evt);
};
/**
 * @param {?} a22
 * @return {?}
 */
mxGraph.prototype.isTransparentClickEvent = function(a22) {
  return false;
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxGraph.prototype.isToggleEvent = function(e) {
  return mxClient.IS_MAC ? mxEvent.isMetaDown(e) : mxEvent.isControlDown(e);
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxGraph.prototype.isGridEnabledEvent = function(evt) {
  return null != evt && !mxEvent.isAltDown(evt);
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxGraph.prototype.isConstrainedEvent = function(e) {
  return mxEvent.isShiftDown(e);
};
/**
 * @param {number} topnode
 * @return {?}
 */
mxGraph.prototype.isIgnoreTerminalEvent = function(topnode) {
  return false;
};
/**
 * @param {?} result
 * @return {undefined}
 */
mxGraph.prototype.validationAlert = function(result) {
  mxUtils.alert(result);
};
/**
 * @param {!Object} responder
 * @param {?} obj
 * @param {!Array} instance
 * @return {?}
 */
mxGraph.prototype.isEdgeValid = function(responder, obj, instance) {
  return null == this.getEdgeValidationError(responder, obj, instance);
};
/**
 * @param {!Object} value
 * @param {?} target
 * @param {?} item
 * @return {?}
 */
mxGraph.prototype.getEdgeValidationError = function(value, target, item) {
  if (null != value && !this.isAllowDanglingEdges() && (null == target || null == item)) {
    return "";
  }
  if (null != value && null == this.model.getTerminal(value, true) && null == this.model.getTerminal(value, false)) {
    return null;
  }
  if (!this.allowLoops && target == item && null != target || !this.isValidConnection(target, item)) {
    return "";
  }
  if (null != target && null != item) {
    /** @type {string} */
    var message = "";
    if (!this.multigraph) {
      var obj = this.model.getEdgesBetween(target, item, true);
      if (1 < obj.length || 1 == obj.length && obj[0] != value) {
        /** @type {string} */
        message = message + ((mxResources.get(this.alreadyConnectedResource) || this.alreadyConnectedResource) + "\n");
      }
    }
    obj = this.model.getDirectedEdgeCount(target, true, value);
    var left = this.model.getDirectedEdgeCount(item, false, value);
    if (null != this.multiplicities) {
      /** @type {number} */
      var i = 0;
      for (; i < this.multiplicities.length; i++) {
        var index = this.multiplicities[i].check(this, value, target, item, obj, left);
        if (null != index) {
          /** @type {string} */
          message = message + index;
        }
      }
    }
    index = this.validateEdge(value, target, item);
    if (null != index) {
      /** @type {string} */
      message = message + index;
    }
    return 0 < message.length ? message : null;
  }
  return this.allowDanglingEdges ? null : "";
};
/**
 * @param {!Object} data
 * @param {?} label
 * @param {?} id
 * @return {?}
 */
mxGraph.prototype.validateEdge = function(data, label, id) {
  return null;
};
/**
 * @param {?} i
 * @param {number} j
 * @return {?}
 */
mxGraph.prototype.validateGraph = function(i, j) {
  i = null != i ? i : this.model.getRoot();
  j = null != j ? j : {};
  /** @type {boolean} */
  var key = true;
  var d = this.model.getChildCount(i);
  /** @type {number} */
  var n = 0;
  for (; n < d; n++) {
    var f = this.model.getChildAt(i, n);
    /** @type {number} */
    var h = j;
    if (this.isValidRoot(f)) {
      h = {};
    }
    h = this.validateGraph(f, h);
    if (null != h) {
      this.setCellWarning(f, h.replace(/\n/g, "<br>"));
    } else {
      this.setCellWarning(f, null);
    }
    /** @type {boolean} */
    key = key && null == h;
  }
  /** @type {string} */
  d = "";
  if (this.isCellCollapsed(i) && !key) {
    /** @type {string} */
    d = d + ((mxResources.get(this.containsValidationErrorsResource) || this.containsValidationErrorsResource) + "\n");
  }
  d = this.model.isEdge(i) ? d + (this.getEdgeValidationError(i, this.model.getTerminal(i, true), this.model.getTerminal(i, false)) || "") : d + (this.getCellValidationError(i) || "");
  n = this.validateCell(i, j);
  if (null != n) {
    d = d + n;
  }
  if (null == this.model.getParent(i)) {
    this.view.validate();
  }
  return 0 < d.length || !key ? d : null;
};
/**
 * @param {!Object} node
 * @return {?}
 */
mxGraph.prototype.getCellValidationError = function(node) {
  var row = this.model.getDirectedEdgeCount(node, true);
  var newWidth = this.model.getDirectedEdgeCount(node, false);
  node = this.model.getValue(node);
  /** @type {string} */
  var ret = "";
  if (null != this.multiplicities) {
    /** @type {number} */
    var target = 0;
    for (; target < this.multiplicities.length; target++) {
      var self = this.multiplicities[target];
      if (self.source && mxUtils.isNode(node, self.type, self.attr, self.value) && (row > self.max || row < self.min)) {
        /** @type {string} */
        ret = ret + (self.countError + "\n");
      } else {
        if (!self.source && mxUtils.isNode(node, self.type, self.attr, self.value) && (newWidth > self.max || newWidth < self.min)) {
          /** @type {string} */
          ret = ret + (self.countError + "\n");
        }
      }
    }
  }
  return 0 < ret.length ? ret : null;
};
/**
 * @param {?} row
 * @param {number} col
 * @return {?}
 */
mxGraph.prototype.validateCell = function(row, col) {
  return null;
};
/**
 * @return {?}
 */
mxGraph.prototype.getBackgroundImage = function() {
  return this.backgroundImage;
};
/**
 * @param {string} img
 * @return {undefined}
 */
mxGraph.prototype.setBackgroundImage = function(img) {
  /** @type {string} */
  this.backgroundImage = img;
};
/**
 * @param {!Object} prototype
 * @return {?}
 */
mxGraph.prototype.getFoldingImage = function(prototype) {
  if (null != prototype && this.foldingEnabled && !this.getModel().isEdge(prototype.cell)) {
    var b = this.isCellCollapsed(prototype.cell);
    if (this.isCellFoldable(prototype.cell, !b)) {
      return b ? this.collapsedImage : this.expandedImage;
    }
  }
  return null;
};
/**
 * @param {!Object} cell
 * @return {?}
 */
mxGraph.prototype.convertValueToString = function(cell) {
  cell = this.model.getValue(cell);
  if (null != cell) {
    if (mxUtils.isNode(cell)) {
      return cell.nodeName;
    }
    if ("function" == typeof cell.toString) {
      return cell.toString();
    }
  }
  return "";
};
/**
 * @param {!Object} name
 * @return {?}
 */
mxGraph.prototype.getLabel = function(name) {
  /** @type {string} */
  var language = "";
  if (this.labelsVisible && null != name) {
    var value = this.getCurrentCellStyle(name);
    if (!mxUtils.getValue(value, mxConstants.STYLE_NOLABEL, false)) {
      language = this.convertValueToString(name);
    }
  }
  return language;
};
/**
 * @param {!Object} cell
 * @return {?}
 */
mxGraph.prototype.isHtmlLabel = function(cell) {
  return this.isHtmlLabels();
};
/**
 * @return {?}
 */
mxGraph.prototype.isHtmlLabels = function() {
  return this.htmlLabels;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setHtmlLabels = function(a) {
  /** @type {boolean} */
  this.htmlLabels = a;
};
/**
 * @param {!Object} mercatorX
 * @return {?}
 */
mxGraph.prototype.isWrapping = function(mercatorX) {
  return "wrap" == this.getCurrentCellStyle(mercatorX)[mxConstants.STYLE_WHITE_SPACE];
};
/**
 * @param {!Object} mercatorX
 * @return {?}
 */
mxGraph.prototype.isLabelClipped = function(mercatorX) {
  return "hidden" == this.getCurrentCellStyle(mercatorX)[mxConstants.STYLE_OVERFLOW];
};
/**
 * @param {!Object} data
 * @param {string} node
 * @param {string} config
 * @param {?} type
 * @return {?}
 */
mxGraph.prototype.getTooltip = function(data, node, config, type) {
  /** @type {null} */
  var value = null;
  if (null != data) {
    if (!(null == data.control || node != data.control.node && node.parentNode != data.control.node)) {
      value = this.collapseExpandResource;
      value = mxUtils.htmlEntities(mxResources.get(value) || value).replace(/\\n/g, "<br>");
    }
    if (null == value && null != data.overlays) {
      data.overlays.visit(function(a, self) {
        if (!(null != value || node != self.node && node.parentNode != self.node)) {
          value = self.overlay.toString();
        }
      });
    }
    if (null == value) {
      config = this.selectionCellsHandler.getHandler(data.cell);
      if (null != config && "function" == typeof config.getTooltipForNode) {
        value = config.getTooltipForNode(node);
      }
    }
    if (null == value) {
      value = this.getTooltipForCell(data.cell);
    }
  }
  return value;
};
/**
 * @param {!Object} cell
 * @return {?}
 */
mxGraph.prototype.getTooltipForCell = function(cell) {
  return null != cell && null != cell.getTooltip ? cell.getTooltip() : this.convertValueToString(cell);
};
/**
 * @param {?} cell
 * @return {?}
 */
mxGraph.prototype.getLinkForCell = function(cell) {
  return null;
};
/**
 * @param {!Object} header
 * @return {?}
 */
mxGraph.prototype.getCursorForMouseEvent = function(header) {
  return this.getCursorForCell(header.getCell());
};
/**
 * @param {?} cell
 * @return {?}
 */
mxGraph.prototype.getCursorForCell = function(cell) {
  return null;
};
/**
 * @param {!Object} element
 * @param {boolean} feature
 * @return {?}
 */
mxGraph.prototype.getStartSize = function(element, feature) {
  var size = new mxRectangle;
  var value = this.getCurrentCellStyle(element, feature);
  /** @type {number} */
  var cw = parseInt(mxUtils.getValue(value, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
  if (mxUtils.getValue(value, mxConstants.STYLE_HORIZONTAL, true)) {
    /** @type {number} */
    size.height = cw;
  } else {
    /** @type {number} */
    size.width = cw;
  }
  return size;
};
/**
 * @param {number} value
 * @return {?}
 */
mxGraph.prototype.getSwimlaneDirection = function(value) {
  var number = mxUtils.getValue(value, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
  /** @type {boolean} */
  var maxvalue = 1 == mxUtils.getValue(value, mxConstants.STYLE_FLIPH, 0);
  /** @type {boolean} */
  var skipErrors = 1 == mxUtils.getValue(value, mxConstants.STYLE_FLIPV, 0);
  /** @type {number} */
  value = mxUtils.getValue(value, mxConstants.STYLE_HORIZONTAL, true) ? 0 : 3;
  if (number == mxConstants.DIRECTION_NORTH) {
    value--;
  } else {
    if (number == mxConstants.DIRECTION_WEST) {
      /** @type {number} */
      value = value + 2;
    } else {
      if (number == mxConstants.DIRECTION_SOUTH) {
        /** @type {number} */
        value = value + 1;
      }
    }
  }
  number = mxUtils.mod(value, 2);
  if (maxvalue && 1 == number) {
    /** @type {number} */
    value = value + 2;
  }
  if (skipErrors && 0 == number) {
    /** @type {number} */
    value = value + 2;
  }
  return [mxConstants.DIRECTION_NORTH, mxConstants.DIRECTION_EAST, mxConstants.DIRECTION_SOUTH, mxConstants.DIRECTION_WEST][mxUtils.mod(value, 4)];
};
/**
 * @param {!Object} d
 * @param {boolean} b
 * @return {?}
 */
mxGraph.prototype.getActualStartSize = function(d, b) {
  var size = new mxRectangle;
  if (this.isSwimlane(d, b)) {
    var value = this.getCurrentCellStyle(d, b);
    /** @type {number} */
    var h = parseInt(mxUtils.getValue(value, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
    value = this.getSwimlaneDirection(value);
    if (value == mxConstants.DIRECTION_NORTH) {
      /** @type {number} */
      size.y = h;
    } else {
      if (value == mxConstants.DIRECTION_WEST) {
        /** @type {number} */
        size.x = h;
      } else {
        if (value == mxConstants.DIRECTION_SOUTH) {
          /** @type {number} */
          size.height = h;
        } else {
          /** @type {number} */
          size.width = h;
        }
      }
    }
  }
  return size;
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxGraph.prototype.getImage = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_IMAGE] : null;
};
/**
 * @param {!Object} key
 * @return {?}
 */
mxGraph.prototype.isTransparentState = function(key) {
  /** @type {boolean} */
  var align = false;
  if (null != key) {
    align = mxUtils.getValue(key.style, mxConstants.STYLE_STROKECOLOR, mxConstants.NONE);
    var valign = mxUtils.getValue(key.style, mxConstants.STYLE_FILLCOLOR, mxConstants.NONE);
    /** @type {boolean} */
    align = align == mxConstants.NONE && valign == mxConstants.NONE && null == this.getImage(key);
  }
  return align;
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxGraph.prototype.getVerticalAlign = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_VERTICAL_ALIGN] || mxConstants.ALIGN_MIDDLE : null;
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxGraph.prototype.getIndicatorColor = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_INDICATOR_COLOR] : null;
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxGraph.prototype.getIndicatorGradientColor = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_INDICATOR_GRADIENTCOLOR] : null;
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxGraph.prototype.getIndicatorShape = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_INDICATOR_SHAPE] : null;
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxGraph.prototype.getIndicatorImage = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_INDICATOR_IMAGE] : null;
};
/**
 * @return {?}
 */
mxGraph.prototype.getBorder = function() {
  return this.border;
};
/**
 * @param {?} border
 * @return {undefined}
 */
mxGraph.prototype.setBorder = function(border) {
  this.border = border;
};
/**
 * @param {!Object} s
 * @param {boolean} prefix
 * @return {?}
 */
mxGraph.prototype.isSwimlane = function(s, prefix) {
  return null == s || this.model.getParent(s) == this.model.getRoot() || this.model.isEdge(s) ? false : this.getCurrentCellStyle(s, prefix)[mxConstants.STYLE_SHAPE] == mxConstants.SHAPE_SWIMLANE;
};
/**
 * @return {?}
 */
mxGraph.prototype.isResizeContainer = function() {
  return this.resizeContainer;
};
/**
 * @param {boolean} resizeContainer
 * @return {undefined}
 */
mxGraph.prototype.setResizeContainer = function(resizeContainer) {
  /** @type {boolean} */
  this.resizeContainer = resizeContainer;
};
/**
 * @return {?}
 */
mxGraph.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxGraph.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxGraph.prototype.isEscapeEnabled = function() {
  return this.escapeEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setEscapeEnabled = function(a) {
  /** @type {boolean} */
  this.escapeEnabled = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isInvokesStopCellEditing = function() {
  return this.invokesStopCellEditing;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setInvokesStopCellEditing = function(a) {
  /** @type {boolean} */
  this.invokesStopCellEditing = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isEnterStopsCellEditing = function() {
  return this.enterStopsCellEditing;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setEnterStopsCellEditing = function(a) {
  /** @type {boolean} */
  this.enterStopsCellEditing = a;
};
/**
 * @param {!Object} element
 * @return {?}
 */
mxGraph.prototype.isCellLocked = function(element) {
  var chunk = this.model.getGeometry(element);
  return this.isCellsLocked() || null != chunk && this.model.isVertex(element) && chunk.relative;
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsLocked = function() {
  return this.cellsLocked;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsLocked = function(a) {
  /** @type {boolean} */
  this.cellsLocked = a;
};
/**
 * @param {!Object} key
 * @return {?}
 */
mxGraph.prototype.getCloneableCells = function(key) {
  return this.model.filterCells(key, mxUtils.bind(this, function(style_in) {
    return this.isCellCloneable(style_in);
  }));
};
/**
 * @param {!Object} style
 * @return {?}
 */
mxGraph.prototype.isCellCloneable = function(style) {
  style = this.getCurrentCellStyle(style);
  return this.isCellsCloneable() && 0 != style[mxConstants.STYLE_CLONEABLE];
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsCloneable = function() {
  return this.cellsCloneable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsCloneable = function(a) {
  /** @type {boolean} */
  this.cellsCloneable = a;
};
/**
 * @param {!Object} i
 * @return {?}
 */
mxGraph.prototype.getExportableCells = function(i) {
  return this.model.filterCells(i, mxUtils.bind(this, function(a) {
    return this.canExportCell(a);
  }));
};
/**
 * @param {?} strip1
 * @return {?}
 */
mxGraph.prototype.canExportCell = function(strip1) {
  return this.exportEnabled;
};
/**
 * @param {!Object} i
 * @return {?}
 */
mxGraph.prototype.getImportableCells = function(i) {
  return this.model.filterCells(i, mxUtils.bind(this, function(a) {
    return this.canImportCell(a);
  }));
};
/**
 * @param {boolean} prams
 * @return {?}
 */
mxGraph.prototype.canImportCell = function(prams) {
  return this.importEnabled;
};
/**
 * @param {?} cell
 * @return {?}
 */
mxGraph.prototype.isCellSelectable = function(cell) {
  return this.isCellsSelectable();
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsSelectable = function() {
  return this.cellsSelectable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsSelectable = function(a) {
  /** @type {boolean} */
  this.cellsSelectable = a;
};
/**
 * @param {!Object} i
 * @return {?}
 */
mxGraph.prototype.getDeletableCells = function(i) {
  return this.model.filterCells(i, mxUtils.bind(this, function(style_in) {
    return this.isCellDeletable(style_in);
  }));
};
/**
 * @param {!Object} style
 * @return {?}
 */
mxGraph.prototype.isCellDeletable = function(style) {
  style = this.getCurrentCellStyle(style);
  return this.isCellsDeletable() && 0 != style[mxConstants.STYLE_DELETABLE];
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsDeletable = function() {
  return this.cellsDeletable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsDeletable = function(a) {
  /** @type {boolean} */
  this.cellsDeletable = a;
};
/**
 * @param {(Object|string)} cell
 * @return {?}
 */
mxGraph.prototype.isLabelMovable = function(cell) {
  return !this.isCellLocked(cell) && (this.model.isEdge(cell) && this.edgeLabelsMovable || this.model.isVertex(cell) && this.vertexLabelsMovable);
};
/**
 * @param {!Object} mercatorX
 * @return {?}
 */
mxGraph.prototype.isCellRotatable = function(mercatorX) {
  return 0 != this.getCurrentCellStyle(mercatorX)[mxConstants.STYLE_ROTATABLE];
};
/**
 * @param {!Object} i
 * @return {?}
 */
mxGraph.prototype.getMovableCells = function(i) {
  return this.model.filterCells(i, mxUtils.bind(this, function(cX1) {
    return this.isCellMovable(cX1);
  }));
};
/**
 * @param {!Object} a
 * @return {?}
 */
mxGraph.prototype.isCellMovable = function(a) {
  var style = this.getCurrentCellStyle(a);
  return this.isCellsMovable() && !this.isCellLocked(a) && 0 != style[mxConstants.STYLE_MOVABLE];
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsMovable = function() {
  return this.cellsMovable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsMovable = function(a) {
  /** @type {boolean} */
  this.cellsMovable = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isGridEnabled = function() {
  return this.gridEnabled;
};
/**
 * @param {number} a
 * @return {undefined}
 */
mxGraph.prototype.setGridEnabled = function(a) {
  /** @type {number} */
  this.gridEnabled = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isPortsEnabled = function() {
  return this.portsEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setPortsEnabled = function(a) {
  /** @type {boolean} */
  this.portsEnabled = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.getGridSize = function() {
  return this.gridSize;
};
/**
 * @param {string} gridSize
 * @return {undefined}
 */
mxGraph.prototype.setGridSize = function(gridSize) {
  /** @type {string} */
  this.gridSize = gridSize;
};
/**
 * @return {?}
 */
mxGraph.prototype.getTolerance = function() {
  return this.tolerance;
};
/**
 * @param {number} tolerance
 * @return {undefined}
 */
mxGraph.prototype.setTolerance = function(tolerance) {
  /** @type {number} */
  this.tolerance = tolerance;
};
/**
 * @return {?}
 */
mxGraph.prototype.isVertexLabelsMovable = function() {
  return this.vertexLabelsMovable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setVertexLabelsMovable = function(a) {
  /** @type {boolean} */
  this.vertexLabelsMovable = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isEdgeLabelsMovable = function() {
  return this.edgeLabelsMovable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setEdgeLabelsMovable = function(a) {
  /** @type {boolean} */
  this.edgeLabelsMovable = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isSwimlaneNesting = function() {
  return this.swimlaneNesting;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setSwimlaneNesting = function(a) {
  /** @type {boolean} */
  this.swimlaneNesting = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isSwimlaneSelectionEnabled = function() {
  return this.swimlaneSelectionEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setSwimlaneSelectionEnabled = function(a) {
  /** @type {boolean} */
  this.swimlaneSelectionEnabled = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isMultigraph = function() {
  return this.multigraph;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setMultigraph = function(a) {
  /** @type {boolean} */
  this.multigraph = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isAllowLoops = function() {
  return this.allowLoops;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setAllowDanglingEdges = function(a) {
  /** @type {boolean} */
  this.allowDanglingEdges = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isAllowDanglingEdges = function() {
  return this.allowDanglingEdges;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setConnectableEdges = function(a) {
  /** @type {boolean} */
  this.connectableEdges = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isConnectableEdges = function() {
  return this.connectableEdges;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCloneInvalidEdges = function(a) {
  /** @type {boolean} */
  this.cloneInvalidEdges = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isCloneInvalidEdges = function() {
  return this.cloneInvalidEdges;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setAllowLoops = function(a) {
  /** @type {boolean} */
  this.allowLoops = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isDisconnectOnMove = function() {
  return this.disconnectOnMove;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setDisconnectOnMove = function(a) {
  /** @type {boolean} */
  this.disconnectOnMove = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isDropEnabled = function() {
  return this.dropEnabled;
};
/**
 * @param {boolean} dropBool
 * @return {undefined}
 */
mxGraph.prototype.setDropEnabled = function(dropBool) {
  /** @type {boolean} */
  this.dropEnabled = dropBool;
};
/**
 * @return {?}
 */
mxGraph.prototype.isSplitEnabled = function() {
  return this.splitEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setSplitEnabled = function(a) {
  /** @type {boolean} */
  this.splitEnabled = a;
};
/**
 * @param {!Object} item
 * @return {?}
 */
mxGraph.prototype.isCellResizable = function(item) {
  var value = this.getCurrentCellStyle(item);
  return this.isCellsResizable() && !this.isCellLocked(item) && "0" != mxUtils.getValue(value, mxConstants.STYLE_RESIZABLE, "1");
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsResizable = function() {
  return this.cellsResizable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsResizable = function(a) {
  /** @type {boolean} */
  this.cellsResizable = a;
};
/**
 * @param {number} name
 * @param {?} replacement
 * @return {?}
 */
mxGraph.prototype.isTerminalPointMovable = function(name, replacement) {
  return true;
};
/**
 * @param {undefined} a
 * @return {?}
 */
mxGraph.prototype.isCellBendable = function(a) {
  var style = this.getCurrentCellStyle(a);
  return this.isCellsBendable() && !this.isCellLocked(a) && 0 != style[mxConstants.STYLE_BENDABLE];
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsBendable = function() {
  return this.cellsBendable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsBendable = function(a) {
  /** @type {boolean} */
  this.cellsBendable = a;
};
/**
 * @param {!Object} cell
 * @return {?}
 */
mxGraph.prototype.isCellEditable = function(cell) {
  var style = this.getCurrentCellStyle(cell);
  return this.isCellsEditable() && !this.isCellLocked(cell) && 0 != style[mxConstants.STYLE_EDITABLE];
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsEditable = function() {
  return this.cellsEditable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsEditable = function(a) {
  /** @type {boolean} */
  this.cellsEditable = a;
};
/**
 * @param {?} label
 * @param {number} name
 * @param {boolean} language
 * @return {?}
 */
mxGraph.prototype.isCellDisconnectable = function(label, name, language) {
  return this.isCellsDisconnectable() && !this.isCellLocked(label);
};
/**
 * @return {?}
 */
mxGraph.prototype.isCellsDisconnectable = function() {
  return this.cellsDisconnectable;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setCellsDisconnectable = function(a) {
  /** @type {boolean} */
  this.cellsDisconnectable = a;
};
/**
 * @param {?} cell
 * @return {?}
 */
mxGraph.prototype.isValidSource = function(cell) {
  return null == cell && this.allowDanglingEdges || null != cell && (!this.model.isEdge(cell) || this.connectableEdges) && this.isCellConnectable(cell);
};
/**
 * @param {?} name
 * @return {?}
 */
mxGraph.prototype.isValidTarget = function(name) {
  return this.isValidSource(name);
};
/**
 * @param {?} b
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.isValidConnection = function(b, a) {
  return this.isValidSource(b) && this.isValidTarget(a);
};
/**
 * @param {string} enabled
 * @return {undefined}
 */
mxGraph.prototype.setConnectable = function(enabled) {
  this.connectionHandler.setEnabled(enabled);
};
/**
 * @return {?}
 */
mxGraph.prototype.isConnectable = function() {
  return this.connectionHandler.isEnabled();
};
/**
 * @param {string} enabled
 * @return {undefined}
 */
mxGraph.prototype.setTooltips = function(enabled) {
  this.tooltipHandler.setEnabled(enabled);
};
/**
 * @param {boolean} value
 * @return {undefined}
 */
mxGraph.prototype.setPanning = function(value) {
  /** @type {boolean} */
  this.panningHandler.panningEnabled = value;
};
/**
 * @param {string} a
 * @return {?}
 */
mxGraph.prototype.isEditing = function(a) {
  if (null != this.cellEditor) {
    var b = this.cellEditor.getEditingCell();
    return null == a ? null != b : a == b;
  }
  return false;
};
/**
 * @param {string} style
 * @return {?}
 */
mxGraph.prototype.isAutoSizeCell = function(style) {
  style = this.getCurrentCellStyle(style);
  return this.isAutoSizeCells() || 1 == style[mxConstants.STYLE_AUTOSIZE];
};
/**
 * @return {?}
 */
mxGraph.prototype.isAutoSizeCells = function() {
  return this.autoSizeCells;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setAutoSizeCells = function(a) {
  /** @type {boolean} */
  this.autoSizeCells = a;
};
/**
 * @param {?} vertexiumObject
 * @return {?}
 */
mxGraph.prototype.isExtendParent = function(vertexiumObject) {
  return !this.getModel().isEdge(vertexiumObject) && this.isExtendParents();
};
/**
 * @return {?}
 */
mxGraph.prototype.isExtendParents = function() {
  return this.extendParents;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setExtendParents = function(a) {
  /** @type {boolean} */
  this.extendParents = a;
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.isExtendParentsOnAdd = function(a) {
  return this.extendParentsOnAdd;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setExtendParentsOnAdd = function(a) {
  /** @type {boolean} */
  this.extendParentsOnAdd = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isExtendParentsOnMove = function() {
  return this.extendParentsOnMove;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setExtendParentsOnMove = function(a) {
  /** @type {boolean} */
  this.extendParentsOnMove = a;
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.isRecursiveResize = function(a) {
  return this.recursiveResize;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setRecursiveResize = function(a) {
  /** @type {boolean} */
  this.recursiveResize = a;
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxGraph.prototype.isConstrainChild = function(e) {
  return this.isConstrainChildren() && !this.getModel().isEdge(this.getModel().getParent(e));
};
/**
 * @return {?}
 */
mxGraph.prototype.isConstrainChildren = function() {
  return this.constrainChildren;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setConstrainChildren = function(a) {
  /** @type {boolean} */
  this.constrainChildren = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isConstrainRelativeChildren = function() {
  return this.constrainRelativeChildren;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraph.prototype.setConstrainRelativeChildren = function(a) {
  /** @type {boolean} */
  this.constrainRelativeChildren = a;
};
/**
 * @return {?}
 */
mxGraph.prototype.isAllowNegativeCoordinates = function() {
  return this.allowNegativeCoordinates;
};
/**
 * @param {boolean} zoomAware
 * @return {undefined}
 */
mxGraph.prototype.setAllowNegativeCoordinates = function(zoomAware) {
  /** @type {boolean} */
  this.allowNegativeCoordinates = zoomAware;
};
/**
 * @param {!Object} other
 * @return {?}
 */
mxGraph.prototype.getOverlap = function(other) {
  return this.isAllowOverlapParent(other) ? this.defaultOverlap : 0;
};
/**
 * @param {!Object} P2
 * @return {?}
 */
mxGraph.prototype.isAllowOverlapParent = function(P2) {
  return false;
};
/**
 * @param {!Object} m
 * @param {string} _value
 * @return {?}
 */
mxGraph.prototype.getFoldableCells = function(m, _value) {
  return this.model.filterCells(m, mxUtils.bind(this, function(code_cell) {
    return this.isCellFoldable(code_cell, _value);
  }));
};
/**
 * @param {!Object} cell
 * @param {string} value
 * @return {?}
 */
mxGraph.prototype.isCellFoldable = function(cell, value) {
  var style = this.getCurrentCellStyle(cell);
  return 0 < this.model.getChildCount(cell) && 0 != style[mxConstants.STYLE_FOLDABLE];
};
/**
 * @param {!Object} cell
 * @param {!Object} field
 * @param {!Array} num
 * @return {?}
 */
mxGraph.prototype.isValidDropTarget = function(cell, field, num) {
  return null != cell && (this.isSplitEnabled() && this.isSplitTarget(cell, field, num) || !this.model.isEdge(cell) && (this.isSwimlane(cell) || 0 < this.model.getChildCount(cell) && !this.isCellCollapsed(cell)));
};
/**
 * @param {string} cell
 * @param {!Object} id
 * @param {!Array} start
 * @return {?}
 */
mxGraph.prototype.isSplitTarget = function(cell, id, start) {
  return this.model.isEdge(cell) && null != id && 1 == id.length && this.isCellConnectable(id[0]) && null == this.getEdgeValidationError(cell, this.model.getTerminal(cell, true), id[0]) ? (start = this.model.getTerminal(cell, true), cell = this.model.getTerminal(cell, false), !this.model.isAncestor(id[0], start) && !this.model.isAncestor(id[0], cell)) : false;
};
/**
 * @param {!Object} data
 * @param {?} evt
 * @param {!Object} name
 * @param {!Object} event
 * @return {?}
 */
mxGraph.prototype.getDropTarget = function(data, evt, name, event) {
  if (!this.isSwimlaneNesting()) {
    /** @type {number} */
    var n = 0;
    for (; n < data.length; n++) {
      if (this.isSwimlane(data[n])) {
        return null;
      }
    }
  }
  n = mxUtils.convertPoint(this.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
  n.x -= this.panDx;
  n.y -= this.panDy;
  n = this.getSwimlaneAt(n.x, n.y);
  if (null == name) {
    name = n;
  } else {
    if (null != n) {
      var p = this.model.getParent(n);
      for (; null != p && this.isSwimlane(p) && p != name;) {
        p = this.model.getParent(p);
      }
      if (p == name) {
        name = n;
      }
    }
  }
  for (; null != name && !this.isValidDropTarget(name, data, evt) && !this.model.isLayer(name);) {
    name = this.model.getParent(name);
  }
  if (null == event || !event) {
    /** @type {!Object} */
    var item = name;
    for (; null != item && 0 > mxUtils.indexOf(data, item);) {
      item = this.model.getParent(item);
    }
  }
  return this.model.isLayer(name) || null != item ? null : name;
};
/**
 * @return {?}
 */
mxGraph.prototype.getDefaultParent = function() {
  var i = this.getCurrentRoot();
  if (null == i) {
    i = this.defaultParent;
    if (null == i) {
      i = this.model.getRoot();
      i = this.model.getChildAt(i, 0);
    }
  }
  return i;
};
/**
 * @param {string} addedRenderer
 * @return {undefined}
 */
mxGraph.prototype.setDefaultParent = function(addedRenderer) {
  /** @type {string} */
  this.defaultParent = addedRenderer;
};
/**
 * @param {!Object} cell
 * @return {?}
 */
mxGraph.prototype.getSwimlane = function(cell) {
  for (; null != cell && !this.isSwimlane(cell);) {
    cell = this.model.getParent(cell);
  }
  return cell;
};
/**
 * @param {?} y
 * @param {number} w
 * @param {!Object} n
 * @return {?}
 */
mxGraph.prototype.getSwimlaneAt = function(y, w, n) {
  if (null == n) {
    n = this.getCurrentRoot();
    if (null == n) {
      n = this.model.getRoot();
    }
  }
  if (null != n) {
    var requestsToPerform = this.model.getChildCount(n);
    /** @type {number} */
    var i = 0;
    for (; i < requestsToPerform; i++) {
      var input = this.model.getChildAt(n, i);
      if (null != input) {
        var d = this.getSwimlaneAt(y, w, input);
        if (null != d) {
          return d;
        }
        if (this.isCellVisible(input) && this.isSwimlane(input) && (d = this.view.getState(input), this.intersects(d, y, w))) {
          return input;
        }
      }
    }
  }
  return null;
};
/**
 * @param {!Object} y
 * @param {!Array} row
 * @param {!Object} x
 * @param {?} e
 * @param {?} pos
 * @param {string} fn
 * @return {?}
 */
mxGraph.prototype.getCellAt = function(y, row, x, e, pos, fn) {
  e = null != e ? e : true;
  pos = null != pos ? pos : true;
  if (null == x) {
    x = this.getCurrentRoot();
    if (null == x) {
      x = this.getModel().getRoot();
    }
  }
  if (null != x) {
    /** @type {number} */
    var i = this.model.getChildCount(x) - 1;
    for (; 0 <= i; i--) {
      var element = this.model.getChildAt(x, i);
      var result = this.getCellAt(y, row, element, e, pos, fn);
      if (null != result) {
        return result;
      }
      if (this.isCellVisible(element) && (pos && this.model.isEdge(element) || e && this.model.isVertex(element)) && (result = this.view.getState(element), null != result && (null == fn || !fn(result, y, row)) && this.intersects(result, y, row))) {
        return element;
      }
    }
  }
  return null;
};
/**
 * @param {?} s
 * @param {!Array} x
 * @param {number} y
 * @return {?}
 */
mxGraph.prototype.intersects = function(s, x, y) {
  if (null != s) {
    var c = s.absolutePoints;
    if (null != c) {
      /** @type {number} */
      s = this.tolerance * this.tolerance;
      var r = c[0];
      /** @type {number} */
      var i = 1;
      for (; i < c.length; i++) {
        var v = c[i];
        if (mxUtils.ptSegDistSq(r.x, r.y, v.x, v.y, x, y) <= s) {
          return true;
        }
        r = v;
      }
    } else {
      if (r = mxUtils.toRadians(mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION) || 0), 0 != r && (c = Math.cos(-r), r = Math.sin(-r), i = new mxPoint(s.getCenterX(), s.getCenterY()), r = mxUtils.getRotatedPoint(new mxPoint(x, y), c, r, i), x = r.x, y = r.y), mxUtils.contains(s, x, y)) {
        return true;
      }
    }
  }
  return false;
};
/**
 * @param {!Object} el
 * @param {number} width
 * @param {number} height
 * @return {?}
 */
mxGraph.prototype.hitsSwimlaneContent = function(el, width, height) {
  var range = this.getView().getState(el);
  el = this.getStartSize(el);
  if (null != range) {
    var scale = this.getView().getScale();
    /** @type {number} */
    width = width - range.x;
    /** @type {number} */
    height = height - range.y;
    if (0 < el.width && 0 < width && width > el.width * scale || 0 < el.height && 0 < height && height > el.height * scale) {
      return true;
    }
  }
  return false;
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.getChildVertices = function(a) {
  return this.getChildCells(a, true, false);
};
/**
 * @param {?} a
 * @return {?}
 */
mxGraph.prototype.getChildEdges = function(a) {
  return this.getChildCells(a, false, true);
};
/**
 * @param {?} a
 * @param {string} b
 * @param {?} i
 * @return {?}
 */
mxGraph.prototype.getChildCells = function(a, b, i) {
  a = null != a ? a : this.getDefaultParent();
  a = this.model.getChildCells(a, null != b ? b : false, null != i ? i : false);
  /** @type {!Array} */
  b = [];
  /** @type {number} */
  i = 0;
  for (; i < a.length; i++) {
    if (this.isCellVisible(a[i])) {
      b.push(a[i]);
    }
  }
  return b;
};
/**
 * @param {!Array} scope
 * @param {(Object|string)} id
 * @return {?}
 */
mxGraph.prototype.getConnections = function(scope, id) {
  return this.getEdges(scope, id, true, true, false);
};
/**
 * @param {!Array} url
 * @param {undefined} node
 * @return {?}
 */
mxGraph.prototype.getIncomingEdges = function(url, node) {
  return this.getEdges(url, node, true, false, false);
};
/**
 * @param {!Array} url
 * @param {undefined} node
 * @return {?}
 */
mxGraph.prototype.getOutgoingEdges = function(url, node) {
  return this.getEdges(url, node, false, true, false);
};
/**
 * @param {!Array} target
 * @param {string} object
 * @param {?} id
 * @param {?} name
 * @param {?} v
 * @param {string} e
 * @return {?}
 */
mxGraph.prototype.getEdges = function(target, object, id, name, v, e) {
  id = null != id ? id : true;
  name = null != name ? name : true;
  v = null != v ? v : true;
  e = null != e ? e : false;
  /** @type {!Array} */
  var parts = [];
  var list = this.isCellCollapsed(target);
  var val = this.model.getChildCount(target);
  /** @type {number} */
  var i = 0;
  for (; i < val; i++) {
    var key = this.model.getChildAt(target, i);
    if (list || !this.isCellVisible(key)) {
      /** @type {!Array<?>} */
      parts = parts.concat(this.model.getEdges(key, id, name));
    }
  }
  /** @type {!Array<?>} */
  parts = parts.concat(this.model.getEdges(target, id, name));
  /** @type {!Array} */
  list = [];
  /** @type {number} */
  i = 0;
  for (; i < parts.length; i++) {
    key = this.view.getState(parts[i]);
    val = null != key ? key.getVisibleTerminal(true) : this.view.getVisibleTerminal(parts[i], true);
    key = null != key ? key.getVisibleTerminal(false) : this.view.getVisibleTerminal(parts[i], false);
    if (v && val == key || val != key && (id && key == target && (null == object || this.isValidAncestor(val, object, e)) || name && val == target && (null == object || this.isValidAncestor(key, object, e)))) {
      list.push(parts[i]);
    }
  }
  return list;
};
/**
 * @param {undefined} type
 * @param {!Object} path
 * @param {!Object} node
 * @return {?}
 */
mxGraph.prototype.isValidAncestor = function(type, path, node) {
  return node ? this.model.isAncestor(path, type) : this.model.getParent(type) == path;
};
/**
 * @param {!Object} a
 * @param {?} b
 * @param {?} status
 * @param {?} e
 * @return {?}
 */
mxGraph.prototype.getOpposites = function(a, b, status, e) {
  status = null != status ? status : true;
  e = null != e ? e : true;
  /** @type {!Array} */
  var t_chksum = [];
  var f = new mxDictionary;
  if (null != a) {
    /** @type {number} */
    var i = 0;
    for (; i < a.length; i++) {
      var r = this.view.getState(a[i]);
      var max = null != r ? r.getVisibleTerminal(true) : this.view.getVisibleTerminal(a[i], true);
      r = null != r ? r.getVisibleTerminal(false) : this.view.getVisibleTerminal(a[i], false);
      if (max == b && null != r && r != b && e) {
        if (!f.get(r)) {
          f.put(r, true);
          t_chksum.push(r);
        }
      } else {
        if (r == b && null != max && max != b && status && !f.get(max)) {
          f.put(max, true);
          t_chksum.push(max);
        }
      }
    }
  }
  return t_chksum;
};
/**
 * @param {!Array} a
 * @param {?} b
 * @param {string} status
 * @return {?}
 */
mxGraph.prototype.getEdgesBetween = function(a, b, status) {
  status = null != status ? status : false;
  var nodes = this.getEdges(a);
  /** @type {!Array} */
  var newNodeCollection = [];
  /** @type {number} */
  var i = 0;
  for (; i < nodes.length; i++) {
    var bP = this.view.getState(nodes[i]);
    var comp = null != bP ? bP.getVisibleTerminal(true) : this.view.getVisibleTerminal(nodes[i], true);
    bP = null != bP ? bP.getVisibleTerminal(false) : this.view.getVisibleTerminal(nodes[i], false);
    if (comp == a && bP == b || !status && comp == b && bP == a) {
      newNodeCollection.push(nodes[i]);
    }
  }
  return newNodeCollection;
};
/**
 * @param {(Object|string)} evt
 * @param {number} originFrameIndex
 * @return {?}
 */
mxGraph.prototype.getPointForEvent = function(evt, originFrameIndex) {
  var c = mxUtils.convertPoint(this.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
  var scale = this.view.scale;
  var t = this.view.translate;
  /** @type {number} */
  var f = 0 != originFrameIndex ? this.gridSize / 2 : 0;
  c.x = this.snap(c.x / scale - t.x - f);
  c.y = this.snap(c.y / scale - t.y - f);
  return c;
};
/**
 * @param {string} end
 * @param {number} min
 * @param {number} range
 * @param {number} size
 * @param {!Object} parent
 * @param {string} data
 * @param {?} node
 * @param {string} $
 * @param {?} elems
 * @return {?}
 */
mxGraph.prototype.getCells = function(end, min, range, size, parent, data, node, $, elems) {
  data = null != data ? data : [];
  if (0 < range || 0 < size || null != node) {
    var model = this.getModel();
    var glue = end + range;
    var i = min + size;
    if (null == parent) {
      parent = this.getCurrentRoot();
      if (null == parent) {
        parent = model.getRoot();
      }
    }
    if (null != parent) {
      var newParentTag = model.getChildCount(parent);
      /** @type {number} */
      var y = 0;
      for (; y < newParentTag; y++) {
        var element = model.getChildAt(parent, y);
        var s = this.view.getState(element);
        if (null != s && this.isCellVisible(element) && (null == $ || !$(s))) {
          var value = mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION) || 0;
          if (0 != value) {
            s = mxUtils.getBoundingBox(s, value);
          }
          if (value = null != node && model.isVertex(element) && mxUtils.intersects(node, s) || null == node && (model.isEdge(element) || model.isVertex(element)) && s.x >= end && s.y + s.height <= i && s.y >= min && s.x + s.width <= glue) {
            data.push(element);
          }
          if (!(value && !elems)) {
            this.getCells(end, min, range, size, element, data, node, $, elems);
          }
        }
      }
    }
  }
  return data;
};
/**
 * @param {?} w
 * @param {?} h
 * @param {!Object} i
 * @param {number} beforeZero
 * @param {boolean} afterZero
 * @return {?}
 */
mxGraph.prototype.getCellsBeyond = function(w, h, i, beforeZero, afterZero) {
  /** @type {!Array} */
  var studentMatrix = [];
  if (beforeZero || afterZero) {
    if (null == i && (i = this.getDefaultParent()), null != i) {
      var g = this.model.getChildCount(i);
      /** @type {number} */
      var y = 0;
      for (; y < g; y++) {
        var row = this.model.getChildAt(i, y);
        var line = this.view.getState(row);
        if (this.isCellVisible(row) && null != line && (!beforeZero || line.x >= w) && (!afterZero || line.y >= h)) {
          studentMatrix.push(row);
        }
      }
    }
  }
  return studentMatrix;
};
/**
 * @param {!Object} j
 * @param {string} max
 * @param {string} reverse
 * @return {?}
 */
mxGraph.prototype.findTreeRoots = function(j, max, reverse) {
  max = null != max ? max : false;
  reverse = null != reverse ? reverse : false;
  /** @type {!Array} */
  var row = [];
  if (null != j) {
    var menu = this.getModel();
    var remaining = menu.getChildCount(j);
    /** @type {null} */
    var previous = null;
    /** @type {number} */
    var maxDistanceAbove = 0;
    /** @type {number} */
    var i = 0;
    for (; i < remaining; i++) {
      var cell = menu.getChildAt(j, i);
      if (this.model.isVertex(cell) && this.isCellVisible(cell)) {
        var value = this.getConnections(cell, max ? j : null);
        /** @type {number} */
        var p = 0;
        /** @type {number} */
        var circlePixel = 0;
        /** @type {number} */
        var i = 0;
        for (; i < value.length; i++) {
          if (this.view.getVisibleTerminal(value[i], true) == cell) {
            p++;
          } else {
            circlePixel++;
          }
        }
        if (reverse && 0 == p && 0 < circlePixel || !reverse && 0 == circlePixel && 0 < p) {
          row.push(cell);
        }
        /** @type {number} */
        value = reverse ? circlePixel - p : p - circlePixel;
        if (value > maxDistanceAbove) {
          /** @type {number} */
          maxDistanceAbove = value;
          previous = cell;
        }
      }
    }
    if (0 == row.length && null != previous) {
      row.push(previous);
    }
  }
  return row;
};
/**
 * @param {?} value
 * @param {?} data
 * @param {?} cb
 * @param {number} type
 * @param {!Object} node
 * @param {!Object} parent
 * @return {undefined}
 */
mxGraph.prototype.traverse = function(value, data, cb, type, node, parent) {
  if (null != cb && null != value && (data = null != data ? data : true, parent = null != parent ? parent : false, node = node || new mxDictionary, !node.get(value) && (node.put(value, true), type = cb(value, type), null == type || type)) && (type = this.model.getEdgeCount(value), 0 < type)) {
    /** @type {number} */
    var y = 0;
    for (; y < type; y++) {
      var i = this.model.getEdgeAt(value, y);
      /** @type {boolean} */
      var selected = this.model.getTerminal(i, true) == value;
      if (!(data && !parent != selected)) {
        selected = this.model.getTerminal(i, !selected);
        this.traverse(selected, data, cb, i, node, parent);
      }
    }
  }
};
/**
 * @param {?} record
 * @return {?}
 */
mxGraph.prototype.isCellSelected = function(record) {
  return this.getSelectionModel().isSelected(record);
};
/**
 * @return {?}
 */
mxGraph.prototype.isSelectionEmpty = function() {
  return this.getSelectionModel().isEmpty();
};
/**
 * @return {?}
 */
mxGraph.prototype.clearSelection = function() {
  return this.getSelectionModel().clear();
};
/**
 * @return {?}
 */
mxGraph.prototype.getSelectionCount = function() {
  return this.getSelectionModel().cells.length;
};
/**
 * @return {?}
 */
mxGraph.prototype.getSelectionCell = function() {
  return this.getSelectionModel().cells[0];
};
/**
 * @return {?}
 */
mxGraph.prototype.getSelectionCells = function() {
  return this.getSelectionModel().cells.slice();
};
/**
 * @param {string} obj
 * @return {undefined}
 */
mxGraph.prototype.setSelectionCell = function(obj) {
  this.getSelectionModel().setCell(obj);
};
/**
 * @param {!Array} cells
 * @return {undefined}
 */
mxGraph.prototype.setSelectionCells = function(cells) {
  this.getSelectionModel().setCells(cells);
};
/**
 * @param {string} r1
 * @return {undefined}
 */
mxGraph.prototype.addSelectionCell = function(r1) {
  this.getSelectionModel().addCell(r1);
};
/**
 * @param {string} cells
 * @return {undefined}
 */
mxGraph.prototype.addSelectionCells = function(cells) {
  this.getSelectionModel().addCells(cells);
};
/**
 * @param {?} index
 * @return {undefined}
 */
mxGraph.prototype.removeSelectionCell = function(index) {
  this.getSelectionModel().removeCell(index);
};
/**
 * @param {!Array} before
 * @return {undefined}
 */
mxGraph.prototype.removeSelectionCells = function(before) {
  this.getSelectionModel().removeCells(before);
};
/**
 * @param {!Object} value
 * @param {!Object} name
 * @return {?}
 */
mxGraph.prototype.selectRegion = function(value, name) {
  var restoreText = this.getCells(value.x, value.y, value.width, value.height);
  this.selectCellsForEvent(restoreText, name);
  return restoreText;
};
/**
 * @return {undefined}
 */
mxGraph.prototype.selectNextCell = function() {
  this.selectCell(true);
};
/**
 * @return {undefined}
 */
mxGraph.prototype.selectPreviousCell = function() {
  this.selectCell();
};
/**
 * @return {undefined}
 */
mxGraph.prototype.selectParentCell = function() {
  this.selectCell(false, true);
};
/**
 * @return {undefined}
 */
mxGraph.prototype.selectChildCell = function() {
  this.selectCell(false, false, true);
};
/**
 * @param {string} y
 * @param {number} val
 * @param {boolean} state
 * @return {undefined}
 */
mxGraph.prototype.selectCell = function(y, val, state) {
  var element = this.selectionModel;
  var n = 0 < element.cells.length ? element.cells[0] : null;
  if (1 < element.cells.length) {
    element.clear();
  }
  element = null != n ? this.model.getParent(n) : this.getDefaultParent();
  var overflow = this.model.getChildCount(element);
  if (null == n && 0 < overflow) {
    y = this.model.getChildAt(element, 0);
    this.setSelectionCell(y);
  } else {
    if (null != n && !val || null == this.view.getState(element) || null == this.model.getGeometry(element)) {
      if (null != n && state) {
        if (0 < this.model.getChildCount(n)) {
          y = this.model.getChildAt(n, 0);
          this.setSelectionCell(y);
        }
      } else {
        if (0 < overflow) {
          val = element.getIndex(n);
          if (y) {
            val++;
            y = this.model.getChildAt(element, val % overflow);
          } else {
            val--;
            y = this.model.getChildAt(element, 0 > val ? overflow - 1 : val);
          }
          this.setSelectionCell(y);
        }
      }
    } else {
      if (this.getCurrentRoot() != element) {
        this.setSelectionCell(element);
      }
    }
  }
};
/**
 * @param {!Array} value
 * @param {?} object
 * @return {undefined}
 */
mxGraph.prototype.selectAll = function(value, object) {
  value = value || this.getDefaultParent();
  var domCells = object ? this.model.filterDescendants(mxUtils.bind(this, function(key) {
    return key != value && null != this.view.getState(key);
  }), value) : this.model.getChildren(value);
  if (null != domCells) {
    this.setSelectionCells(domCells);
  }
};
/**
 * @param {!Object} delim
 * @param {string} silent
 * @return {undefined}
 */
mxGraph.prototype.selectVertices = function(delim, silent) {
  this.selectCells(true, false, delim, silent);
};
/**
 * @param {!Object} selection
 * @return {undefined}
 */
mxGraph.prototype.selectEdges = function(selection) {
  this.selectCells(false, true, selection);
};
/**
 * @param {string} amount
 * @param {string} target
 * @param {!Object} s
 * @param {string} suppressEvent
 * @return {undefined}
 */
mxGraph.prototype.selectCells = function(amount, target, s, suppressEvent) {
  s = s || this.getDefaultParent();
  var id = mxUtils.bind(this, function(cell) {
    return null != this.view.getState(cell) && ((suppressEvent || 0 == this.model.getChildCount(cell)) && this.model.isVertex(cell) && amount && !this.model.isEdge(this.model.getParent(cell)) || this.model.isEdge(cell) && target);
  });
  s = this.model.filterDescendants(id, s);
  if (null != s) {
    this.setSelectionCells(s);
  }
};
/**
 * @param {boolean} a
 * @param {!Object} e
 * @return {undefined}
 */
mxGraph.prototype.selectCellForEvent = function(a, e) {
  var _ref_a = this.isCellSelected(a);
  if (this.isToggleEvent(e)) {
    if (_ref_a) {
      this.removeSelectionCell(a);
    } else {
      this.addSelectionCell(a);
    }
  } else {
    if (!(_ref_a && 1 == this.getSelectionCount())) {
      this.setSelectionCell(a);
    }
  }
};
/**
 * @param {undefined} after
 * @param {!Object} e
 * @return {undefined}
 */
mxGraph.prototype.selectCellsForEvent = function(after, e) {
  if (this.isToggleEvent(e)) {
    this.addSelectionCells(after);
  } else {
    this.setSelectionCells(after);
  }
};
/**
 * @param {!Object} state
 * @return {?}
 */
mxGraph.prototype.createHandler = function(state) {
  /** @type {null} */
  var element = null;
  if (null != state) {
    if (this.model.isEdge(state.cell)) {
      element = state.getVisibleTerminalState(true);
      var label = state.getVisibleTerminalState(false);
      var geo = this.getCellGeometry(state.cell);
      element = this.view.getEdgeStyle(state, null != geo ? geo.points : null, element, label);
      element = this.createEdgeHandler(state, element);
    } else {
      element = this.createVertexHandler(state);
    }
  }
  return element;
};
/**
 * @param {!Object} basecolumn
 * @return {?}
 */
mxGraph.prototype.createVertexHandler = function(basecolumn) {
  return new mxVertexHandler(basecolumn);
};
/**
 * @param {!Object} a
 * @param {!Object} item
 * @return {?}
 */
mxGraph.prototype.createEdgeHandler = function(a, item) {
  return item == mxEdgeStyle.Loop || item == mxEdgeStyle.ElbowConnector || item == mxEdgeStyle.SideToSide || item == mxEdgeStyle.TopToBottom ? this.createElbowEdgeHandler(a) : item == mxEdgeStyle.SegmentConnector || item == mxEdgeStyle.OrthConnector ? this.createEdgeSegmentHandler(a) : new mxEdgeHandler(a);
};
/**
 * @param {!Object} strip1
 * @return {?}
 */
mxGraph.prototype.createEdgeSegmentHandler = function(strip1) {
  return new mxEdgeSegmentHandler(strip1);
};
/**
 * @param {!Object} strip1
 * @return {?}
 */
mxGraph.prototype.createElbowEdgeHandler = function(strip1) {
  return new mxElbowEdgeHandler(strip1);
};
/**
 * @param {?} callback
 * @return {undefined}
 */
mxGraph.prototype.addMouseListener = function(callback) {
  if (null == this.mouseListeners) {
    /** @type {!Array} */
    this.mouseListeners = [];
  }
  this.mouseListeners.push(callback);
};
/**
 * @param {?} value
 * @return {undefined}
 */
mxGraph.prototype.removeMouseListener = function(value) {
  if (null != this.mouseListeners) {
    /** @type {number} */
    var i = 0;
    for (; i < this.mouseListeners.length; i++) {
      if (this.mouseListeners[i] == value) {
        this.mouseListeners.splice(i, 1);
        break;
      }
    }
  }
};
/**
 * @param {!Object} me
 * @param {number} evtName
 * @return {?}
 */
mxGraph.prototype.updateMouseEvent = function(me, evtName) {
  if (null == me.graphX || null == me.graphY) {
    var pt = mxUtils.convertPoint(this.container, me.getX(), me.getY());
    /** @type {number} */
    me.graphX = pt.x - this.panDx;
    /** @type {number} */
    me.graphY = pt.y - this.panDy;
    if (null == me.getCell() && this.isMouseDown && evtName == mxEvent.MOUSE_MOVE) {
      me.state = this.view.getState(this.getCellAt(pt.x, pt.y, null, null, null, function(cell) {
        return null == cell.shape || cell.shape.paintBackground != mxRectangleShape.prototype.paintBackground || "1" == mxUtils.getValue(cell.style, mxConstants.STYLE_POINTER_EVENTS, "1") || null != cell.shape.fill && cell.shape.fill != mxConstants.NONE;
      }));
    }
  }
  return me;
};
/**
 * @param {?} evt
 * @return {?}
 */
mxGraph.prototype.getStateForTouchEvent = function(evt) {
  var pt = mxEvent.getClientX(evt);
  evt = mxEvent.getClientY(evt);
  pt = mxUtils.convertPoint(this.container, pt, evt);
  return this.view.getState(this.getCellAt(pt.x, pt.y));
};
/**
 * @param {?} evtName
 * @param {!Object} me
 * @param {!Object} val
 * @return {?}
 */
mxGraph.prototype.isEventIgnored = function(evtName, me, val) {
  var d = mxEvent.isMouseEvent(me.getEvent());
  /** @type {boolean} */
  var nucleicOnly = false;
  if (me.getEvent() == this.lastEvent) {
    /** @type {boolean} */
    nucleicOnly = true;
  } else {
    this.lastEvent = me.getEvent();
  }
  if (null != this.eventSource && evtName != mxEvent.MOUSE_MOVE) {
    mxEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
    /** @type {null} */
    this.eventSource = this.mouseUpRedirect = this.mouseMoveRedirect = null;
  } else {
    if (mxClient.IS_GC || null == this.eventSource || me.getSource() == this.eventSource) {
      if (!(!mxClient.IS_TOUCH || evtName != mxEvent.MOUSE_DOWN || d || mxEvent.isPenEvent(me.getEvent()))) {
        this.eventSource = me.getSource();
        this.mouseMoveRedirect = mxUtils.bind(this, function(evt) {
          this.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, this.getStateForTouchEvent(evt)));
        });
        this.mouseUpRedirect = mxUtils.bind(this, function(evt) {
          this.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, this.getStateForTouchEvent(evt)));
        });
        mxEvent.addGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
      }
    } else {
      /** @type {boolean} */
      nucleicOnly = true;
    }
  }
  if (this.isSyntheticEventIgnored(evtName, me, val)) {
    /** @type {boolean} */
    nucleicOnly = true;
  }
  if (!mxEvent.isPopupTrigger(this.lastEvent) && evtName != mxEvent.MOUSE_MOVE && 2 == this.lastEvent.detail) {
    return true;
  }
  if (evtName == mxEvent.MOUSE_UP && this.isMouseDown) {
    /** @type {boolean} */
    this.isMouseDown = false;
  } else {
    if (evtName != mxEvent.MOUSE_DOWN || this.isMouseDown) {
      if (!nucleicOnly && ((!mxClient.IS_FF || evtName != mxEvent.MOUSE_MOVE) && this.isMouseDown && this.isMouseTrigger != d || evtName == mxEvent.MOUSE_DOWN && this.isMouseDown || evtName == mxEvent.MOUSE_UP && !this.isMouseDown)) {
        /** @type {boolean} */
        nucleicOnly = true;
      }
    } else {
      /** @type {boolean} */
      this.isMouseDown = true;
      this.isMouseTrigger = d;
    }
  }
  if (!(nucleicOnly || evtName != mxEvent.MOUSE_DOWN)) {
    this.lastMouseX = me.getX();
    this.lastMouseY = me.getY();
  }
  return nucleicOnly;
};
/**
 * @param {?} evtName
 * @param {!Object} type
 * @param {boolean} shapeTypes
 * @return {?}
 */
mxGraph.prototype.isSyntheticEventIgnored = function(evtName, type, shapeTypes) {
  /** @type {boolean} */
  shapeTypes = false;
  type = mxEvent.isMouseEvent(type.getEvent());
  if (this.ignoreMouseEvents && type && evtName != mxEvent.MOUSE_MOVE) {
    /** @type {boolean} */
    this.ignoreMouseEvents = evtName != mxEvent.MOUSE_UP;
    /** @type {boolean} */
    shapeTypes = true;
  } else {
    if (mxClient.IS_FF && !type && evtName == mxEvent.MOUSE_UP) {
      /** @type {boolean} */
      this.ignoreMouseEvents = true;
    }
  }
  return shapeTypes;
};
/**
 * @param {number} evtName
 * @param {!Object} me
 * @return {?}
 */
mxGraph.prototype.isEventSourceIgnored = function(evtName, me) {
  var self = me.getSource();
  var type = null != self.nodeName ? self.nodeName.toLowerCase() : "";
  var dataModel = !mxEvent.isMouseEvent(me.getEvent()) || mxEvent.isLeftMouseButton(me.getEvent());
  return evtName == mxEvent.MOUSE_DOWN && dataModel && ("select" == type || "option" == type || "input" == type && "checkbox" != self.type && "radio" != self.type && "button" != self.type && "submit" != self.type && "file" != self.type);
};
/**
 * @param {?} childType
 * @return {?}
 */
mxGraph.prototype.getEventState = function(childType) {
  return childType;
};
/**
 * @param {number} evtName
 * @param {!Object} me
 * @param {!Object} type
 * @return {undefined}
 */
mxGraph.prototype.fireMouseEvent = function(evtName, me, type) {
  if (this.isEventSourceIgnored(evtName, me)) {
    if (null != this.tooltipHandler) {
      this.tooltipHandler.hide();
    }
  } else {
    if (null == type) {
      type = this;
    }
    me = this.updateMouseEvent(me, evtName);
    if (!this.nativeDblClickEnabled && !mxEvent.isPopupTrigger(me.getEvent()) || this.doubleTapEnabled && mxClient.IS_TOUCH && (mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent()))) {
      /** @type {number} */
      var zoom = (new Date).getTime();
      if (!mxClient.IS_QUIRKS && evtName == mxEvent.MOUSE_DOWN || mxClient.IS_QUIRKS && evtName == mxEvent.MOUSE_UP && !this.fireDoubleClick) {
        if (null != this.lastTouchEvent && this.lastTouchEvent != me.getEvent() && zoom - this.lastTouchTime < this.doubleTapTimeout && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance && 2 > this.doubleClickCounter) {
          if (this.doubleClickCounter++, zoom = false, evtName == mxEvent.MOUSE_UP ? me.getCell() == this.lastTouchCell && null != this.lastTouchCell && (this.lastTouchTime = 0, zoom = this.lastTouchCell, this.lastTouchCell = null, mxClient.IS_QUIRKS && me.getSource().fireEvent("ondblclick"), this.dblClick(me.getEvent(), zoom), zoom = true) : (this.fireDoubleClick = true, this.lastTouchTime = 0), !mxClient.IS_QUIRKS || zoom) {
            mxEvent.consume(me.getEvent());
            return;
          }
        } else {
          if (null == this.lastTouchEvent || this.lastTouchEvent != me.getEvent()) {
            this.lastTouchCell = me.getCell();
            this.lastTouchX = me.getX();
            this.lastTouchY = me.getY();
            /** @type {number} */
            this.lastTouchTime = zoom;
            this.lastTouchEvent = me.getEvent();
            /** @type {number} */
            this.doubleClickCounter = 0;
          }
        }
      } else {
        if ((this.isMouseDown || evtName == mxEvent.MOUSE_UP) && this.fireDoubleClick) {
          /** @type {boolean} */
          this.fireDoubleClick = false;
          zoom = this.lastTouchCell;
          /** @type {null} */
          this.lastTouchCell = null;
          /** @type {boolean} */
          this.isMouseDown = false;
          if ((null != zoom || (mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())) && (mxClient.IS_GC || mxClient.IS_SF)) && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance) {
            this.dblClick(me.getEvent(), zoom);
          } else {
            mxEvent.consume(me.getEvent());
          }
          return;
        }
      }
    }
    if (!this.isEventIgnored(evtName, me, type)) {
      me.state = this.getEventState(me.getState());
      this.fireEvent(new mxEventObject(mxEvent.FIRE_MOUSE_EVENT, "eventName", evtName, "event", me));
      if (mxClient.IS_OP || mxClient.IS_SF || mxClient.IS_GC || mxClient.IS_IE11 || mxClient.IS_IE && mxClient.IS_SVG || me.getEvent().target != this.container) {
        if (evtName == mxEvent.MOUSE_MOVE && this.isMouseDown && this.autoScroll && !mxEvent.isMultiTouchEvent(me.getEvent)) {
          this.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.autoExtend);
        } else {
          if (evtName == mxEvent.MOUSE_UP && this.ignoreScrollbars && this.translateToScrollPosition && (0 != this.container.scrollLeft || 0 != this.container.scrollTop)) {
            zoom = this.view.scale;
            var p = this.view.translate;
            this.view.setTranslate(p.x - this.container.scrollLeft / zoom, p.y - this.container.scrollTop / zoom);
            /** @type {number} */
            this.container.scrollLeft = 0;
            /** @type {number} */
            this.container.scrollTop = 0;
          }
        }
        if (null != this.mouseListeners) {
          /** @type {!Array} */
          zoom = [type, me];
          if (!me.getEvent().preventDefault) {
            /** @type {boolean} */
            me.getEvent().returnValue = true;
          }
          /** @type {number} */
          p = 0;
          for (; p < this.mouseListeners.length; p++) {
            var o = this.mouseListeners[p];
            if (evtName == mxEvent.MOUSE_DOWN) {
              o.mouseDown.apply(o, zoom);
            } else {
              if (evtName == mxEvent.MOUSE_MOVE) {
                o.mouseMove.apply(o, zoom);
              } else {
                if (evtName == mxEvent.MOUSE_UP) {
                  o.mouseUp.apply(o, zoom);
                }
              }
            }
          }
        }
        if (evtName == mxEvent.MOUSE_UP) {
          this.click(me);
        }
      }
      if ((mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())) && evtName == mxEvent.MOUSE_DOWN && this.tapAndHoldEnabled && !this.tapAndHoldInProgress) {
        /** @type {boolean} */
        this.tapAndHoldInProgress = true;
        this.initialTouchX = me.getGraphX();
        this.initialTouchY = me.getGraphY();
        if (this.tapAndHoldThread) {
          window.clearTimeout(this.tapAndHoldThread);
        }
        this.tapAndHoldThread = window.setTimeout(mxUtils.bind(this, function() {
          if (this.tapAndHoldValid) {
            this.tapAndHold(me);
          }
          /** @type {boolean} */
          this.tapAndHoldValid = this.tapAndHoldInProgress = false;
        }), this.tapAndHoldDelay);
        /** @type {boolean} */
        this.tapAndHoldValid = true;
      } else {
        if (evtName == mxEvent.MOUSE_UP) {
          /** @type {boolean} */
          this.tapAndHoldValid = this.tapAndHoldInProgress = false;
        } else {
          if (this.tapAndHoldValid) {
            /** @type {boolean} */
            this.tapAndHoldValid = Math.abs(this.initialTouchX - me.getGraphX()) < this.tolerance && Math.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;
          }
        }
      }
      if (evtName == mxEvent.MOUSE_DOWN && this.isEditing() && !this.cellEditor.isEventSource(me.getEvent())) {
        this.stopEditing(!this.isInvokesStopCellEditing());
      }
      this.consumeMouseEvent(evtName, me, type);
    }
  }
};
/**
 * @param {number} evtName
 * @param {!Event} me
 * @param {!Object} value
 * @return {undefined}
 */
mxGraph.prototype.consumeMouseEvent = function(evtName, me, value) {
  if (evtName == mxEvent.MOUSE_DOWN && mxEvent.isTouchEvent(me.getEvent())) {
    me.consume(false);
  }
};
/**
 * @param {number} $o
 * @param {boolean} i
 * @return {undefined}
 */
mxGraph.prototype.fireGestureEvent = function($o, i) {
  /** @type {number} */
  this.lastTouchTime = 0;
  this.fireEvent(new mxEventObject(mxEvent.GESTURE, "event", $o, "cell", i));
};
/**
 * @return {undefined}
 */
mxGraph.prototype.destroy = function() {
  if (!this.destroyed) {
    /** @type {boolean} */
    this.destroyed = true;
    if (null != this.tooltipHandler) {
      this.tooltipHandler.destroy();
    }
    if (null != this.selectionCellsHandler) {
      this.selectionCellsHandler.destroy();
    }
    if (null != this.panningHandler) {
      this.panningHandler.destroy();
    }
    if (null != this.popupMenuHandler) {
      this.popupMenuHandler.destroy();
    }
    if (null != this.connectionHandler) {
      this.connectionHandler.destroy();
    }
    if (null != this.graphHandler) {
      this.graphHandler.destroy();
    }
    if (null != this.cellEditor) {
      this.cellEditor.destroy();
    }
    if (null != this.view) {
      this.view.destroy();
    }
    if (null != this.model && null != this.graphModelChangeListener) {
      this.model.removeListener(this.graphModelChangeListener);
      /** @type {null} */
      this.graphModelChangeListener = null;
    }
    /** @type {null} */
    this.container = null;
  }
};
/**
 * @param {string} image
 * @param {string} tooltip
 * @param {string} data
 * @param {string} path
 * @param {string} len
 * @param {string} iotype
 * @return {undefined}
 */
function mxCellOverlay(image, tooltip, data, path, len, iotype) {
  /** @type {string} */
  this.image = image;
  /** @type {string} */
  this.tooltip = tooltip;
  this.align = null != data ? data : this.align;
  this.verticalAlign = null != path ? path : this.verticalAlign;
  this.offset = null != len ? len : new mxPoint;
  this.cursor = null != iotype ? iotype : "help";
}
mxCellOverlay.prototype = new mxEventSource;
/** @type {function(string, string, string, string, string, string): undefined} */
mxCellOverlay.prototype.constructor = mxCellOverlay;
/** @type {null} */
mxCellOverlay.prototype.image = null;
/** @type {null} */
mxCellOverlay.prototype.tooltip = null;
/** @type {string} */
mxCellOverlay.prototype.align = mxConstants.ALIGN_RIGHT;
/** @type {string} */
mxCellOverlay.prototype.verticalAlign = mxConstants.ALIGN_BOTTOM;
/** @type {null} */
mxCellOverlay.prototype.offset = null;
/** @type {null} */
mxCellOverlay.prototype.cursor = null;
/** @type {number} */
mxCellOverlay.prototype.defaultOverlap = .5;
/**
 * @param {!Object} state
 * @return {?}
 */
mxCellOverlay.prototype.getBounds = function(state) {
  var data = state.view.graph.getModel().isEdge(state.cell);
  var scale = state.view.scale;
  var width = this.image.width;
  var height = this.image.height;
  if (data) {
    if (data = state.absolutePoints, 1 == data.length % 2) {
      data = data[Math.floor(data.length / 2)];
    } else {
      /** @type {number} */
      var j = data.length / 2;
      state = data[j - 1];
      data = data[j];
      data = new mxPoint(state.x + (data.x - state.x) / 2, state.y + (data.y - state.y) / 2);
    }
  } else {
    data = new mxPoint;
    data.x = this.align == mxConstants.ALIGN_LEFT ? state.x : this.align == mxConstants.ALIGN_CENTER ? state.x + state.width / 2 : state.x + state.width;
    data.y = this.verticalAlign == mxConstants.ALIGN_TOP ? state.y : this.verticalAlign == mxConstants.ALIGN_MIDDLE ? state.y + state.height / 2 : state.y + state.height;
  }
  return new mxRectangle(Math.round(data.x - (width * this.defaultOverlap - this.offset.x) * scale), Math.round(data.y - (height * this.defaultOverlap - this.offset.y) * scale), width * scale, height * scale);
};
/**
 * @return {?}
 */
mxCellOverlay.prototype.toString = function() {
  return this.tooltip;
};
/**
 * @param {string} source
 * @param {string} initialValue
 * @return {undefined}
 */
function mxOutline(source, initialValue) {
  /** @type {string} */
  this.source = source;
  if (null != initialValue) {
    this.init(initialValue);
  }
}
/** @type {null} */
mxOutline.prototype.source = null;
/** @type {null} */
mxOutline.prototype.outline = null;
/** @type {string} */
mxOutline.prototype.graphRenderHint = mxConstants.RENDERING_HINT_FASTER;
/** @type {boolean} */
mxOutline.prototype.enabled = true;
/** @type {boolean} */
mxOutline.prototype.showViewport = true;
/** @type {number} */
mxOutline.prototype.border = 10;
/** @type {number} */
mxOutline.prototype.sizerSize = 8;
/** @type {boolean} */
mxOutline.prototype.labelsVisible = false;
/** @type {boolean} */
mxOutline.prototype.updateOnPan = false;
/** @type {null} */
mxOutline.prototype.sizerImage = null;
/** @type {number} */
mxOutline.prototype.minScale = 1E-4;
/** @type {boolean} */
mxOutline.prototype.suspended = false;
/** @type {boolean} */
mxOutline.prototype.forceVmlHandles = 8 == document.documentMode;
/**
 * @param {!Object} g
 * @return {?}
 */
mxOutline.prototype.createGraph = function(g) {
  g = new mxGraph(g, this.source.getModel(), this.graphRenderHint, this.source.getStylesheet());
  /** @type {boolean} */
  g.foldingEnabled = false;
  /** @type {boolean} */
  g.autoScroll = false;
  return g;
};
/**
 * @param {!Object} target
 * @return {undefined}
 */
mxOutline.prototype.init = function(target) {
  this.outline = this.createGraph(target);
  var node = this.outline.graphModelChanged;
  this.outline.graphModelChanged = mxUtils.bind(this, function(a) {
    if (!(this.suspended || null == this.outline)) {
      node.apply(this.outline, arguments);
    }
  });
  if (mxClient.IS_SVG) {
    target = this.outline.getView().getCanvas().parentNode;
    target.setAttribute("shape-rendering", "optimizeSpeed");
    target.setAttribute("image-rendering", "optimizeSpeed");
  }
  this.outline.labelsVisible = this.labelsVisible;
  this.outline.setEnabled(false);
  this.updateHandler = mxUtils.bind(this, function(a, b) {
    if (!(this.suspended || this.active)) {
      this.update();
    }
  });
  this.source.getModel().addListener(mxEvent.CHANGE, this.updateHandler);
  this.outline.addMouseListener(this);
  target = this.source.getView();
  target.addListener(mxEvent.SCALE, this.updateHandler);
  target.addListener(mxEvent.TRANSLATE, this.updateHandler);
  target.addListener(mxEvent.SCALE_AND_TRANSLATE, this.updateHandler);
  target.addListener(mxEvent.DOWN, this.updateHandler);
  target.addListener(mxEvent.UP, this.updateHandler);
  mxEvent.addListener(this.source.container, "scroll", this.updateHandler);
  this.panHandler = mxUtils.bind(this, function(a) {
    if (this.updateOnPan) {
      this.updateHandler.apply(this, arguments);
    }
  });
  this.source.addListener(mxEvent.PAN, this.panHandler);
  this.refreshHandler = mxUtils.bind(this, function(a) {
    this.outline.setStylesheet(this.source.getStylesheet());
    this.outline.refresh();
  });
  this.source.addListener(mxEvent.REFRESH, this.refreshHandler);
  this.bounds = new mxRectangle(0, 0, 0, 0);
  this.selectionBorder = new mxRectangleShape(this.bounds, null, mxConstants.OUTLINE_COLOR, mxConstants.OUTLINE_STROKEWIDTH);
  this.selectionBorder.dialect = this.outline.dialect;
  if (this.forceVmlHandles) {
    /**
     * @return {?}
     */
    this.selectionBorder.isHtmlAllowed = function() {
      return false;
    };
  }
  this.selectionBorder.init(this.outline.getView().getOverlayPane());
  target = mxUtils.bind(this, function(evt) {
    var img = mxEvent.getSource(evt);
    var update = mxUtils.bind(this, function(evt) {
      this.outline.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
    });
    var handleMoveOrResize = mxUtils.bind(this, function(evt) {
      mxEvent.removeGestureListeners(img, null, update, handleMoveOrResize);
      this.outline.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
    });
    mxEvent.addGestureListeners(img, null, update, handleMoveOrResize);
    this.outline.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
  });
  mxEvent.addGestureListeners(this.selectionBorder.node, target);
  this.sizer = this.createSizer();
  if (this.forceVmlHandles) {
    /**
     * @return {?}
     */
    this.sizer.isHtmlAllowed = function() {
      return false;
    };
  }
  this.sizer.init(this.outline.getView().getOverlayPane());
  if (this.enabled) {
    /** @type {string} */
    this.sizer.node.style.cursor = "nwse-resize";
  }
  mxEvent.addGestureListeners(this.sizer.node, target);
  /** @type {string} */
  this.selectionBorder.node.style.display = this.showViewport ? "" : "none";
  /** @type {string} */
  this.sizer.node.style.display = this.selectionBorder.node.style.display;
  /** @type {string} */
  this.selectionBorder.node.style.cursor = "move";
  this.update(false);
};
/**
 * @return {?}
 */
mxOutline.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxOutline.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @param {boolean} enabled
 * @return {undefined}
 */
mxOutline.prototype.setZoomEnabled = function(enabled) {
  /** @type {string} */
  this.sizer.node.style.visibility = enabled ? "visible" : "hidden";
};
/**
 * @return {undefined}
 */
mxOutline.prototype.refresh = function() {
  this.update(true);
};
/**
 * @return {?}
 */
mxOutline.prototype.createSizer = function() {
  var options = null != this.sizerImage ? new mxImageShape(new mxRectangle(0, 0, this.sizerImage.width, this.sizerImage.height), this.sizerImage.src) : new mxRectangleShape(new mxRectangle(0, 0, this.sizerSize, this.sizerSize), mxConstants.OUTLINE_HANDLE_FILLCOLOR, mxConstants.OUTLINE_HANDLE_STROKECOLOR);
  options.dialect = this.outline.dialect;
  return options;
};
/**
 * @return {?}
 */
mxOutline.prototype.getSourceContainerSize = function() {
  return new mxRectangle(0, 0, this.source.container.scrollWidth, this.source.container.scrollHeight);
};
/**
 * @param {?} scale
 * @return {?}
 */
mxOutline.prototype.getOutlineOffset = function(scale) {
  return null;
};
/**
 * @return {?}
 */
mxOutline.prototype.getSourceGraphBounds = function() {
  return this.source.getGraphBounds();
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxOutline.prototype.update = function(a) {
  if (null != this.source && null != this.source.container && null != this.outline && null != this.outline.container) {
    var s = this.source.view.scale;
    var bounds = this.getSourceGraphBounds();
    bounds = new mxRectangle(bounds.x / s + this.source.panDx, bounds.y / s + this.source.panDy, bounds.width / s, bounds.height / s);
    var scale = new mxRectangle(0, 0, this.source.container.clientWidth / s, this.source.container.clientHeight / s);
    var c = bounds.clone();
    c.add(scale);
    scale = this.getSourceContainerSize();
    /** @type {number} */
    s = Math.min(Math.max(0, this.outline.container.clientWidth - this.border) / Math.max(scale.width / s, c.width), Math.max(0, this.outline.container.clientHeight - this.border) / Math.max(scale.height / s, c.height));
    scale = isNaN(s) ? this.minScale : Math.max(this.minScale, s);
    if (0 < scale) {
      if (this.outline.getView().scale != scale) {
        this.outline.getView().scale = scale;
        /** @type {boolean} */
        a = true;
      }
      s = this.outline.getView();
      if (s.currentRoot != this.source.getView().currentRoot) {
        s.setCurrentRoot(this.source.getView().currentRoot);
      }
      c = this.source.view.translate;
      var x = c.x + this.source.panDx;
      var y = c.y + this.source.panDy;
      scale = this.getOutlineOffset(scale);
      if (null != scale) {
        x = x + scale.x;
        y = y + scale.y;
      }
      if (0 > bounds.x) {
        /** @type {number} */
        x = x - bounds.x;
      }
      if (0 > bounds.y) {
        /** @type {number} */
        y = y - bounds.y;
      }
      if (s.translate.x != x || s.translate.y != y) {
        s.translate.x = x;
        s.translate.y = y;
        /** @type {boolean} */
        a = true;
      }
      bounds = s.translate;
      scale = this.source.getView().scale;
      /** @type {number} */
      x = scale / s.scale;
      /** @type {number} */
      y = 1 / s.scale;
      var chart = this.source.container;
      this.bounds = new mxRectangle((bounds.x - c.x - this.source.panDx) / y, (bounds.y - c.y - this.source.panDy) / y, chart.clientWidth / x, chart.clientHeight / x);
      this.bounds.x += this.source.container.scrollLeft * s.scale / scale;
      this.bounds.y += this.source.container.scrollTop * s.scale / scale;
      bounds = this.selectionBorder.bounds;
      if (bounds.x != this.bounds.x || bounds.y != this.bounds.y || bounds.width != this.bounds.width || bounds.height != this.bounds.height) {
        this.selectionBorder.bounds = this.bounds;
        this.selectionBorder.redraw();
      }
      bounds = this.sizer.bounds;
      s = new mxRectangle(this.bounds.x + this.bounds.width - bounds.width / 2, this.bounds.y + this.bounds.height - bounds.height / 2, bounds.width, bounds.height);
      if (bounds.x != s.x || bounds.y != s.y || bounds.width != s.width || bounds.height != s.height) {
        this.sizer.bounds = s;
        if ("hidden" != this.sizer.node.style.visibility) {
          this.sizer.redraw();
        }
      }
      if (a) {
        this.outline.view.revalidate();
      }
    }
  }
};
/**
 * @param {!Object} e
 * @param {!Object} me
 * @return {undefined}
 */
mxOutline.prototype.mouseDown = function(e, me) {
  if (this.enabled && this.showViewport) {
    var tol = mxEvent.isMouseEvent(me.getEvent()) ? 0 : this.source.tolerance;
    tol = this.source.allowHandleBoundsCheck && (mxClient.IS_IE || 0 < tol) ? new mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
    this.zoom = me.isSource(this.sizer) || null != tol && mxUtils.intersects(shape.bounds, tol);
    this.startX = me.getX();
    this.startY = me.getY();
    /** @type {boolean} */
    this.active = true;
    if (this.source.useScrollbarsForPanning && mxUtils.hasScrollbars(this.source.container)) {
      this.dx0 = this.source.container.scrollLeft;
      this.dy0 = this.source.container.scrollTop;
    } else {
      /** @type {number} */
      this.dy0 = this.dx0 = 0;
    }
  }
  me.consume();
};
/**
 * @param {?} callback
 * @param {!Event} event
 * @return {undefined}
 */
mxOutline.prototype.mouseMove = function(callback, event) {
  if (this.active) {
    /** @type {string} */
    this.selectionBorder.node.style.display = this.showViewport ? "" : "none";
    /** @type {string} */
    this.sizer.node.style.display = this.selectionBorder.node.style.display;
    var container = this.getTranslateForEvent(event);
    var x = container.x;
    var y = container.y;
    if (this.zoom) {
      container = this.source.container;
      /** @type {number} */
      y = x / (container.clientWidth / container.clientHeight);
      container = new mxRectangle(this.bounds.x, this.bounds.y, Math.max(1, this.bounds.width + x), Math.max(1, this.bounds.height + y));
      this.selectionBorder.bounds = container;
      this.selectionBorder.redraw();
    } else {
      var scale = this.outline.getView().scale;
      container = new mxRectangle(this.bounds.x + x, this.bounds.y + y, this.bounds.width, this.bounds.height);
      this.selectionBorder.bounds = container;
      this.selectionBorder.redraw();
      /** @type {number} */
      x = x / scale * this.source.getView().scale;
      /** @type {number} */
      y = y / scale * this.source.getView().scale;
      this.source.panGraph(-x - this.dx0, -y - this.dy0);
    }
    x = this.sizer.bounds;
    this.sizer.bounds = new mxRectangle(container.x + container.width - x.width / 2, container.y + container.height - x.height / 2, x.width, x.height);
    if ("hidden" != this.sizer.node.style.visibility) {
      this.sizer.redraw();
    }
    event.consume();
  }
};
/**
 * @param {!Object} event
 * @return {?}
 */
mxOutline.prototype.getTranslateForEvent = function(event) {
  return new mxPoint(event.getX() - this.startX, event.getY() - this.startY);
};
/**
 * @param {?} editor
 * @param {!Event} e
 * @return {undefined}
 */
mxOutline.prototype.mouseUp = function(editor, e) {
  if (this.active) {
    var w = this.getTranslateForEvent(e);
    var x = w.x;
    w = w.y;
    if (0 < Math.abs(x) || 0 < Math.abs(w)) {
      if (this.zoom) {
        w = this.selectionBorder.bounds.width;
        var r = this.source.getView().scale;
        this.source.zoomTo(Math.max(this.minScale, r - x * r / w), false);
      } else {
        if (!(this.source.useScrollbarsForPanning && mxUtils.hasScrollbars(this.source.container))) {
          this.source.panGraph(0, 0);
          /** @type {number} */
          x = x / this.outline.getView().scale;
          /** @type {number} */
          w = w / this.outline.getView().scale;
          r = this.source.getView().translate;
          this.source.getView().setTranslate(r.x - x, r.y - w);
        }
      }
      this.update();
      e.consume();
    }
    /** @type {null} */
    this.index = null;
    /** @type {boolean} */
    this.active = false;
  }
};
/**
 * @return {undefined}
 */
mxOutline.prototype.destroy = function() {
  if (null != this.source) {
    this.source.removeListener(this.panHandler);
    this.source.removeListener(this.refreshHandler);
    this.source.getModel().removeListener(this.updateHandler);
    this.source.getView().removeListener(this.updateHandler);
    mxEvent.removeListener(this.source.container, "scroll", this.updateHandler);
    /** @type {null} */
    this.source = null;
  }
  if (null != this.outline) {
    this.outline.removeMouseListener(this);
    this.outline.destroy();
    /** @type {null} */
    this.outline = null;
  }
  if (null != this.selectionBorder) {
    this.selectionBorder.destroy();
    /** @type {null} */
    this.selectionBorder = null;
  }
  if (null != this.sizer) {
    this.sizer.destroy();
    /** @type {null} */
    this.sizer = null;
  }
};
/**
 * @param {string} data
 * @param {string} tag
 * @param {string} attrName
 * @param {!Object} value
 * @param {number} min
 * @param {string} max
 * @param {!Object} initialValue
 * @param {!Object} name
 * @param {!Object} key
 * @param {?} optModifiers
 * @return {undefined}
 */
function mxMultiplicity(data, tag, attrName, value, min, max, initialValue, name, key, optModifiers) {
  /** @type {string} */
  this.source = data;
  /** @type {string} */
  this.type = tag;
  /** @type {string} */
  this.attr = attrName;
  /** @type {!Object} */
  this.value = value;
  this.min = null != min ? min : 0;
  this.max = null != max ? max : "n";
  /** @type {!Object} */
  this.validNeighbors = initialValue;
  this.countError = mxResources.get(name) || name;
  this.typeError = mxResources.get(key) || key;
  this.validNeighborsAllowed = null != optModifiers ? optModifiers : true;
}
/** @type {null} */
mxMultiplicity.prototype.type = null;
/** @type {null} */
mxMultiplicity.prototype.attr = null;
/** @type {null} */
mxMultiplicity.prototype.value = null;
/** @type {null} */
mxMultiplicity.prototype.source = null;
/** @type {null} */
mxMultiplicity.prototype.min = null;
/** @type {null} */
mxMultiplicity.prototype.max = null;
/** @type {null} */
mxMultiplicity.prototype.validNeighbors = null;
/** @type {boolean} */
mxMultiplicity.prototype.validNeighborsAllowed = true;
/** @type {null} */
mxMultiplicity.prototype.countError = null;
/** @type {null} */
mxMultiplicity.prototype.typeError = null;
/**
 * @param {!Object} element
 * @param {!Object} t
 * @param {boolean} f
 * @param {boolean} s
 * @param {?} v
 * @param {?} n
 * @return {?}
 */
mxMultiplicity.prototype.check = function(element, t, f, s, v, n) {
  /** @type {string} */
  var coreCourseInvalidMessages = "";
  if (this.source && this.checkTerminal(element, f, t) || !this.source && this.checkTerminal(element, s, t)) {
    if (null != this.countError && (this.source && (0 == this.max || v >= this.max) || !this.source && (0 == this.max || n >= this.max))) {
      /** @type {string} */
      coreCourseInvalidMessages = coreCourseInvalidMessages + (this.countError + "\n");
    }
    if (null != this.validNeighbors && null != this.typeError && 0 < this.validNeighbors.length) {
      if (!this.checkNeighbors(element, t, f, s)) {
        /** @type {string} */
        coreCourseInvalidMessages = coreCourseInvalidMessages + (this.typeError + "\n");
      }
    }
  }
  return 0 < coreCourseInvalidMessages.length ? coreCourseInvalidMessages : null;
};
/**
 * @param {!Object} element
 * @param {!Object} file
 * @param {?} f
 * @param {?} o
 * @return {?}
 */
mxMultiplicity.prototype.checkNeighbors = function(element, file, f, o) {
  file = element.model.getValue(f);
  o = element.model.getValue(o);
  /** @type {boolean} */
  f = !this.validNeighborsAllowed;
  var spheres = this.validNeighbors;
  /** @type {number} */
  var iter_sph = 0;
  for (; iter_sph < spheres.length; iter_sph++) {
    if (this.source && this.checkType(element, o, spheres[iter_sph])) {
      f = this.validNeighborsAllowed;
      break;
    } else {
      if (!this.source && this.checkType(element, file, spheres[iter_sph])) {
        f = this.validNeighborsAllowed;
        break;
      }
    }
  }
  return f;
};
/**
 * @param {!Object} type
 * @param {string} item
 * @param {!Object} size
 * @return {?}
 */
mxMultiplicity.prototype.checkTerminal = function(type, item, size) {
  item = type.model.getValue(item);
  return this.checkType(type, item, this.type, this.attr, this.value);
};
/**
 * @param {!Object} val
 * @param {!Object} data
 * @param {undefined} value
 * @param {string} key
 * @param {?} ct
 * @return {?}
 */
mxMultiplicity.prototype.checkType = function(val, data, value, key, ct) {
  return null != data ? isNaN(data.nodeType) ? data == value : mxUtils.isNode(data, value, key, ct) : false;
};
/**
 * @param {!Object} vScale
 * @return {undefined}
 */
function mxLayoutManager(vScale) {
  this.undoHandler = mxUtils.bind(this, function(a, link) {
    if (this.isEnabled()) {
      this.beforeUndo(link.getProperty("edit"));
    }
  });
  this.moveHandler = mxUtils.bind(this, function(a, utils) {
    if (this.isEnabled()) {
      this.cellsMoved(utils.getProperty("cells"), utils.getProperty("event"));
    }
  });
  this.resizeHandler = mxUtils.bind(this, function(a, self) {
    if (this.isEnabled()) {
      this.cellsResized(self.getProperty("cells"), self.getProperty("bounds"), self.getProperty("previous"));
    }
  });
  this.setGraph(vScale);
}
mxLayoutManager.prototype = new mxEventSource;
/** @type {function(!Object): undefined} */
mxLayoutManager.prototype.constructor = mxLayoutManager;
/** @type {null} */
mxLayoutManager.prototype.graph = null;
/** @type {boolean} */
mxLayoutManager.prototype.bubbling = true;
/** @type {boolean} */
mxLayoutManager.prototype.enabled = true;
/** @type {null} */
mxLayoutManager.prototype.undoHandler = null;
/** @type {null} */
mxLayoutManager.prototype.moveHandler = null;
/** @type {null} */
mxLayoutManager.prototype.resizeHandler = null;
/**
 * @return {?}
 */
mxLayoutManager.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxLayoutManager.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxLayoutManager.prototype.isBubbling = function() {
  return this.bubbling;
};
/**
 * @param {!Object} a
 * @return {undefined}
 */
mxLayoutManager.prototype.setBubbling = function(a) {
  /** @type {!Object} */
  this.bubbling = a;
};
/**
 * @return {?}
 */
mxLayoutManager.prototype.getGraph = function() {
  return this.graph;
};
/**
 * @param {!Object} gf
 * @return {undefined}
 */
mxLayoutManager.prototype.setGraph = function(gf) {
  if (null != this.graph) {
    var undoMgr = this.graph.getModel();
    undoMgr.removeListener(this.undoHandler);
    this.graph.removeListener(this.moveHandler);
    this.graph.removeListener(this.resizeHandler);
  }
  /** @type {!Object} */
  this.graph = gf;
  if (null != this.graph) {
    undoMgr = this.graph.getModel();
    undoMgr.addListener(mxEvent.BEFORE_UNDO, this.undoHandler);
    this.graph.addListener(mxEvent.MOVE_CELLS, this.moveHandler);
    this.graph.addListener(mxEvent.RESIZE_CELLS, this.resizeHandler);
  }
};
/**
 * @param {!Object} content
 * @return {?}
 */
mxLayoutManager.prototype.hasLayout = function(content) {
  return this.getLayout(content, mxEvent.LAYOUT_CELLS);
};
/**
 * @param {!Object} i
 * @param {?} arr
 * @return {?}
 */
mxLayoutManager.prototype.getLayout = function(i, arr) {
  return null;
};
/**
 * @param {!Object} memberChangeInfo
 * @return {undefined}
 */
mxLayoutManager.prototype.beforeUndo = function(memberChangeInfo) {
  this.executeLayoutForCells(this.getCellsForChanges(memberChangeInfo.changes));
};
/**
 * @param {string} obj
 * @param {number} evt
 * @return {undefined}
 */
mxLayoutManager.prototype.cellsMoved = function(obj, evt) {
  if (null != obj && null != evt) {
    var pos = mxUtils.convertPoint(this.getGraph().container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
    var _util = this.getGraph().getModel();
    /** @type {number} */
    var i = 0;
    for (; i < obj.length; i++) {
      var layout = this.getLayout(_util.getParent(obj[i]), mxEvent.MOVE_CELLS);
      if (null != layout) {
        layout.moveCell(obj[i], pos.x, pos.y);
      }
    }
  }
};
/**
 * @param {!Object} props
 * @param {?} a
 * @param {string} obj
 * @return {undefined}
 */
mxLayoutManager.prototype.cellsResized = function(props, a, obj) {
  if (null != props && null != a) {
    var vm = this.getGraph().getModel();
    /** @type {number} */
    var i = 0;
    for (; i < props.length; i++) {
      var $ = this.getLayout(vm.getParent(props[i]), mxEvent.RESIZE_CELLS);
      if (null != $) {
        $.resizeCell(props[i], a[i], obj[i]);
      }
    }
  }
};
/**
 * @param {!NodeList} set
 * @return {?}
 */
mxLayoutManager.prototype.getCellsForChanges = function(set) {
  /** @type {!Array} */
  var collection = [];
  /** @type {number} */
  var i = 0;
  for (; i < set.length; i++) {
    var change = set[i];
    if (change instanceof mxRootChange) {
      return [];
    }
    /** @type {!Array<?>} */
    collection = collection.concat(this.getCellsForChange(change));
  }
  return collection;
};
/**
 * @param {!Object} change
 * @return {?}
 */
mxLayoutManager.prototype.getCellsForChange = function(change) {
  return change instanceof mxChildChange ? this.addCellsWithLayout(change.child, this.addCellsWithLayout(change.previous)) : change instanceof mxTerminalChange || change instanceof mxGeometryChange || change instanceof mxVisibleChange || change instanceof mxStyleChange ? this.addCellsWithLayout(change.cell) : [];
};
/**
 * @param {!Object} a
 * @param {string} low
 * @return {?}
 */
mxLayoutManager.prototype.addCellsWithLayout = function(a, low) {
  return this.addDescendantsWithLayout(a, this.addAncestorsWithLayout(a, low));
};
/**
 * @param {!Object} key
 * @param {string} min
 * @return {?}
 */
mxLayoutManager.prototype.addAncestorsWithLayout = function(key, min) {
  min = null != min ? min : [];
  if (null != key && (null != this.hasLayout(key) && min.push(key), this.isBubbling())) {
    var searchSource = this.getGraph().getModel();
    this.addAncestorsWithLayout(searchSource.getParent(key), min);
  }
  return min;
};
/**
 * @param {!Object} value
 * @param {string} min
 * @return {?}
 */
mxLayoutManager.prototype.addDescendantsWithLayout = function(value, min) {
  min = null != min ? min : [];
  if (null != value && this.hasLayout(value)) {
    var self = this.getGraph().getModel();
    /** @type {number} */
    var i = 0;
    for (; i < self.getChildCount(value); i++) {
      var command = self.getChildAt(value, i);
      if (this.hasLayout(command)) {
        min.push(command);
        this.addDescendantsWithLayout(command, min);
      }
    }
  }
  return min;
};
/**
 * @param {!Array} value
 * @return {undefined}
 */
mxLayoutManager.prototype.executeLayoutForCells = function(value) {
  value = mxUtils.sortCells(value, false);
  this.layoutCells(value, true);
  this.layoutCells(value.reverse(), false);
};
/**
 * @param {!Object} e
 * @param {boolean} start
 * @return {undefined}
 */
mxLayoutManager.prototype.layoutCells = function(e, start) {
  if (0 < e.length) {
    var that = this.getGraph().getModel();
    that.beginUpdate();
    try {
      /** @type {null} */
      var name = null;
      /** @type {number} */
      var i = 0;
      for (; i < e.length; i++) {
        if (e[i] != that.getRoot() && e[i] != name) {
          this.executeLayout(e[i], start);
          name = e[i];
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.LAYOUT_CELLS, "cells", e));
    } finally {
      that.endUpdate();
    }
  }
};
/**
 * @param {undefined} name
 * @param {boolean} status
 * @return {undefined}
 */
mxLayoutManager.prototype.executeLayout = function(name, status) {
  var layout = this.getLayout(name, status ? mxEvent.BEGIN_UPDATE : mxEvent.END_UPDATE);
  if (null != layout) {
    layout.execute(name);
  }
};
/**
 * @return {undefined}
 */
mxLayoutManager.prototype.destroy = function() {
  this.setGraph(null);
};
/**
 * @param {!Object} vScale
 * @param {number} hTrim
 * @param {?} vTrim
 * @param {?} queueUpdate
 * @return {undefined}
 */
function mxSwimlaneManager(vScale, hTrim, vTrim, queueUpdate) {
  this.horizontal = null != hTrim ? hTrim : true;
  this.addEnabled = null != vTrim ? vTrim : true;
  this.resizeEnabled = null != queueUpdate ? queueUpdate : true;
  this.addHandler = mxUtils.bind(this, function(a, utils) {
    if (this.isEnabled() && this.isAddEnabled()) {
      this.cellsAdded(utils.getProperty("cells"));
    }
  });
  this.resizeHandler = mxUtils.bind(this, function(a, utils) {
    if (this.isEnabled() && this.isResizeEnabled()) {
      this.cellsResized(utils.getProperty("cells"));
    }
  });
  this.setGraph(vScale);
}
mxSwimlaneManager.prototype = new mxEventSource;
/** @type {function(!Object, number, ?, ?): undefined} */
mxSwimlaneManager.prototype.constructor = mxSwimlaneManager;
/** @type {null} */
mxSwimlaneManager.prototype.graph = null;
/** @type {boolean} */
mxSwimlaneManager.prototype.enabled = true;
/** @type {boolean} */
mxSwimlaneManager.prototype.horizontal = true;
/** @type {boolean} */
mxSwimlaneManager.prototype.addEnabled = true;
/** @type {boolean} */
mxSwimlaneManager.prototype.resizeEnabled = true;
/** @type {null} */
mxSwimlaneManager.prototype.addHandler = null;
/** @type {null} */
mxSwimlaneManager.prototype.resizeHandler = null;
/**
 * @return {?}
 */
mxSwimlaneManager.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxSwimlaneManager.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxSwimlaneManager.prototype.isHorizontal = function() {
  return this.horizontal;
};
/**
 * @param {number} string
 * @return {undefined}
 */
mxSwimlaneManager.prototype.setHorizontal = function(string) {
  /** @type {number} */
  this.horizontal = string;
};
/**
 * @return {?}
 */
mxSwimlaneManager.prototype.isAddEnabled = function() {
  return this.addEnabled;
};
/**
 * @param {?} enabled
 * @return {undefined}
 */
mxSwimlaneManager.prototype.setAddEnabled = function(enabled) {
  this.addEnabled = enabled;
};
/**
 * @return {?}
 */
mxSwimlaneManager.prototype.isResizeEnabled = function() {
  return this.resizeEnabled;
};
/**
 * @param {?} enabled
 * @return {undefined}
 */
mxSwimlaneManager.prototype.setResizeEnabled = function(enabled) {
  this.resizeEnabled = enabled;
};
/**
 * @return {?}
 */
mxSwimlaneManager.prototype.getGraph = function() {
  return this.graph;
};
/**
 * @param {!Object} gf
 * @return {undefined}
 */
mxSwimlaneManager.prototype.setGraph = function(gf) {
  if (null != this.graph) {
    this.graph.removeListener(this.addHandler);
    this.graph.removeListener(this.resizeHandler);
  }
  /** @type {!Object} */
  this.graph = gf;
  if (null != this.graph) {
    this.graph.addListener(mxEvent.ADD_CELLS, this.addHandler);
    this.graph.addListener(mxEvent.CELLS_RESIZED, this.resizeHandler);
  }
};
/**
 * @param {!Object} fieldname
 * @return {?}
 */
mxSwimlaneManager.prototype.isSwimlaneIgnored = function(fieldname) {
  return !this.getGraph().isSwimlane(fieldname);
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxSwimlaneManager.prototype.isCellHorizontal = function(value) {
  return this.graph.isSwimlane(value) ? (value = this.graph.getCellStyle(value), 1 == mxUtils.getValue(value, mxConstants.STYLE_HORIZONTAL, 1)) : !this.isHorizontal();
};
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxSwimlaneManager.prototype.cellsAdded = function(obj) {
  if (null != obj) {
    var targetFragment = this.getGraph().getModel();
    targetFragment.beginUpdate();
    try {
      /** @type {number} */
      var i = 0;
      for (; i < obj.length; i++) {
        if (!this.isSwimlaneIgnored(obj[i])) {
          this.swimlaneAdded(obj[i]);
        }
      }
    } finally {
      targetFragment.endUpdate();
    }
  }
};
/**
 * @param {undefined} p
 * @return {undefined}
 */
mxSwimlaneManager.prototype.swimlaneAdded = function(p) {
  var node = this.getGraph().getModel();
  var n = node.getParent(p);
  var requestsToPerform = node.getChildCount(n);
  /** @type {null} */
  var $child = null;
  /** @type {number} */
  var i = 0;
  for (; i < requestsToPerform; i++) {
    var child = node.getChildAt(n, i);
    if (child != p && !this.isSwimlaneIgnored(child) && ($child = node.getGeometry(child), null != $child)) {
      break;
    }
  }
  if (null != $child) {
    node = null != n ? this.isCellHorizontal(n) : this.horizontal;
    this.resizeSwimlane(p, $child.width, $child.height, node);
  }
};
/**
 * @param {!Object} array
 * @return {undefined}
 */
mxSwimlaneManager.prototype.cellsResized = function(array) {
  if (null != array) {
    var me = this.getGraph().getModel();
    me.beginUpdate();
    try {
      /** @type {number} */
      var i = 0;
      for (; i < array.length; i++) {
        if (!this.isSwimlaneIgnored(array[i])) {
          var table = me.getGeometry(array[i]);
          if (null != table) {
            var bounds = new mxRectangle(0, 0, table.width, table.height);
            var f = array[i];
            var id = f;
            for (; null != id;) {
              f = id;
              id = me.getParent(id);
              var fBounds = this.graph.isSwimlane(id) ? this.graph.getStartSize(id) : new mxRectangle;
              bounds.width += fBounds.width;
              bounds.height += fBounds.height;
            }
            var PipeBinding = null != id ? this.isCellHorizontal(id) : this.horizontal;
            this.resizeSwimlane(f, bounds.width, bounds.height, PipeBinding);
          }
        }
      }
    } finally {
      me.endUpdate();
    }
  }
};
/**
 * @param {!Object} i
 * @param {number} width
 * @param {number} height
 * @param {number} k
 * @return {undefined}
 */
mxSwimlaneManager.prototype.resizeSwimlane = function(i, width, height, k) {
  var self = this.getGraph().getModel();
  self.beginUpdate();
  try {
    var n = this.isCellHorizontal(i);
    if (!this.isSwimlaneIgnored(i)) {
      var canvas = self.getGeometry(i);
      if (null != canvas && (k && canvas.height != height || !k && canvas.width != width)) {
        canvas = canvas.clone();
        if (k) {
          /** @type {number} */
          canvas.height = height;
        } else {
          /** @type {number} */
          canvas.width = width;
        }
        self.setGeometry(i, canvas);
      }
    }
    var overflowAdjust = this.graph.isSwimlane(i) ? this.graph.getStartSize(i) : new mxRectangle;
    /** @type {number} */
    width = width - overflowAdjust.width;
    /** @type {number} */
    height = height - overflowAdjust.height;
    var l = self.getChildCount(i);
    /** @type {number} */
    k = 0;
    for (; k < l; k++) {
      var square = self.getChildAt(i, k);
      this.resizeSwimlane(square, width, height, n);
    }
  } finally {
    self.endUpdate();
  }
};
/**
 * @return {undefined}
 */
mxSwimlaneManager.prototype.destroy = function() {
  this.setGraph(null);
};
/**
 * @param {!Object} self
 * @param {!Object} path
 * @param {!Object} q
 * @param {string} a
 * @param {?} slice
 * @return {undefined}
 */
function mxTemporaryCellStates(self, path, q, a, slice) {
  path = null != path ? path : 1;
  /** @type {!Object} */
  this.view = self;
  /** @type {function(string, boolean): ?} */
  this.oldValidateCellState = self.validateCellState;
  this.oldBounds = self.getGraphBounds();
  this.oldStates = self.getStates();
  this.oldScale = self.getScale();
  /** @type {function(!Object): undefined} */
  this.oldDoRedrawShape = self.graph.cellRenderer.doRedrawShape;
  var NKScripting = this;
  if (null != slice) {
    /**
     * @param {!Object} item
     * @return {undefined}
     */
    self.graph.cellRenderer.doRedrawShape = function(item) {
      /** @type {function(!Object): undefined} */
      var paint = item.shape.paint;
      /**
       * @param {!Object} node
       * @return {undefined}
       */
      item.shape.paint = function(node) {
        var a = slice(item);
        if (null != a) {
          node.setLink(a);
        }
        paint.apply(this, arguments);
        if (null != a) {
          node.setLink(null);
        }
      };
      NKScripting.oldDoRedrawShape.apply(self.graph.cellRenderer, arguments);
      /** @type {function(!Object): undefined} */
      item.shape.paint = paint;
    };
  }
  /**
   * @param {string} b
   * @param {boolean} excludeFalseConflicts
   * @return {?}
   */
  self.validateCellState = function(b, excludeFalseConflicts) {
    return null == b || null == a || a(b) ? NKScripting.oldValidateCellState.apply(self, arguments) : null;
  };
  self.setStates(new mxDictionary);
  self.setScale(path);
  if (null != q) {
    self.resetValidationState();
    /** @type {null} */
    path = null;
    /** @type {number} */
    var i = 0;
    for (; i < q.length; i++) {
      var k = self.getBoundingBox(self.validateCellState(self.validateCell(q[i])));
      if (null == path) {
        path = k;
      } else {
        path.add(k);
      }
    }
    self.setGraphBounds(path || new mxRectangle);
  }
}
/** @type {null} */
mxTemporaryCellStates.prototype.view = null;
/** @type {null} */
mxTemporaryCellStates.prototype.oldStates = null;
/** @type {null} */
mxTemporaryCellStates.prototype.oldBounds = null;
/** @type {null} */
mxTemporaryCellStates.prototype.oldScale = null;
/**
 * @return {undefined}
 */
mxTemporaryCellStates.prototype.destroy = function() {
  this.view.setScale(this.oldScale);
  this.view.setStates(this.oldStates);
  this.view.setGraphBounds(this.oldBounds);
  this.view.validateCellState = this.oldValidateCellState;
  this.view.graph.cellRenderer.doRedrawShape = this.oldDoRedrawShape;
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxCellStatePreview(targetGraph) {
  this.deltas = new mxDictionary;
  /** @type {!Object} */
  this.graph = targetGraph;
}
/** @type {null} */
mxCellStatePreview.prototype.graph = null;
/** @type {null} */
mxCellStatePreview.prototype.deltas = null;
/** @type {number} */
mxCellStatePreview.prototype.count = 0;
/**
 * @return {?}
 */
mxCellStatePreview.prototype.isEmpty = function() {
  return 0 == this.count;
};
/**
 * @param {!Object} state
 * @param {number} x
 * @param {number} y
 * @param {?} duration
 * @param {?} ease
 * @return {?}
 */
mxCellStatePreview.prototype.moveState = function(state, x, y, duration, ease) {
  duration = null != duration ? duration : true;
  ease = null != ease ? ease : true;
  var data = this.deltas.get(state.cell);
  if (null == data) {
    data = {
      point : new mxPoint(x, y),
      state : state
    };
    this.deltas.put(state.cell, data);
    this.count++;
  } else {
    if (duration) {
      data.point.x += x;
      data.point.y += y;
    } else {
      /** @type {number} */
      data.point.x = x;
      /** @type {number} */
      data.point.y = y;
    }
  }
  if (ease) {
    this.addEdges(state);
  }
  return data.point;
};
/**
 * @param {?} v
 * @return {undefined}
 */
mxCellStatePreview.prototype.show = function(v) {
  this.deltas.visit(mxUtils.bind(this, function(a, c) {
    this.translateState(c.state, c.point.x, c.point.y);
  }));
  this.deltas.visit(mxUtils.bind(this, function(b, c) {
    this.revalidateState(c.state, c.point.x, c.point.y, v);
  }));
};
/**
 * @param {!Object} me
 * @param {?} dx
 * @param {?} dy
 * @return {undefined}
 */
mxCellStatePreview.prototype.translateState = function(me, dx, dy) {
  if (null != me) {
    var layer = this.graph.getModel();
    if (layer.isVertex(me.cell)) {
      me.view.updateCellState(me);
      var dest = layer.getGeometry(me.cell);
      if (!(0 == dx && 0 == dy || null == dest || dest.relative && null == this.deltas.get(me.cell))) {
        me.x += dx;
        me.y += dy;
      }
    }
    dest = layer.getChildCount(me.cell);
    /** @type {number} */
    var i = 0;
    for (; i < dest; i++) {
      this.translateState(me.view.getState(layer.getChildAt(me.cell, i)), dx, dy);
    }
  }
};
/**
 * @param {!Object} node
 * @param {?} fx
 * @param {?} fy
 * @param {?} fn
 * @return {undefined}
 */
mxCellStatePreview.prototype.revalidateState = function(node, fx, fy, fn) {
  if (null != node) {
    var self = this.graph.getModel();
    if (self.isEdge(node.cell)) {
      node.view.updateCellState(node);
    }
    var dest = this.graph.getCellGeometry(node.cell);
    var i = node.view.getState(self.getParent(node.cell));
    if (!(0 == fx && 0 == fy || null == dest || !dest.relative || !self.isVertex(node.cell) || null != i && !self.isVertex(i.cell) && null == this.deltas.get(node.cell))) {
      node.x += fx;
      node.y += fy;
    }
    this.graph.cellRenderer.redraw(node);
    if (null != fn) {
      fn(node);
    }
    dest = self.getChildCount(node.cell);
    /** @type {number} */
    i = 0;
    for (; i < dest; i++) {
      this.revalidateState(this.graph.view.getState(self.getChildAt(node.cell, i)), fx, fy, fn);
    }
  }
};
/**
 * @param {!Object} state
 * @return {undefined}
 */
mxCellStatePreview.prototype.addEdges = function(state) {
  var $ = this.graph.getModel();
  var prevVal = $.getEdgeCount(state.cell);
  /** @type {number} */
  var val = 0;
  for (; val < prevVal; val++) {
    var PRE_DIGEST_STATE = state.view.getState($.getEdgeAt(state.cell, val));
    if (null != PRE_DIGEST_STATE) {
      this.moveState(PRE_DIGEST_STATE, 0, 0);
    }
  }
};
/**
 * @param {!Object} p
 * @param {?} ytox
 * @param {string} ytoy
 * @param {number} dx
 * @param {number} dy
 * @return {undefined}
 */
function mxConnectionConstraint(p, ytox, ytoy, dx, dy) {
  /** @type {!Object} */
  this.point = p;
  this.perimeter = null != ytox ? ytox : true;
  /** @type {string} */
  this.name = ytoy;
  this.dx = dx ? dx : 0;
  this.dy = dy ? dy : 0;
}
/** @type {null} */
mxConnectionConstraint.prototype.point = null;
/** @type {null} */
mxConnectionConstraint.prototype.perimeter = null;
/** @type {null} */
mxConnectionConstraint.prototype.name = null;
/** @type {null} */
mxConnectionConstraint.prototype.dx = null;
/** @type {null} */
mxConnectionConstraint.prototype.dy = null;
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxGraphHandler(targetGraph) {
  /** @type {!Object} */
  this.graph = targetGraph;
  this.graph.addMouseListener(this);
  this.panHandler = mxUtils.bind(this, function() {
    if (!this.suspended) {
      this.updatePreview();
      this.updateHint();
    }
  });
  this.graph.addListener(mxEvent.PAN, this.panHandler);
  this.escapeHandler = mxUtils.bind(this, function(a, canCreateDiscussions) {
    this.reset();
  });
  this.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
  this.refreshHandler = mxUtils.bind(this, function(a, canCreateDiscussions) {
    if (this.refreshThread) {
      window.clearTimeout(this.refreshThread);
    }
    this.refreshThread = window.setTimeout(mxUtils.bind(this, function() {
      /** @type {null} */
      this.refreshThread = null;
      if (null != this.first && !this.suspended) {
        var a = this.currentDx;
        var b = this.currentDy;
        /** @type {number} */
        this.currentDy = this.currentDx = 0;
        this.updatePreview();
        this.bounds = this.graph.getView().getBounds(this.cells);
        this.pBounds = this.getPreviewBounds(this.cells);
        if (null != this.pBounds || this.livePreviewUsed) {
          this.currentDx = a;
          this.currentDy = b;
          this.updatePreview();
          this.updateHint();
          if (this.livePreviewUsed) {
            this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), false, true);
            this.updatePreview();
          }
        } else {
          this.reset();
        }
      }
    }), 0);
  });
  this.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler);
  this.graph.addListener(mxEvent.REFRESH, this.refreshHandler);
  this.keyHandler = mxUtils.bind(this, function(url) {
    if (!(null == this.graph.container || "hidden" == this.graph.container.style.visibility || null == this.first || this.suspended)) {
      url = this.graph.isCloneEvent(url) && this.graph.isCellsCloneable() && this.isCloneEnabled();
      if (url != this.cloning) {
        this.cloning = url;
        this.checkPreview();
        this.updatePreview();
      }
    }
  });
  mxEvent.addListener(document, "keydown", this.keyHandler);
  mxEvent.addListener(document, "keyup", this.keyHandler);
}
/** @type {null} */
mxGraphHandler.prototype.graph = null;
/** @type {number} */
mxGraphHandler.prototype.maxCells = mxClient.IS_IE ? 20 : 50;
/** @type {boolean} */
mxGraphHandler.prototype.enabled = true;
/** @type {boolean} */
mxGraphHandler.prototype.highlightEnabled = true;
/** @type {boolean} */
mxGraphHandler.prototype.cloneEnabled = true;
/** @type {boolean} */
mxGraphHandler.prototype.moveEnabled = true;
/** @type {boolean} */
mxGraphHandler.prototype.guidesEnabled = false;
/** @type {boolean} */
mxGraphHandler.prototype.handlesVisible = true;
/** @type {null} */
mxGraphHandler.prototype.guide = null;
/** @type {null} */
mxGraphHandler.prototype.currentDx = null;
/** @type {null} */
mxGraphHandler.prototype.currentDy = null;
/** @type {boolean} */
mxGraphHandler.prototype.updateCursor = true;
/** @type {boolean} */
mxGraphHandler.prototype.selectEnabled = true;
/** @type {boolean} */
mxGraphHandler.prototype.removeCellsFromParent = true;
/** @type {boolean} */
mxGraphHandler.prototype.removeEmptyParents = false;
/** @type {boolean} */
mxGraphHandler.prototype.connectOnDrop = false;
/** @type {boolean} */
mxGraphHandler.prototype.scrollOnMove = true;
/** @type {number} */
mxGraphHandler.prototype.minimumSize = 6;
/** @type {string} */
mxGraphHandler.prototype.previewColor = "black";
/** @type {boolean} */
mxGraphHandler.prototype.htmlPreview = false;
/** @type {null} */
mxGraphHandler.prototype.shape = null;
/** @type {boolean} */
mxGraphHandler.prototype.scaleGrid = false;
/** @type {boolean} */
mxGraphHandler.prototype.rotationEnabled = true;
/** @type {number} */
mxGraphHandler.prototype.maxLivePreview = 0;
/** @type {boolean} */
mxGraphHandler.prototype.allowLivePreview = mxClient.IS_SVG;
/**
 * @return {?}
 */
mxGraphHandler.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxGraphHandler.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxGraphHandler.prototype.isCloneEnabled = function() {
  return this.cloneEnabled;
};
/**
 * @param {?} a
 * @return {undefined}
 */
mxGraphHandler.prototype.setCloneEnabled = function(a) {
  this.cloneEnabled = a;
};
/**
 * @return {?}
 */
mxGraphHandler.prototype.isMoveEnabled = function() {
  return this.moveEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraphHandler.prototype.setMoveEnabled = function(a) {
  /** @type {boolean} */
  this.moveEnabled = a;
};
/**
 * @return {?}
 */
mxGraphHandler.prototype.isSelectEnabled = function() {
  return this.selectEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxGraphHandler.prototype.setSelectEnabled = function(a) {
  /** @type {boolean} */
  this.selectEnabled = a;
};
/**
 * @return {?}
 */
mxGraphHandler.prototype.isRemoveCellsFromParent = function() {
  return this.removeCellsFromParent;
};
/**
 * @param {!Object} a
 * @return {undefined}
 */
mxGraphHandler.prototype.setRemoveCellsFromParent = function(a) {
  /** @type {!Object} */
  this.removeCellsFromParent = a;
};
/**
 * @param {?} cell
 * @param {string} target
 * @param {!Object} panel
 * @return {?}
 */
mxGraphHandler.prototype.isPropagateSelectionCell = function(cell, target, panel) {
  var parent = this.graph.model.getParent(cell);
  return target ? (target = this.graph.model.isEdge(cell) ? null : this.graph.getCellGeometry(cell), !this.graph.isSiblingSelected(cell) && (null != target && target.relative || !this.graph.isSwimlane(parent))) : (!this.graph.isToggleEvent(panel.getEvent()) || !this.graph.isSiblingSelected(cell) && !this.graph.isCellSelected(cell) && !this.graph.isSwimlane(parent) || this.graph.isCellSelected(parent)) && (this.graph.isToggleEvent(panel.getEvent()) || !this.graph.isCellSelected(parent));
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxGraphHandler.prototype.getInitialCellForEvent = function(me) {
  var e = me.getState();
  if (!(this.graph.isToggleEvent(me.getEvent()) && mxEvent.isAltDown(me.getEvent()) || null == e || this.graph.isCellSelected(e.cell))) {
    var model = this.graph.model;
    var tmp = this.graph.view.getState(model.getParent(e.cell));
    for (; null != tmp && !this.graph.isCellSelected(tmp.cell) && (model.isVertex(tmp.cell) || model.isEdge(tmp.cell)) && this.isPropagateSelectionCell(e.cell, true, me);) {
      e = tmp;
      tmp = this.graph.view.getState(this.graph.getModel().getParent(e.cell));
    }
  }
  return null != e ? e.cell : null;
};
/**
 * @param {!Object} name
 * @param {!Object} menu
 * @return {?}
 */
mxGraphHandler.prototype.isDelayedSelection = function(name, menu) {
  if (!this.graph.isToggleEvent(menu.getEvent()) || !mxEvent.isAltDown(menu.getEvent())) {
    for (; null != name;) {
      if (this.graph.selectionCellsHandler.isHandled(name)) {
        return this.graph.cellEditor.getEditingCell() != name;
      }
      name = this.graph.model.getParent(name);
    }
  }
  return this.graph.isToggleEvent(menu.getEvent()) && !mxEvent.isAltDown(menu.getEvent());
};
/**
 * @param {!Event} obj
 * @return {undefined}
 */
mxGraphHandler.prototype.selectDelayed = function(obj) {
  if (!this.graph.popupMenuHandler.isPopupTrigger(obj)) {
    var cell = obj.getCell();
    if (null == cell) {
      cell = this.cell;
    }
    this.selectCellForEvent(cell, obj);
  }
};
/**
 * @param {!Array} name
 * @param {!Object} t
 * @return {?}
 */
mxGraphHandler.prototype.selectCellForEvent = function(name, t) {
  var model = this.graph.view.getState(name);
  if (null != model) {
    if (!(t.isSource(model.control) || this.graph.isToggleEvent(t.getEvent()) && mxEvent.isAltDown(t.getEvent()))) {
      model = this.graph.getModel();
      var element = model.getParent(name);
      for (; null != this.graph.view.getState(element) && (model.isVertex(element) || model.isEdge(element)) && this.isPropagateSelectionCell(name, false, t);) {
        name = element;
        element = model.getParent(name);
      }
    }
    this.graph.selectCellForEvent(name, t.getEvent());
  }
  return name;
};
/**
 * @param {number} state
 * @param {!Event} from
 * @return {undefined}
 */
mxGraphHandler.prototype.consumeMouseEvent = function(state, from) {
  from.consume();
};
/**
 * @param {!Object} e
 * @param {!Object} me
 * @return {undefined}
 */
mxGraphHandler.prototype.mouseDown = function(e, me) {
  if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && null != me.getState() && !mxEvent.isMultiTouchEvent(me.getEvent())) {
    var cell = this.getInitialCellForEvent(me);
    this.delayedSelection = this.isDelayedSelection(cell, me);
    /** @type {null} */
    this.cell = null;
    if (this.isSelectEnabled() && !this.delayedSelection) {
      this.graph.selectCellForEvent(cell, me.getEvent());
    }
    if (this.isMoveEnabled()) {
      var model = this.graph.model;
      var d = model.getGeometry(cell);
      if (this.graph.isCellMovable(cell) && (!model.isEdge(cell) || 1 < this.graph.getSelectionCount() || null != d.points && 0 < d.points.length || null == model.getTerminal(cell, true) || null == model.getTerminal(cell, false) || this.graph.allowDanglingEdges || this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable())) {
        this.start(cell, me.getX(), me.getY());
      } else {
        if (this.delayedSelection) {
          this.cell = cell;
        }
      }
      /** @type {boolean} */
      this.cellWasClicked = true;
      this.consumeMouseEvent(mxEvent.MOUSE_DOWN, me);
    }
  }
};
/**
 * @return {?}
 */
mxGraphHandler.prototype.getGuideStates = function() {
  var a = this.graph.getDefaultParent();
  var model = this.graph.getModel();
  var handleMin = mxUtils.bind(this, function(element) {
    return null != this.graph.view.getState(element) && model.isVertex(element) && null != model.getGeometry(element) && !model.getGeometry(element).relative;
  });
  return this.graph.view.getCellStates(model.filterDescendants(handleMin, a));
};
/**
 * @param {!Object} cell
 * @return {?}
 */
mxGraphHandler.prototype.getCells = function(cell) {
  return !this.delayedSelection && this.graph.isCellMovable(cell) ? [cell] : this.graph.getMovableCells(this.graph.getSelectionCells());
};
/**
 * @param {!Object} el
 * @return {?}
 */
mxGraphHandler.prototype.getPreviewBounds = function(el) {
  el = this.getBoundingBox(el);
  if (null != el) {
    /** @type {number} */
    el.width = Math.max(0, el.width - 1);
    /** @type {number} */
    el.height = Math.max(0, el.height - 1);
    if (el.width < this.minimumSize) {
      el.x -= (this.minimumSize - el.width) / 2;
      el.width = this.minimumSize;
    } else {
      /** @type {number} */
      el.x = Math.round(el.x);
      /** @type {number} */
      el.width = Math.ceil(el.width);
    }
    if (el.height < this.minimumSize) {
      el.y -= (this.minimumSize - el.height) / 2;
      el.height = this.minimumSize;
    } else {
      /** @type {number} */
      el.y = Math.round(el.y);
      /** @type {number} */
      el.height = Math.ceil(el.height);
    }
  }
  return el;
};
/**
 * @param {!Object} o
 * @return {?}
 */
mxGraphHandler.prototype.getBoundingBox = function(o) {
  /** @type {null} */
  var result = null;
  if (null != o && 0 < o.length) {
    var utils = this.graph.getModel();
    /** @type {number} */
    var i = 0;
    for (; i < o.length; i++) {
      if (utils.isVertex(o[i]) || utils.isEdge(o[i])) {
        var node = this.graph.view.getState(o[i]);
        if (null != node) {
          var el = node;
          if (utils.isVertex(o[i]) && null != node.shape && null != node.shape.boundingBox) {
            el = node.shape.boundingBox;
          }
          if (null == result) {
            result = mxRectangle.fromRectangle(el);
          } else {
            result.add(el);
          }
        }
      }
    }
  }
  return result;
};
/**
 * @param {!Object} options
 * @return {?}
 */
mxGraphHandler.prototype.createPreviewShape = function(options) {
  options = new mxRectangleShape(options, null, this.previewColor);
  /** @type {boolean} */
  options.isDashed = true;
  if (this.htmlPreview) {
    options.dialect = mxConstants.DIALECT_STRICTHTML;
    options.init(this.graph.container);
  } else {
    options.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
    options.init(this.graph.getView().getOverlayPane());
    /** @type {boolean} */
    options.pointerEvents = false;
    if (mxClient.IS_IOS) {
      /**
       * @return {?}
       */
      options.getSvgScreenOffset = function() {
        return 0;
      };
    }
  }
  return options;
};
/**
 * @param {!Object} el
 * @param {number} i
 * @param {?} id
 * @param {number} finished
 * @return {undefined}
 */
mxGraphHandler.prototype.start = function(el, i, id, finished) {
  /** @type {!Object} */
  this.cell = el;
  this.first = mxUtils.convertPoint(this.graph.container, i, id);
  this.cells = null != finished ? finished : this.getCells(this.cell);
  this.bounds = this.graph.getView().getBounds(this.cells);
  this.pBounds = this.getPreviewBounds(this.cells);
  this.allCells = new mxDictionary;
  /** @type {boolean} */
  this.cloning = false;
  /** @type {number} */
  i = this.cellCount = 0;
  for (; i < this.cells.length; i++) {
    this.cellCount += this.addStates(this.cells[i], this.allCells);
  }
  if (this.guidesEnabled) {
    this.guide = new mxGuide(this.graph, this.getGuideStates());
    var parent = this.graph.model.getParent(el);
    /** @type {boolean} */
    var f = 2 > this.graph.model.getChildCount(parent);
    var g = new mxDictionary;
    el = this.graph.getOpposites(this.graph.getEdges(this.cell), this.cell);
    /** @type {number} */
    i = 0;
    for (; i < el.length; i++) {
      id = this.graph.view.getState(el[i]);
      if (!(null == id || g.get(id))) {
        g.put(id, true);
      }
    }
    this.guide.isStateIgnored = mxUtils.bind(this, function(item) {
      var b = this.graph.model.getParent(item.cell);
      return null != item.cell && (!this.cloning && this.isCellMoving(item.cell) || item.cell != (this.target || parent) && !f && !g.get(item) && (null == this.target || 2 <= this.graph.model.getChildCount(this.target)) && b != (this.target || parent));
    });
  }
};
/**
 * @param {undefined} index
 * @param {!Object} state
 * @return {?}
 */
mxGraphHandler.prototype.addStates = function(index, state) {
  var c = this.graph.view.getState(index);
  /** @type {number} */
  var code = 0;
  if (null != c && null == state.get(index)) {
    state.put(index, c);
    code++;
    c = this.graph.model.getChildCount(index);
    /** @type {number} */
    var i = 0;
    for (; i < c; i++) {
      code = code + this.addStates(this.graph.model.getChildAt(index, i), state);
    }
  }
  return code;
};
/**
 * @param {!Object} a
 * @return {?}
 */
mxGraphHandler.prototype.isCellMoving = function(a) {
  return null != this.allCells.get(a);
};
/**
 * @param {!Object} menu
 * @return {?}
 */
mxGraphHandler.prototype.useGuidesForEvent = function(menu) {
  return null != this.guide ? this.guide.isEnabledForEvent(menu.getEvent()) && !this.graph.isConstrainedEvent(menu.getEvent()) : true;
};
/**
 * @param {number} pos
 * @return {?}
 */
mxGraphHandler.prototype.snap = function(pos) {
  var scale = this.scaleGrid ? this.graph.view.scale : 1;
  /** @type {number} */
  pos.x = this.graph.snap(pos.x / scale) * scale;
  /** @type {number} */
  pos.y = this.graph.snap(pos.y / scale) * scale;
  return pos;
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxGraphHandler.prototype.getDelta = function(e) {
  e = mxUtils.convertPoint(this.graph.container, e.getX(), e.getY());
  return new mxPoint(e.x - this.first.x - this.graph.panDx, e.y - this.first.y - this.graph.panDy);
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxGraphHandler.prototype.updateHint = function(data) {
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.removeHint = function() {
};
/**
 * @param {number} litresInCubicFeet
 * @return {?}
 */
mxGraphHandler.prototype.roundLength = function(litresInCubicFeet) {
  return Math.round(100 * litresInCubicFeet) / 100;
};
/**
 * @param {!Object} name
 * @param {!Object} editor
 * @return {?}
 */
mxGraphHandler.prototype.isValidDropTarget = function(name, editor) {
  return this.graph.model.getParent(this.cell) != name;
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.checkPreview = function() {
  if (this.livePreviewActive && this.cloning) {
    this.resetLivePreview();
    /** @type {boolean} */
    this.livePreviewActive = false;
  } else {
    if (this.maxLivePreview >= this.cellCount && !this.livePreviewActive && this.allowLivePreview) {
      if (!(this.cloning && this.livePreviewActive)) {
        /** @type {boolean} */
        this.livePreviewUsed = this.livePreviewActive = true;
      }
    } else {
      if (!(this.livePreviewUsed || null != this.shape)) {
        this.shape = this.createPreviewShape(this.bounds);
      }
    }
  }
};
/**
 * @param {?} e
 * @param {!Object} me
 * @return {undefined}
 */
mxGraphHandler.prototype.mouseMove = function(e, me) {
  var self = this.graph;
  if (me.isConsumed() || !self.isMouseDown || null == this.cell || null == this.first || null == this.bounds || this.suspended) {
    if (!(!this.isMoveEnabled() && !this.isCloneEnabled() || !this.updateCursor || me.isConsumed() || null == me.getState() && null == me.sourceState || self.isMouseDown)) {
      value = self.getCursorForMouseEvent(me);
      if (null == value && self.isEnabled() && self.isCellMovable(me.getCell())) {
        value = self.getModel().isEdge(me.getCell()) ? mxConstants.CURSOR_MOVABLE_EDGE : mxConstants.CURSOR_MOVABLE_VERTEX;
      }
      if (null != value && null != me.sourceState) {
        me.sourceState.setCursor(value);
      }
    }
  } else {
    if (mxEvent.isMultiTouchEvent(me.getEvent())) {
      this.reset();
    } else {
      var value = this.getDelta(me);
      var callback = self.tolerance;
      if (null != this.shape || this.livePreviewActive || Math.abs(value.x) > callback || Math.abs(value.y) > callback) {
        if (null == this.highlight) {
          this.highlight = new mxCellHighlight(this.graph, mxConstants.DROP_TARGET_COLOR, 3);
        }
        callback = self.isCloneEvent(me.getEvent()) && self.isCellsCloneable() && this.isCloneEnabled();
        var width = self.isGridEnabledEvent(me.getEvent());
        var el = me.getCell();
        /** @type {boolean} */
        var k = true;
        /** @type {null} */
        var target = null;
        this.cloning = callback;
        if (self.isDropEnabled() && this.highlightEnabled) {
          target = self.getDropTarget(this.cells, me.getEvent(), el, callback);
        }
        var state = self.getView().getState(target);
        /** @type {boolean} */
        var n = false;
        if (null != state && (callback || this.isValidDropTarget(target, me))) {
          if (this.target != target) {
            this.target = target;
            this.setHighlightColor(mxConstants.DROP_TARGET_COLOR);
          }
          /** @type {boolean} */
          n = true;
        } else {
          /** @type {null} */
          this.target = null;
          if (this.connectOnDrop && null != el && 1 == this.cells.length && self.getModel().isVertex(el) && self.isCellConnectable(el)) {
            state = self.getView().getState(el);
            if (null != state) {
              el = null == self.getEdgeValidationError(null, this.cell, el) ? mxConstants.VALID_COLOR : mxConstants.INVALID_CONNECT_TARGET_COLOR;
              this.setHighlightColor(el);
              /** @type {boolean} */
              n = true;
            }
          }
        }
        if (null != state && n) {
          this.highlight.highlight(state);
        } else {
          this.highlight.hide();
        }
        if (null != this.guide && this.useGuidesForEvent(me)) {
          value = this.guide.move(this.bounds, value, width, callback);
          /** @type {boolean} */
          k = false;
        } else {
          value = this.graph.snapDelta(value, this.bounds, !width, false, false);
        }
        if (null != this.guide && k) {
          this.guide.hide();
        }
        if (self.isConstrainedEvent(me.getEvent())) {
          if (Math.abs(value.x) > Math.abs(value.y)) {
            /** @type {number} */
            value.y = 0;
          } else {
            /** @type {number} */
            value.x = 0;
          }
        }
        this.checkPreview();
        if (this.currentDx != value.x || this.currentDy != value.y) {
          this.currentDx = value.x;
          this.currentDy = value.y;
          this.updatePreview();
        }
      }
      this.updateHint(me);
      this.consumeMouseEvent(mxEvent.MOUSE_MOVE, me);
      mxEvent.consume(me.getEvent());
    }
  }
};
/**
 * @param {boolean} size
 * @return {undefined}
 */
mxGraphHandler.prototype.updatePreview = function(size) {
  if (this.livePreviewUsed && !size) {
    if (null != this.cells) {
      this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), false);
      this.updateLivePreview(this.currentDx, this.currentDy);
    }
  } else {
    this.updatePreviewShape();
  }
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.updatePreviewShape = function() {
  if (null != this.shape && null != this.pBounds) {
    this.shape.bounds = new mxRectangle(Math.round(this.pBounds.x + this.currentDx), Math.round(this.pBounds.y + this.currentDy), this.pBounds.width, this.pBounds.height);
    this.shape.redraw();
  }
};
/**
 * @param {number} size
 * @param {number} offset
 * @return {undefined}
 */
mxGraphHandler.prototype.updateLivePreview = function(size, offset) {
  if (!this.suspended) {
    /** @type {!Array} */
    var triangles = [];
    if (null != this.allCells) {
      this.allCells.visit(mxUtils.bind(this, function(canCreateDiscussions, self) {
        var n = this.graph.view.getState(self.cell);
        if (n != self) {
          self.destroy();
          if (null != n) {
            this.allCells.put(self.cell, n);
          } else {
            this.allCells.remove(self.cell);
          }
          self = n;
        }
        if (null != self && (n = self.clone(), triangles.push([self, n]), null != self.shape && (null == self.shape.originalPointerEvents && (self.shape.originalPointerEvents = self.shape.pointerEvents), self.shape.pointerEvents = false, null != self.text && (null == self.text.originalPointerEvents && (self.text.originalPointerEvents = self.text.pointerEvents), self.text.pointerEvents = false)), this.graph.model.isVertex(self.cell))) {
          if (self.x += size, self.y += offset, this.cloning) {
            if (null != self.text) {
              self.text.updateBoundingBox();
              if (null != self.text.boundingBox) {
                self.text.boundingBox.x += size;
                self.text.boundingBox.y += offset;
              }
              if (null != self.text.unrotatedBoundingBox) {
                self.text.unrotatedBoundingBox.x += size;
                self.text.unrotatedBoundingBox.y += offset;
              }
            }
          } else {
            self.view.graph.cellRenderer.redraw(self, true);
            self.view.invalidate(self.cell);
            /** @type {boolean} */
            self.invalid = false;
            if (null != self.control && null != self.control.node) {
              /** @type {string} */
              self.control.node.style.visibility = "hidden";
            }
          }
        }
      }));
    }
    if (0 == triangles.length) {
      this.reset();
    } else {
      var scale = this.graph.view.scale;
      /** @type {number} */
      var i = 0;
      for (; i < triangles.length; i++) {
        var data = triangles[i][0];
        if (this.graph.model.isEdge(data.cell)) {
          var options = this.graph.getCellGeometry(data.cell);
          /** @type {!Array} */
          var points = [];
          if (null != options && null != options.points) {
            /** @type {number} */
            var pos = 0;
            for (; pos < options.points.length; pos++) {
              if (null != options.points[pos]) {
                points.push(new mxPoint(options.points[pos].x + size / scale, options.points[pos].y + offset / scale));
              }
            }
          }
          options = data.visibleSourceState;
          pos = data.visibleTargetState;
          var args = triangles[i][1].absolutePoints;
          if (null != options && this.isCellMoving(options.cell)) {
            data.view.updateFixedTerminalPoint(data, options, true, this.graph.getConnectionConstraint(data, options, true));
          } else {
            options = args[0];
            data.setAbsoluteTerminalPoint(new mxPoint(options.x + size, options.y + offset), true);
            /** @type {null} */
            options = null;
          }
          if (null != pos && this.isCellMoving(pos.cell)) {
            data.view.updateFixedTerminalPoint(data, pos, false, this.graph.getConnectionConstraint(data, pos, false));
          } else {
            pos = args[args.length - 1];
            data.setAbsoluteTerminalPoint(new mxPoint(pos.x + size, pos.y + offset), false);
            /** @type {null} */
            pos = null;
          }
          data.view.updatePoints(data, points, options, pos);
          data.view.updateFloatingTerminalPoints(data, options, pos);
          data.view.updateEdgeLabelOffset(data);
          /** @type {boolean} */
          data.invalid = false;
          if (!this.cloning) {
            data.view.graph.cellRenderer.redraw(data, true);
          }
        }
      }
      this.graph.view.validate();
      this.redrawHandles(triangles);
      this.resetPreviewStates(triangles);
    }
  }
};
/**
 * @param {!Array} polys
 * @return {undefined}
 */
mxGraphHandler.prototype.redrawHandles = function(polys) {
  /** @type {number} */
  var i = 0;
  for (; i < polys.length; i++) {
    var _donut_chart_file_type_attach = this.graph.selectionCellsHandler.getHandler(polys[i][0].cell);
    if (null != _donut_chart_file_type_attach) {
      _donut_chart_file_type_attach.redraw(true);
    }
  }
};
/**
 * @param {!Array} polys
 * @return {undefined}
 */
mxGraphHandler.prototype.resetPreviewStates = function(polys) {
  /** @type {number} */
  var i = 0;
  for (; i < polys.length; i++) {
    polys[i][0].setState(polys[i][1]);
  }
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.suspend = function() {
  if (!this.suspended) {
    if (this.livePreviewUsed) {
      this.updateLivePreview(0, 0);
    }
    if (null != this.shape) {
      /** @type {string} */
      this.shape.node.style.visibility = "hidden";
    }
    if (null != this.guide) {
      this.guide.setVisible(false);
    }
    /** @type {boolean} */
    this.suspended = true;
  }
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.resume = function() {
  if (this.suspended) {
    /** @type {null} */
    this.suspended = null;
    if (this.livePreviewUsed) {
      /** @type {boolean} */
      this.livePreviewActive = true;
    }
    if (null != this.shape) {
      /** @type {string} */
      this.shape.node.style.visibility = "visible";
    }
    if (null != this.guide) {
      this.guide.setVisible(true);
    }
  }
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.resetLivePreview = function() {
  if (null != this.allCells) {
    this.allCells.visit(mxUtils.bind(this, function(a, e) {
      if (null != e.shape && null != e.shape.originalPointerEvents) {
        e.shape.pointerEvents = e.shape.originalPointerEvents;
        /** @type {null} */
        e.shape.originalPointerEvents = null;
        /** @type {null} */
        e.shape.bounds = null;
        if (null != e.text) {
          e.text.pointerEvents = e.text.originalPointerEvents;
          /** @type {null} */
          e.text.originalPointerEvents = null;
        }
      }
      if (null != e.control && null != e.control.node && "hidden" == e.control.node.style.visibility) {
        /** @type {string} */
        e.control.node.style.visibility = "";
      }
      if (!this.cloning) {
        if (null != e.text) {
          e.text.updateBoundingBox();
        }
      }
      e.view.invalidate(e.cell);
    }));
    this.graph.view.validate();
  }
};
/**
 * @param {!NodeList} config
 * @param {boolean} i
 * @param {number} size
 * @return {undefined}
 */
mxGraphHandler.prototype.setHandlesVisibleForCells = function(config, i, size) {
  if (size || this.handlesVisible != i) {
    /** @type {boolean} */
    this.handlesVisible = i;
    /** @type {number} */
    size = 0;
    for (; size < config.length; size++) {
      var area = this.graph.selectionCellsHandler.getHandler(config[size]);
      if (null != area) {
        area.setHandlesVisible(i);
        if (i) {
          area.redraw();
        }
      }
    }
  }
};
/**
 * @param {string} color
 * @return {undefined}
 */
mxGraphHandler.prototype.setHighlightColor = function(color) {
  if (null != this.highlight) {
    this.highlight.setHighlightColor(color);
  }
};
/**
 * @param {?} e
 * @param {!Event} me
 * @return {undefined}
 */
mxGraphHandler.prototype.mouseUp = function(e, me) {
  if (!me.isConsumed()) {
    if (this.livePreviewUsed && this.resetLivePreview(), null == this.cell || null == this.first || null == this.shape && !this.livePreviewUsed || null == this.currentDx || null == this.currentDy) {
      if (this.isSelectEnabled() && this.delayedSelection && null != this.cell) {
        this.selectDelayed(me);
      }
    } else {
      var graph = this.graph;
      var e = me.getCell();
      if (this.connectOnDrop && null == this.target && null != e && graph.getModel().isVertex(e) && graph.isCellConnectable(e) && graph.isEdgeValid(null, this.cell, e)) {
        graph.connectionHandler.connect(this.cell, e, me.getEvent());
      } else {
        e = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();
        var s = graph.getView().scale;
        var x = this.roundLength(this.currentDx / s);
        s = this.roundLength(this.currentDy / s);
        var target = this.target;
        if (graph.isSplitEnabled() && graph.isSplitTarget(target, this.cells, me.getEvent())) {
          graph.splitEdge(target, this.cells, null, x, s, me.getGraphX(), me.getGraphY());
        } else {
          this.moveCells(this.cells, x, s, e, this.target, me.getEvent());
        }
      }
    }
  }
  if (this.cellWasClicked) {
    this.consumeMouseEvent(mxEvent.MOUSE_UP, me);
  }
  this.reset();
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.reset = function() {
  if (this.livePreviewUsed) {
    this.resetLivePreview();
    this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), true);
  }
  this.destroyShapes();
  this.removeHint();
  /** @type {boolean} */
  this.delayedSelection = false;
  /** @type {null} */
  this.livePreviewUsed = this.livePreviewActive = null;
  /** @type {boolean} */
  this.cellWasClicked = false;
  /** @type {null} */
  this.cellCount = this.currentDy = this.currentDx = this.suspended = null;
  /** @type {boolean} */
  this.cloning = false;
  /** @type {null} */
  this.cell = this.cells = this.first = this.target = this.guides = this.pBounds = this.allCells = null;
};
/**
 * @param {!Object} s
 * @param {?} name
 * @param {?} evt
 * @return {?}
 */
mxGraphHandler.prototype.shouldRemoveCellsFromParent = function(s, name, evt) {
  if (this.graph.getModel().isVertex(s) && (s = this.graph.getView().getState(s), null != s)) {
    evt = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
    var z = mxUtils.toRadians(mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION) || 0);
    if (0 != z) {
      /** @type {number} */
      name = Math.cos(-z);
      /** @type {number} */
      z = Math.sin(-z);
      var ct = new mxPoint(s.getCenterX(), s.getCenterY());
      evt = mxUtils.getRotatedPoint(evt, name, z, ct);
    }
    return !mxUtils.contains(s, evt.x, evt.y);
  }
  return false;
};
/**
 * @param {!Array} cells
 * @param {!Object} target
 * @param {number} name
 * @param {boolean} callback
 * @param {number} parent
 * @param {string} start
 * @return {undefined}
 */
mxGraphHandler.prototype.moveCells = function(cells, target, name, callback, parent, start) {
  if (callback) {
    cells = this.graph.getCloneableCells(cells);
  }
  var source = this.graph.getModel().getParent(this.cell);
  if (null == parent && this.isRemoveCellsFromParent() && this.shouldRemoveCellsFromParent(source, cells, start)) {
    parent = this.graph.getDefaultParent();
  }
  callback = callback && !this.graph.isCellLocked(parent || this.graph.getDefaultParent());
  this.graph.getModel().beginUpdate();
  try {
    /** @type {!Array} */
    source = [];
    if (!callback && null != parent && this.removeEmptyParents) {
      var range = new mxDictionary;
      /** @type {number} */
      var i = 0;
      for (; i < cells.length; i++) {
        range.put(cells[i], true);
      }
      /** @type {number} */
      i = 0;
      for (; i < cells.length; i++) {
        var m = this.graph.model.getParent(cells[i]);
        if (!(null == m || range.get(m))) {
          range.put(m, true);
          source.push(m);
        }
      }
    }
    cells = this.graph.moveCells(cells, target, name, callback, parent, start);
    /** @type {!Array} */
    target = [];
    /** @type {number} */
    i = 0;
    for (; i < source.length; i++) {
      if (this.shouldRemoveParent(source[i])) {
        target.push(source[i]);
      }
    }
    this.graph.removeCells(target, false);
  } finally {
    this.graph.getModel().endUpdate();
  }
  if (callback) {
    this.graph.setSelectionCells(cells);
  }
  if (this.isSelectEnabled() && this.scrollOnMove) {
    this.graph.scrollCellToVisible(cells[0]);
  }
};
/**
 * @param {!Object} d
 * @return {?}
 */
mxGraphHandler.prototype.shouldRemoveParent = function(d) {
  d = this.graph.view.getState(d);
  return null != d && (this.graph.model.isEdge(d.cell) || this.graph.model.isVertex(d.cell)) && this.graph.isCellDeletable(d.cell) && 0 == this.graph.model.getChildCount(d.cell) && this.graph.isTransparentState(d);
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.destroyShapes = function() {
  if (null != this.shape) {
    this.shape.destroy();
    /** @type {null} */
    this.shape = null;
  }
  if (null != this.guide) {
    this.guide.destroy();
    /** @type {null} */
    this.guide = null;
  }
  if (null != this.highlight) {
    this.highlight.destroy();
    /** @type {null} */
    this.highlight = null;
  }
};
/**
 * @return {undefined}
 */
mxGraphHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.panHandler);
  if (null != this.escapeHandler) {
    this.graph.removeListener(this.escapeHandler);
    /** @type {null} */
    this.escapeHandler = null;
  }
  if (null != this.refreshHandler) {
    this.graph.getModel().removeListener(this.refreshHandler);
    this.graph.removeListener(this.refreshHandler);
    /** @type {null} */
    this.refreshHandler = null;
  }
  mxEvent.removeListener(document, "keydown", this.keyHandler);
  mxEvent.removeListener(document, "keyup", this.keyHandler);
  this.destroyShapes();
  this.removeHint();
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxPanningHandler(targetGraph) {
  if (null != targetGraph) {
    /** @type {!Object} */
    this.graph = targetGraph;
    this.graph.addMouseListener(this);
    this.forcePanningHandler = mxUtils.bind(this, function(a, c) {
      var evtName = c.getProperty("eventName");
      var e = c.getProperty("event");
      if (evtName == mxEvent.MOUSE_DOWN && this.isForcePanningEvent(e)) {
        this.start(e);
        /** @type {boolean} */
        this.active = true;
        this.fireEvent(new mxEventObject(mxEvent.PAN_START, "event", e));
        e.consume();
      }
    });
    this.graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.forcePanningHandler);
    this.gestureHandler = mxUtils.bind(this, function(a, wm) {
      if (this.isPinchEnabled()) {
        var evt = wm.getProperty("event");
        if (mxEvent.isConsumed(evt) || "gesturestart" != evt.type) {
          if ("gestureend" == evt.type && null != this.initialScale) {
            /** @type {null} */
            this.initialScale = null;
          }
        } else {
          this.initialScale = this.graph.view.scale;
          if (!(this.active || null == this.mouseDownEvent)) {
            this.start(this.mouseDownEvent);
            /** @type {null} */
            this.mouseDownEvent = null;
          }
        }
        if (null != this.initialScale) {
          this.zoomGraph(evt);
        }
      }
    });
    this.graph.addListener(mxEvent.GESTURE, this.gestureHandler);
    this.mouseUpListener = mxUtils.bind(this, function() {
      if (this.active) {
        this.reset();
      }
    });
    mxEvent.addListener(document, "mouseup", this.mouseUpListener);
  }
}
mxPanningHandler.prototype = new mxEventSource;
/** @type {function(!Object): undefined} */
mxPanningHandler.prototype.constructor = mxPanningHandler;
/** @type {null} */
mxPanningHandler.prototype.graph = null;
/** @type {boolean} */
mxPanningHandler.prototype.useLeftButtonForPanning = false;
/** @type {boolean} */
mxPanningHandler.prototype.usePopupTrigger = true;
/** @type {boolean} */
mxPanningHandler.prototype.ignoreCell = false;
/** @type {boolean} */
mxPanningHandler.prototype.previewEnabled = true;
/** @type {boolean} */
mxPanningHandler.prototype.useGrid = false;
/** @type {boolean} */
mxPanningHandler.prototype.panningEnabled = true;
/** @type {boolean} */
mxPanningHandler.prototype.pinchEnabled = true;
/** @type {number} */
mxPanningHandler.prototype.maxScale = 8;
/** @type {number} */
mxPanningHandler.prototype.minScale = .01;
/** @type {null} */
mxPanningHandler.prototype.dx = null;
/** @type {null} */
mxPanningHandler.prototype.dy = null;
/** @type {number} */
mxPanningHandler.prototype.startX = 0;
/** @type {number} */
mxPanningHandler.prototype.startY = 0;
/**
 * @return {?}
 */
mxPanningHandler.prototype.isActive = function() {
  return this.active || null != this.initialScale;
};
/**
 * @return {?}
 */
mxPanningHandler.prototype.isPanningEnabled = function() {
  return this.panningEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxPanningHandler.prototype.setPanningEnabled = function(a) {
  /** @type {boolean} */
  this.panningEnabled = a;
};
/**
 * @return {?}
 */
mxPanningHandler.prototype.isPinchEnabled = function() {
  return this.pinchEnabled;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxPanningHandler.prototype.setPinchEnabled = function(a) {
  /** @type {boolean} */
  this.pinchEnabled = a;
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxPanningHandler.prototype.isPanningTrigger = function(me) {
  var evt = me.getEvent();
  return this.useLeftButtonForPanning && null == me.getState() && mxEvent.isLeftMouseButton(evt) || mxEvent.isControlDown(evt) && mxEvent.isShiftDown(evt) || this.usePopupTrigger && mxEvent.isPopupTrigger(evt);
};
/**
 * @param {?} event
 * @return {?}
 */
mxPanningHandler.prototype.isForcePanningEvent = function(event) {
  return this.ignoreCell || mxEvent.isMultiTouchEvent(event.getEvent());
};
/**
 * @param {!Object} e
 * @param {!Object} element
 * @return {undefined}
 */
mxPanningHandler.prototype.mouseDown = function(e, element) {
  /** @type {!Object} */
  this.mouseDownEvent = element;
  if (!element.isConsumed() && this.isPanningEnabled() && !this.active && this.isPanningTrigger(element)) {
    this.start(element);
    this.consumePanningTrigger(element);
  }
};
/**
 * @param {!Object} item
 * @return {undefined}
 */
mxPanningHandler.prototype.start = function(item) {
  /** @type {number} */
  this.dx0 = -this.graph.container.scrollLeft;
  /** @type {number} */
  this.dy0 = -this.graph.container.scrollTop;
  this.startX = item.getX();
  this.startY = item.getY();
  /** @type {null} */
  this.dy = this.dx = null;
  /** @type {boolean} */
  this.panningTrigger = true;
};
/**
 * @param {!Event} s
 * @return {undefined}
 */
mxPanningHandler.prototype.consumePanningTrigger = function(s) {
  s.consume();
};
/**
 * @param {?} callback
 * @param {!Object} event
 * @return {undefined}
 */
mxPanningHandler.prototype.mouseMove = function(callback, event) {
  /** @type {number} */
  this.dx = event.getX() - this.startX;
  /** @type {number} */
  this.dy = event.getY() - this.startY;
  if (this.active) {
    if (this.previewEnabled) {
      if (this.useGrid) {
        this.dx = this.graph.snap(this.dx);
        this.dy = this.graph.snap(this.dy);
      }
      this.graph.panGraph(this.dx + this.dx0, this.dy + this.dy0);
    }
    this.fireEvent(new mxEventObject(mxEvent.PAN, "event", event));
  } else {
    if (this.panningTrigger) {
      var active = this.active;
      /** @type {boolean} */
      this.active = Math.abs(this.dx) > this.graph.tolerance || Math.abs(this.dy) > this.graph.tolerance;
      if (!active && this.active) {
        this.fireEvent(new mxEventObject(mxEvent.PAN_START, "event", event));
      }
    }
  }
  if (this.active || this.panningTrigger) {
    event.consume();
  }
};
/**
 * @param {?} editor
 * @param {!Function} e
 * @return {undefined}
 */
mxPanningHandler.prototype.mouseUp = function(editor, e) {
  if (this.active) {
    if (null != this.dx && null != this.dy) {
      if (!this.graph.useScrollbarsForPanning || !mxUtils.hasScrollbars(this.graph.container)) {
        var scale = this.graph.getView().scale;
        var translate = this.graph.getView().translate;
        this.graph.panGraph(0, 0);
        this.panGraph(translate.x + this.dx / scale, translate.y + this.dy / scale);
      }
      e.consume();
    }
    this.fireEvent(new mxEventObject(mxEvent.PAN_END, "event", e));
  }
  this.reset();
};
/**
 * @param {string} e
 * @return {undefined}
 */
mxPanningHandler.prototype.zoomGraph = function(e) {
  /** @type {number} */
  var scale = Math.round(this.initialScale * e.scale * 100) / 100;
  if (null != this.minScale) {
    /** @type {number} */
    scale = Math.max(this.minScale, scale);
  }
  if (null != this.maxScale) {
    /** @type {number} */
    scale = Math.min(this.maxScale, scale);
  }
  if (this.graph.view.scale != scale) {
    this.graph.zoomTo(scale);
    mxEvent.consume(e);
  }
};
/**
 * @return {undefined}
 */
mxPanningHandler.prototype.reset = function() {
  /** @type {boolean} */
  this.panningTrigger = false;
  /** @type {null} */
  this.mouseDownEvent = null;
  /** @type {boolean} */
  this.active = false;
  /** @type {null} */
  this.dy = this.dx = null;
};
/**
 * @param {number} dx
 * @param {number} dy
 * @return {undefined}
 */
mxPanningHandler.prototype.panGraph = function(dx, dy) {
  this.graph.getView().setTranslate(dx, dy);
};
/**
 * @return {undefined}
 */
mxPanningHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.forcePanningHandler);
  this.graph.removeListener(this.gestureHandler);
  mxEvent.removeListener(document, "mouseup", this.mouseUpListener);
};
/**
 * @param {!Object} targetGraph
 * @param {?} srcDoc
 * @return {undefined}
 */
function mxPopupMenuHandler(targetGraph, srcDoc) {
  if (null != targetGraph) {
    /** @type {!Object} */
    this.graph = targetGraph;
    this.factoryMethod = srcDoc;
    this.graph.addMouseListener(this);
    this.gestureHandler = mxUtils.bind(this, function(a, b) {
      /** @type {boolean} */
      this.inTolerance = false;
    });
    this.graph.addListener(mxEvent.GESTURE, this.gestureHandler);
    this.init();
  }
}
mxPopupMenuHandler.prototype = new mxPopupMenu;
/** @type {function(!Object, ?): undefined} */
mxPopupMenuHandler.prototype.constructor = mxPopupMenuHandler;
/** @type {null} */
mxPopupMenuHandler.prototype.graph = null;
/** @type {boolean} */
mxPopupMenuHandler.prototype.selectOnPopup = true;
/** @type {boolean} */
mxPopupMenuHandler.prototype.clearSelectionOnBackground = true;
/** @type {null} */
mxPopupMenuHandler.prototype.triggerX = null;
/** @type {null} */
mxPopupMenuHandler.prototype.triggerY = null;
/** @type {null} */
mxPopupMenuHandler.prototype.screenX = null;
/** @type {null} */
mxPopupMenuHandler.prototype.screenY = null;
/**
 * @return {undefined}
 */
mxPopupMenuHandler.prototype.init = function() {
  mxPopupMenu.prototype.init.apply(this);
  mxEvent.addGestureListeners(this.div, mxUtils.bind(this, function(a) {
    this.graph.tooltipHandler.hide();
  }));
};
/**
 * @param {!Object} gib
 * @return {?}
 */
mxPopupMenuHandler.prototype.isSelectOnPopup = function(gib) {
  return this.selectOnPopup;
};
/**
 * @param {!Object} e
 * @param {!Event} me
 * @return {undefined}
 */
mxPopupMenuHandler.prototype.mouseDown = function(e, me) {
  if (this.isEnabled() && !mxEvent.isMultiTouchEvent(me.getEvent())) {
    this.hideMenu();
    this.triggerX = me.getGraphX();
    this.triggerY = me.getGraphY();
    this.screenX = mxEvent.getMainEvent(me.getEvent()).screenX;
    this.screenY = mxEvent.getMainEvent(me.getEvent()).screenY;
    this.popupTrigger = this.isPopupTrigger(me);
    /** @type {boolean} */
    this.inTolerance = true;
  }
};
/**
 * @param {?} callback
 * @param {?} event
 * @return {undefined}
 */
mxPopupMenuHandler.prototype.mouseMove = function(callback, event) {
  if (this.inTolerance && null != this.screenX && null != this.screenY && (Math.abs(mxEvent.getMainEvent(event.getEvent()).screenX - this.screenX) > this.graph.tolerance || Math.abs(mxEvent.getMainEvent(event.getEvent()).screenY - this.screenY) > this.graph.tolerance)) {
    /** @type {boolean} */
    this.inTolerance = false;
  }
};
/**
 * @param {?} callback
 * @param {!Object} self
 * @return {undefined}
 */
mxPopupMenuHandler.prototype.mouseUp = function(callback, self) {
  if (this.popupTrigger && this.inTolerance && null != this.triggerX && null != this.triggerY) {
    var cell = this.getCellForPopupEvent(self);
    if (this.graph.isEnabled() && this.isSelectOnPopup(self) && null != cell && !this.graph.isCellSelected(cell)) {
      this.graph.setSelectionCell(cell);
    } else {
      if (this.clearSelectionOnBackground && null == cell) {
        this.graph.clearSelection();
      }
    }
    this.graph.tooltipHandler.hide();
    var xhair = mxUtils.getScrollOrigin();
    this.popup(self.getX() + xhair.x + 1, self.getY() + xhair.y + 1, cell, self.getEvent());
    self.consume();
  }
  /** @type {boolean} */
  this.inTolerance = this.popupTrigger = false;
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxPopupMenuHandler.prototype.getCellForPopupEvent = function(me) {
  return me.getCell();
};
/**
 * @return {undefined}
 */
mxPopupMenuHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.gestureHandler);
  mxPopupMenu.prototype.destroy.apply(this);
};
/**
 * @param {!Object} graph
 * @param {string} data
 * @param {string} name
 * @param {string} force
 * @return {undefined}
 */
function mxCellMarker(graph, data, name, force) {
  mxEventSource.call(this);
  if (null != graph) {
    /** @type {!Object} */
    this.graph = graph;
    this.validColor = null != data ? data : mxConstants.DEFAULT_VALID_COLOR;
    this.invalidColor = null != name ? name : mxConstants.DEFAULT_INVALID_COLOR;
    this.hotspot = null != force ? force : mxConstants.DEFAULT_HOTSPOT;
    this.highlight = new mxCellHighlight(graph);
  }
}
mxUtils.extend(mxCellMarker, mxEventSource);
/** @type {null} */
mxCellMarker.prototype.graph = null;
/** @type {boolean} */
mxCellMarker.prototype.enabled = true;
/** @type {number} */
mxCellMarker.prototype.hotspot = mxConstants.DEFAULT_HOTSPOT;
/** @type {boolean} */
mxCellMarker.prototype.hotspotEnabled = false;
/** @type {null} */
mxCellMarker.prototype.validColor = null;
/** @type {null} */
mxCellMarker.prototype.invalidColor = null;
/** @type {null} */
mxCellMarker.prototype.currentColor = null;
/** @type {null} */
mxCellMarker.prototype.validState = null;
/** @type {null} */
mxCellMarker.prototype.markedState = null;
/**
 * @param {string} state
 * @return {undefined}
 */
mxCellMarker.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxCellMarker.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} a
 * @return {undefined}
 */
mxCellMarker.prototype.setHotspot = function(a) {
  /** @type {string} */
  this.hotspot = a;
};
/**
 * @return {?}
 */
mxCellMarker.prototype.getHotspot = function() {
  return this.hotspot;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxCellMarker.prototype.setHotspotEnabled = function(a) {
  /** @type {boolean} */
  this.hotspotEnabled = a;
};
/**
 * @return {?}
 */
mxCellMarker.prototype.isHotspotEnabled = function() {
  return this.hotspotEnabled;
};
/**
 * @return {?}
 */
mxCellMarker.prototype.hasValidState = function() {
  return null != this.validState;
};
/**
 * @return {?}
 */
mxCellMarker.prototype.getValidState = function() {
  return this.validState;
};
/**
 * @return {?}
 */
mxCellMarker.prototype.getMarkedState = function() {
  return this.markedState;
};
/**
 * @return {undefined}
 */
mxCellMarker.prototype.reset = function() {
  /** @type {null} */
  this.validState = null;
  if (null != this.markedState) {
    /** @type {null} */
    this.markedState = null;
    this.unmark();
  }
};
/**
 * @param {!Object} name
 * @return {?}
 */
mxCellMarker.prototype.process = function(name) {
  /** @type {null} */
  var payload = null;
  if (this.isEnabled()) {
    payload = this.getState(name);
    this.setCurrentState(payload, name);
  }
  return payload;
};
/**
 * @param {string} key
 * @param {!Object} s
 * @param {number} data
 * @return {undefined}
 */
mxCellMarker.prototype.setCurrentState = function(key, s, data) {
  var isKey = null != key ? this.isValidState(key) : false;
  data = null != data ? data : this.getMarkerColor(s.getEvent(), key, isKey);
  this.validState = isKey ? key : null;
  if (key != this.markedState || data != this.currentColor) {
    /** @type {number} */
    this.currentColor = data;
    if (null != key && null != this.currentColor) {
      /** @type {string} */
      this.markedState = key;
      this.mark();
    } else {
      if (null != this.markedState) {
        /** @type {null} */
        this.markedState = null;
        this.unmark();
      }
    }
  }
};
/**
 * @param {!Object} port
 * @param {string} name
 * @return {undefined}
 */
mxCellMarker.prototype.markCell = function(port, name) {
  var tester = this.graph.getView().getState(port);
  if (null != tester) {
    this.currentColor = null != name ? name : this.validColor;
    this.markedState = tester;
    this.mark();
  }
};
/**
 * @return {undefined}
 */
mxCellMarker.prototype.mark = function() {
  this.highlight.setHighlightColor(this.currentColor);
  this.highlight.highlight(this.markedState);
  this.fireEvent(new mxEventObject(mxEvent.MARK, "state", this.markedState));
};
/**
 * @return {undefined}
 */
mxCellMarker.prototype.unmark = function() {
  this.mark();
};
/**
 * @param {string} key
 * @return {?}
 */
mxCellMarker.prototype.isValidState = function(key) {
  return true;
};
/**
 * @param {?} envId
 * @param {string} url
 * @param {number} isKey
 * @return {?}
 */
mxCellMarker.prototype.getMarkerColor = function(envId, url, isKey) {
  return isKey ? this.validColor : this.invalidColor;
};
/**
 * @param {!Object} key
 * @return {?}
 */
mxCellMarker.prototype.getState = function(key) {
  var obj = this.graph.getView();
  var target = this.getCell(key);
  obj = this.getStateToMark(obj.getState(target));
  return null != obj && this.intersects(obj, key) ? obj : null;
};
/**
 * @param {!Object} o
 * @return {?}
 */
mxCellMarker.prototype.getCell = function(o) {
  return o.getCell();
};
/**
 * @param {?} a
 * @return {?}
 */
mxCellMarker.prototype.getStateToMark = function(a) {
  return a;
};
/**
 * @param {!Array} value
 * @param {!Object} x
 * @return {?}
 */
mxCellMarker.prototype.intersects = function(value, x) {
  return this.hotspotEnabled ? mxUtils.intersectsHotspot(value, x.getGraphX(), x.getGraphY(), this.hotspot, mxConstants.MIN_HOTSPOT_SIZE, mxConstants.MAX_HOTSPOT_SIZE) : true;
};
/**
 * @return {undefined}
 */
mxCellMarker.prototype.destroy = function() {
  this.graph.getView().removeListener(this.resetHandler);
  this.graph.getModel().removeListener(this.resetHandler);
  this.highlight.destroy();
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxSelectionCellsHandler(targetGraph) {
  mxEventSource.call(this);
  /** @type {!Object} */
  this.graph = targetGraph;
  this.handlers = new mxDictionary;
  this.graph.addMouseListener(this);
  this.refreshHandler = mxUtils.bind(this, function(a, canCreateDiscussions) {
    if (this.isEnabled()) {
      this.refresh();
    }
  });
  this.graph.getSelectionModel().addListener(mxEvent.CHANGE, this.refreshHandler);
  this.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.SCALE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.TRANSLATE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.DOWN, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.UP, this.refreshHandler);
}
mxUtils.extend(mxSelectionCellsHandler, mxEventSource);
/** @type {null} */
mxSelectionCellsHandler.prototype.graph = null;
/** @type {boolean} */
mxSelectionCellsHandler.prototype.enabled = true;
/** @type {null} */
mxSelectionCellsHandler.prototype.refreshHandler = null;
/** @type {number} */
mxSelectionCellsHandler.prototype.maxHandlers = 100;
/** @type {null} */
mxSelectionCellsHandler.prototype.handlers = null;
/**
 * @return {?}
 */
mxSelectionCellsHandler.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @param {!Object} name
 * @return {?}
 */
mxSelectionCellsHandler.prototype.getHandler = function(name) {
  return this.handlers.get(name);
};
/**
 * @param {!Object} name
 * @return {?}
 */
mxSelectionCellsHandler.prototype.isHandled = function(name) {
  return null != this.getHandler(name);
};
/**
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.reset = function() {
  this.handlers.visit(function(a, b) {
    b.reset.apply(b);
  });
};
/**
 * @return {?}
 */
mxSelectionCellsHandler.prototype.getHandledSelectionCells = function() {
  return this.graph.getSelectionCells();
};
/**
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.refresh = function() {
  var c = this.handlers;
  this.handlers = new mxDictionary;
  var a = mxUtils.sortCells(this.getHandledSelectionCells(), false);
  /** @type {number} */
  var i = 0;
  for (; i < a.length; i++) {
    var opts = this.graph.view.getState(a[i]);
    if (null != opts) {
      var args = c.remove(a[i]);
      if (null != args) {
        if (args.state != opts) {
          args.destroy();
          /** @type {null} */
          args = null;
        } else {
          if (!this.isHandlerActive(args)) {
            if (null != args.refresh) {
              args.refresh();
            }
            args.redraw();
          }
        }
      }
      if (null != args) {
        this.handlers.put(a[i], args);
      }
    }
  }
  c.visit(mxUtils.bind(this, function(a, b) {
    this.fireEvent(new mxEventObject(mxEvent.REMOVE, "state", b.state));
    b.destroy();
  }));
  /** @type {number} */
  i = 0;
  for (; i < a.length; i++) {
    opts = this.graph.view.getState(a[i]);
    if (null != opts) {
      args = this.handlers.get(a[i]);
      if (null == args) {
        args = this.graph.createHandler(opts);
        this.fireEvent(new mxEventObject(mxEvent.ADD, "state", opts));
        this.handlers.put(a[i], args);
      } else {
        args.updateParentHighlight();
      }
    }
  }
};
/**
 * @param {?} a
 * @return {?}
 */
mxSelectionCellsHandler.prototype.isHandlerActive = function(a) {
  return null != a.index;
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.updateHandler = function(data) {
  var b = this.handlers.remove(data.cell);
  if (null != b) {
    var e = b.index;
    var x = b.startX;
    var y = b.startY;
    b.destroy();
    b = this.graph.createHandler(data);
    if (null != b) {
      this.handlers.put(data.cell, b);
      if (null != e && null != x && null != y) {
        b.start(x, y, e);
      }
    }
  }
};
/**
 * @param {!Object} e
 * @param {?} ch
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.mouseDown = function(e, ch) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    /** @type {!Array} */
    var es = [e, ch];
    this.handlers.visit(function(a, d) {
      d.mouseDown.apply(d, es);
    });
  }
};
/**
 * @param {?} new_yaw
 * @param {?} new_pitch
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.mouseMove = function(new_yaw, new_pitch) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    /** @type {!Array} */
    var c = [new_yaw, new_pitch];
    this.handlers.visit(function(a, o) {
      o.mouseMove.apply(o, c);
    });
  }
};
/**
 * @param {?} callback
 * @param {?} where
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.mouseUp = function(callback, where) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    /** @type {!Array} */
    var args = [callback, where];
    this.handlers.visit(function(a, d) {
      d.mouseUp.apply(d, args);
    });
  }
};
/**
 * @return {undefined}
 */
mxSelectionCellsHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  if (null != this.refreshHandler) {
    this.graph.getSelectionModel().removeListener(this.refreshHandler);
    this.graph.getModel().removeListener(this.refreshHandler);
    this.graph.getView().removeListener(this.refreshHandler);
    /** @type {null} */
    this.refreshHandler = null;
  }
};
/**
 * @param {!Object} targetGraph
 * @param {?} srcDoc
 * @return {undefined}
 */
function mxConnectionHandler(targetGraph, srcDoc) {
  mxEventSource.call(this);
  if (null != targetGraph) {
    /** @type {!Object} */
    this.graph = targetGraph;
    this.factoryMethod = srcDoc;
    this.init();
    this.escapeHandler = mxUtils.bind(this, function(a, b) {
      this.reset();
    });
    this.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
  }
}
mxUtils.extend(mxConnectionHandler, mxEventSource);
/** @type {null} */
mxConnectionHandler.prototype.graph = null;
/** @type {boolean} */
mxConnectionHandler.prototype.factoryMethod = true;
/** @type {boolean} */
mxConnectionHandler.prototype.moveIconFront = false;
/** @type {boolean} */
mxConnectionHandler.prototype.moveIconBack = false;
/** @type {null} */
mxConnectionHandler.prototype.connectImage = null;
/** @type {boolean} */
mxConnectionHandler.prototype.targetConnectImage = false;
/** @type {boolean} */
mxConnectionHandler.prototype.enabled = true;
/** @type {boolean} */
mxConnectionHandler.prototype.select = true;
/** @type {boolean} */
mxConnectionHandler.prototype.createTarget = false;
/** @type {null} */
mxConnectionHandler.prototype.marker = null;
/** @type {null} */
mxConnectionHandler.prototype.constraintHandler = null;
/** @type {null} */
mxConnectionHandler.prototype.error = null;
/** @type {boolean} */
mxConnectionHandler.prototype.waypointsEnabled = false;
/** @type {boolean} */
mxConnectionHandler.prototype.ignoreMouseDown = false;
/** @type {null} */
mxConnectionHandler.prototype.first = null;
mxConnectionHandler.prototype.connectIconOffset = new mxPoint(0, mxConstants.TOOLTIP_VERTICAL_OFFSET);
/** @type {null} */
mxConnectionHandler.prototype.edgeState = null;
/** @type {null} */
mxConnectionHandler.prototype.changeHandler = null;
/** @type {null} */
mxConnectionHandler.prototype.drillHandler = null;
/** @type {number} */
mxConnectionHandler.prototype.mouseDownCounter = 0;
/** @type {boolean} */
mxConnectionHandler.prototype.movePreviewAway = mxClient.IS_VML;
/** @type {boolean} */
mxConnectionHandler.prototype.outlineConnect = false;
/** @type {boolean} */
mxConnectionHandler.prototype.livePreview = false;
/** @type {null} */
mxConnectionHandler.prototype.cursor = null;
/** @type {boolean} */
mxConnectionHandler.prototype.insertBeforeSource = false;
/**
 * @return {?}
 */
mxConnectionHandler.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxConnectionHandler.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @param {!Object} a
 * @param {string} b
 * @param {string} s
 * @param {number} cont
 * @param {number} width
 * @return {?}
 */
mxConnectionHandler.prototype.isInsertBefore = function(a, b, s, cont, width) {
  return this.insertBeforeSource && b != s;
};
/**
 * @param {number} topnode
 * @return {?}
 */
mxConnectionHandler.prototype.isCreateTarget = function(topnode) {
  return this.createTarget;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxConnectionHandler.prototype.setCreateTarget = function(a) {
  /** @type {boolean} */
  this.createTarget = a;
};
/**
 * @return {?}
 */
mxConnectionHandler.prototype.createShape = function() {
  var options = this.livePreview && null != this.edgeState ? this.graph.cellRenderer.createShape(this.edgeState) : new mxPolyline([], mxConstants.INVALID_COLOR);
  options.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
  options.scale = this.graph.view.scale;
  /** @type {boolean} */
  options.pointerEvents = false;
  /** @type {boolean} */
  options.isDashed = true;
  options.init(this.graph.getView().getOverlayPane());
  mxEvent.redirectMouseEvents(options.node, this.graph, null);
  return options;
};
/**
 * @return {undefined}
 */
mxConnectionHandler.prototype.init = function() {
  this.graph.addMouseListener(this);
  this.marker = this.createMarker();
  this.constraintHandler = new mxConstraintHandler(this.graph);
  this.changeHandler = mxUtils.bind(this, function(a) {
    if (null != this.iconState) {
      this.iconState = this.graph.getView().getState(this.iconState.cell);
    }
    if (null != this.iconState) {
      this.redrawIcons(this.icons, this.iconState);
      this.constraintHandler.reset();
    } else {
      if (null != this.previous && null == this.graph.view.getState(this.previous.cell)) {
        this.reset();
      }
    }
  });
  this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
  this.graph.getView().addListener(mxEvent.SCALE, this.changeHandler);
  this.graph.getView().addListener(mxEvent.TRANSLATE, this.changeHandler);
  this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.changeHandler);
  this.drillHandler = mxUtils.bind(this, function(a) {
    this.reset();
  });
  this.graph.addListener(mxEvent.START_EDITING, this.drillHandler);
  this.graph.getView().addListener(mxEvent.DOWN, this.drillHandler);
  this.graph.getView().addListener(mxEvent.UP, this.drillHandler);
};
/**
 * @param {?} cell
 * @return {?}
 */
mxConnectionHandler.prototype.isConnectableCell = function(cell) {
  return true;
};
/**
 * @return {?}
 */
mxConnectionHandler.prototype.createMarker = function() {
  var tree = new mxCellMarker(this.graph);
  /** @type {boolean} */
  tree.hotspotEnabled = true;
  tree.getCell = mxUtils.bind(this, function(s) {
    var name = mxCellMarker.prototype.getCell.apply(tree, arguments);
    /** @type {null} */
    this.error = null;
    if (null == name && null != this.currentPoint) {
      name = this.graph.getCellAt(this.currentPoint.x, this.currentPoint.y);
    }
    if (null != name && !this.graph.isCellConnectable(name)) {
      var parent = this.graph.getModel().getParent(name);
      if (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent)) {
        name = parent;
      }
    }
    if (this.graph.isSwimlane(name) && null != this.currentPoint && this.graph.hitsSwimlaneContent(name, this.currentPoint.x, this.currentPoint.y) || !this.isConnectableCell(name)) {
      /** @type {null} */
      name = null;
    }
    if (null != name) {
      if (this.isConnecting()) {
        if (null != this.previous) {
          this.error = this.validateConnection(this.previous.cell, name);
          if (null != this.error && 0 == this.error.length) {
            /** @type {null} */
            name = null;
            if (this.isCreateTarget(s.getEvent())) {
              /** @type {null} */
              this.error = null;
            }
          }
        }
      } else {
        if (!this.isValidSource(name, s)) {
          /** @type {null} */
          name = null;
        }
      }
    } else {
      if (!(!this.isConnecting() || this.isCreateTarget(s.getEvent()) || this.graph.allowDanglingEdges)) {
        /** @type {string} */
        this.error = "";
      }
    }
    return name;
  });
  tree.isValidState = mxUtils.bind(this, function(b) {
    return this.isConnecting() ? null == this.error : mxCellMarker.prototype.isValidState.apply(tree, arguments);
  });
  tree.getMarkerColor = mxUtils.bind(this, function(b, canCreateDiscussions, isSlidingUp) {
    return null == this.connectImage || this.isConnecting() ? mxCellMarker.prototype.getMarkerColor.apply(tree, arguments) : null;
  });
  tree.intersects = mxUtils.bind(this, function(b, canCreateDiscussions) {
    return null != this.connectImage || this.isConnecting() ? true : mxCellMarker.prototype.intersects.apply(tree, arguments);
  });
  return tree;
};
/**
 * @param {string} value
 * @param {?} x
 * @param {boolean} arr
 * @param {!Object} index
 * @return {undefined}
 */
mxConnectionHandler.prototype.start = function(value, x, arr, index) {
  /** @type {string} */
  this.previous = value;
  this.first = new mxPoint(x, arr);
  this.edgeState = null != index ? index : this.createEdgeState(null);
  this.marker.currentColor = this.marker.validColor;
  /** @type {string} */
  this.marker.markedState = value;
  this.marker.mark();
  this.fireEvent(new mxEventObject(mxEvent.START, "state", this.previous));
};
/**
 * @return {?}
 */
mxConnectionHandler.prototype.isConnecting = function() {
  return null != this.first && null != this.shape;
};
/**
 * @param {?} source
 * @param {?} x
 * @return {?}
 */
mxConnectionHandler.prototype.isValidSource = function(source, x) {
  return this.graph.isValidSource(source);
};
/**
 * @param {?} name
 * @return {?}
 */
mxConnectionHandler.prototype.isValidTarget = function(name) {
  return true;
};
/**
 * @param {?} args
 * @param {?} value
 * @return {?}
 */
mxConnectionHandler.prototype.validateConnection = function(args, value) {
  return this.isValidTarget(value) ? this.graph.getEdgeValidationError(null, args, value) : "";
};
/**
 * @param {?} cur
 * @return {?}
 */
mxConnectionHandler.prototype.getConnectImage = function(cur) {
  return this.connectImage;
};
/**
 * @param {?} elem
 * @return {?}
 */
mxConnectionHandler.prototype.isMoveIconToFrontForState = function(elem) {
  return null != elem.text && elem.text.node.parentNode == this.graph.container ? true : this.moveIconFront;
};
/**
 * @param {?} elem
 * @return {?}
 */
mxConnectionHandler.prototype.createIcons = function(elem) {
  var table = this.getConnectImage(elem);
  if (null != table && null != elem) {
    this.iconState = elem;
    /** @type {!Array} */
    var startTimes = [];
    var bounds = new mxRectangle(0, 0, table.width, table.height);
    var control = new mxImageShape(bounds, table.src, null, null, 0);
    /** @type {boolean} */
    control.preserveImageAspect = false;
    if (this.isMoveIconToFrontForState(elem)) {
      control.dialect = mxConstants.DIALECT_STRICTHTML;
      control.init(this.graph.container);
    } else {
      control.dialect = this.graph.dialect == mxConstants.DIALECT_SVG ? mxConstants.DIALECT_SVG : mxConstants.DIALECT_VML;
      control.init(this.graph.getView().getOverlayPane());
      if (this.moveIconBack && null != control.node.previousSibling) {
        control.node.parentNode.insertBefore(control.node, control.node.parentNode.firstChild);
      }
    }
    control.node.style.cursor = mxConstants.CURSOR_CONNECT;
    var update = mxUtils.bind(this, function() {
      return null != this.currentState ? this.currentState : elem;
    });
    table = mxUtils.bind(this, function(evt) {
      if (!mxEvent.isConsumed(evt)) {
        this.icon = control;
        this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, update()));
      }
    });
    mxEvent.redirectMouseEvents(control.node, this.graph, update, table);
    startTimes.push(control);
    this.redrawIcons(startTimes, this.iconState);
    return startTimes;
  }
  return null;
};
/**
 * @param {!Object} overlays
 * @param {!Object} data
 * @return {undefined}
 */
mxConnectionHandler.prototype.redrawIcons = function(overlays, data) {
  if (null != overlays && null != overlays[0] && null != data) {
    var result = this.getIconPosition(overlays[0], data);
    overlays[0].bounds.x = result.x;
    overlays[0].bounds.y = result.y;
    overlays[0].redraw();
  }
};
/**
 * @param {!Object} _
 * @param {!Object} s
 * @return {?}
 */
mxConnectionHandler.prototype.getIconPosition = function(_, s) {
  var cos = this.graph.getView().scale;
  var width = s.getCenterX();
  var bottom = s.getCenterY();
  if (this.graph.isSwimlane(s.cell)) {
    var a = this.graph.getStartSize(s.cell);
    width = 0 != a.width ? s.x + a.width * cos / 2 : width;
    bottom = 0 != a.height ? s.y + a.height * cos / 2 : bottom;
    a = mxUtils.toRadians(mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION) || 0);
    if (0 != a) {
      /** @type {number} */
      cos = Math.cos(a);
      /** @type {number} */
      a = Math.sin(a);
      var ct = new mxPoint(s.getCenterX(), s.getCenterY());
      bottom = mxUtils.getRotatedPoint(new mxPoint(width, bottom), cos, a, ct);
      width = bottom.x;
      bottom = bottom.y;
    }
  }
  return new mxPoint(width - _.bounds.width / 2, bottom - _.bounds.height / 2);
};
/**
 * @return {undefined}
 */
mxConnectionHandler.prototype.destroyIcons = function() {
  if (null != this.icons) {
    /** @type {number} */
    var i = 0;
    for (; i < this.icons.length; i++) {
      this.icons[i].destroy();
    }
    /** @type {null} */
    this.iconState = this.selectedIcon = this.icon = this.icons = null;
  }
};
/**
 * @param {!Event} object
 * @return {?}
 */
mxConnectionHandler.prototype.isStartEvent = function(object) {
  return null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentConstraint || null != this.previous && null == this.error && (null == this.icons || null != this.icons && null != this.icon);
};
/**
 * @param {!Object} e
 * @param {!Event} me
 * @return {undefined}
 */
mxConnectionHandler.prototype.mouseDown = function(e, me) {
  this.mouseDownCounter++;
  if (this.isEnabled() && this.graph.isEnabled() && !me.isConsumed() && !this.isConnecting() && this.isStartEvent(me)) {
    if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentPoint) {
      this.sourceConstraint = this.constraintHandler.currentConstraint;
      this.previous = this.constraintHandler.currentFocus;
      this.first = this.constraintHandler.currentPoint.clone();
    } else {
      this.first = new mxPoint(me.getGraphX(), me.getGraphY());
    }
    this.edgeState = this.createEdgeState(me);
    /** @type {number} */
    this.mouseDownCounter = 1;
    if (this.waypointsEnabled && null == this.shape) {
      /** @type {null} */
      this.waypoints = null;
      this.shape = this.createShape();
      if (null != this.edgeState) {
        this.shape.apply(this.edgeState);
      }
    }
    if (null == this.previous && null != this.edgeState) {
      var bounceBackAmount = this.graph.getPointForEvent(me.getEvent());
      this.edgeState.cell.geometry.setTerminalPoint(bounceBackAmount, true);
    }
    this.fireEvent(new mxEventObject(mxEvent.START, "state", this.previous));
    me.consume();
  }
  this.selectedIcon = this.icon;
  /** @type {null} */
  this.icon = null;
};
/**
 * @param {?} data
 * @return {?}
 */
mxConnectionHandler.prototype.isImmediateConnectSource = function(data) {
  return !this.graph.isCellMovable(data.cell);
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxConnectionHandler.prototype.createEdgeState = function(me) {
  return null;
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxConnectionHandler.prototype.isOutlineConnectEvent = function(me) {
  var n = mxUtils.getOffset(this.graph.container);
  var e = me.getEvent();
  var d = mxEvent.getClientX(e);
  e = mxEvent.getClientY(e);
  /** @type {!Element} */
  var doc = document.documentElement;
  /** @type {number} */
  var df = this.currentPoint.x - this.graph.container.scrollLeft + n.x - ((window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0));
  /** @type {number} */
  n = this.currentPoint.y - this.graph.container.scrollTop + n.y - ((window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0));
  return this.outlineConnect && !mxEvent.isShiftDown(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || mxEvent.isAltDown(me.getEvent()) && null != me.getState() || this.marker.highlight.isHighlightAt(d, e) || (df != d || n != e) && null == me.getState() && this.marker.highlight.isHighlightAt(df, n));
};
/**
 * @param {!Object} me
 * @param {number} width
 * @return {undefined}
 */
mxConnectionHandler.prototype.updateCurrentState = function(me, width) {
  this.constraintHandler.update(me, null == this.first, false, null == this.first || me.isSource(this.marker.highlight.shape) ? null : width);
  if (null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentConstraint) {
    if (null != this.marker.highlight && null != this.marker.highlight.state && this.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell) {
      if ("transparent" != this.marker.highlight.shape.stroke) {
        /** @type {string} */
        this.marker.highlight.shape.stroke = "transparent";
        this.marker.highlight.repaint();
      }
    } else {
      this.marker.markCell(this.constraintHandler.currentFocus.cell, "transparent");
    }
    if (null != this.previous) {
      this.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);
      if (null == this.error) {
        this.currentState = this.constraintHandler.currentFocus;
      }
      if (null != this.error || null != this.currentState && !this.isCellEnabled(this.currentState.cell)) {
        this.constraintHandler.reset();
      }
    }
  } else {
    if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {
      this.marker.reset();
      /** @type {null} */
      this.currentState = null;
    } else {
      this.marker.process(me);
      this.currentState = this.marker.getValidState();
    }
    if (!(null == this.currentState || this.isCellEnabled(this.currentState.cell))) {
      this.constraintHandler.reset();
      this.marker.reset();
      /** @type {null} */
      this.currentState = null;
    }
    var value = this.isOutlineConnectEvent(me);
    if (null != this.currentState && value) {
      if (me.isSource(this.marker.highlight.shape)) {
        width = new mxPoint(me.getGraphX(), me.getGraphY());
      }
      value = this.graph.getOutlineConstraint(width, this.currentState, me);
      this.constraintHandler.setFocus(me, this.currentState, false);
      this.constraintHandler.currentConstraint = value;
      /** @type {number} */
      this.constraintHandler.currentPoint = width;
    }
    if (this.outlineConnect && null != this.marker.highlight && null != this.marker.highlight.shape) {
      value = this.graph.view.scale;
      if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus) {
        this.marker.highlight.shape.stroke = mxConstants.OUTLINE_HIGHLIGHT_COLOR;
        /** @type {number} */
        this.marker.highlight.shape.strokewidth = mxConstants.OUTLINE_HIGHLIGHT_STROKEWIDTH / value / value;
        this.marker.highlight.repaint();
      } else {
        if (this.marker.hasValidState()) {
          if (this.graph.isCellConnectable(me.getCell()) && this.marker.getValidState() != me.getState()) {
            /** @type {string} */
            this.marker.highlight.shape.stroke = "transparent";
            /** @type {null} */
            this.currentState = null;
          } else {
            this.marker.highlight.shape.stroke = mxConstants.DEFAULT_VALID_COLOR;
          }
          /** @type {number} */
          this.marker.highlight.shape.strokewidth = mxConstants.HIGHLIGHT_STROKEWIDTH / value / value;
          this.marker.highlight.repaint();
        }
      }
    }
  }
};
/**
 * @param {?} a
 * @return {?}
 */
mxConnectionHandler.prototype.isCellEnabled = function(a) {
  return true;
};
/**
 * @param {!Object} pt
 * @return {undefined}
 */
mxConnectionHandler.prototype.convertWaypoint = function(pt) {
  var scale = this.graph.getView().getScale();
  var geo = this.graph.getView().getTranslate();
  /** @type {number} */
  pt.x = pt.x / scale - geo.x;
  /** @type {number} */
  pt.y = pt.y / scale - geo.y;
};
/**
 * @param {!Object} me
 * @param {!Object} variable
 * @return {undefined}
 */
mxConnectionHandler.prototype.snapToPreview = function(me, variable) {
  if (!mxEvent.isAltDown(me.getEvent()) && null != this.previous) {
    /** @type {number} */
    var c = this.graph.gridSize * this.graph.view.scale / 2;
    var current = null != this.sourceConstraint ? this.first : new mxPoint(this.previous.getCenterX(), this.previous.getCenterY());
    if (Math.abs(current.x - me.getGraphX()) < c) {
      variable.x = current.x;
    }
    if (Math.abs(current.y - me.getGraphY()) < c) {
      variable.y = current.y;
    }
  }
};
/**
 * @param {?} e
 * @param {!Object} me
 * @return {undefined}
 */
mxConnectionHandler.prototype.mouseMove = function(e, me) {
  if (me.isConsumed() || !this.ignoreMouseDown && null == this.first && this.graph.isMouseDown) {
    this.constraintHandler.reset();
  } else {
    if (!(this.isEnabled() || null == this.currentState)) {
      this.destroyIcons();
      /** @type {null} */
      this.currentState = null;
    }
    var value = this.graph.getView();
    var s = value.scale;
    var i = value.translate;
    value = new mxPoint(me.getGraphX(), me.getGraphY());
    /** @type {null} */
    this.error = null;
    if (this.graph.isGridEnabledEvent(me.getEvent())) {
      value = new mxPoint((this.graph.snap(value.x / s - i.x) + i.x) * s, (this.graph.snap(value.y / s - i.y) + i.y) * s);
    }
    this.snapToPreview(me, value);
    this.currentPoint = value;
    if ((null != this.first || this.isEnabled() && this.graph.isEnabled()) && (null != this.shape || null == this.first || Math.abs(me.getGraphX() - this.first.x) > this.graph.tolerance || Math.abs(me.getGraphY() - this.first.y) > this.graph.tolerance)) {
      this.updateCurrentState(me, value);
    }
    if (null != this.first) {
      /** @type {null} */
      var labelWidth = null;
      s = value;
      if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentPoint) {
        labelWidth = this.constraintHandler.currentConstraint;
        s = this.constraintHandler.currentPoint.clone();
      } else {
        if (null != this.previous && !this.graph.isIgnoreTerminalEvent(me.getEvent()) && mxEvent.isShiftDown(me.getEvent())) {
          if (Math.abs(this.previous.getCenterX() - value.x) < Math.abs(this.previous.getCenterY() - value.y)) {
            value.x = this.previous.getCenterX();
          } else {
            value.y = this.previous.getCenterY();
          }
        }
      }
      i = this.first;
      if (null != this.selectedIcon) {
        var size = this.selectedIcon.bounds.width;
        var factor = this.selectedIcon.bounds.height;
        if (null != this.currentState && this.targetConnectImage) {
          size = this.getIconPosition(this.selectedIcon, this.currentState);
          this.selectedIcon.bounds.x = size.x;
          this.selectedIcon.bounds.y = size.y;
        } else {
          size = new mxRectangle(me.getGraphX() + this.connectIconOffset.x, me.getGraphY() + this.connectIconOffset.y, size, factor);
          this.selectedIcon.bounds = size;
        }
        this.selectedIcon.redraw();
      }
      if (null != this.edgeState) {
        this.updateEdgeState(s, labelWidth);
        s = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];
        i = this.edgeState.absolutePoints[0];
      } else {
        if (null != this.currentState && null == this.constraintHandler.currentConstraint) {
          size = this.getTargetPerimeterPoint(this.currentState, me);
          if (null != size) {
            s = size;
          }
        }
        if (null == this.sourceConstraint && null != this.previous) {
          size = this.getSourcePerimeterPoint(this.previous, null != this.waypoints && 0 < this.waypoints.length ? this.waypoints[0] : s, me);
          if (null != size) {
            i = size;
          }
        }
      }
      if (null == this.currentState && this.movePreviewAway) {
        size = i;
        if (null != this.edgeState && 2 <= this.edgeState.absolutePoints.length) {
          labelWidth = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];
          if (null != labelWidth) {
            size = labelWidth;
          }
        }
        /** @type {number} */
        labelWidth = s.x - size.x;
        /** @type {number} */
        size = s.y - size.y;
        /** @type {number} */
        factor = Math.sqrt(labelWidth * labelWidth + size * size);
        if (0 == factor) {
          return;
        }
        this.originalPoint = s.clone();
        s.x -= 4 * labelWidth / factor;
        s.y -= 4 * size / factor;
      } else {
        /** @type {null} */
        this.originalPoint = null;
      }
      if (null == this.shape && (labelWidth = Math.abs(me.getGraphX() - this.first.x), size = Math.abs(me.getGraphY() - this.first.y), labelWidth > this.graph.tolerance || size > this.graph.tolerance)) {
        this.shape = this.createShape();
        if (null != this.edgeState) {
          this.shape.apply(this.edgeState);
        }
        this.updateCurrentState(me, value);
      }
      if (null != this.shape) {
        if (null != this.edgeState) {
          this.shape.points = this.edgeState.absolutePoints;
        } else {
          /** @type {!Array} */
          value = [i];
          if (null != this.waypoints) {
            /** @type {!Array<?>} */
            value = value.concat(this.waypoints);
          }
          value.push(s);
          /** @type {!Array} */
          this.shape.points = value;
        }
        this.drawPreview();
      }
      if (null != this.cursor) {
        this.graph.container.style.cursor = this.cursor;
      }
      mxEvent.consume(me.getEvent());
      me.consume();
    } else {
      if (this.isEnabled() && this.graph.isEnabled()) {
        if (this.previous != this.currentState && null == this.edgeState) {
          this.destroyIcons();
          if (null != this.currentState && null == this.error && null == this.constraintHandler.currentConstraint) {
            this.icons = this.createIcons(this.currentState);
            if (null == this.icons) {
              this.currentState.setCursor(mxConstants.CURSOR_CONNECT);
              me.consume();
            }
          }
          this.previous = this.currentState;
        } else {
          if (!(this.previous != this.currentState || null == this.currentState || null != this.icons || this.graph.isMouseDown)) {
            me.consume();
          }
        }
      } else {
        this.constraintHandler.reset();
      }
    }
    if (!this.graph.isMouseDown && null != this.currentState && null != this.icons) {
      /** @type {boolean} */
      value = false;
      s = me.getSource();
      /** @type {number} */
      i = 0;
      for (; i < this.icons.length && !value; i++) {
        /** @type {boolean} */
        value = s == this.icons[i].node || s.parentNode == this.icons[i].node;
      }
      if (!value) {
        this.updateIcons(this.currentState, this.icons, me);
      }
    }
  }
};
/**
 * @param {!Object} _
 * @param {!Object} v
 * @return {undefined}
 */
mxConnectionHandler.prototype.updateEdgeState = function(_, v) {
  if (null != this.sourceConstraint && null != this.sourceConstraint.point) {
    this.edgeState.style[mxConstants.STYLE_EXIT_X] = this.sourceConstraint.point.x;
    this.edgeState.style[mxConstants.STYLE_EXIT_Y] = this.sourceConstraint.point.y;
  }
  if (null != v && null != v.point) {
    this.edgeState.style[mxConstants.STYLE_ENTRY_X] = v.point.x;
    this.edgeState.style[mxConstants.STYLE_ENTRY_Y] = v.point.y;
  } else {
    delete this.edgeState.style[mxConstants.STYLE_ENTRY_X];
    delete this.edgeState.style[mxConstants.STYLE_ENTRY_Y];
  }
  /** @type {!Array} */
  this.edgeState.absolutePoints = [null, null != this.currentState ? null : _];
  this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);
  if (null != this.currentState) {
    if (null == v) {
      v = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);
    }
    this.edgeState.setAbsoluteTerminalPoint(null, false);
    this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, v);
  }
  /** @type {null} */
  var points = null;
  if (null != this.waypoints) {
    /** @type {!Array} */
    points = [];
    /** @type {number} */
    var j = 0;
    for (; j < this.waypoints.length; j++) {
      var pt = this.waypoints[j].clone();
      this.convertWaypoint(pt);
      points[j] = pt;
    }
  }
  this.graph.view.updatePoints(this.edgeState, points, this.previous, this.currentState);
  this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);
};
/**
 * @param {(Object|string)} self
 * @param {!Object} one
 * @return {?}
 */
mxConnectionHandler.prototype.getTargetPerimeterPoint = function(self, one) {
  /** @type {null} */
  var first = null;
  var v = self.view;
  var func = v.getPerimeterFunction(self);
  if (null != func) {
    var y = null != this.waypoints && 0 < this.waypoints.length ? this.waypoints[this.waypoints.length - 1] : new mxPoint(this.previous.getCenterX(), this.previous.getCenterY());
    v = func(v.getPerimeterBounds(self), this.edgeState, y, false);
    if (null != v) {
      first = v;
    }
  } else {
    first = new mxPoint(self.getCenterX(), self.getCenterY());
  }
  return first;
};
/**
 * @param {!Object} point
 * @param {number} threshold
 * @param {!Object} type
 * @return {?}
 */
mxConnectionHandler.prototype.getSourcePerimeterPoint = function(point, threshold, type) {
  /** @type {null} */
  type = null;
  var node = point.view;
  var resolveSaddlePointWithAvg = node.getPerimeterFunction(point);
  var ct = new mxPoint(point.getCenterX(), point.getCenterY());
  if (null != resolveSaddlePointWithAvg) {
    var g = mxUtils.getValue(point.style, mxConstants.STYLE_ROTATION, 0);
    /** @type {number} */
    var r = Math.PI / 180 * -g;
    if (0 != g) {
      threshold = mxUtils.getRotatedPoint(new mxPoint(threshold.x, threshold.y), Math.cos(r), Math.sin(r), ct);
    }
    point = resolveSaddlePointWithAvg(node.getPerimeterBounds(point), point, threshold, false);
    if (null != point) {
      if (0 != g) {
        point = mxUtils.getRotatedPoint(new mxPoint(point.x, point.y), Math.cos(-r), Math.sin(-r), ct);
      }
      /** @type {!Object} */
      type = point;
    }
  } else {
    type = ct;
  }
  return type;
};
/**
 * @param {?} urls
 * @param {?} callback
 * @param {!Object} page
 * @return {undefined}
 */
mxConnectionHandler.prototype.updateIcons = function(urls, callback, page) {
};
/**
 * @param {!Object} job
 * @return {?}
 */
mxConnectionHandler.prototype.isStopEvent = function(job) {
  return null != job.getState();
};
/**
 * @param {!Object} me
 * @return {undefined}
 */
mxConnectionHandler.prototype.addWaypointForEvent = function(me) {
  var destination = mxUtils.convertPoint(this.graph.container, me.getX(), me.getY());
  /** @type {number} */
  var scale = Math.abs(destination.x - this.first.x);
  /** @type {number} */
  destination = Math.abs(destination.y - this.first.y);
  if (null != this.waypoints || 1 < this.mouseDownCounter && (scale > this.graph.tolerance || destination > this.graph.tolerance)) {
    if (null == this.waypoints) {
      /** @type {!Array} */
      this.waypoints = [];
    }
    scale = this.graph.view.scale;
    destination = new mxPoint(this.graph.snap(me.getGraphX() / scale) * scale, this.graph.snap(me.getGraphY() / scale) * scale);
    this.waypoints.push(destination);
  }
};
/**
 * @param {!Object} op
 * @param {!Object} options
 * @return {?}
 */
mxConnectionHandler.prototype.checkConstraints = function(op, options) {
  return null == op || null == options || null == op.point || null == options.point || !op.point.equals(options.point) || op.dx != options.dx || op.dy != options.dy || op.perimeter != options.perimeter;
};
/**
 * @param {?} e
 * @param {!Event} me
 * @return {undefined}
 */
mxConnectionHandler.prototype.mouseUp = function(e, me) {
  if (!me.isConsumed() && this.isConnecting()) {
    if (this.waypointsEnabled && !this.isStopEvent(me)) {
      this.addWaypointForEvent(me);
      me.consume();
      return;
    }
    var showCalInConv = this.sourceConstraint;
    var selector = this.constraintHandler.currentConstraint;
    var c = null != this.previous ? this.previous.cell : null;
    /** @type {null} */
    var p = null;
    if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus) {
      p = this.constraintHandler.currentFocus.cell;
    }
    if (null == p && null != this.currentState) {
      p = this.currentState.cell;
    }
    if (null != this.error || null != c && null != p && c == p && !this.checkConstraints(showCalInConv, selector)) {
      if (null != this.previous && null != this.marker.validState && this.previous.cell == this.marker.validState.cell) {
        this.graph.selectCellForEvent(this.marker.source, me.getEvent());
      }
      if (null != this.error && 0 < this.error.length) {
        this.graph.validationAlert(this.error);
      }
    } else {
      this.connect(c, p, me.getEvent(), me.getCell());
    }
    this.destroyIcons();
    me.consume();
  }
  if (null != this.first) {
    this.reset();
  }
};
/**
 * @return {undefined}
 */
mxConnectionHandler.prototype.reset = function() {
  if (null != this.shape) {
    this.shape.destroy();
    /** @type {null} */
    this.shape = null;
  }
  if (null != this.cursor && null != this.graph.container) {
    /** @type {string} */
    this.graph.container.style.cursor = "";
  }
  this.destroyIcons();
  this.marker.reset();
  this.constraintHandler.reset();
  /** @type {null} */
  this.sourceConstraint = this.error = this.previous = this.edgeState = this.currentPoint = this.originalPoint = null;
  /** @type {number} */
  this.mouseDownCounter = 0;
  /** @type {null} */
  this.first = null;
  this.fireEvent(new mxEventObject(mxEvent.RESET));
};
/**
 * @return {undefined}
 */
mxConnectionHandler.prototype.drawPreview = function() {
  this.updatePreview(null == this.error);
  this.shape.redraw();
};
/**
 * @param {boolean} dataUrl
 * @return {undefined}
 */
mxConnectionHandler.prototype.updatePreview = function(dataUrl) {
  this.shape.strokewidth = this.getEdgeWidth(dataUrl);
  this.shape.stroke = this.getEdgeColor(dataUrl);
};
/**
 * @param {boolean} ls
 * @return {?}
 */
mxConnectionHandler.prototype.getEdgeColor = function(ls) {
  return ls ? mxConstants.VALID_COLOR : mxConstants.INVALID_COLOR;
};
/**
 * @param {boolean} dataurl
 * @return {?}
 */
mxConnectionHandler.prototype.getEdgeWidth = function(dataurl) {
  return dataurl ? 3 : 1;
};
/**
 * @param {string} i
 * @param {string} element
 * @param {number} node
 * @param {number} value
 * @return {undefined}
 */
mxConnectionHandler.prototype.connect = function(i, element, node, value) {
  if (null != element || this.isCreateTarget(node) || this.graph.allowDanglingEdges) {
    var me = this.graph.getModel();
    /** @type {boolean} */
    var fileSet = false;
    /** @type {null} */
    var b = null;
    me.beginUpdate();
    try {
      if (null != i && null == element && !this.graph.isIgnoreTerminalEvent(node) && this.isCreateTarget(node) && (element = this.createTargetVertex(node, i), null != element)) {
        value = this.graph.getDropTarget([element], node, value);
        /** @type {boolean} */
        fileSet = true;
        if (null != value && this.graph.getModel().isEdge(value)) {
          value = this.graph.getDefaultParent();
        } else {
          var t = this.graph.getView().getState(value);
          if (null != t) {
            var target = me.getGeometry(element);
            target.x -= t.origin.x;
            target.y -= t.origin.y;
          }
        }
        this.graph.addCell(element, value);
      }
      var name = this.graph.getDefaultParent();
      if (null != i && null != element && me.getParent(i) == me.getParent(element) && me.getParent(me.getParent(i)) != me.getRoot()) {
        name = me.getParent(i);
        if (null != i.geometry && i.geometry.relative && null != element.geometry && element.geometry.relative) {
          name = me.getParent(name);
        }
      }
      /** @type {null} */
      var f = t = null;
      if (null != this.edgeState) {
        t = this.edgeState.cell.value;
        f = this.edgeState.cell.style;
      }
      b = this.insertEdge(name, null, t, i, element, f);
      if (null != b) {
        this.graph.setConnectionConstraint(b, i, true, this.sourceConstraint);
        this.graph.setConnectionConstraint(b, element, false, this.constraintHandler.currentConstraint);
        if (null != this.edgeState) {
          me.setGeometry(b, this.edgeState.cell.geometry);
        }
        name = me.getParent(i);
        if (this.isInsertBefore(b, i, element, node, value)) {
          /** @type {string} */
          target = i;
          for (; null != target.parent && null != target.geometry && target.geometry.relative && target.parent != b.parent;) {
            target = this.graph.model.getParent(target);
          }
          if (null != target && null != target.parent && target.parent == b.parent) {
            me.add(name, b, target.parent.getIndex(target));
          }
        }
        var res = me.getGeometry(b);
        if (null == res) {
          res = new mxGeometry;
          /** @type {boolean} */
          res.relative = true;
          me.setGeometry(b, res);
        }
        if (null != this.waypoints && 0 < this.waypoints.length) {
          var scale = this.graph.view.scale;
          var geo = this.graph.view.translate;
          /** @type {!Array} */
          res.points = [];
          /** @type {number} */
          i = 0;
          for (; i < this.waypoints.length; i++) {
            var pt = this.waypoints[i];
            res.points.push(new mxPoint(pt.x / scale - geo.x, pt.y / scale - geo.y));
          }
        }
        if (null == element) {
          var geo = this.graph.view.translate;
          scale = this.graph.view.scale;
          pt = null != this.originalPoint ? new mxPoint(this.originalPoint.x / scale - geo.x, this.originalPoint.y / scale - geo.y) : new mxPoint(this.currentPoint.x / scale - geo.x, this.currentPoint.y / scale - geo.y);
          pt.x -= this.graph.panDx / this.graph.view.scale;
          pt.y -= this.graph.panDy / this.graph.view.scale;
          res.setTerminalPoint(pt, false);
        }
        this.fireEvent(new mxEventObject(mxEvent.CONNECT, "cell", b, "terminal", element, "event", node, "target", value, "terminalInserted", fileSet));
      }
    } catch (logEntry) {
      mxLog.show();
      mxLog.debug(logEntry.message);
    } finally {
      me.endUpdate();
    }
    if (this.select) {
      this.selectCells(b, fileSet ? element : null);
    }
  }
};
/**
 * @param {string} target
 * @param {boolean} includeClasses
 * @return {undefined}
 */
mxConnectionHandler.prototype.selectCells = function(target, includeClasses) {
  this.graph.setSelectionCell(target);
};
/**
 * @param {boolean} parent
 * @param {string} node
 * @param {string} source
 * @param {string} i
 * @param {string} value
 * @param {string} start
 * @return {?}
 */
mxConnectionHandler.prototype.insertEdge = function(parent, node, source, i, value, start) {
  if (null == this.factoryMethod) {
    return this.graph.insertEdge(parent, node, source, i, value, start);
  }
  node = this.createEdge(source, i, value, start);
  return node = this.graph.addEdge(node, parent, i, value);
};
/**
 * @param {number} sc
 * @param {string} element
 * @return {?}
 */
mxConnectionHandler.prototype.createTargetVertex = function(sc, element) {
  var item = this.graph.getCellGeometry(element);
  for (; null != item && item.relative;) {
    element = this.graph.getModel().getParent(element);
    item = this.graph.getCellGeometry(element);
  }
  var target = this.graph.cloneCell(element);
  item = this.graph.getModel().getGeometry(target);
  if (null != item) {
    var t = this.graph.view.translate;
    var scale = this.graph.view.scale;
    var pt = new mxPoint(this.currentPoint.x / scale - t.x, this.currentPoint.y / scale - t.y);
    /** @type {number} */
    item.x = Math.round(pt.x - item.width / 2 - this.graph.panDx / scale);
    /** @type {number} */
    item.y = Math.round(pt.y - item.height / 2 - this.graph.panDy / scale);
    pt = this.getAlignmentTolerance();
    if (0 < pt) {
      var pos = this.graph.view.getState(element);
      if (null != pos) {
        /** @type {number} */
        var i = pos.x / scale - t.x;
        /** @type {number} */
        t = pos.y / scale - t.y;
        if (Math.abs(i - item.x) <= pt) {
          /** @type {number} */
          item.x = Math.round(i);
        }
        if (Math.abs(t - item.y) <= pt) {
          /** @type {number} */
          item.y = Math.round(t);
        }
      }
    }
  }
  return target;
};
/**
 * @param {?} a
 * @return {?}
 */
mxConnectionHandler.prototype.getAlignmentTolerance = function(a) {
  return this.graph.isGridEnabled() ? this.graph.gridSize / 2 : this.graph.tolerance;
};
/**
 * @param {string} a
 * @param {string} b
 * @param {string} input
 * @param {string} name
 * @return {?}
 */
mxConnectionHandler.prototype.createEdge = function(a, b, input, name) {
  /** @type {null} */
  var g = null;
  if (null != this.factoryMethod) {
    g = this.factoryMethod(b, input, name);
  }
  if (null == g) {
    g = new mxCell(a || "");
    g.setEdge(true);
    g.setStyle(name);
    a = new mxGeometry;
    /** @type {boolean} */
    a.relative = true;
    g.setGeometry(a);
  }
  return g;
};
/**
 * @return {undefined}
 */
mxConnectionHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  if (null != this.shape) {
    this.shape.destroy();
    /** @type {null} */
    this.shape = null;
  }
  if (null != this.marker) {
    this.marker.destroy();
    /** @type {null} */
    this.marker = null;
  }
  if (null != this.constraintHandler) {
    this.constraintHandler.destroy();
    /** @type {null} */
    this.constraintHandler = null;
  }
  if (null != this.changeHandler) {
    this.graph.getModel().removeListener(this.changeHandler);
    this.graph.getView().removeListener(this.changeHandler);
    /** @type {null} */
    this.changeHandler = null;
  }
  if (null != this.drillHandler) {
    this.graph.removeListener(this.drillHandler);
    this.graph.getView().removeListener(this.drillHandler);
    /** @type {null} */
    this.drillHandler = null;
  }
  if (null != this.escapeHandler) {
    this.graph.removeListener(this.escapeHandler);
    /** @type {null} */
    this.escapeHandler = null;
  }
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxConstraintHandler(targetGraph) {
  /** @type {!Object} */
  this.graph = targetGraph;
  this.resetHandler = mxUtils.bind(this, function(a, canCreateDiscussions) {
    if (null != this.currentFocus && null == this.graph.view.getState(this.currentFocus.cell)) {
      this.reset();
    } else {
      this.redraw();
    }
  });
  this.graph.model.addListener(mxEvent.CHANGE, this.resetHandler);
  this.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.resetHandler);
  this.graph.view.addListener(mxEvent.TRANSLATE, this.resetHandler);
  this.graph.view.addListener(mxEvent.SCALE, this.resetHandler);
  this.graph.addListener(mxEvent.ROOT, this.resetHandler);
}
mxConstraintHandler.prototype.pointImage = new mxImage(mxClient.imageBasePath + "/point.gif", 5, 5);
/** @type {null} */
mxConstraintHandler.prototype.graph = null;
/** @type {boolean} */
mxConstraintHandler.prototype.enabled = true;
/** @type {string} */
mxConstraintHandler.prototype.highlightColor = mxConstants.DEFAULT_VALID_COLOR;
/**
 * @return {?}
 */
mxConstraintHandler.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxConstraintHandler.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @return {undefined}
 */
mxConstraintHandler.prototype.reset = function() {
  if (null != this.focusIcons) {
    /** @type {number} */
    var i = 0;
    for (; i < this.focusIcons.length; i++) {
      this.focusIcons[i].destroy();
    }
    /** @type {null} */
    this.focusIcons = null;
  }
  if (null != this.focusHighlight) {
    this.focusHighlight.destroy();
    /** @type {null} */
    this.focusHighlight = null;
  }
  /** @type {null} */
  this.focusPoints = this.currentFocus = this.currentPoint = this.currentFocusArea = this.currentConstraint = null;
};
/**
 * @param {!Function} object
 * @return {?}
 */
mxConstraintHandler.prototype.getTolerance = function(object) {
  return this.graph.getTolerance();
};
/**
 * @param {!Object} dbRow
 * @param {?} queryContext
 * @param {?} row
 * @return {?}
 */
mxConstraintHandler.prototype.getImageForConstraint = function(dbRow, queryContext, row) {
  return this.pointImage;
};
/**
 * @param {!Function} type
 * @param {!Object} who
 * @return {?}
 */
mxConstraintHandler.prototype.isEventIgnored = function(type, who) {
  return false;
};
/**
 * @param {!Object} tag
 * @param {number} prefix
 * @return {?}
 */
mxConstraintHandler.prototype.isStateIgnored = function(tag, prefix) {
  return false;
};
/**
 * @return {undefined}
 */
mxConstraintHandler.prototype.destroyIcons = function() {
  if (null != this.focusIcons) {
    /** @type {number} */
    var i = 0;
    for (; i < this.focusIcons.length; i++) {
      this.focusIcons[i].destroy();
    }
    /** @type {null} */
    this.focusPoints = this.focusIcons = null;
  }
};
/**
 * @return {undefined}
 */
mxConstraintHandler.prototype.destroyFocusHighlight = function() {
  if (null != this.focusHighlight) {
    this.focusHighlight.destroy();
    /** @type {null} */
    this.focusHighlight = null;
  }
};
/**
 * @param {number} scope
 * @return {?}
 */
mxConstraintHandler.prototype.isKeepFocusEvent = function(scope) {
  return mxEvent.isShiftDown(scope.getEvent());
};
/**
 * @param {number} me
 * @param {!Object} event
 * @return {?}
 */
mxConstraintHandler.prototype.getCellForEvent = function(me, event) {
  var el = me.getCell();
  if (!(null != el || null == event || me.getGraphX() == event.x && me.getGraphY() == event.y)) {
    el = this.graph.getCellAt(event.x, event.y);
  }
  if (null != el && !this.graph.isCellConnectable(el)) {
    var element = this.graph.getModel().getParent(el);
    if (this.graph.getModel().isVertex(element) && this.graph.isCellConnectable(element)) {
      el = element;
    }
  }
  return this.graph.isCellLocked(el) ? null : el;
};
/**
 * @param {number} key
 * @param {number} min
 * @param {boolean} max
 * @param {!Object} query
 * @return {undefined}
 */
mxConstraintHandler.prototype.update = function(key, min, max, query) {
  if (this.isEnabled() && !this.isEventIgnored(key)) {
    if (null == this.mouseleaveHandler && null != this.graph.container) {
      this.mouseleaveHandler = mxUtils.bind(this, function() {
        this.reset();
      });
      mxEvent.addListener(this.graph.container, "mouseleave", this.resetHandler);
    }
    var tol = this.getTolerance(key);
    var y = null != query ? query.x : key.getGraphX();
    var x = null != query ? query.y : key.getGraphY();
    y = new mxRectangle(y - tol, x - tol, 2 * tol, 2 * tol);
    tol = new mxRectangle(key.getGraphX() - tol, key.getGraphY() - tol, 2 * tol, 2 * tol);
    var node = this.graph.view.getState(this.getCellForEvent(key, query));
    if (!(this.isKeepFocusEvent(key) || null != this.currentFocusArea && null != this.currentFocus && null == node && this.graph.getModel().isVertex(this.currentFocus.cell) && mxUtils.intersects(this.currentFocusArea, tol) || node == this.currentFocus)) {
      /** @type {null} */
      this.currentFocus = this.currentFocusArea = null;
      this.setFocus(key, node, min);
    }
    /** @type {null} */
    key = this.currentPoint = this.currentConstraint = null;
    if (null != this.focusIcons && null != this.constraints && (null == node || this.currentFocus == node)) {
      x = tol.getCenterX();
      var l = tol.getCenterY();
      /** @type {number} */
      var i = 0;
      for (; i < this.focusIcons.length; i++) {
        /** @type {number} */
        var longX = x - this.focusIcons[i].bounds.getCenterX();
        /** @type {number} */
        var longY = l - this.focusIcons[i].bounds.getCenterY();
        /** @type {number} */
        longX = longX * longX + longY * longY;
        if ((this.intersects(this.focusIcons[i], tol, min, max) || null != query && this.intersects(this.focusIcons[i], y, min, max)) && (null == key || longX < key)) {
          this.currentConstraint = this.constraints[i];
          this.currentPoint = this.focusPoints[i];
          /** @type {number} */
          key = longX;
          longX = this.focusIcons[i].bounds.clone();
          longX.grow(mxConstants.HIGHLIGHT_SIZE + 1);
          --longX.width;
          --longX.height;
          if (null == this.focusHighlight) {
            longY = this.createHighlightShape();
            longY.dialect = this.graph.dialect == mxConstants.DIALECT_SVG ? mxConstants.DIALECT_SVG : mxConstants.DIALECT_VML;
            /** @type {boolean} */
            longY.pointerEvents = false;
            longY.init(this.graph.getView().getOverlayPane());
            this.focusHighlight = longY;
            var update = mxUtils.bind(this, function() {
              return null != this.currentFocus ? this.currentFocus : node;
            });
            mxEvent.redirectMouseEvents(longY.node, this.graph, update);
          }
          this.focusHighlight.bounds = longX;
          this.focusHighlight.redraw();
        }
      }
    }
    if (null == this.currentConstraint) {
      this.destroyFocusHighlight();
    }
  } else {
    /** @type {null} */
    this.currentPoint = this.currentFocus = this.currentConstraint = null;
  }
};
/**
 * @return {undefined}
 */
mxConstraintHandler.prototype.redraw = function() {
  if (null != this.currentFocus && null != this.constraints && null != this.focusIcons) {
    var table = this.graph.view.getState(this.currentFocus.cell);
    this.currentFocus = table;
    this.currentFocusArea = new mxRectangle(table.x, table.y, table.width, table.height);
    /** @type {number} */
    var i = 0;
    for (; i < this.constraints.length; i++) {
      var d = this.graph.getConnectionPoint(table, this.constraints[i]);
      var bounds = this.getImageForConstraint(table, this.constraints[i], d);
      bounds = new mxRectangle(Math.round(d.x - bounds.width / 2), Math.round(d.y - bounds.height / 2), bounds.width, bounds.height);
      this.focusIcons[i].bounds = bounds;
      this.focusIcons[i].redraw();
      this.currentFocusArea.add(this.focusIcons[i].bounds);
      this.focusPoints[i] = d;
    }
  }
};
/**
 * @param {!Function} view
 * @param {!Object} table
 * @param {number} i
 * @return {undefined}
 */
mxConstraintHandler.prototype.setFocus = function(view, table, i) {
  this.constraints = null != table && !this.isStateIgnored(table, i) && this.graph.isCellConnectable(table.cell) ? this.isEnabled() ? this.graph.getAllConnectionConstraints(table, i) || [] : [] : null;
  if (null != this.constraints) {
    /** @type {!Object} */
    this.currentFocus = table;
    this.currentFocusArea = new mxRectangle(table.x, table.y, table.width, table.height);
    if (null != this.focusIcons) {
      /** @type {number} */
      i = 0;
      for (; i < this.focusIcons.length; i++) {
        this.focusIcons[i].destroy();
      }
      /** @type {null} */
      this.focusPoints = this.focusIcons = null;
    }
    /** @type {!Array} */
    this.focusPoints = [];
    /** @type {!Array} */
    this.focusIcons = [];
    /** @type {number} */
    i = 0;
    for (; i < this.constraints.length; i++) {
      var head = this.graph.getConnectionPoint(table, this.constraints[i]);
      var result = this.getImageForConstraint(table, this.constraints[i], head);
      var e = result.src;
      result = new mxRectangle(Math.round(head.x - result.width / 2), Math.round(head.y - result.height / 2), result.width, result.height);
      e = new mxImageShape(result, e);
      e.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
      /** @type {boolean} */
      e.preserveImageAspect = false;
      e.init(this.graph.getView().getDecoratorPane());
      if (mxClient.IS_QUIRKS || 8 == document.documentMode) {
        mxEvent.addListener(e.node, "dragstart", function(e) {
          mxEvent.consume(e);
          return false;
        });
      }
      if (null != e.node.previousSibling) {
        e.node.parentNode.insertBefore(e.node, e.node.parentNode.firstChild);
      }
      result = mxUtils.bind(this, function() {
        return null != this.currentFocus ? this.currentFocus : table;
      });
      e.redraw();
      mxEvent.redirectMouseEvents(e.node, this.graph, result);
      this.currentFocusArea.add(e.bounds);
      this.focusIcons.push(e);
      this.focusPoints.push(head);
    }
    this.currentFocusArea.grow(this.getTolerance(view));
  } else {
    this.destroyIcons();
    this.destroyFocusHighlight();
  }
};
/**
 * @return {?}
 */
mxConstraintHandler.prototype.createHighlightShape = function() {
  var control = new mxRectangleShape(null, this.highlightColor, this.highlightColor, mxConstants.HIGHLIGHT_STROKEWIDTH);
  control.opacity = mxConstants.HIGHLIGHT_OPACITY;
  return control;
};
/**
 * @param {!Object} obj
 * @param {!Object} x
 * @param {number} y
 * @param {boolean} w
 * @return {?}
 */
mxConstraintHandler.prototype.intersects = function(obj, x, y, w) {
  return mxUtils.intersects(obj.bounds, x);
};
/**
 * @return {undefined}
 */
mxConstraintHandler.prototype.destroy = function() {
  this.reset();
  if (null != this.resetHandler) {
    this.graph.model.removeListener(this.resetHandler);
    this.graph.view.removeListener(this.resetHandler);
    this.graph.removeListener(this.resetHandler);
    /** @type {null} */
    this.resetHandler = null;
  }
  if (null != this.mouseleaveHandler && null != this.graph.container) {
    mxEvent.removeListener(this.graph.container, "mouseleave", this.mouseleaveHandler);
    /** @type {null} */
    this.mouseleaveHandler = null;
  }
};
/**
 * @param {!Object} targetGraph
 * @return {undefined}
 */
function mxRubberband(targetGraph) {
  if (null != targetGraph) {
    /** @type {!Object} */
    this.graph = targetGraph;
    this.graph.addMouseListener(this);
    this.forceRubberbandHandler = mxUtils.bind(this, function(a, c) {
      var pageOffset = c.getProperty("eventName");
      var event = c.getProperty("event");
      if (pageOffset == mxEvent.MOUSE_DOWN && this.isForceRubberbandEvent(event)) {
        pageOffset = mxUtils.getOffset(this.graph.container);
        var paperRect = mxUtils.getScrollOrigin(this.graph.container);
        paperRect.x -= pageOffset.x;
        paperRect.y -= pageOffset.y;
        this.start(event.getX() + paperRect.x, event.getY() + paperRect.y);
        event.consume(false);
      }
    });
    this.graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.forceRubberbandHandler);
    this.panHandler = mxUtils.bind(this, function() {
      this.repaint();
    });
    this.graph.addListener(mxEvent.PAN, this.panHandler);
    this.gestureHandler = mxUtils.bind(this, function(a, canCreateDiscussions) {
      if (null != this.first) {
        this.reset();
      }
    });
    this.graph.addListener(mxEvent.GESTURE, this.gestureHandler);
    if (mxClient.IS_IE) {
      mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
        this.destroy();
      }));
    }
  }
}
/** @type {number} */
mxRubberband.prototype.defaultOpacity = 20;
/** @type {boolean} */
mxRubberband.prototype.enabled = true;
/** @type {null} */
mxRubberband.prototype.div = null;
/** @type {null} */
mxRubberband.prototype.sharedDiv = null;
/** @type {number} */
mxRubberband.prototype.currentX = 0;
/** @type {number} */
mxRubberband.prototype.currentY = 0;
/** @type {boolean} */
mxRubberband.prototype.fadeOut = false;
/**
 * @return {?}
 */
mxRubberband.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxRubberband.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @param {?} event
 * @return {?}
 */
mxRubberband.prototype.isForceRubberbandEvent = function(event) {
  return mxEvent.isAltDown(event.getEvent());
};
/**
 * @param {!Object} e
 * @param {!Object} me
 * @return {undefined}
 */
mxRubberband.prototype.mouseDown = function(e, me) {
  if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && null == me.getState() && !mxEvent.isMultiTouchEvent(me.getEvent())) {
    var pageOffset = mxUtils.getOffset(this.graph.container);
    var paperRect = mxUtils.getScrollOrigin(this.graph.container);
    paperRect.x -= pageOffset.x;
    paperRect.y -= pageOffset.y;
    this.start(me.getX() + paperRect.x, me.getY() + paperRect.y);
    me.consume(false);
  }
};
/**
 * @param {!Object} x
 * @param {string} height
 * @return {undefined}
 */
mxRubberband.prototype.start = function(x, height) {
  /**
   * @param {!Object} that
   * @return {?}
   */
  function update(that) {
    that = new mxMouseEvent(that);
    var events = mxUtils.convertPoint(node, that.getX(), that.getY());
    that.graphX = events.x;
    that.graphY = events.y;
    return that;
  }
  this.first = new mxPoint(x, height);
  var node = this.graph.container;
  this.dragHandler = mxUtils.bind(this, function(obj) {
    this.mouseMove(this.graph, update(obj));
  });
  this.dropHandler = mxUtils.bind(this, function(obj) {
    this.mouseUp(this.graph, update(obj));
  });
  if (mxClient.IS_FF) {
    mxEvent.addGestureListeners(document, null, this.dragHandler, this.dropHandler);
  }
};
/**
 * @param {?} e
 * @param {!Object} me
 * @return {undefined}
 */
mxRubberband.prototype.mouseMove = function(e, me) {
  if (!me.isConsumed() && null != this.first) {
    var position = mxUtils.getScrollOrigin(this.graph.container);
    var offset = mxUtils.getOffset(this.graph.container);
    position.x -= offset.x;
    position.y -= offset.y;
    offset = me.getX() + position.x;
    position = me.getY() + position.y;
    /** @type {number} */
    var chooseOffset = this.first.x - offset;
    /** @type {number} */
    var sinA_ = this.first.y - position;
    var sinC = this.graph.tolerance;
    if (null != this.div || Math.abs(chooseOffset) > sinC || Math.abs(sinA_) > sinC) {
      if (null == this.div) {
        this.div = this.createShape();
      }
      mxUtils.clearSelection();
      this.update(offset, position);
      me.consume();
    }
  }
};
/**
 * @return {?}
 */
mxRubberband.prototype.createShape = function() {
  if (null == this.sharedDiv) {
    /** @type {!Element} */
    this.sharedDiv = document.createElement("div");
    /** @type {string} */
    this.sharedDiv.className = "mxRubberband";
    mxUtils.setOpacity(this.sharedDiv, this.defaultOpacity);
  }
  this.graph.container.appendChild(this.sharedDiv);
  var shape = this.sharedDiv;
  if (mxClient.IS_SVG && (!mxClient.IS_IE || 10 <= document.documentMode) && this.fadeOut) {
    /** @type {null} */
    this.sharedDiv = null;
  }
  return shape;
};
/**
 * @param {?} areaSets
 * @param {?} highlightSubsets
 * @return {?}
 */
mxRubberband.prototype.isActive = function(areaSets, highlightSubsets) {
  return null != this.div && "none" != this.div.style.display;
};
/**
 * @param {?} editor
 * @param {!Event} e
 * @return {undefined}
 */
mxRubberband.prototype.mouseUp = function(editor, e) {
  var active = this.isActive();
  this.reset();
  if (active) {
    this.execute(e.getEvent());
    e.consume();
  }
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
mxRubberband.prototype.execute = function(value) {
  var d = new mxRectangle(this.x, this.y, this.width, this.height);
  this.graph.selectRegion(d, value);
};
/**
 * @return {undefined}
 */
mxRubberband.prototype.reset = function() {
  if (null != this.div) {
    if (mxClient.IS_SVG && (!mxClient.IS_IE || 10 <= document.documentMode) && this.fadeOut) {
      var div = this.div;
      mxUtils.setPrefixedStyle(div.style, "transition", "all 0.2s linear");
      /** @type {string} */
      div.style.pointerEvents = "none";
      /** @type {number} */
      div.style.opacity = 0;
      window.setTimeout(function() {
        div.parentNode.removeChild(div);
      }, 200);
    } else {
      this.div.parentNode.removeChild(this.div);
    }
  }
  mxEvent.removeGestureListeners(document, null, this.dragHandler, this.dropHandler);
  /** @type {null} */
  this.dropHandler = this.dragHandler = null;
  /** @type {number} */
  this.currentY = this.currentX = 0;
  /** @type {null} */
  this.div = this.first = null;
};
/**
 * @param {number} x
 * @param {number} y
 * @return {undefined}
 */
mxRubberband.prototype.update = function(x, y) {
  /** @type {number} */
  this.currentX = x;
  /** @type {number} */
  this.currentY = y;
  this.repaint();
};
/**
 * @return {undefined}
 */
mxRubberband.prototype.repaint = function() {
  if (null != this.div) {
    /** @type {number} */
    var dy = this.currentX - this.graph.panDx;
    /** @type {number} */
    var n = this.currentY - this.graph.panDy;
    /** @type {number} */
    this.x = Math.min(this.first.x, dy);
    /** @type {number} */
    this.y = Math.min(this.first.y, n);
    /** @type {number} */
    this.width = Math.max(this.first.x, dy) - this.x;
    /** @type {number} */
    this.height = Math.max(this.first.y, n) - this.y;
    dy = mxClient.IS_VML ? this.graph.panDy : 0;
    /** @type {string} */
    this.div.style.left = this.x + (mxClient.IS_VML ? this.graph.panDx : 0) + "px";
    /** @type {string} */
    this.div.style.top = this.y + dy + "px";
    /** @type {string} */
    this.div.style.width = Math.max(1, this.width) + "px";
    /** @type {string} */
    this.div.style.height = Math.max(1, this.height) + "px";
  }
};
/**
 * @return {undefined}
 */
mxRubberband.prototype.destroy = function() {
  if (!this.destroyed) {
    /** @type {boolean} */
    this.destroyed = true;
    this.graph.removeMouseListener(this);
    this.graph.removeListener(this.forceRubberbandHandler);
    this.graph.removeListener(this.panHandler);
    this.reset();
    if (null != this.sharedDiv) {
      /** @type {null} */
      this.sharedDiv = null;
    }
  }
};
/**
 * @param {!Object} state
 * @param {string} name
 * @param {string} m
 * @param {!Object} _succeeded
 * @return {undefined}
 */
function mxHandle(state, name, m, _succeeded) {
  this.graph = state.view.graph;
  /** @type {!Object} */
  this.state = state;
  this.cursor = null != name ? name : this.cursor;
  this.image = null != m ? m : this.image;
  this.shape = null != _succeeded ? _succeeded : null;
  this.init();
}
/** @type {string} */
mxHandle.prototype.cursor = "default";
/** @type {null} */
mxHandle.prototype.image = null;
/** @type {boolean} */
mxHandle.prototype.ignoreGrid = false;
/**
 * @param {?} time_in_millis
 * @return {undefined}
 */
mxHandle.prototype.getPosition = function(time_in_millis) {
};
/**
 * @param {?} ignoreActions
 * @param {?} jump
 * @param {!Object} callback
 * @return {undefined}
 */
mxHandle.prototype.setPosition = function(ignoreActions, jump, callback) {
};
/**
 * @param {!Object} obj
 * @return {undefined}
 */
mxHandle.prototype.execute = function(obj) {
};
/**
 * @param {(Object|string)} key
 * @return {undefined}
 */
mxHandle.prototype.copyStyle = function(key) {
  this.graph.setCellStyles(key, this.state.style[key], [this.state.cell]);
};
/**
 * @param {!Object} me
 * @return {undefined}
 */
mxHandle.prototype.processEvent = function(me) {
  var scale = this.graph.view.scale;
  var start = this.graph.view.translate;
  start = new mxPoint(me.getGraphX() / scale - start.x, me.getGraphY() / scale - start.y);
  if (null != this.shape && null != this.shape.bounds) {
    start.x -= this.shape.bounds.width / scale / 4;
    start.y -= this.shape.bounds.height / scale / 4;
  }
  /** @type {number} */
  scale = -mxUtils.toRadians(this.getRotation());
  /** @type {number} */
  var y = -mxUtils.toRadians(this.getTotalRotation()) - scale;
  start = this.flipPoint(this.rotatePoint(this.snapPoint(this.rotatePoint(start, scale), this.ignoreGrid || !this.graph.isGridEnabledEvent(me.getEvent())), y));
  this.setPosition(this.state.getPaintBounds(), start, me);
  this.redraw();
};
/**
 * @return {undefined}
 */
mxHandle.prototype.positionChanged = function() {
  if (null != this.state.text) {
    this.state.text.apply(this.state);
  }
  if (null != this.state.shape) {
    this.state.shape.apply(this.state);
  }
  this.graph.cellRenderer.redraw(this.state, true);
};
/**
 * @return {?}
 */
mxHandle.prototype.getRotation = function() {
  return null != this.state.shape ? this.state.shape.getRotation() : 0;
};
/**
 * @return {?}
 */
mxHandle.prototype.getTotalRotation = function() {
  return null != this.state.shape ? this.state.shape.getShapeRotation() : 0;
};
/**
 * @return {undefined}
 */
mxHandle.prototype.init = function() {
  var from = this.isHtmlRequired();
  if (null != this.image) {
    this.shape = new mxImageShape(new mxRectangle(0, 0, this.image.width, this.image.height), this.image.src);
    /** @type {boolean} */
    this.shape.preserveImageAspect = false;
  } else {
    if (null == this.shape) {
      this.shape = this.createShape(from);
    }
  }
  this.initShape(from);
};
/**
 * @param {string} bounds
 * @return {?}
 */
mxHandle.prototype.createShape = function(bounds) {
  bounds = new mxRectangle(0, 0, mxConstants.HANDLE_SIZE, mxConstants.HANDLE_SIZE);
  return new mxRectangleShape(bounds, mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
};
/**
 * @param {?} item
 * @return {undefined}
 */
mxHandle.prototype.initShape = function(item) {
  if (item && this.shape.isHtmlAllowed()) {
    this.shape.dialect = mxConstants.DIALECT_STRICTHTML;
    this.shape.init(this.graph.container);
  } else {
    this.shape.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
    if (null != this.cursor) {
      this.shape.init(this.graph.getView().getOverlayPane());
    }
  }
  mxEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);
  this.shape.node.style.cursor = this.cursor;
};
/**
 * @return {undefined}
 */
mxHandle.prototype.redraw = function() {
  if (null != this.shape && null != this.state.shape) {
    var p = this.getPosition(this.state.getPaintBounds());
    if (null != p) {
      var y = mxUtils.toRadians(this.getTotalRotation());
      p = this.rotatePoint(this.flipPoint(p), y);
      y = this.graph.view.scale;
      var t = this.graph.view.translate;
      /** @type {number} */
      this.shape.bounds.x = Math.floor((p.x + t.x) * y - this.shape.bounds.width / 2);
      /** @type {number} */
      this.shape.bounds.y = Math.floor((p.y + t.y) * y - this.shape.bounds.height / 2);
      this.shape.redraw();
    }
  }
};
/**
 * @return {?}
 */
mxHandle.prototype.isHtmlRequired = function() {
  return null != this.state.text && this.state.text.node.parentNode == this.graph.container;
};
/**
 * @param {number} a
 * @param {number} x
 * @return {?}
 */
mxHandle.prototype.rotatePoint = function(a, x) {
  var ellipse = this.state.getCellBounds();
  ellipse = new mxPoint(ellipse.getCenterX(), ellipse.getCenterY());
  return mxUtils.getRotatedPoint(a, Math.cos(x), Math.sin(x), ellipse);
};
/**
 * @param {!Object} npoint
 * @return {?}
 */
mxHandle.prototype.flipPoint = function(npoint) {
  if (null != this.state.shape) {
    var arg_json = this.state.getCellBounds();
    if (this.state.shape.flipH) {
      /** @type {number} */
      npoint.x = 2 * arg_json.x + arg_json.width - npoint.x;
    }
    if (this.state.shape.flipV) {
      /** @type {number} */
      npoint.y = 2 * arg_json.y + arg_json.height - npoint.y;
    }
  }
  return npoint;
};
/**
 * @param {!Object} pt
 * @param {?} lastRotate
 * @return {?}
 */
mxHandle.prototype.snapPoint = function(pt, lastRotate) {
  if (!lastRotate) {
    pt.x = this.graph.snap(pt.x);
    pt.y = this.graph.snap(pt.y);
  }
  return pt;
};
/**
 * @param {boolean} isVisible
 * @return {undefined}
 */
mxHandle.prototype.setVisible = function(isVisible) {
  if (null != this.shape && null != this.shape.node) {
    /** @type {string} */
    this.shape.node.style.display = isVisible ? "" : "none";
  }
};
/**
 * @return {undefined}
 */
mxHandle.prototype.reset = function() {
  this.setVisible(true);
  this.state.style = this.graph.getCellStyle(this.state.cell);
  this.positionChanged();
};
/**
 * @return {undefined}
 */
mxHandle.prototype.destroy = function() {
  if (null != this.shape) {
    this.shape.destroy();
    /** @type {null} */
    this.shape = null;
  }
};
/**
 * @param {!Object} value
 * @return {undefined}
 */
function mxVertexHandler(value) {
  if (null != value) {
    /** @type {!Object} */
    this.state = value;
    this.init();
    this.escapeHandler = mxUtils.bind(this, function(a, canCreateDiscussions) {
      if (this.livePreview && null != this.index) {
        this.state.view.graph.cellRenderer.redraw(this.state, true);
        this.state.view.invalidate(this.state.cell);
        /** @type {boolean} */
        this.state.invalid = false;
        this.state.view.validate();
      }
      this.reset();
    });
    this.state.view.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
  }
}
/** @type {null} */
mxVertexHandler.prototype.graph = null;
/** @type {null} */
mxVertexHandler.prototype.state = null;
/** @type {boolean} */
mxVertexHandler.prototype.singleSizer = false;
/** @type {null} */
mxVertexHandler.prototype.index = null;
/** @type {boolean} */
mxVertexHandler.prototype.allowHandleBoundsCheck = true;
/** @type {null} */
mxVertexHandler.prototype.handleImage = null;
/** @type {boolean} */
mxVertexHandler.prototype.handlesVisible = true;
/** @type {number} */
mxVertexHandler.prototype.tolerance = 0;
/** @type {boolean} */
mxVertexHandler.prototype.rotationEnabled = false;
/** @type {boolean} */
mxVertexHandler.prototype.parentHighlightEnabled = false;
/** @type {boolean} */
mxVertexHandler.prototype.rotationRaster = true;
/** @type {string} */
mxVertexHandler.prototype.rotationCursor = "crosshair";
/** @type {boolean} */
mxVertexHandler.prototype.livePreview = false;
/** @type {boolean} */
mxVertexHandler.prototype.movePreviewToFront = false;
/** @type {boolean} */
mxVertexHandler.prototype.manageSizers = false;
/** @type {boolean} */
mxVertexHandler.prototype.constrainGroupByChildren = false;
/** @type {number} */
mxVertexHandler.prototype.rotationHandleVSpacing = -16;
/** @type {number} */
mxVertexHandler.prototype.horizontalOffset = 0;
/** @type {number} */
mxVertexHandler.prototype.verticalOffset = 0;
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.init = function() {
  this.graph = this.state.view.graph;
  this.selectionBounds = this.getSelectionBounds(this.state);
  this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
  this.selectionBorder = this.createSelectionShape(this.bounds);
  this.selectionBorder.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
  /** @type {boolean} */
  this.selectionBorder.pointerEvents = false;
  /** @type {number} */
  this.selectionBorder.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
  this.selectionBorder.init(this.graph.getView().getOverlayPane());
  mxEvent.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);
  if (this.graph.isCellMovable(this.state.cell)) {
    this.selectionBorder.setCursor(mxConstants.CURSOR_MOVABLE_VERTEX);
  }
  if (0 >= mxGraphHandler.prototype.maxCells || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells) {
    var other = this.graph.isCellResizable(this.state.cell);
    /** @type {!Array} */
    this.sizers = [];
    if (other || this.graph.isLabelMovable(this.state.cell) && 2 <= this.state.width && 2 <= this.state.height) {
      /** @type {number} */
      var b = 0;
      if (other) {
        if (!this.singleSizer) {
          this.sizers.push(this.createSizer("nw-resize", b++));
          this.sizers.push(this.createSizer("n-resize", b++));
          this.sizers.push(this.createSizer("ne-resize", b++));
          this.sizers.push(this.createSizer("w-resize", b++));
          this.sizers.push(this.createSizer("e-resize", b++));
          this.sizers.push(this.createSizer("sw-resize", b++));
          this.sizers.push(this.createSizer("s-resize", b++));
        }
        this.sizers.push(this.createSizer("se-resize", b++));
      }
      other = this.graph.model.getGeometry(this.state.cell);
      if (!(null == other || other.relative || this.graph.isSwimlane(this.state.cell) || !this.graph.isLabelMovable(this.state.cell))) {
        this.labelShape = this.createSizer(mxConstants.CURSOR_LABEL_HANDLE, mxEvent.LABEL_HANDLE, mxConstants.LABEL_HANDLE_SIZE, mxConstants.LABEL_HANDLE_FILLCOLOR);
        this.sizers.push(this.labelShape);
      }
    } else {
      if (this.graph.isCellMovable(this.state.cell) && !this.graph.isCellResizable(this.state.cell) && 2 > this.state.width && 2 > this.state.height) {
        this.labelShape = this.createSizer(mxConstants.CURSOR_MOVABLE_VERTEX, mxEvent.LABEL_HANDLE, null, mxConstants.LABEL_HANDLE_FILLCOLOR);
        this.sizers.push(this.labelShape);
      }
    }
  }
  if (this.isRotationHandleVisible()) {
    this.rotationShape = this.createSizer(this.rotationCursor, mxEvent.ROTATION_HANDLE, mxConstants.HANDLE_SIZE + 3, mxConstants.HANDLE_FILLCOLOR);
    this.sizers.push(this.rotationShape);
  }
  this.customHandles = this.createCustomHandles();
  this.redraw();
  if (this.constrainGroupByChildren) {
    this.updateMinBounds();
  }
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.isRotationHandleVisible = function() {
  return this.graph.isEnabled() && this.rotationEnabled && this.graph.isCellRotatable(this.state.cell) && (0 >= mxGraphHandler.prototype.maxCells || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells);
};
/**
 * @param {!Object} tree
 * @return {?}
 */
mxVertexHandler.prototype.isConstrainedEvent = function(tree) {
  return mxEvent.isShiftDown(tree.getEvent()) || "fixed" == this.state.style[mxConstants.STYLE_ASPECT];
};
/**
 * @param {?} requestWaterMask
 * @param {!Object} f
 * @return {?}
 */
mxVertexHandler.prototype.isCenteredEvent = function(requestWaterMask, f) {
  return false;
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.createCustomHandles = function() {
  return null;
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.updateMinBounds = function() {
  var scale = this.graph.getChildCells(this.state.cell);
  if (0 < scale.length && (this.minBounds = this.graph.view.getBounds(scale), null != this.minBounds)) {
    scale = this.state.view.scale;
    var geo = this.state.view.translate;
    this.minBounds.x -= this.state.x;
    this.minBounds.y -= this.state.y;
    this.minBounds.x /= scale;
    this.minBounds.y /= scale;
    this.minBounds.width /= scale;
    this.minBounds.height /= scale;
    /** @type {number} */
    this.x0 = this.state.x / scale - geo.x;
    /** @type {number} */
    this.y0 = this.state.y / scale - geo.y;
  }
};
/**
 * @param {!Object} aroundRect
 * @return {?}
 */
mxVertexHandler.prototype.getSelectionBounds = function(aroundRect) {
  return new mxRectangle(Math.round(aroundRect.x), Math.round(aroundRect.y), Math.round(aroundRect.width), Math.round(aroundRect.height));
};
/**
 * @param {!Arguments} className
 * @return {?}
 */
mxVertexHandler.prototype.createParentHighlightShape = function(className) {
  return this.createSelectionShape(className);
};
/**
 * @param {!Array} o
 * @return {?}
 */
mxVertexHandler.prototype.createSelectionShape = function(o) {
  o = new mxRectangleShape(mxRectangle.fromRectangle(o), null, this.getSelectionColor());
  o.strokewidth = this.getSelectionStrokeWidth();
  o.isDashed = this.isSelectionDashed();
  return o;
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.getSelectionColor = function() {
  return mxConstants.VERTEX_SELECTION_COLOR;
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.getSelectionStrokeWidth = function() {
  return mxConstants.VERTEX_SELECTION_STROKEWIDTH;
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.isSelectionDashed = function() {
  return mxConstants.VERTEX_SELECTION_DASHED;
};
/**
 * @param {string} direction
 * @param {number} element
 * @param {string} value
 * @param {!Object} options
 * @return {?}
 */
mxVertexHandler.prototype.createSizer = function(direction, element, value, options) {
  value = value || mxConstants.HANDLE_SIZE;
  value = new mxRectangle(0, 0, value, value);
  options = this.createSizerShape(value, element, options);
  if (options.isHtmlAllowed() && null != this.state.text && this.state.text.node.parentNode == this.graph.container) {
    --options.bounds.height;
    --options.bounds.width;
    options.dialect = mxConstants.DIALECT_STRICTHTML;
    options.init(this.graph.container);
  } else {
    options.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
    options.init(this.graph.getView().getOverlayPane());
  }
  mxEvent.redirectMouseEvents(options.node, this.graph, this.state);
  if (this.graph.isEnabled()) {
    options.setCursor(direction);
  }
  if (!this.isSizerVisible(element)) {
    /** @type {boolean} */
    options.visible = false;
  }
  return options;
};
/**
 * @param {number} suppressDisabledCheck
 * @return {?}
 */
mxVertexHandler.prototype.isSizerVisible = function(suppressDisabledCheck) {
  return true;
};
/**
 * @param {!Object} bounds
 * @param {number} scope
 * @param {boolean} positionOptions
 * @return {?}
 */
mxVertexHandler.prototype.createSizerShape = function(bounds, scope, positionOptions) {
  return null != this.handleImage ? (bounds = new mxRectangle(bounds.x, bounds.y, this.handleImage.width, this.handleImage.height), bounds = new mxImageShape(bounds, this.handleImage.src), bounds.preserveImageAspect = false, bounds) : scope == mxEvent.ROTATION_HANDLE ? new mxEllipse(bounds, positionOptions || mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR) : new mxRectangleShape(bounds, positionOptions || mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
};
/**
 * @param {!Object} m
 * @param {number} b
 * @param {number} center
 * @return {undefined}
 */
mxVertexHandler.prototype.moveSizerTo = function(m, b, center) {
  if (null != m) {
    /** @type {number} */
    m.bounds.x = Math.floor(b - m.bounds.width / 2);
    /** @type {number} */
    m.bounds.y = Math.floor(center - m.bounds.height / 2);
    if (null != m.node && "none" != m.node.style.display) {
      m.redraw();
    }
  }
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxVertexHandler.prototype.getHandleForEvent = function(me) {
  var tol = mxEvent.isMouseEvent(me.getEvent()) ? 1 : this.tolerance;
  var _ctx$request$query$si = this.allowHandleBoundsCheck && (mxClient.IS_IE || 0 < tol) ? new mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
  tol = mxUtils.bind(this, function(o) {
    var size = null != o && o.constructor != mxImageShape && this.allowHandleBoundsCheck ? o.strokewidth + o.svgStrokeTolerance : null;
    size = null != size ? new mxRectangle(me.getGraphX() - Math.floor(size / 2), me.getGraphY() - Math.floor(size / 2), size, size) : _ctx$request$query$si;
    return null != o && (me.isSource(o) || null != size && mxUtils.intersects(o.bounds, size) && "none" != o.node.style.display && "hidden" != o.node.style.visibility);
  });
  if (tol(this.rotationShape)) {
    return mxEvent.ROTATION_HANDLE;
  }
  if (tol(this.labelShape)) {
    return mxEvent.LABEL_HANDLE;
  }
  if (null != this.sizers) {
    /** @type {number} */
    var i = 0;
    for (; i < this.sizers.length; i++) {
      if (tol(this.sizers[i])) {
        return i;
      }
    }
  }
  if (null != this.customHandles && this.isCustomHandleEvent(me)) {
    /** @type {number} */
    i = this.customHandles.length - 1;
    for (; 0 <= i; i--) {
      if (tol(this.customHandles[i].shape)) {
        return mxEvent.CUSTOM_HANDLE - i;
      }
    }
  }
  return null;
};
/**
 * @param {!Object} me1
 * @return {?}
 */
mxVertexHandler.prototype.isCustomHandleEvent = function(me1) {
  return true;
};
/**
 * @param {!Object} e
 * @param {!Event} me
 * @return {undefined}
 */
mxVertexHandler.prototype.mouseDown = function(e, me) {
  if (!me.isConsumed() && this.graph.isEnabled()) {
    var before = this.getHandleForEvent(me);
    if (null != before) {
      this.start(me.getGraphX(), me.getGraphY(), before);
      me.consume();
    }
  }
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.isLivePreviewBorder = function() {
  return null != this.state.shape && null == this.state.shape.fill && null == this.state.shape.stroke;
};
/**
 * @param {number} b
 * @param {number} a
 * @param {string} index
 * @return {undefined}
 */
mxVertexHandler.prototype.start = function(b, a, index) {
  if (null != this.selectionBorder) {
    if (this.livePreviewActive = this.livePreview && 0 == this.graph.model.getChildCount(this.state.cell), this.inTolerance = true, this.childOffsetY = this.childOffsetX = 0, this.index = index, this.startX = b, this.startY = a, this.index <= mxEvent.CUSTOM_HANDLE && this.isGhostPreview()) {
      this.ghostPreview = this.createGhostPreview();
    } else {
      b = this.state.view.graph.model;
      a = b.getParent(this.state.cell);
      if (this.state.view.currentRoot != a && (b.isVertex(a) || b.isEdge(a))) {
        this.parentState = this.state.view.graph.view.getState(a);
      }
      /** @type {string} */
      this.selectionBorder.node.style.display = index == mxEvent.ROTATION_HANDLE ? "inline" : "none";
      if (!this.livePreviewActive || this.isLivePreviewBorder()) {
        this.preview = this.createSelectionShape(this.bounds);
        if (mxClient.IS_SVG && 0 != Number(this.state.style[mxConstants.STYLE_ROTATION] || "0") || null == this.state.text || this.state.text.node.parentNode != this.graph.container) {
          this.preview.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
          this.preview.init(this.graph.view.getOverlayPane());
        } else {
          this.preview.dialect = mxConstants.DIALECT_STRICTHTML;
          this.preview.init(this.graph.container);
        }
      }
      if (index == mxEvent.ROTATION_HANDLE) {
        a = this.getRotationHandlePosition();
        /** @type {number} */
        b = a.x - this.state.getCenterX();
        /** @type {number} */
        a = a.y - this.state.getCenterY();
        /** @type {number} */
        this.startAngle = 0 != b ? 180 * Math.atan(a / b) / Math.PI + 90 : 0;
        /** @type {number} */
        this.startDist = Math.sqrt(b * b + a * a);
      }
      if (this.livePreviewActive) {
        this.hideSizers();
        if (index == mxEvent.ROTATION_HANDLE) {
          /** @type {string} */
          this.rotationShape.node.style.display = "";
        } else {
          if (index == mxEvent.LABEL_HANDLE) {
            /** @type {string} */
            this.labelShape.node.style.display = "";
          } else {
            if (null != this.sizers && null != this.sizers[index]) {
              /** @type {string} */
              this.sizers[index].node.style.display = "";
            } else {
              if (index <= mxEvent.CUSTOM_HANDLE && null != this.customHandles) {
                this.customHandles[mxEvent.CUSTOM_HANDLE - index].setVisible(true);
              }
            }
          }
        }
        index = this.graph.getEdges(this.state.cell);
        /** @type {!Array} */
        this.edgeHandlers = [];
        /** @type {number} */
        b = 0;
        for (; b < index.length; b++) {
          a = this.graph.selectionCellsHandler.getHandler(index[b]);
          if (null != a) {
            this.edgeHandlers.push(a);
          }
        }
      }
    }
  }
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.createGhostPreview = function() {
  var state = this.graph.cellRenderer.createShape(this.state);
  state.init(this.graph.view.getOverlayPane());
  state.scale = this.state.view.scale;
  state.bounds = this.bounds;
  /** @type {boolean} */
  state.outline = true;
  return state;
};
/**
 * @param {boolean} value
 * @return {undefined}
 */
mxVertexHandler.prototype.setHandlesVisible = function(value) {
  /** @type {boolean} */
  this.handlesVisible = value;
  if (null != this.sizers) {
    /** @type {number} */
    var i = 0;
    for (; i < this.sizers.length; i++) {
      /** @type {string} */
      this.sizers[i].node.style.display = value ? "" : "none";
    }
  }
  if (null != this.customHandles) {
    /** @type {number} */
    i = 0;
    for (; i < this.customHandles.length; i++) {
      this.customHandles[i].setVisible(value);
    }
  }
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.hideSizers = function() {
  this.setHandlesVisible(false);
};
/**
 * @param {!Event} me
 * @return {undefined}
 */
mxVertexHandler.prototype.checkTolerance = function(me) {
  if (this.inTolerance && null != this.startX && null != this.startY && (mxEvent.isMouseEvent(me.getEvent()) || Math.abs(me.getGraphX() - this.startX) > this.graph.tolerance || Math.abs(me.getGraphY() - this.startY) > this.graph.tolerance)) {
    /** @type {boolean} */
    this.inTolerance = false;
  }
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxVertexHandler.prototype.updateHint = function(data) {
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.removeHint = function() {
};
/**
 * @param {number} litresInCubicFeet
 * @return {?}
 */
mxVertexHandler.prototype.roundAngle = function(litresInCubicFeet) {
  return Math.round(10 * litresInCubicFeet) / 10;
};
/**
 * @param {number} litresInCubicFeet
 * @return {?}
 */
mxVertexHandler.prototype.roundLength = function(litresInCubicFeet) {
  return Math.round(100 * litresInCubicFeet) / 100;
};
/**
 * @param {?} e
 * @param {!Event} me
 * @return {undefined}
 */
mxVertexHandler.prototype.mouseMove = function(e, me) {
  if (me.isConsumed() || null == this.index) {
    if (!(this.graph.isMouseDown || null == this.getHandleForEvent(me))) {
      me.consume(false);
    }
  } else {
    this.checkTolerance(me);
    if (!this.inTolerance) {
      if (this.index <= mxEvent.CUSTOM_HANDLE) {
        if (null != this.customHandles) {
          this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].processEvent(me);
          /** @type {boolean} */
          this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].active = true;
          if (null != this.ghostPreview) {
            this.ghostPreview.apply(this.state);
            /** @type {number} */
            this.ghostPreview.strokewidth = this.getSelectionStrokeWidth() / this.ghostPreview.scale / this.ghostPreview.scale;
            this.ghostPreview.isDashed = this.isSelectionDashed();
            this.ghostPreview.stroke = this.getSelectionColor();
            this.ghostPreview.redraw();
            if (null != this.selectionBounds) {
              /** @type {string} */
              this.selectionBorder.node.style.display = "none";
            }
          } else {
            if (this.movePreviewToFront) {
              this.moveToFront();
            }
            this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].positionChanged();
          }
        }
      } else {
        if (this.index == mxEvent.LABEL_HANDLE) {
          this.moveLabel(me);
        } else {
          if (this.index == mxEvent.ROTATION_HANDLE) {
            this.rotateVertex(me);
          } else {
            this.resizeVertex(me);
          }
          this.updateHint(me);
        }
      }
    }
    me.consume();
  }
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.isGhostPreview = function() {
  return 0 < this.state.view.graph.model.getChildCount(this.state.cell);
};
/**
 * @param {!Event} me
 * @return {undefined}
 */
mxVertexHandler.prototype.moveLabel = function(me) {
  var point = new mxPoint(me.getGraphX(), me.getGraphY());
  var geo = this.graph.view.translate;
  var scale = this.graph.view.scale;
  if (this.graph.isGridEnabledEvent(me.getEvent())) {
    /** @type {number} */
    point.x = (this.graph.snap(point.x / scale - geo.x) + geo.x) * scale;
    /** @type {number} */
    point.y = (this.graph.snap(point.y / scale - geo.y) + geo.y) * scale;
  }
  this.moveSizerTo(this.sizers[null != this.rotationShape ? this.sizers.length - 2 : this.sizers.length - 1], point.x, point.y);
};
/**
 * @param {!Object} me
 * @return {undefined}
 */
mxVertexHandler.prototype.rotateVertex = function(me) {
  var pt = new mxPoint(me.getGraphX(), me.getGraphY());
  /** @type {number} */
  var argR = this.state.x + this.state.width / 2 - pt.x;
  /** @type {number} */
  var arg = this.state.y + this.state.height / 2 - pt.y;
  /** @type {number} */
  this.currentAlpha = 0 != argR ? 180 * Math.atan(arg / argR) / Math.PI + 90 : 0 > arg ? 180 : 0;
  if (0 < argR) {
    this.currentAlpha -= 180;
  }
  this.currentAlpha -= this.startAngle;
  if (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent())) {
    /** @type {number} */
    argR = pt.x - this.state.getCenterX();
    /** @type {number} */
    arg = pt.y - this.state.getCenterY();
    /** @type {number} */
    me = Math.sqrt(argR * argR + arg * arg);
    /** @type {number} */
    raster = 2 > me - this.startDist ? 15 : 25 > me - this.startDist ? 5 : 1;
    /** @type {number} */
    this.currentAlpha = Math.round(this.currentAlpha / raster) * raster;
  } else {
    this.currentAlpha = this.roundAngle(this.currentAlpha);
  }
  /** @type {number} */
  this.selectionBorder.rotation = this.currentAlpha;
  this.selectionBorder.redraw();
  if (this.livePreviewActive) {
    this.redrawHandles();
  }
};
/**
 * @param {!Object} me
 * @return {undefined}
 */
mxVertexHandler.prototype.resizeVertex = function(me) {
  var w = new mxPoint(this.state.getCenterX(), this.state.getCenterY());
  var r = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
  var e = new mxPoint(me.getGraphX(), me.getGraphY());
  var translate = this.graph.view.translate;
  var scale = this.graph.view.scale;
  /** @type {number} */
  var b = Math.cos(-r);
  /** @type {number} */
  var a = Math.sin(-r);
  /** @type {number} */
  var x = e.x - this.startX;
  /** @type {number} */
  var y = e.y - this.startY;
  /** @type {number} */
  e = a * x + b * y;
  /** @type {number} */
  x = b * x - a * y;
  /** @type {number} */
  y = e;
  b = this.graph.getCellGeometry(this.state.cell);
  this.unscaledBounds = this.union(b, x / scale, y / scale, this.index, this.graph.isGridEnabledEvent(me.getEvent()), 1, new mxPoint(0, 0), this.isConstrainedEvent(me), this.isCenteredEvent(this.state, me));
  if (!b.relative) {
    a = this.graph.getMaximumGraphBounds();
    if (null != a && null != this.parentState) {
      a = mxRectangle.fromRectangle(a);
      a.x -= (this.parentState.x - translate.x * scale) / scale;
      a.y -= (this.parentState.y - translate.y * scale) / scale;
    }
    if (this.graph.isConstrainChild(this.state.cell)) {
      e = this.graph.getCellContainmentArea(this.state.cell);
      if (null != e) {
        x = this.graph.getOverlap(this.state.cell);
        if (0 < x) {
          e = mxRectangle.fromRectangle(e);
          e.x -= e.width * x;
          e.y -= e.height * x;
          e.width += 2 * e.width * x;
          e.height += 2 * e.height * x;
        }
        if (null == a) {
          a = e;
        } else {
          a = mxRectangle.fromRectangle(a);
          a.intersect(e);
        }
      }
    }
    if (null != a) {
      if (this.unscaledBounds.x < a.x) {
        this.unscaledBounds.width -= a.x - this.unscaledBounds.x;
        this.unscaledBounds.x = a.x;
      }
      if (this.unscaledBounds.y < a.y) {
        this.unscaledBounds.height -= a.y - this.unscaledBounds.y;
        this.unscaledBounds.y = a.y;
      }
      if (this.unscaledBounds.x + this.unscaledBounds.width > a.x + a.width) {
        this.unscaledBounds.width -= this.unscaledBounds.x + this.unscaledBounds.width - a.x - a.width;
      }
      if (this.unscaledBounds.y + this.unscaledBounds.height > a.y + a.height) {
        this.unscaledBounds.height -= this.unscaledBounds.y + this.unscaledBounds.height - a.y - a.height;
      }
    }
  }
  e = this.bounds;
  this.bounds = new mxRectangle((null != this.parentState ? this.parentState.x : translate.x * scale) + this.unscaledBounds.x * scale, (null != this.parentState ? this.parentState.y : translate.y * scale) + this.unscaledBounds.y * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);
  if (b.relative && null != this.parentState) {
    this.bounds.x += this.state.x - this.parentState.x;
    this.bounds.y += this.state.y - this.parentState.y;
  }
  /** @type {number} */
  b = Math.cos(r);
  /** @type {number} */
  a = Math.sin(r);
  r = new mxPoint(this.bounds.getCenterX(), this.bounds.getCenterY());
  /** @type {number} */
  x = r.x - w.x;
  /** @type {number} */
  y = r.y - w.y;
  /** @type {number} */
  w = b * x - a * y - x;
  /** @type {number} */
  r = a * x + b * y - y;
  /** @type {number} */
  x = this.bounds.x - this.state.x;
  /** @type {number} */
  y = this.bounds.y - this.state.y;
  /** @type {number} */
  translate = b * x - a * y;
  /** @type {number} */
  b = a * x + b * y;
  this.bounds.x += w;
  this.bounds.y += r;
  this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + w / scale);
  this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + r / scale);
  this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);
  this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);
  if (this.graph.isCellCollapsed(this.state.cell) || 0 == w && 0 == r) {
    /** @type {number} */
    this.childOffsetY = this.childOffsetX = 0;
  } else {
    /** @type {number} */
    this.childOffsetX = this.state.x - this.bounds.x + translate;
    /** @type {number} */
    this.childOffsetY = this.state.y - this.bounds.y + b;
  }
  if (!e.equals(this.bounds)) {
    if (this.livePreviewActive) {
      this.updateLivePreview(me);
    }
    if (null != this.preview) {
      this.drawPreview();
    } else {
      this.updateParentHighlight();
    }
  }
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxVertexHandler.prototype.updateLivePreview = function(data) {
  var scale = this.graph.view.scale;
  var geo = this.graph.view.translate;
  data = this.state.clone();
  this.state.x = this.bounds.x;
  this.state.y = this.bounds.y;
  this.state.origin = new mxPoint(this.state.x / scale - geo.x, this.state.y / scale - geo.y);
  this.state.width = this.bounds.width;
  this.state.height = this.bounds.height;
  scale = this.state.absoluteOffset;
  new mxPoint(scale.x, scale.y);
  /** @type {number} */
  this.state.absoluteOffset.x = 0;
  /** @type {number} */
  this.state.absoluteOffset.y = 0;
  scale = this.graph.getCellGeometry(this.state.cell);
  if (null != scale) {
    geo = scale.offset || this.EMPTY_POINT;
    if (!(null == geo || scale.relative)) {
      /** @type {number} */
      this.state.absoluteOffset.x = this.state.view.scale * geo.x;
      /** @type {number} */
      this.state.absoluteOffset.y = this.state.view.scale * geo.y;
    }
    this.state.view.updateVertexLabelOffset(this.state);
  }
  this.state.view.graph.cellRenderer.redraw(this.state, true);
  this.state.view.invalidate(this.state.cell);
  /** @type {boolean} */
  this.state.invalid = false;
  this.state.view.validate();
  this.redrawHandles();
  if (this.movePreviewToFront) {
    this.moveToFront();
  }
  if (null != this.state.control && null != this.state.control.node) {
    /** @type {string} */
    this.state.control.node.style.visibility = "hidden";
  }
  this.state.setState(data);
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.moveToFront = function() {
  if (null != this.state.text && null != this.state.text.node && null != this.state.text.node.nextSibling || null != this.state.shape && null != this.state.shape.node && null != this.state.shape.node.nextSibling && (null == this.state.text || this.state.shape.node.nextSibling != this.state.text.node)) {
    if (null != this.state.shape && null != this.state.shape.node) {
      this.state.shape.node.parentNode.appendChild(this.state.shape.node);
    }
    if (null != this.state.text && null != this.state.text.node) {
      this.state.text.node.parentNode.appendChild(this.state.text.node);
    }
  }
};
/**
 * @param {?} editor
 * @param {undefined} e
 * @return {undefined}
 */
mxVertexHandler.prototype.mouseUp = function(editor, e) {
  if (null != this.index && null != this.state) {
    var point = new mxPoint(e.getGraphX(), e.getGraphY());
    var i = this.index;
    /** @type {null} */
    this.index = null;
    if (null == this.ghostPreview) {
      this.state.view.invalidate(this.state.cell, false, false);
      this.state.view.validate();
    }
    this.graph.getModel().beginUpdate();
    try {
      if (i <= mxEvent.CUSTOM_HANDLE) {
        if (null != this.customHandles) {
          var value = this.state.view.graph.getCellStyle(this.state.cell);
          /** @type {boolean} */
          this.customHandles[mxEvent.CUSTOM_HANDLE - i].active = false;
          this.customHandles[mxEvent.CUSTOM_HANDLE - i].execute(e);
          if (null != this.customHandles && null != this.customHandles[mxEvent.CUSTOM_HANDLE - i]) {
            this.state.style = value;
            this.customHandles[mxEvent.CUSTOM_HANDLE - i].positionChanged();
          }
        }
      } else {
        if (i == mxEvent.ROTATION_HANDLE) {
          if (null != this.currentAlpha) {
            /** @type {number} */
            var cell = this.currentAlpha - (this.state.style[mxConstants.STYLE_ROTATION] || 0);
            if (0 != cell) {
              this.rotateCell(this.state.cell, cell);
            }
          } else {
            this.rotateClick();
          }
        } else {
          var authChallenge = this.graph.isGridEnabledEvent(e.getEvent());
          var theta = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
          /** @type {number} */
          var uv1v = Math.cos(-theta);
          /** @type {number} */
          var uv2v = Math.sin(-theta);
          /** @type {number} */
          var deltaX = point.x - this.startX;
          /** @type {number} */
          var deltaY = point.y - this.startY;
          /** @type {number} */
          point = uv2v * deltaX + uv1v * deltaY;
          /** @type {number} */
          deltaX = uv1v * deltaX - uv2v * deltaY;
          /** @type {number} */
          deltaY = point;
          var lowestDeltaXY = this.graph.view.scale;
          var t = this.isRecursiveResize(this.state, e);
          this.resizeCell(this.state.cell, this.roundLength(deltaX / lowestDeltaXY), this.roundLength(deltaY / lowestDeltaXY), i, authChallenge, this.isConstrainedEvent(e), t);
        }
      }
    } finally {
      this.graph.getModel().endUpdate();
    }
    e.consume();
    this.reset();
    this.redrawHandles();
  }
};
/**
 * @param {?} a
 * @param {!Object} b
 * @return {?}
 */
mxVertexHandler.prototype.isRecursiveResize = function(a, b) {
  return this.graph.isRecursiveResize(this.state);
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.rotateClick = function() {
};
/**
 * @param {(Object|string)} cell
 * @param {number} data
 * @param {?} index
 * @return {undefined}
 */
mxVertexHandler.prototype.rotateCell = function(cell, data, index) {
  if (0 != data) {
    var self = this.graph.getModel();
    if (self.isVertex(cell) || self.isEdge(cell)) {
      if (!self.isEdge(cell)) {
        var value = (this.graph.getCurrentCellStyle(cell)[mxConstants.STYLE_ROTATION] || 0) + data;
        this.graph.setCellStyles(mxConstants.STYLE_ROTATION, value, [cell]);
      }
      value = this.graph.getCellGeometry(cell);
      if (null != value) {
        var v = this.graph.getCellGeometry(index);
        if (!(null == v || self.isEdge(index))) {
          value = value.clone();
          value.rotate(data, new mxPoint(v.width / 2, v.height / 2));
          self.setGeometry(cell, value);
        }
        if (self.isVertex(cell) && !value.relative || self.isEdge(cell)) {
          index = self.getChildCount(cell);
          /** @type {number} */
          value = 0;
          for (; value < index; value++) {
            this.rotateCell(self.getChildAt(cell, value), data, cell);
          }
        }
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.reset = function() {
  if (null != this.sizers && null != this.index && null != this.sizers[this.index] && "none" == this.sizers[this.index].node.style.display) {
    /** @type {string} */
    this.sizers[this.index].node.style.display = "";
  }
  /** @type {null} */
  this.index = this.inTolerance = this.currentAlpha = null;
  if (null != this.preview) {
    this.preview.destroy();
    /** @type {null} */
    this.preview = null;
  }
  if (null != this.ghostPreview) {
    this.ghostPreview.destroy();
    /** @type {null} */
    this.ghostPreview = null;
  }
  if (this.livePreviewActive && null != this.sizers) {
    /** @type {number} */
    var i = 0;
    for (; i < this.sizers.length; i++) {
      if (null != this.sizers[i]) {
        /** @type {string} */
        this.sizers[i].node.style.display = "";
      }
    }
    if (null != this.state.control && null != this.state.control.node) {
      /** @type {string} */
      this.state.control.node.style.visibility = "";
    }
  }
  if (null != this.customHandles) {
    /** @type {number} */
    i = 0;
    for (; i < this.customHandles.length; i++) {
      if (this.customHandles[i].active) {
        /** @type {boolean} */
        this.customHandles[i].active = false;
        this.customHandles[i].reset();
      } else {
        this.customHandles[i].setVisible(true);
      }
    }
  }
  if (null != this.selectionBorder) {
    /** @type {string} */
    this.selectionBorder.node.style.display = "inline";
    this.selectionBounds = this.getSelectionBounds(this.state);
    this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
    this.drawPreview();
  }
  this.removeHint();
  this.redrawHandles();
  /** @type {null} */
  this.edgeHandlers = null;
  /** @type {boolean} */
  this.handlesVisible = true;
  /** @type {null} */
  this.livePreviewActive = this.unscaledBounds = null;
};
/**
 * @param {string} child
 * @param {!Object} res
 * @param {number} n
 * @param {number} s
 * @param {?} cb
 * @param {?} index
 * @param {number} c
 * @return {undefined}
 */
mxVertexHandler.prototype.resizeCell = function(child, res, n, s, cb, index, c) {
  res = this.graph.model.getGeometry(child);
  if (null != res) {
    if (s == mxEvent.LABEL_HANDLE) {
      /** @type {number} */
      s = -mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
      /** @type {number} */
      c = Math.cos(s);
      /** @type {number} */
      n = Math.sin(s);
      s = this.graph.view.scale;
      c = mxUtils.getRotatedPoint(new mxPoint(Math.round((this.labelShape.bounds.getCenterX() - this.startX) / s), Math.round((this.labelShape.bounds.getCenterY() - this.startY) / s)), c, n);
      res = res.clone();
      if (null == res.offset) {
        /** @type {number} */
        res.offset = c;
      } else {
        res.offset.x += c.x;
        res.offset.y += c.y;
      }
      this.graph.model.setGeometry(child, res);
    } else {
      if (null != this.unscaledBounds) {
        s = this.graph.view.scale;
        if (!(0 == this.childOffsetX && 0 == this.childOffsetY)) {
          this.moveChildren(child, Math.round(this.childOffsetX / s), Math.round(this.childOffsetY / s));
        }
        this.graph.resizeCell(child, this.unscaledBounds, c);
      }
    }
  }
};
/**
 * @param {!Object} index
 * @param {number} value
 * @param {number} m
 * @return {undefined}
 */
mxVertexHandler.prototype.moveChildren = function(index, value, m) {
  var target = this.graph.getModel();
  var nintv = target.getChildCount(index);
  /** @type {number} */
  var i = 0;
  for (; i < nintv; i++) {
    var cell = target.getChildAt(index, i);
    var d = this.graph.getCellGeometry(cell);
    if (null != d) {
      d = d.clone();
      d.translate(value, m);
      target.setGeometry(cell, d);
    }
  }
};
/**
 * @param {number} a
 * @param {number} i
 * @param {number} b
 * @param {number} x
 * @param {number} h
 * @param {!Object} scale
 * @param {number} p
 * @param {number} s
 * @param {?} result
 * @return {?}
 */
mxVertexHandler.prototype.union = function(a, i, b, x, h, scale, p, s, result) {
  h = null != h ? h && this.graph.gridEnabled : this.graph.gridEnabled;
  if (this.singleSizer) {
    return x = a.x + a.width + i, p = a.y + a.height + b, h && (x = this.graph.snap(x / scale) * scale, p = this.graph.snap(p / scale) * scale), scale = new mxRectangle(a.x, a.y, 0, 0), scale.add(new mxRectangle(x, p, 0, 0)), scale;
  }
  var size = a.width;
  var k = a.height;
  /** @type {number} */
  var top = a.x - p.x * scale;
  var y = top + size;
  /** @type {number} */
  a = a.y - p.y * scale;
  var d = a + k;
  /** @type {number} */
  var height = top + size / 2;
  /** @type {number} */
  var digits = a + k / 2;
  if (4 < x) {
    d = d + b;
    /** @type {number} */
    d = h ? this.graph.snap(d / scale) * scale : Math.round(d / scale) * scale;
  } else {
    if (3 > x) {
      a = a + b;
      /** @type {number} */
      a = h ? this.graph.snap(a / scale) * scale : Math.round(a / scale) * scale;
    }
  }
  if (0 == x || 3 == x || 5 == x) {
    top = top + i;
    /** @type {number} */
    top = h ? this.graph.snap(top / scale) * scale : Math.round(top / scale) * scale;
  } else {
    if (2 == x || 4 == x || 7 == x) {
      y = y + i;
      /** @type {number} */
      y = h ? this.graph.snap(y / scale) * scale : Math.round(y / scale) * scale;
    }
  }
  /** @type {number} */
  h = y - top;
  /** @type {number} */
  b = d - a;
  if (s) {
    s = this.graph.getCellGeometry(this.state.cell);
    if (null != s) {
      /** @type {number} */
      s = s.width / s.height;
      if (1 == x || 2 == x || 7 == x || 6 == x) {
        /** @type {number} */
        h = b * s;
      } else {
        /** @type {number} */
        b = h / s;
      }
      if (0 == x) {
        /** @type {number} */
        top = y - h;
        /** @type {number} */
        a = d - b;
      }
    }
  }
  if (result) {
    /** @type {number} */
    h = h + (h - size);
    /** @type {number} */
    b = b + (b - k);
    /** @type {number} */
    top = top + (height - (top + h / 2));
    /** @type {number} */
    a = a + (digits - (a + b / 2));
  }
  if (0 > h) {
    /** @type {number} */
    top = top + h;
    /** @type {number} */
    h = Math.abs(h);
  }
  if (0 > b) {
    /** @type {number} */
    a = a + b;
    /** @type {number} */
    b = Math.abs(b);
  }
  x = new mxRectangle(top + p.x * scale, a + p.y * scale, h, b);
  if (null != this.minBounds) {
    /** @type {number} */
    x.width = Math.max(x.width, this.minBounds.x * scale + this.minBounds.width * scale + Math.max(0, this.x0 * scale - x.x));
    /** @type {number} */
    x.height = Math.max(x.height, this.minBounds.y * scale + this.minBounds.height * scale + Math.max(0, this.y0 * scale - x.y));
  }
  return x;
};
/**
 * @param {!Function} elem
 * @return {undefined}
 */
mxVertexHandler.prototype.redraw = function(elem) {
  this.selectionBounds = this.getSelectionBounds(this.state);
  this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
  this.drawPreview();
  if (!elem) {
    this.redrawHandles();
  }
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.getHandlePadding = function() {
  var xyzMax = new mxPoint(0, 0);
  var margin = this.tolerance;
  if (null != this.sizers && 0 < this.sizers.length && null != this.sizers[0] && (this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * margin || this.bounds.height < 2 * this.sizers[0].bounds.height + 2 * margin)) {
    /** @type {number} */
    margin = margin / 2;
    xyzMax.x = this.sizers[0].bounds.width + margin;
    xyzMax.y = this.sizers[0].bounds.height + margin;
  }
  return xyzMax;
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.getSizerBounds = function() {
  return this.bounds;
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.redrawHandles = function() {
  var point = this.getSizerBounds();
  var b = this.tolerance;
  /** @type {number} */
  this.verticalOffset = this.horizontalOffset = 0;
  if (null != this.customHandles) {
    /** @type {number} */
    var i = 0;
    for (; i < this.customHandles.length; i++) {
      var value = this.customHandles[i].shape.node.style.display;
      this.customHandles[i].redraw();
      this.customHandles[i].shape.node.style.display = value;
      /** @type {string} */
      this.customHandles[i].shape.node.style.visibility = this.handlesVisible && this.isCustomHandleVisible(this.customHandles[i]) ? "" : "hidden";
    }
  }
  if (null != this.sizers && 0 < this.sizers.length && null != this.sizers[0]) {
    if (null == this.index && this.manageSizers && 8 <= this.sizers.length) {
      i = this.getHandlePadding();
      this.horizontalOffset = i.x;
      this.verticalOffset = i.y;
      if (0 != this.horizontalOffset || 0 != this.verticalOffset) {
        point = new mxRectangle(point.x, point.y, point.width, point.height);
        point.x -= this.horizontalOffset / 2;
        point.width += this.horizontalOffset;
        point.y -= this.verticalOffset / 2;
        point.height += this.verticalOffset;
      }
      if (8 <= this.sizers.length) {
        if (point.width < 2 * this.sizers[0].bounds.width + 2 * b || point.height < 2 * this.sizers[0].bounds.height + 2 * b) {
          /** @type {string} */
          this.sizers[0].node.style.display = "none";
          /** @type {string} */
          this.sizers[2].node.style.display = "none";
          /** @type {string} */
          this.sizers[5].node.style.display = "none";
          /** @type {string} */
          this.sizers[7].node.style.display = "none";
        } else {
          if (this.handlesVisible) {
            /** @type {string} */
            this.sizers[0].node.style.display = "";
            /** @type {string} */
            this.sizers[2].node.style.display = "";
            /** @type {string} */
            this.sizers[5].node.style.display = "";
            /** @type {string} */
            this.sizers[7].node.style.display = "";
          }
        }
      }
    }
    b = point.x + point.width;
    i = point.y + point.height;
    if (this.singleSizer) {
      this.moveSizerTo(this.sizers[0], b, i);
    } else {
      value = point.x + point.width / 2;
      var t = point.y + point.height / 2;
      if (8 <= this.sizers.length) {
        /** @type {!Array<string>} */
        var panes = "nw-resize n-resize ne-resize e-resize se-resize s-resize sw-resize w-resize".split(" ");
        var angle = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
        /** @type {number} */
        var cos = Math.cos(angle);
        /** @type {number} */
        var sin = Math.sin(angle);
        /** @type {number} */
        angle = Math.round(4 * angle / Math.PI);
        var ct = new mxPoint(point.getCenterX(), point.getCenterY());
        var result = mxUtils.getRotatedPoint(new mxPoint(point.x, point.y), cos, sin, ct);
        this.moveSizerTo(this.sizers[0], result.x, result.y);
        this.sizers[0].setCursor(panes[mxUtils.mod(0 + angle, panes.length)]);
        result.x = value;
        result.y = point.y;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[1], result.x, result.y);
        this.sizers[1].setCursor(panes[mxUtils.mod(1 + angle, panes.length)]);
        result.x = b;
        result.y = point.y;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[2], result.x, result.y);
        this.sizers[2].setCursor(panes[mxUtils.mod(2 + angle, panes.length)]);
        result.x = point.x;
        result.y = t;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[3], result.x, result.y);
        this.sizers[3].setCursor(panes[mxUtils.mod(7 + angle, panes.length)]);
        result.x = b;
        result.y = t;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[4], result.x, result.y);
        this.sizers[4].setCursor(panes[mxUtils.mod(3 + angle, panes.length)]);
        result.x = point.x;
        result.y = i;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[5], result.x, result.y);
        this.sizers[5].setCursor(panes[mxUtils.mod(6 + angle, panes.length)]);
        result.x = value;
        result.y = i;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[6], result.x, result.y);
        this.sizers[6].setCursor(panes[mxUtils.mod(5 + angle, panes.length)]);
        result.x = b;
        result.y = i;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[7], result.x, result.y);
        this.sizers[7].setCursor(panes[mxUtils.mod(4 + angle, panes.length)]);
        result.x = value + this.state.absoluteOffset.x;
        result.y = t + this.state.absoluteOffset.y;
        result = mxUtils.getRotatedPoint(result, cos, sin, ct);
        this.moveSizerTo(this.sizers[8], result.x, result.y);
      } else {
        if (2 <= this.state.width && 2 <= this.state.height) {
          this.moveSizerTo(this.sizers[0], value + this.state.absoluteOffset.x, t + this.state.absoluteOffset.y);
        } else {
          this.moveSizerTo(this.sizers[0], this.state.x, this.state.y);
        }
      }
    }
  }
  if (null != this.rotationShape) {
    angle = mxUtils.toRadians(null != this.currentAlpha ? this.currentAlpha : this.state.style[mxConstants.STYLE_ROTATION] || "0");
    /** @type {number} */
    cos = Math.cos(angle);
    /** @type {number} */
    sin = Math.sin(angle);
    ct = new mxPoint(this.state.getCenterX(), this.state.getCenterY());
    result = mxUtils.getRotatedPoint(this.getRotationHandlePosition(), cos, sin, ct);
    if (null != this.rotationShape.node) {
      this.moveSizerTo(this.rotationShape, result.x, result.y);
      /** @type {string} */
      this.rotationShape.node.style.visibility = this.state.view.graph.isEditing() || !this.handlesVisible ? "hidden" : "";
    }
  }
  if (null != this.selectionBorder) {
    /** @type {number} */
    this.selectionBorder.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
  }
  if (null != this.edgeHandlers) {
    /** @type {number} */
    i = 0;
    for (; i < this.edgeHandlers.length; i++) {
      this.edgeHandlers[i].redraw();
    }
  }
};
/**
 * @param {?} a
 * @return {?}
 */
mxVertexHandler.prototype.isCustomHandleVisible = function(a) {
  return !this.graph.isEditing() && 1 == this.state.view.graph.getSelectionCount();
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.getRotationHandlePosition = function() {
  return new mxPoint(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.rotationHandleVSpacing);
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.isParentHighlightVisible = function() {
  return !this.graph.isCellSelected(this.graph.model.getParent(this.state.cell));
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.updateParentHighlight = function() {
  if (!this.isDestroyed()) {
    var one = this.isParentHighlightVisible();
    var element = this.graph.model.getParent(this.state.cell);
    var two = this.graph.view.getState(element);
    if (null != this.parentHighlight) {
      if (this.graph.model.isVertex(element) && one) {
        one = this.parentHighlight.bounds;
        if (!(null == two || one.x == two.x && one.y == two.y && one.width == two.width && one.height == two.height)) {
          this.parentHighlight.bounds = mxRectangle.fromRectangle(two);
          this.parentHighlight.redraw();
        }
      } else {
        if (null != two && two.parentHighlight == this.parentHighlight) {
          /** @type {null} */
          two.parentHighlight = null;
        }
        this.parentHighlight.destroy();
        /** @type {null} */
        this.parentHighlight = null;
      }
    } else {
      if (this.parentHighlightEnabled && one && this.graph.model.isVertex(element) && null != two && null == two.parentHighlight) {
        this.parentHighlight = this.createParentHighlightShape(two);
        this.parentHighlight.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
        /** @type {boolean} */
        this.parentHighlight.pointerEvents = false;
        /** @type {number} */
        this.parentHighlight.rotation = Number(two.style[mxConstants.STYLE_ROTATION] || "0");
        this.parentHighlight.init(this.graph.getView().getOverlayPane());
        this.parentHighlight.redraw();
        two.parentHighlight = this.parentHighlight;
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.drawPreview = function() {
  if (null != this.preview) {
    this.preview.bounds = this.bounds;
    if (this.preview.node.parentNode == this.graph.container) {
      /** @type {number} */
      this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);
      /** @type {number} */
      this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);
    }
    /** @type {number} */
    this.preview.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
    this.preview.redraw();
  }
  this.selectionBorder.bounds = this.getSelectionBorderBounds();
  this.selectionBorder.redraw();
  this.updateParentHighlight();
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.getSelectionBorderBounds = function() {
  return this.bounds;
};
/**
 * @return {?}
 */
mxVertexHandler.prototype.isDestroyed = function() {
  return null == this.selectionBorder;
};
/**
 * @return {undefined}
 */
mxVertexHandler.prototype.destroy = function() {
  if (null != this.escapeHandler) {
    this.state.view.graph.removeListener(this.escapeHandler);
    /** @type {null} */
    this.escapeHandler = null;
  }
  if (null != this.preview) {
    this.preview.destroy();
    /** @type {null} */
    this.preview = null;
  }
  if (null != this.parentHighlight) {
    var i = this.graph.model.getParent(this.state.cell);
    i = this.graph.view.getState(i);
    if (null != i && i.parentHighlight == this.parentHighlight) {
      /** @type {null} */
      i.parentHighlight = null;
    }
    this.parentHighlight.destroy();
    /** @type {null} */
    this.parentHighlight = null;
  }
  if (null != this.ghostPreview) {
    this.ghostPreview.destroy();
    /** @type {null} */
    this.ghostPreview = null;
  }
  if (null != this.selectionBorder) {
    this.selectionBorder.destroy();
    /** @type {null} */
    this.selectionBorder = null;
  }
  /** @type {null} */
  this.labelShape = null;
  this.removeHint();
  if (null != this.sizers) {
    /** @type {number} */
    i = 0;
    for (; i < this.sizers.length; i++) {
      this.sizers[i].destroy();
    }
    /** @type {null} */
    this.sizers = null;
  }
  if (null != this.customHandles) {
    /** @type {number} */
    i = 0;
    for (; i < this.customHandles.length; i++) {
      this.customHandles[i].destroy();
    }
    /** @type {null} */
    this.customHandles = null;
  }
};
/**
 * @param {!Object} context
 * @return {undefined}
 */
function mxEdgeHandler(context) {
  if (null != context && null != context.shape) {
    /** @type {!Object} */
    this.state = context;
    this.init();
    this.escapeHandler = mxUtils.bind(this, function(b, canCreateDiscussions) {
      /** @type {boolean} */
      var d = null != this.index;
      this.reset();
      if (d) {
        this.graph.cellRenderer.redraw(this.state, false, context.view.isRendering());
      }
    });
    this.state.view.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
  }
}
/** @type {null} */
mxEdgeHandler.prototype.graph = null;
/** @type {null} */
mxEdgeHandler.prototype.state = null;
/** @type {null} */
mxEdgeHandler.prototype.marker = null;
/** @type {null} */
mxEdgeHandler.prototype.constraintHandler = null;
/** @type {null} */
mxEdgeHandler.prototype.error = null;
/** @type {null} */
mxEdgeHandler.prototype.shape = null;
/** @type {null} */
mxEdgeHandler.prototype.bends = null;
/** @type {null} */
mxEdgeHandler.prototype.labelShape = null;
/** @type {boolean} */
mxEdgeHandler.prototype.cloneEnabled = true;
/** @type {boolean} */
mxEdgeHandler.prototype.addEnabled = false;
/** @type {boolean} */
mxEdgeHandler.prototype.removeEnabled = false;
/** @type {boolean} */
mxEdgeHandler.prototype.dblClickRemoveEnabled = false;
/** @type {boolean} */
mxEdgeHandler.prototype.mergeRemoveEnabled = false;
/** @type {boolean} */
mxEdgeHandler.prototype.straightRemoveEnabled = false;
/** @type {boolean} */
mxEdgeHandler.prototype.virtualBendsEnabled = false;
/** @type {number} */
mxEdgeHandler.prototype.virtualBendOpacity = 20;
/** @type {boolean} */
mxEdgeHandler.prototype.parentHighlightEnabled = false;
/** @type {boolean} */
mxEdgeHandler.prototype.preferHtml = false;
/** @type {boolean} */
mxEdgeHandler.prototype.allowHandleBoundsCheck = true;
/** @type {boolean} */
mxEdgeHandler.prototype.snapToTerminals = false;
/** @type {null} */
mxEdgeHandler.prototype.handleImage = null;
/** @type {number} */
mxEdgeHandler.prototype.tolerance = 0;
/** @type {boolean} */
mxEdgeHandler.prototype.outlineConnect = false;
/** @type {boolean} */
mxEdgeHandler.prototype.manageLabelHandle = false;
/**
 * @return {undefined}
 */
mxEdgeHandler.prototype.init = function() {
  this.graph = this.state.view.graph;
  this.marker = this.createMarker();
  this.constraintHandler = new mxConstraintHandler(this.graph);
  /** @type {!Array} */
  this.points = [];
  this.abspoints = this.getSelectionPoints(this.state);
  this.shape = this.createSelectionShape(this.abspoints);
  this.shape.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
  this.shape.init(this.graph.getView().getOverlayPane());
  /** @type {boolean} */
  this.shape.pointerEvents = false;
  this.shape.setCursor(mxConstants.CURSOR_MOVABLE_EDGE);
  mxEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);
  /** @type {boolean} */
  this.preferHtml = null != this.state.text && this.state.text.node.parentNode == this.graph.container;
  if (!this.preferHtml) {
    var nextAtom = this.state.getVisibleTerminalState(true);
    if (null != nextAtom) {
      /** @type {boolean} */
      this.preferHtml = null != nextAtom.text && nextAtom.text.node.parentNode == this.graph.container;
    }
    if (!this.preferHtml) {
      nextAtom = this.state.getVisibleTerminalState(false);
      if (null != nextAtom) {
        /** @type {boolean} */
        this.preferHtml = null != nextAtom.text && nextAtom.text.node.parentNode == this.graph.container;
      }
    }
  }
  if (this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells || 0 >= mxGraphHandler.prototype.maxCells) {
    this.bends = this.createBends();
    if (this.isVirtualBendsEnabled()) {
      this.virtualBends = this.createVirtualBends();
    }
  }
  this.label = new mxPoint(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
  this.labelShape = this.createLabelHandleShape();
  this.initBend(this.labelShape);
  this.labelShape.setCursor(mxConstants.CURSOR_LABEL_HANDLE);
  this.customHandles = this.createCustomHandles();
  this.updateParentHighlight();
  this.redraw();
};
/** @type {function(): ?} */
mxEdgeHandler.prototype.isParentHighlightVisible = mxVertexHandler.prototype.isParentHighlightVisible;
/** @type {function(): undefined} */
mxEdgeHandler.prototype.updateParentHighlight = mxVertexHandler.prototype.updateParentHighlight;
/**
 * @return {?}
 */
mxEdgeHandler.prototype.createCustomHandles = function() {
  return null;
};
/**
 * @param {?} a
 * @return {?}
 */
mxEdgeHandler.prototype.isVirtualBendsEnabled = function(a) {
  return this.virtualBendsEnabled && (null == this.state.style[mxConstants.STYLE_EDGE] || this.state.style[mxConstants.STYLE_EDGE] == mxConstants.NONE || 1 == this.state.style[mxConstants.STYLE_NOEDGESTYLE]) && "arrow" != mxUtils.getValue(this.state.style, mxConstants.STYLE_SHAPE, null);
};
/**
 * @param {?} a
 * @return {?}
 */
mxEdgeHandler.prototype.isCellEnabled = function(a) {
  return true;
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxEdgeHandler.prototype.isAddPointEvent = function(evt) {
  return mxEvent.isShiftDown(evt);
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxEdgeHandler.prototype.isRemovePointEvent = function(evt) {
  return mxEvent.isShiftDown(evt);
};
/**
 * @param {?} a
 * @return {?}
 */
mxEdgeHandler.prototype.getSelectionPoints = function(a) {
  return a.absolutePoints;
};
/**
 * @param {?} o
 * @return {?}
 */
mxEdgeHandler.prototype.createParentHighlightShape = function(o) {
  o = new mxRectangleShape(mxRectangle.fromRectangle(o), null, this.getSelectionColor());
  o.strokewidth = this.getSelectionStrokeWidth();
  o.isDashed = this.isSelectionDashed();
  return o;
};
/**
 * @param {!Object} item
 * @return {?}
 */
mxEdgeHandler.prototype.createSelectionShape = function(item) {
  item = new this.state.shape.constructor;
  /** @type {boolean} */
  item.outline = true;
  item.apply(this.state);
  item.isDashed = this.isSelectionDashed();
  item.stroke = this.getSelectionColor();
  /** @type {boolean} */
  item.isShadow = false;
  return item;
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.getSelectionColor = function() {
  return mxConstants.EDGE_SELECTION_COLOR;
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.getSelectionStrokeWidth = function() {
  return mxConstants.EDGE_SELECTION_STROKEWIDTH;
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.isSelectionDashed = function() {
  return mxConstants.EDGE_SELECTION_DASHED;
};
/**
 * @param {?} cell
 * @return {?}
 */
mxEdgeHandler.prototype.isConnectableCell = function(cell) {
  return true;
};
/**
 * @param {!Object} x
 * @param {!Array} y
 * @return {?}
 */
mxEdgeHandler.prototype.getCellAt = function(x, y) {
  return this.outlineConnect ? null : this.graph.getCellAt(x, y);
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.createMarker = function() {
  var iterator = new mxCellMarker(this.graph);
  var self = this;
  /**
   * @param {!Object} o
   * @return {?}
   */
  iterator.getCell = function(o) {
    var cell = mxCellMarker.prototype.getCell.apply(this, arguments);
    if (!(cell != self.state.cell && null != cell || null == self.currentPoint)) {
      cell = self.graph.getCellAt(self.currentPoint.x, self.currentPoint.y);
    }
    if (null != cell && !this.graph.isCellConnectable(cell)) {
      var parent = this.graph.getModel().getParent(cell);
      if (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent)) {
        cell = parent;
      }
    }
    parent = self.graph.getModel();
    if (this.graph.isSwimlane(cell) && null != self.currentPoint && this.graph.hitsSwimlaneContent(cell, self.currentPoint.x, self.currentPoint.y) || !self.isConnectableCell(cell) || cell == self.state.cell || null != cell && !self.graph.connectableEdges && parent.isEdge(cell) || parent.isAncestor(self.state.cell, cell)) {
      /** @type {null} */
      cell = null;
    }
    if (!this.graph.isCellConnectable(cell)) {
      /** @type {null} */
      cell = null;
    }
    return cell;
  };
  /**
   * @param {!Object} doc
   * @return {?}
   */
  iterator.isValidState = function(doc) {
    var data = self.graph.getModel();
    data = self.graph.view.getTerminalPort(doc, self.graph.view.getState(data.getTerminal(self.state.cell, !self.isSource)), !self.isSource);
    data = null != data ? data.cell : null;
    self.error = self.validateConnection(self.isSource ? doc.cell : data, self.isSource ? data : doc.cell);
    return null == self.error;
  };
  return iterator;
};
/**
 * @param {?} i
 * @param {?} v
 * @return {?}
 */
mxEdgeHandler.prototype.validateConnection = function(i, v) {
  return this.graph.getEdgeValidationError(this.state.cell, i, v);
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.createBends = function() {
  var width = this.state.cell;
  /** @type {!Array} */
  var yRanges = [];
  /** @type {number} */
  var clojIsReversed = 0;
  for (; clojIsReversed < this.abspoints.length; clojIsReversed++) {
    if (this.isHandleVisible(clojIsReversed)) {
      /** @type {boolean} */
      var error = clojIsReversed == this.abspoints.length - 1;
      /** @type {boolean} */
      var ls = 0 == clojIsReversed || error;
      if (ls || this.graph.isCellBendable(width)) {
        mxUtils.bind(this, function(length) {
          var range = this.createHandleShape(length);
          this.initBend(range, mxUtils.bind(this, mxUtils.bind(this, function() {
            if (this.dblClickRemoveEnabled) {
              this.removePoint(this.state, length);
            }
          })));
          if (this.isHandleEnabled(clojIsReversed)) {
            range.setCursor(ls ? mxConstants.CURSOR_TERMINAL_HANDLE : mxConstants.CURSOR_BEND_HANDLE);
          }
          yRanges.push(range);
          if (!ls) {
            this.points.push(new mxPoint(0, 0));
            /** @type {string} */
            range.node.style.visibility = "hidden";
          }
        })(clojIsReversed);
      }
    }
  }
  return yRanges;
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.createVirtualBends = function() {
  /** @type {!Array} */
  var yRanges = [];
  if (this.graph.isCellBendable(this.state.cell)) {
    /** @type {number} */
    var ki$13 = 1;
    for (; ki$13 < this.abspoints.length; ki$13++) {
      mxUtils.bind(this, function(range) {
        this.initBend(range);
        range.setCursor(mxConstants.CURSOR_VIRTUAL_BEND_HANDLE);
        yRanges.push(range);
      })(this.createHandleShape());
    }
  }
  return yRanges;
};
/**
 * @param {number} isSlidingUp
 * @return {?}
 */
mxEdgeHandler.prototype.isHandleEnabled = function(isSlidingUp) {
  return true;
};
/**
 * @param {number} isSlidingUp
 * @return {?}
 */
mxEdgeHandler.prototype.isHandleVisible = function(isSlidingUp) {
  var value = this.state.getVisibleTerminalState(true);
  var BidirectionalSubject = this.state.getVisibleTerminalState(false);
  var number = this.graph.getCellGeometry(this.state.cell);
  return (null != number ? this.graph.view.getEdgeStyle(this.state, number.points, value, BidirectionalSubject) : null) != mxEdgeStyle.EntityRelation || 0 == isSlidingUp || isSlidingUp == this.abspoints.length - 1;
};
/**
 * @param {number} size
 * @return {?}
 */
mxEdgeHandler.prototype.createHandleShape = function(size) {
  if (null != this.handleImage) {
    return size = new mxImageShape(new mxRectangle(0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src), size.preserveImageAspect = false, size;
  }
  size = mxConstants.HANDLE_SIZE;
  if (this.preferHtml) {
    --size;
  }
  return new mxRectangleShape(new mxRectangle(0, 0, size, size), mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.createLabelHandleShape = function() {
  if (null != this.labelHandleImage) {
    var size = new mxImageShape(new mxRectangle(0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);
    /** @type {boolean} */
    size.preserveImageAspect = false;
    return size;
  }
  size = mxConstants.LABEL_HANDLE_SIZE;
  return new mxRectangleShape(new mxRectangle(0, 0, size, size), mxConstants.LABEL_HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
};
/**
 * @param {!Object} _
 * @param {?} urlToText
 * @return {undefined}
 */
mxEdgeHandler.prototype.initBend = function(_, urlToText) {
  if (this.preferHtml) {
    _.dialect = mxConstants.DIALECT_STRICTHTML;
    _.init(this.graph.container);
  } else {
    _.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
    _.init(this.graph.getView().getOverlayPane());
  }
  mxEvent.redirectMouseEvents(_.node, this.graph, this.state, null, null, null, urlToText);
  if (mxClient.IS_QUIRKS || 8 == document.documentMode) {
    mxEvent.addListener(_.node, "dragstart", function(e) {
      mxEvent.consume(e);
      return false;
    });
  }
  if (mxClient.IS_TOUCH) {
    _.node.setAttribute("pointer-events", "none");
  }
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxEdgeHandler.prototype.getHandleForEvent = function(me) {
  /** @type {null} */
  var result = null;
  if (null != this.state) {
    /**
     * @param {!Object} s
     * @return {?}
     */
    var update = function(s) {
      if (null != s && null != s.node && "none" != s.node.style.display && "hidden" != s.node.style.visibility && (me.isSource(s) || null != end && mxUtils.intersects(s.bounds, end))) {
        /** @type {number} */
        var u = me.getGraphX() - s.bounds.getCenterX();
        /** @type {number} */
        s = me.getGraphY() - s.bounds.getCenterY();
        /** @type {number} */
        u = u * u + s * s;
        if (null == w || u <= w) {
          return w = u, true;
        }
      }
      return false;
    };
    var i = mxEvent.isMouseEvent(me.getEvent()) ? 1 : this.tolerance;
    var end = this.allowHandleBoundsCheck && (mxClient.IS_IE || 0 < i) ? new mxRectangle(me.getGraphX() - i, me.getGraphY() - i, 2 * i, 2 * i) : null;
    /** @type {null} */
    var w = null;
    if (null != this.customHandles && this.isCustomHandleEvent(me)) {
      /** @type {number} */
      i = this.customHandles.length - 1;
      for (; 0 <= i; i--) {
        if (update(this.customHandles[i].shape)) {
          return mxEvent.CUSTOM_HANDLE - i;
        }
      }
    }
    if (me.isSource(this.state.text) || update(this.labelShape)) {
      result = mxEvent.LABEL_HANDLE;
    }
    if (null != this.bends) {
      /** @type {number} */
      i = 0;
      for (; i < this.bends.length; i++) {
        if (update(this.bends[i])) {
          /** @type {number} */
          result = i;
        }
      }
    }
    if (null != this.virtualBends && this.isAddVirtualBendEvent(me)) {
      /** @type {number} */
      i = 0;
      for (; i < this.virtualBends.length; i++) {
        if (update(this.virtualBends[i])) {
          /** @type {number} */
          result = mxEvent.VIRTUAL_HANDLE - i;
        }
      }
    }
  }
  return result;
};
/**
 * @param {!Object} object
 * @return {?}
 */
mxEdgeHandler.prototype.isAddVirtualBendEvent = function(object) {
  return true;
};
/**
 * @param {!Object} me1
 * @return {?}
 */
mxEdgeHandler.prototype.isCustomHandleEvent = function(me1) {
  return true;
};
/**
 * @param {!Object} e
 * @param {!Object} me
 * @return {undefined}
 */
mxEdgeHandler.prototype.mouseDown = function(e, me) {
  var id = this.getHandleForEvent(me);
  if (null != this.bends && null != this.bends[id]) {
    var me = this.bends[id].bounds;
    this.snapPoint = new mxPoint(me.getCenterX(), me.getCenterY());
  }
  if (this.addEnabled && null == id && this.isAddPointEvent(me.getEvent())) {
    this.addPoint(this.state, me.getEvent());
    me.consume();
  } else {
    if (null != id && !me.isConsumed() && this.graph.isEnabled()) {
      if (this.removeEnabled && this.isRemovePointEvent(me.getEvent())) {
        this.removePoint(this.state, id);
      } else {
        if (id != mxEvent.LABEL_HANDLE || this.graph.isLabelMovable(me.getCell())) {
          if (id <= mxEvent.VIRTUAL_HANDLE) {
            mxUtils.setOpacity(this.virtualBends[mxEvent.VIRTUAL_HANDLE - id].node, 100);
          }
          this.start(me.getX(), me.getY(), id);
        }
      }
      me.consume();
    }
  }
};
/**
 * @param {number} start
 * @param {number} end
 * @param {number} id
 * @return {undefined}
 */
mxEdgeHandler.prototype.start = function(start, end, id) {
  /** @type {number} */
  this.startX = start;
  /** @type {number} */
  this.startY = end;
  /** @type {boolean} */
  this.isSource = null == this.bends ? false : 0 == id;
  /** @type {boolean} */
  this.isTarget = null == this.bends ? false : id == this.bends.length - 1;
  /** @type {boolean} */
  this.isLabel = id == mxEvent.LABEL_HANDLE;
  if (this.isSource || this.isTarget) {
    if (start = this.state.cell, end = this.graph.model.getTerminal(start, this.isSource), null == end && this.graph.isTerminalPointMovable(start, this.isSource) || null != end && this.graph.isCellDisconnectable(start, end, this.isSource)) {
      /** @type {number} */
      this.index = id;
    }
  } else {
    /** @type {number} */
    this.index = id;
  }
  if (this.index <= mxEvent.CUSTOM_HANDLE && this.index > mxEvent.VIRTUAL_HANDLE && null != this.customHandles) {
    /** @type {number} */
    id = 0;
    for (; id < this.customHandles.length; id++) {
      if (id != mxEvent.CUSTOM_HANDLE - this.index) {
        this.customHandles[id].setVisible(false);
      }
    }
  }
};
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
mxEdgeHandler.prototype.clonePreviewState = function(a, b) {
  return this.state.clone();
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.getSnapToTerminalTolerance = function() {
  return this.graph.gridSize * this.graph.view.scale / 2;
};
/**
 * @param {!Object} data
 * @param {?} linkedEntities
 * @return {undefined}
 */
mxEdgeHandler.prototype.updateHint = function(data, linkedEntities) {
};
/**
 * @return {undefined}
 */
mxEdgeHandler.prototype.removeHint = function() {
};
/**
 * @param {number} pNumber
 * @return {?}
 */
mxEdgeHandler.prototype.roundLength = function(pNumber) {
  return Math.round(pNumber);
};
/**
 * @param {!Object} menu
 * @return {?}
 */
mxEdgeHandler.prototype.isSnapToTerminalsEvent = function(menu) {
  return this.snapToTerminals && !mxEvent.isAltDown(menu.getEvent());
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxEdgeHandler.prototype.getPointForEvent = function(me) {
  var data = this.graph.getView();
  var scale = data.scale;
  var c = new mxPoint(this.roundLength(me.getGraphX() / scale) * scale, this.roundLength(me.getGraphY() / scale) * scale);
  var e = this.getSnapToTerminalTolerance();
  /** @type {boolean} */
  var f = false;
  /** @type {boolean} */
  var g = false;
  if (0 < e && this.isSnapToTerminalsEvent(me)) {
    /**
     * @param {!Object} evt
     * @return {undefined}
     */
    var key = function(evt) {
      if (null != evt) {
        regularLight.call(this, new mxPoint(data.getRoutingCenterX(evt), data.getRoutingCenterY(evt)));
      }
    };
    /**
     * @param {number} a
     * @return {undefined}
     */
    var regularLight = function(a) {
      if (null != a) {
        var i = a.x;
        if (Math.abs(c.x - i) < e) {
          c.x = i;
          /** @type {boolean} */
          f = true;
        }
        a = a.y;
        if (Math.abs(c.y - a) < e) {
          /** @type {number} */
          c.y = a;
          /** @type {boolean} */
          g = true;
        }
      }
    };
    key.call(this, this.state.getVisibleTerminalState(true));
    key.call(this, this.state.getVisibleTerminalState(false));
    if (null != this.state.absolutePoints) {
      /** @type {number} */
      key = 0;
      for (; key < this.state.absolutePoints.length; key++) {
        regularLight.call(this, this.state.absolutePoints[key]);
      }
    }
  }
  if (this.graph.isGridEnabledEvent(me.getEvent())) {
    me = data.translate;
    if (!f) {
      /** @type {number} */
      c.x = (this.graph.snap(c.x / scale - me.x) + me.x) * scale;
    }
    if (!g) {
      /** @type {number} */
      c.y = (this.graph.snap(c.y / scale - me.y) + me.y) * scale;
    }
  }
  return c;
};
/**
 * @param {?} me
 * @return {?}
 */
mxEdgeHandler.prototype.getPreviewTerminalState = function(me) {
  this.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);
  if (null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentConstraint) {
    return null != this.marker.highlight && null != this.marker.highlight.state && this.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell ? "transparent" != this.marker.highlight.shape.stroke && (this.marker.highlight.shape.stroke = "transparent", this.marker.highlight.repaint()) : this.marker.markCell(this.constraintHandler.currentFocus.cell, "transparent"), me = this.graph.getModel(), me = this.graph.view.getTerminalPort(this.state, this.graph.view.getState(me.getTerminal(this.state.cell, 
    !this.isSource)), !this.isSource), me = null != me ? me.cell : null, this.error = this.validateConnection(this.isSource ? this.constraintHandler.currentFocus.cell : me, this.isSource ? me : this.constraintHandler.currentFocus.cell), me = null, null == this.error && (me = this.constraintHandler.currentFocus), (null != this.error || null != me && !this.isCellEnabled(me.cell)) && this.constraintHandler.reset(), me;
  }
  if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {
    return this.marker.reset(), null;
  }
  this.marker.process(me);
  me = this.marker.getValidState();
  if (!(null == me || this.isCellEnabled(me.cell))) {
    this.constraintHandler.reset();
    this.marker.reset();
  }
  return this.marker.getValidState();
};
/**
 * @param {!Object} point
 * @param {!Object} event
 * @return {?}
 */
mxEdgeHandler.prototype.getPreviewPoints = function(point, event) {
  var items = this.graph.getCellGeometry(this.state.cell);
  items = null != items.points ? items.points.slice() : null;
  var item = new mxPoint(point.x, point.y);
  /** @type {null} */
  var data = null;
  if (this.isSource || this.isTarget) {
    if (this.graph.resetEdgesOnConnect) {
      /** @type {null} */
      items = null;
    }
  } else {
    if (this.convertPoint(item, false), null == items) {
      /** @type {!Array} */
      items = [item];
    } else {
      if (this.index <= mxEvent.VIRTUAL_HANDLE) {
        items.splice(mxEvent.VIRTUAL_HANDLE - this.index, 0, item);
      }
      if (!this.isSource && !this.isTarget) {
        /** @type {number} */
        var index = 0;
        for (; index < this.bends.length; index++) {
          if (index != this.index) {
            var data = this.bends[index];
            if (null != data && mxUtils.contains(data.bounds, point.x, point.y)) {
              if (this.index <= mxEvent.VIRTUAL_HANDLE) {
                items.splice(mxEvent.VIRTUAL_HANDLE - this.index, 1);
              } else {
                items.splice(this.index - 1, 1);
              }
              data = items;
            }
          }
        }
        if (null == data && this.straightRemoveEnabled && (null == event || !mxEvent.isAltDown(event.getEvent()))) {
          /** @type {number} */
          index = this.graph.tolerance * this.graph.tolerance;
          data = this.state.absolutePoints.slice();
          /** @type {!Object} */
          data[this.index] = point;
          var i = this.state.getVisibleTerminalState(true);
          if (null != i) {
            var idx = this.graph.getConnectionConstraint(this.state, i, true);
            if (null == idx || null == this.graph.getConnectionPoint(i, idx)) {
              data[0] = new mxPoint(i.view.getRoutingCenterX(i), i.view.getRoutingCenterY(i));
            }
          }
          i = this.state.getVisibleTerminalState(false);
          if (null != i && (idx = this.graph.getConnectionConstraint(this.state, i, false), null == idx || null == this.graph.getConnectionPoint(i, idx))) {
            data[data.length - 1] = new mxPoint(i.view.getRoutingCenterX(i), i.view.getRoutingCenterY(i));
          }
          idx = this.index;
          if (0 < idx && idx < data.length - 1 && mxUtils.ptSegDistSq(data[idx - 1].x, data[idx - 1].y, data[idx + 1].x, data[idx + 1].y, point.x, point.y) < index) {
            items.splice(idx - 1, 1);
            data = items;
          }
        }
      }
      if (null == data && this.index > mxEvent.VIRTUAL_HANDLE) {
        items[this.index - 1] = item;
      }
    }
  }
  return null != data ? data : items;
};
/**
 * @param {!Object} me
 * @return {?}
 */
mxEdgeHandler.prototype.isOutlineConnectEvent = function(me) {
  var n = mxUtils.getOffset(this.graph.container);
  var e = me.getEvent();
  var d = mxEvent.getClientX(e);
  e = mxEvent.getClientY(e);
  /** @type {!Element} */
  var doc = document.documentElement;
  /** @type {number} */
  var df = this.currentPoint.x - this.graph.container.scrollLeft + n.x - ((window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0));
  /** @type {number} */
  n = this.currentPoint.y - this.graph.container.scrollTop + n.y - ((window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0));
  return this.outlineConnect && !mxEvent.isShiftDown(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || mxEvent.isAltDown(me.getEvent()) && null != me.getState() || this.marker.highlight.isHighlightAt(d, e) || (df != d || n != e) && null == me.getState() && this.marker.highlight.isHighlightAt(df, n));
};
/**
 * @param {!Object} parent
 * @param {undefined} first
 * @param {string} args
 * @param {!Object} me
 * @param {boolean} color
 * @return {undefined}
 */
mxEdgeHandler.prototype.updatePreviewState = function(parent, first, args, me, color) {
  var i = this.isSource ? args : this.state.getVisibleTerminalState(true);
  var url = this.isTarget ? args : this.state.getVisibleTerminalState(false);
  var index = this.graph.getConnectionConstraint(parent, i, true);
  var log = this.graph.getConnectionConstraint(parent, url, false);
  var result = this.constraintHandler.currentConstraint;
  if (null == result && color) {
    if (null != args) {
      if (me.isSource(this.marker.highlight.shape)) {
        first = new mxPoint(me.getGraphX(), me.getGraphY());
      }
      result = this.graph.getOutlineConstraint(first, args, me);
      this.constraintHandler.setFocus(me, args, this.isSource);
      this.constraintHandler.currentConstraint = result;
      this.constraintHandler.currentPoint = first;
    } else {
      result = new mxConnectionConstraint;
    }
  }
  if (this.outlineConnect && null != this.marker.highlight && null != this.marker.highlight.shape) {
    var r = this.graph.view.scale;
    if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus) {
      this.marker.highlight.shape.stroke = color ? mxConstants.OUTLINE_HIGHLIGHT_COLOR : "transparent";
      /** @type {number} */
      this.marker.highlight.shape.strokewidth = mxConstants.OUTLINE_HIGHLIGHT_STROKEWIDTH / r / r;
      this.marker.highlight.repaint();
    } else {
      if (this.marker.hasValidState()) {
        this.marker.highlight.shape.stroke = this.graph.isCellConnectable(me.getCell()) && this.marker.getValidState() != me.getState() ? "transparent" : mxConstants.DEFAULT_VALID_COLOR;
        /** @type {number} */
        this.marker.highlight.shape.strokewidth = mxConstants.HIGHLIGHT_STROKEWIDTH / r / r;
        this.marker.highlight.repaint();
      }
    }
  }
  if (this.isSource) {
    index = result;
  } else {
    if (this.isTarget) {
      log = result;
    }
  }
  if (this.isSource || this.isTarget) {
    if (null != result && null != result.point) {
      parent.style[this.isSource ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X] = result.point.x;
      parent.style[this.isSource ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y] = result.point.y;
    } else {
      delete parent.style[this.isSource ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X];
      delete parent.style[this.isSource ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y];
    }
  }
  parent.setVisibleTerminalState(i, true);
  parent.setVisibleTerminalState(url, false);
  if (!(this.isSource && null == i)) {
    parent.view.updateFixedTerminalPoint(parent, i, true, index);
  }
  if (!(this.isTarget && null == url)) {
    parent.view.updateFixedTerminalPoint(parent, url, false, log);
  }
  if ((this.isSource || this.isTarget) && null == args) {
    parent.setAbsoluteTerminalPoint(first, this.isSource);
    if (null == this.marker.getMarkedState()) {
      /** @type {(null|string)} */
      this.error = this.graph.allowDanglingEdges ? null : "";
    }
  }
  parent.view.updatePoints(parent, this.points, i, url);
  parent.view.updateFloatingTerminalPoints(parent, i, url);
};
/**
 * @param {?} callback
 * @param {!Object} self
 * @return {undefined}
 */
mxEdgeHandler.prototype.mouseMove = function(callback, self) {
  if (null != this.index && null != this.marker) {
    this.currentPoint = this.getPointForEvent(self);
    /** @type {null} */
    this.error = null;
    if (!this.graph.isIgnoreTerminalEvent(self.getEvent()) && mxEvent.isShiftDown(self.getEvent()) && null != this.snapPoint) {
      if (Math.abs(this.snapPoint.x - this.currentPoint.x) < Math.abs(this.snapPoint.y - this.currentPoint.y)) {
        this.currentPoint.x = this.snapPoint.x;
      } else {
        this.currentPoint.y = this.snapPoint.y;
      }
    }
    if (this.index <= mxEvent.CUSTOM_HANDLE && this.index > mxEvent.VIRTUAL_HANDLE) {
      if (null != this.customHandles) {
        this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].processEvent(self);
        this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].positionChanged();
        if (null != this.shape && null != this.shape.node) {
          /** @type {string} */
          this.shape.node.style.display = "none";
        }
      }
    } else {
      if (this.isLabel) {
        this.label.x = this.currentPoint.x;
        this.label.y = this.currentPoint.y;
      } else {
        this.points = this.getPreviewPoints(this.currentPoint, self);
        var value = this.isSource || this.isTarget ? this.getPreviewTerminalState(self) : null;
        if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentPoint) {
          this.currentPoint = this.constraintHandler.currentPoint.clone();
        } else {
          if (this.outlineConnect) {
            var pureColor = this.isSource || this.isTarget ? this.isOutlineConnectEvent(self) : false;
            if (pureColor) {
              value = this.marker.highlight.state;
            } else {
              if (null != value && value != self.getState() && this.graph.isCellConnectable(self.getCell()) && null != this.marker.highlight.shape) {
                /** @type {string} */
                this.marker.highlight.shape.stroke = "transparent";
                this.marker.highlight.repaint();
                /** @type {null} */
                value = null;
              }
            }
          }
        }
        if (!(null == value || this.isCellEnabled(value.cell))) {
          /** @type {null} */
          value = null;
          this.marker.reset();
        }
        var tagspace = this.clonePreviewState(this.currentPoint, null != value ? value.cell : null);
        this.updatePreviewState(tagspace, this.currentPoint, value, self, pureColor);
        this.setPreviewColor(null == this.error ? this.marker.validColor : this.marker.invalidColor);
        this.abspoints = tagspace.absolutePoints;
        /** @type {boolean} */
        this.active = true;
        this.updateHint(self, this.currentPoint);
      }
    }
    this.drawPreview();
    mxEvent.consume(self.getEvent());
    self.consume();
  } else {
    if (mxClient.IS_IE && null != this.getHandleForEvent(self)) {
      self.consume(false);
    }
  }
};
/**
 * @param {?} editor
 * @param {!Object} e
 * @return {undefined}
 */
mxEdgeHandler.prototype.mouseUp = function(editor, e) {
  if (null != this.index && null != this.marker) {
    if (null != this.shape && null != this.shape.node) {
      /** @type {string} */
      this.shape.node.style.display = "";
    }
    var target = this.state.cell;
    var index = this.index;
    /** @type {null} */
    this.index = null;
    if (e.getX() != this.startX || e.getY() != this.startY) {
      var t = !this.graph.isIgnoreTerminalEvent(e.getEvent()) && this.graph.isCloneEvent(e.getEvent()) && this.cloneEnabled && this.graph.isCellsCloneable();
      if (null != this.error) {
        if (0 < this.error.length) {
          this.graph.validationAlert(this.error);
        }
      } else {
        if (index <= mxEvent.CUSTOM_HANDLE && index > mxEvent.VIRTUAL_HANDLE) {
          if (null != this.customHandles) {
            var s = this.graph.getModel();
            s.beginUpdate();
            try {
              this.customHandles[mxEvent.CUSTOM_HANDLE - index].execute(e);
              if (null != this.shape && null != this.shape.node) {
                this.shape.apply(this.state);
                this.shape.redraw();
              }
            } finally {
              s.endUpdate();
            }
          }
        } else {
          if (this.isLabel) {
            this.moveLabel(this.state, this.label.x, this.label.y);
          } else {
            if (this.isSource || this.isTarget) {
              if (index = null, null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus && (index = this.constraintHandler.currentFocus.cell), null == index && this.marker.hasValidState() && null != this.marker.highlight && null != this.marker.highlight.shape && "transparent" != this.marker.highlight.shape.stroke && "white" != this.marker.highlight.shape.stroke && (index = this.marker.validState.cell), null != index) {
                s = this.graph.getModel();
                var title = s.getParent(target);
                s.beginUpdate();
                try {
                  if (t) {
                    var res = s.getGeometry(target);
                    t = this.graph.cloneCell(target);
                    s.add(title, t, s.getChildCount(title));
                    if (null != res) {
                      res = res.clone();
                      s.setGeometry(t, res);
                    }
                    var url = s.getTerminal(target, !this.isSource);
                    this.graph.connectCell(t, url, !this.isSource);
                    target = t;
                  }
                  target = this.connect(target, index, this.isSource, t, e);
                } finally {
                  s.endUpdate();
                }
              } else {
                if (this.graph.isAllowDanglingEdges()) {
                  s = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];
                  s.x = this.roundLength(s.x / this.graph.view.scale - this.graph.view.translate.x);
                  s.y = this.roundLength(s.y / this.graph.view.scale - this.graph.view.translate.y);
                  res = this.graph.getView().getState(this.graph.getModel().getParent(target));
                  if (null != res) {
                    s.x -= res.origin.x;
                    s.y -= res.origin.y;
                  }
                  s.x -= this.graph.panDx / this.graph.view.scale;
                  s.y -= this.graph.panDy / this.graph.view.scale;
                  target = this.changeTerminalPoint(target, s, this.isSource, t);
                }
              }
            } else {
              if (this.active) {
                target = this.changePoints(target, this.points, t);
              } else {
                this.graph.getView().invalidate(this.state.cell);
                this.graph.getView().validate(this.state.cell);
              }
            }
          }
        }
      }
    } else {
      if (this.graph.isToggleEvent(e.getEvent())) {
        this.graph.selectCellForEvent(this.state.cell, e.getEvent());
      }
    }
    if (null != this.marker) {
      this.reset();
      if (target != this.state.cell) {
        this.graph.setSelectionCell(target);
      }
    }
    e.consume();
  }
};
/**
 * @return {undefined}
 */
mxEdgeHandler.prototype.reset = function() {
  if (this.active) {
    this.refresh();
  }
  /** @type {null} */
  this.snapPoint = this.points = this.label = this.index = this.error = null;
  /** @type {boolean} */
  this.active = this.isTarget = this.isSource = this.isLabel = false;
  if (this.livePreview && null != this.sizers) {
    /** @type {number} */
    var i = 0;
    for (; i < this.sizers.length; i++) {
      if (null != this.sizers[i]) {
        /** @type {string} */
        this.sizers[i].node.style.display = "";
      }
    }
  }
  if (null != this.marker) {
    this.marker.reset();
  }
  if (null != this.constraintHandler) {
    this.constraintHandler.reset();
  }
  if (null != this.customHandles) {
    /** @type {number} */
    i = 0;
    for (; i < this.customHandles.length; i++) {
      this.customHandles[i].reset();
    }
  }
  this.setPreviewColor(mxConstants.EDGE_SELECTION_COLOR);
  this.removeHint();
  this.redraw();
};
/**
 * @param {!Object} v
 * @return {undefined}
 */
mxEdgeHandler.prototype.setPreviewColor = function(v) {
  if (null != this.shape) {
    /** @type {!Object} */
    this.shape.stroke = v;
  }
};
/**
 * @param {!Object} target
 * @param {string} point
 * @return {?}
 */
mxEdgeHandler.prototype.convertPoint = function(target, point) {
  var step = this.graph.getView().getScale();
  var geo = this.graph.getView().getTranslate();
  if (point) {
    target.x = this.graph.snap(target.x);
    target.y = this.graph.snap(target.y);
  }
  /** @type {number} */
  target.x = Math.round(target.x / step - geo.x);
  /** @type {number} */
  target.y = Math.round(target.y / step - geo.y);
  step = this.graph.getView().getState(this.graph.getModel().getParent(this.state.cell));
  if (null != step) {
    target.x -= step.origin.x;
    target.y -= step.origin.y;
  }
  return target;
};
/**
 * @param {!Object} f
 * @param {number} start
 * @param {number} end
 * @return {undefined}
 */
mxEdgeHandler.prototype.moveLabel = function(f, start, end) {
  var layer = this.graph.getModel();
  var b = layer.getGeometry(f.cell);
  if (null != b) {
    var bppp = this.graph.getView().scale;
    b = b.clone();
    if (b.relative) {
      var v = this.graph.getView().getRelativePoint(f, start, end);
      /** @type {number} */
      b.x = Math.round(1E4 * v.x) / 1E4;
      /** @type {number} */
      b.y = Math.round(v.y);
      b.offset = new mxPoint(0, 0);
      v = this.graph.view.getPoint(f, b);
      b.offset = new mxPoint(Math.round((start - v.x) / bppp), Math.round((end - v.y) / bppp));
    } else {
      var p = f.absolutePoints;
      v = p[0];
      p = p[p.length - 1];
      if (null != v && null != p) {
        b.offset = new mxPoint(Math.round((start - (v.x + (p.x - v.x) / 2)) / bppp), Math.round((end - (v.y + (p.y - v.y) / 2)) / bppp));
        /** @type {number} */
        b.x = 0;
        /** @type {number} */
        b.y = 0;
      }
    }
    layer.setGeometry(f.cell, b);
  }
};
/**
 * @param {string} id
 * @param {boolean} value
 * @param {boolean} source
 * @param {?} s
 * @param {!Object} width
 * @return {?}
 */
mxEdgeHandler.prototype.connect = function(id, value, source, s, width) {
  s = this.graph.getModel();
  s.getParent(id);
  s.beginUpdate();
  try {
    var dashes = this.constraintHandler.currentConstraint;
    if (null == dashes) {
      dashes = new mxConnectionConstraint;
    }
    this.graph.connectCell(id, value, source, dashes);
  } finally {
    s.endUpdate();
  }
  return id;
};
/**
 * @param {string} id
 * @param {string} component
 * @param {boolean} value
 * @param {?} _in
 * @return {?}
 */
mxEdgeHandler.prototype.changeTerminalPoint = function(id, component, value, _in) {
  var self = this.graph.getModel();
  self.beginUpdate();
  try {
    if (_in) {
      var node = self.getParent(id);
      var term = self.getTerminal(id, !value);
      id = this.graph.cloneCell(id);
      self.add(node, id, self.getChildCount(node));
      self.setTerminal(id, term, !value);
    }
    var res = self.getGeometry(id);
    if (null != res) {
      res = res.clone();
      res.setTerminalPoint(component, value);
      self.setGeometry(id, res);
      this.graph.connectCell(id, null, value, new mxConnectionConstraint);
    }
  } finally {
    self.endUpdate();
  }
  return id;
};
/**
 * @param {string} id
 * @param {?} points
 * @param {?} img
 * @return {?}
 */
mxEdgeHandler.prototype.changePoints = function(id, points, img) {
  var self = this.graph.getModel();
  self.beginUpdate();
  try {
    if (img) {
      var node = self.getParent(id);
      var term = self.getTerminal(id, true);
      var g = self.getTerminal(id, false);
      id = this.graph.cloneCell(id);
      self.add(node, id, self.getChildCount(node));
      self.setTerminal(id, term, true);
      self.setTerminal(id, g, false);
    }
    var p = self.getGeometry(id);
    if (null != p) {
      p = p.clone();
      p.points = points;
      self.setGeometry(id, p);
    }
  } finally {
    self.endUpdate();
  }
  return id;
};
/**
 * @param {?} y
 * @param {undefined} evt
 * @return {undefined}
 */
mxEdgeHandler.prototype.addPoint = function(y, evt) {
  var c = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
  var newPoint = this.graph.isGridEnabledEvent(evt);
  this.convertPoint(c, newPoint);
  this.addPointAt(y, c.x, c.y);
  mxEvent.consume(evt);
};
/**
 * @param {?} data
 * @param {number} x
 * @param {number} s
 * @return {undefined}
 */
mxEdgeHandler.prototype.addPointAt = function(data, x, s) {
  var model = this.graph.getCellGeometry(data.cell);
  x = new mxPoint(x, s);
  if (null != model) {
    model = model.clone();
    var p = this.graph.view.translate;
    s = this.graph.view.scale;
    p = new mxPoint(p.x * s, p.y * s);
    var element = this.graph.model.getParent(this.state.cell);
    if (this.graph.model.isVertex(element)) {
      p = this.graph.view.getState(element);
      p = new mxPoint(p.x, p.y);
    }
    s = mxUtils.findNearestSegment(data, x.x * s + p.x, x.y * s + p.y);
    if (null == model.points) {
      /** @type {!Array} */
      model.points = [x];
    } else {
      model.points.splice(s, 0, x);
    }
    this.graph.getModel().setGeometry(data.cell, model);
    this.refresh();
    this.redraw();
  }
};
/**
 * @param {?} e
 * @param {number} index
 * @return {undefined}
 */
mxEdgeHandler.prototype.removePoint = function(e, index) {
  if (0 < index && index < this.abspoints.length - 1) {
    var geo = this.graph.getCellGeometry(this.state.cell);
    if (null != geo && null != geo.points) {
      geo = geo.clone();
      geo.points.splice(index - 1, 1);
      this.graph.getModel().setGeometry(e.cell, geo);
      this.refresh();
      this.redraw();
    }
  }
};
/**
 * @param {?} value
 * @return {?}
 */
mxEdgeHandler.prototype.getHandleFillColor = function(value) {
  /** @type {boolean} */
  value = 0 == value;
  var cell = this.state.cell;
  var index = this.graph.getModel().getTerminal(cell, value);
  var a4 = mxConstants.HANDLE_FILLCOLOR;
  if (null != index && !this.graph.isCellDisconnectable(cell, index, value) || null == index && !this.graph.isTerminalPointMovable(cell, value)) {
    a4 = mxConstants.LOCKED_HANDLE_FILLCOLOR;
  } else {
    if (null != index && this.graph.isCellDisconnectable(cell, index, value)) {
      a4 = mxConstants.CONNECT_HANDLE_FILLCOLOR;
    }
  }
  return a4;
};
/**
 * @param {!Function} elem
 * @return {undefined}
 */
mxEdgeHandler.prototype.redraw = function(elem) {
  if (null != this.state) {
    this.abspoints = this.state.absolutePoints.slice();
    var p = this.graph.getModel().getGeometry(this.state.cell);
    if (null != p && (p = p.points, null != this.bends && 0 < this.bends.length && null != p)) {
      if (null == this.points) {
        /** @type {!Array} */
        this.points = [];
      }
      /** @type {number} */
      var i = 1;
      for (; i < this.bends.length - 1; i++) {
        if (null != this.bends[i] && null != this.abspoints[i]) {
          this.points[i - 1] = p[i - 1];
        }
      }
    }
    this.drawPreview();
    if (!elem) {
      this.redrawHandles();
    }
  }
};
/**
 * @return {undefined}
 */
mxEdgeHandler.prototype.redrawHandles = function() {
  var i = this.state.cell;
  var s = this.labelShape.bounds;
  this.label = new mxPoint(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
  this.labelShape.bounds = new mxRectangle(Math.round(this.label.x - s.width / 2), Math.round(this.label.y - s.height / 2), s.width, s.height);
  s = this.graph.getLabel(i);
  this.labelShape.visible = null != s && 0 < s.length && this.graph.isLabelMovable(i);
  if (null != this.bends && 0 < this.bends.length) {
    /** @type {number} */
    var c = this.abspoints.length - 1;
    i = this.abspoints[0];
    var p = i.x;
    var j = i.y;
    s = this.bends[0].bounds;
    this.bends[0].bounds = new mxRectangle(Math.floor(p - s.width / 2), Math.floor(j - s.height / 2), s.width, s.height);
    this.bends[0].fill = this.getHandleFillColor(0);
    this.bends[0].redraw();
    if (this.manageLabelHandle) {
      this.checkLabelHandle(this.bends[0].bounds);
    }
    c = this.abspoints[c];
    p = c.x;
    j = c.y;
    /** @type {number} */
    var key = this.bends.length - 1;
    s = this.bends[key].bounds;
    this.bends[key].bounds = new mxRectangle(Math.floor(p - s.width / 2), Math.floor(j - s.height / 2), s.width, s.height);
    this.bends[key].fill = this.getHandleFillColor(key);
    this.bends[key].redraw();
    if (this.manageLabelHandle) {
      this.checkLabelHandle(this.bends[key].bounds);
    }
    this.redrawInnerBends(i, c);
  }
  if (null != this.abspoints && null != this.virtualBends && 0 < this.virtualBends.length) {
    c = this.abspoints[0];
    /** @type {number} */
    i = 0;
    for (; i < this.virtualBends.length; i++) {
      if (null != this.virtualBends[i] && null != this.abspoints[i + 1]) {
        p = this.abspoints[i + 1];
        s = this.virtualBends[i];
        s.bounds = new mxRectangle(Math.floor(c.x + (p.x - c.x) / 2 - s.bounds.width / 2), Math.floor(c.y + (p.y - c.y) / 2 - s.bounds.height / 2), s.bounds.width, s.bounds.height);
        s.redraw();
        mxUtils.setOpacity(s.node, this.virtualBendOpacity);
        c = p;
        if (this.manageLabelHandle) {
          this.checkLabelHandle(s.bounds);
        }
      }
    }
  }
  if (null != this.labelShape) {
    this.labelShape.redraw();
  }
  if (null != this.customHandles) {
    /** @type {number} */
    i = 0;
    for (; i < this.customHandles.length; i++) {
      s = this.customHandles[i].shape.node.style.display;
      this.customHandles[i].redraw();
      this.customHandles[i].shape.node.style.display = s;
      /** @type {string} */
      this.customHandles[i].shape.node.style.visibility = this.isCustomHandleVisible(this.customHandles[i]) ? "" : "hidden";
    }
  }
};
/**
 * @param {?} a
 * @return {?}
 */
mxEdgeHandler.prototype.isCustomHandleVisible = function(a) {
  return !this.graph.isEditing() && 1 == this.state.view.graph.getSelectionCount();
};
/**
 * @param {boolean} value
 * @return {undefined}
 */
mxEdgeHandler.prototype.setHandlesVisible = function(value) {
  if (null != this.bends) {
    /** @type {number} */
    var i = 0;
    for (; i < this.bends.length; i++) {
      /** @type {string} */
      this.bends[i].node.style.display = value ? "" : "none";
    }
  }
  if (null != this.virtualBends) {
    /** @type {number} */
    i = 0;
    for (; i < this.virtualBends.length; i++) {
      /** @type {string} */
      this.virtualBends[i].node.style.display = value ? "" : "none";
    }
  }
  if (null != this.labelShape) {
    /** @type {string} */
    this.labelShape.node.style.display = value ? "" : "none";
  }
  if (null != this.customHandles) {
    /** @type {number} */
    i = 0;
    for (; i < this.customHandles.length; i++) {
      this.customHandles[i].setVisible(value);
    }
  }
};
/**
 * @param {?} position
 * @param {number} hexColor
 * @return {undefined}
 */
mxEdgeHandler.prototype.redrawInnerBends = function(position, hexColor) {
  /** @type {number} */
  var i = 1;
  for (; i < this.bends.length - 1; i++) {
    if (null != this.bends[i]) {
      if (null != this.abspoints[i]) {
        var left = this.abspoints[i].x;
        var y = this.abspoints[i].y;
        var table = this.bends[i].bounds;
        /** @type {string} */
        this.bends[i].node.style.visibility = "visible";
        this.bends[i].bounds = new mxRectangle(Math.round(left - table.width / 2), Math.round(y - table.height / 2), table.width, table.height);
        if (this.manageLabelHandle) {
          this.checkLabelHandle(this.bends[i].bounds);
        } else {
          if (null == this.handleImage && this.labelShape.visible && mxUtils.intersects(this.bends[i].bounds, this.labelShape.bounds)) {
            w = mxConstants.HANDLE_SIZE + 3;
            h = mxConstants.HANDLE_SIZE + 3;
            this.bends[i].bounds = new mxRectangle(Math.round(left - w / 2), Math.round(y - h / 2), w, h);
          }
        }
        this.bends[i].redraw();
      } else {
        this.bends[i].destroy();
        /** @type {null} */
        this.bends[i] = null;
      }
    }
  }
};
/**
 * @param {?} o
 * @return {undefined}
 */
mxEdgeHandler.prototype.checkLabelHandle = function(o) {
  if (null != this.labelShape) {
    var point = this.labelShape.bounds;
    if (mxUtils.intersects(o, point)) {
      if (o.getCenterY() < point.getCenterY()) {
        point.y = o.y + o.height;
      } else {
        /** @type {number} */
        point.y = o.y - point.height;
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxEdgeHandler.prototype.drawPreview = function() {
  try {
    if (this.isLabel) {
      var table = this.labelShape.bounds;
      var size = new mxRectangle(Math.round(this.label.x - table.width / 2), Math.round(this.label.y - table.height / 2), table.width, table.height);
      if (!this.labelShape.bounds.equals(size)) {
        this.labelShape.bounds = size;
        this.labelShape.redraw();
      }
    }
    if (!(null == this.shape || mxUtils.equalPoints(this.shape.points, this.abspoints))) {
      this.shape.apply(this.state);
      this.shape.points = this.abspoints.slice();
      this.shape.scale = this.state.view.scale;
      this.shape.isDashed = this.isSelectionDashed();
      this.shape.stroke = this.getSelectionColor();
      /** @type {number} */
      this.shape.strokewidth = this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;
      /** @type {boolean} */
      this.shape.isShadow = false;
      this.shape.redraw();
    }
    this.updateParentHighlight();
  } catch (c) {
  }
};
/**
 * @return {undefined}
 */
mxEdgeHandler.prototype.refresh = function() {
  if (null != this.state) {
    this.abspoints = this.getSelectionPoints(this.state);
    /** @type {!Array} */
    this.points = [];
    if (null != this.bends) {
      this.destroyBends(this.bends);
      this.bends = this.createBends();
    }
    if (null != this.virtualBends) {
      this.destroyBends(this.virtualBends);
      this.virtualBends = this.createVirtualBends();
    }
    if (null != this.customHandles) {
      this.destroyBends(this.customHandles);
      this.customHandles = this.createCustomHandles();
    }
    if (null != this.labelShape && null != this.labelShape.node && null != this.labelShape.node.parentNode) {
      this.labelShape.node.parentNode.appendChild(this.labelShape.node);
    }
  }
};
/**
 * @return {?}
 */
mxEdgeHandler.prototype.isDestroyed = function() {
  return null == this.shape;
};
/**
 * @param {!Object} birds
 * @return {undefined}
 */
mxEdgeHandler.prototype.destroyBends = function(birds) {
  if (null != birds) {
    /** @type {number} */
    var i = 0;
    for (; i < birds.length; i++) {
      if (null != birds[i]) {
        birds[i].destroy();
      }
    }
  }
};
/**
 * @return {undefined}
 */
mxEdgeHandler.prototype.destroy = function() {
  if (null != this.escapeHandler) {
    this.state.view.graph.removeListener(this.escapeHandler);
    /** @type {null} */
    this.escapeHandler = null;
  }
  if (null != this.marker) {
    this.marker.destroy();
    /** @type {null} */
    this.marker = null;
  }
  if (null != this.shape) {
    this.shape.destroy();
    /** @type {null} */
    this.shape = null;
  }
  if (null != this.parentHighlight) {
    var type = this.graph.model.getParent(this.state.cell);
    type = this.graph.view.getState(type);
    if (null != type && type.parentHighlight == this.parentHighlight) {
      /** @type {null} */
      type.parentHighlight = null;
    }
    this.parentHighlight.destroy();
    /** @type {null} */
    this.parentHighlight = null;
  }
  if (null != this.labelShape) {
    this.labelShape.destroy();
    /** @type {null} */
    this.labelShape = null;
  }
  if (null != this.constraintHandler) {
    this.constraintHandler.destroy();
    /** @type {null} */
    this.constraintHandler = null;
  }
  this.destroyBends(this.virtualBends);
  /** @type {null} */
  this.virtualBends = null;
  this.destroyBends(this.customHandles);
  /** @type {null} */
  this.customHandles = null;
  this.destroyBends(this.bends);
  /** @type {null} */
  this.bends = null;
  this.removeHint();
};
/**
 * @param {?} p1__3354_SHARP_
 * @return {undefined}
 */
function mxElbowEdgeHandler(p1__3354_SHARP_) {
  mxEdgeHandler.call(this, p1__3354_SHARP_);
}
mxUtils.extend(mxElbowEdgeHandler, mxEdgeHandler);
/** @type {boolean} */
mxElbowEdgeHandler.prototype.flipEnabled = true;
/** @type {string} */
mxElbowEdgeHandler.prototype.doubleClickOrientationResource = "none" != mxClient.language ? "doubleClickOrientation" : "";
/**
 * @return {?}
 */
mxElbowEdgeHandler.prototype.createBends = function() {
  /** @type {!Array} */
  var yRanges = [];
  var range = this.createHandleShape(0);
  this.initBend(range);
  range.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
  yRanges.push(range);
  yRanges.push(this.createVirtualBend(mxUtils.bind(this, function(evt) {
    if (!mxEvent.isConsumed(evt) && this.flipEnabled) {
      this.graph.flipEdge(this.state.cell, evt);
      mxEvent.consume(evt);
    }
  })));
  this.points.push(new mxPoint(0, 0));
  range = this.createHandleShape(2);
  this.initBend(range);
  range.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
  yRanges.push(range);
  return yRanges;
};
/**
 * @param {?} urlToText
 * @return {?}
 */
mxElbowEdgeHandler.prototype.createVirtualBend = function(urlToText) {
  var that = this.createHandleShape();
  this.initBend(that, urlToText);
  that.setCursor(this.getCursorForBend());
  if (!this.graph.isCellBendable(this.state.cell)) {
    /** @type {string} */
    that.node.style.display = "none";
  }
  return that;
};
/**
 * @return {?}
 */
mxElbowEdgeHandler.prototype.getCursorForBend = function() {
  return this.state.style[mxConstants.STYLE_EDGE] == mxEdgeStyle.TopToBottom || this.state.style[mxConstants.STYLE_EDGE] == mxConstants.EDGESTYLE_TOPTOBOTTOM || (this.state.style[mxConstants.STYLE_EDGE] == mxEdgeStyle.ElbowConnector || this.state.style[mxConstants.STYLE_EDGE] == mxConstants.EDGESTYLE_ELBOW) && this.state.style[mxConstants.STYLE_ELBOW] == mxConstants.ELBOW_VERTICAL ? "row-resize" : "col-resize";
};
/**
 * @param {string} targetNode
 * @return {?}
 */
mxElbowEdgeHandler.prototype.getTooltipForNode = function(targetNode) {
  /** @type {null} */
  var name = null;
  if (!(null == this.bends || null == this.bends[1] || targetNode != this.bends[1].node && targetNode.parentNode != this.bends[1].node)) {
    name = this.doubleClickOrientationResource;
    name = mxResources.get(name) || name;
  }
  return name;
};
/**
 * @param {!Object} data
 * @param {string} point
 * @return {?}
 */
mxElbowEdgeHandler.prototype.convertPoint = function(data, point) {
  var scale = this.graph.getView().getScale();
  var geo = this.graph.getView().getTranslate();
  var position = this.state.origin;
  if (point) {
    data.x = this.graph.snap(data.x);
    data.y = this.graph.snap(data.y);
  }
  /** @type {number} */
  data.x = Math.round(data.x / scale - geo.x - position.x);
  /** @type {number} */
  data.y = Math.round(data.y / scale - geo.y - position.y);
  return data;
};
/**
 * @param {number} a
 * @param {number} b
 * @return {undefined}
 */
mxElbowEdgeHandler.prototype.redrawInnerBends = function(a, b) {
  var value = this.graph.getModel().getGeometry(this.state.cell);
  var w = this.state.absolutePoints;
  /** @type {null} */
  var pt = null;
  if (1 < w.length) {
    a = w[1];
    b = w[w.length - 2];
  } else {
    if (null != value.points && 0 < value.points.length) {
      pt = w[0];
    }
  }
  pt = null == pt ? new mxPoint(a.x + (b.x - a.x) / 2, a.y + (b.y - a.y) / 2) : new mxPoint(this.graph.getView().scale * (pt.x + this.graph.getView().translate.x + this.state.origin.x), this.graph.getView().scale * (pt.y + this.graph.getView().translate.y + this.state.origin.y));
  w = this.bends[1].bounds;
  value = w.width;
  w = w.height;
  value = new mxRectangle(Math.round(pt.x - value / 2), Math.round(pt.y - w / 2), value, w);
  if (this.manageLabelHandle) {
    this.checkLabelHandle(value);
  } else {
    if (null == this.handleImage && this.labelShape.visible && mxUtils.intersects(value, this.labelShape.bounds)) {
      value = mxConstants.HANDLE_SIZE + 3;
      w = mxConstants.HANDLE_SIZE + 3;
      value = new mxRectangle(Math.floor(pt.x - value / 2), Math.floor(pt.y - w / 2), value, w);
    }
  }
  this.bends[1].bounds = value;
  this.bends[1].redraw();
  if (this.manageLabelHandle) {
    this.checkLabelHandle(this.bends[1].bounds);
  }
};
/**
 * @param {?} p1__3354_SHARP_
 * @return {undefined}
 */
function mxEdgeSegmentHandler(p1__3354_SHARP_) {
  mxEdgeHandler.call(this, p1__3354_SHARP_);
}
mxUtils.extend(mxEdgeSegmentHandler, mxElbowEdgeHandler);
/**
 * @return {?}
 */
mxEdgeSegmentHandler.prototype.getCurrentPoints = function() {
  var segPoints = this.state.absolutePoints;
  if (null != segPoints) {
    /** @type {number} */
    var right = Math.max(1, this.graph.view.scale);
    if (2 == segPoints.length || 3 == segPoints.length && (Math.abs(segPoints[0].x - segPoints[1].x) < right && Math.abs(segPoints[1].x - segPoints[2].x) < right || Math.abs(segPoints[0].y - segPoints[1].y) < right && Math.abs(segPoints[1].y - segPoints[2].y) < right)) {
      right = segPoints[0].x + (segPoints[segPoints.length - 1].x - segPoints[0].x) / 2;
      var bottom = segPoints[0].y + (segPoints[segPoints.length - 1].y - segPoints[0].y) / 2;
      /** @type {!Array} */
      segPoints = [segPoints[0], new mxPoint(right, bottom), new mxPoint(right, bottom), segPoints[segPoints.length - 1]];
    }
  }
  return segPoints;
};
/**
 * @param {!Object} a
 * @return {?}
 */
mxEdgeSegmentHandler.prototype.getPreviewPoints = function(a) {
  if (this.isSource || this.isTarget) {
    return mxElbowEdgeHandler.prototype.getPreviewPoints.apply(this, arguments);
  }
  var value = this.getCurrentPoints();
  var node = this.convertPoint(value[0].clone(), false);
  a = this.convertPoint(a.clone(), false);
  /** @type {!Array} */
  var values = [];
  /** @type {number} */
  var i = 1;
  for (; i < value.length; i++) {
    var p = this.convertPoint(value[i].clone(), false);
    if (i == this.index) {
      if (0 == Math.round(node.x - p.x)) {
        node.x = a.x;
        p.x = a.x;
      }
      if (0 == Math.round(node.y - p.y)) {
        node.y = a.y;
        p.y = a.y;
      }
    }
    if (i < value.length - 1) {
      values.push(p);
    }
    node = p;
  }
  if (1 == values.length) {
    value = this.state.getVisibleTerminalState(true);
    node = this.state.getVisibleTerminalState(false);
    p = this.state.view.getScale();
    var currPaperPosition = this.state.view.getTranslate();
    i = values[0].x * p + currPaperPosition.x;
    p = values[0].y * p + currPaperPosition.y;
    if (null != value && mxUtils.contains(value, i, p) || null != node && mxUtils.contains(node, i, p)) {
      /** @type {!Array} */
      values = [a, a];
    }
  }
  return values;
};
/**
 * @param {!Object} name
 * @param {!Object} a
 * @param {?} val
 * @param {!Object} global
 * @return {undefined}
 */
mxEdgeSegmentHandler.prototype.updatePreviewState = function(name, a, val, global) {
  mxEdgeHandler.prototype.updatePreviewState.apply(this, arguments);
  if (!this.isSource && !this.isTarget) {
    a = this.convertPoint(a.clone(), false);
    var ref = name.absolutePoints;
    var value = ref[0];
    var target = ref[1];
    /** @type {!Array} */
    var points = [];
    /** @type {number} */
    var i = 2;
    for (; i < ref.length; i++) {
      var object = ref[i];
      if (!(0 == Math.round(value.x - target.x) && 0 == Math.round(target.x - object.x) || 0 == Math.round(value.y - target.y) && 0 == Math.round(target.y - object.y))) {
        points.push(this.convertPoint(target.clone(), false));
      }
      value = target;
      target = object;
    }
    value = this.state.getVisibleTerminalState(true);
    target = this.state.getVisibleTerminalState(false);
    i = this.state.absolutePoints;
    if (0 == points.length && (0 == Math.round(ref[0].x - ref[ref.length - 1].x) || 0 == Math.round(ref[0].y - ref[ref.length - 1].y))) {
      /** @type {!Array} */
      points = [a, a];
    } else {
      if (5 == ref.length && 2 == points.length && null != value && null != target && null != i && 0 == Math.round(i[0].x - i[i.length - 1].x)) {
        points = this.graph.getView();
        i = points.getScale();
        object = points.getTranslate();
        /** @type {number} */
        ref = points.getRoutingCenterY(value) / i - object.y;
        var args = this.graph.getConnectionConstraint(name, value, true);
        if (null != args) {
          args = this.graph.getConnectionPoint(value, args);
          if (null != args) {
            this.convertPoint(args, false);
            ref = args.y;
          }
        }
        /** @type {number} */
        points = points.getRoutingCenterY(target) / i - object.y;
        if (i = this.graph.getConnectionConstraint(name, target, false)) {
          args = this.graph.getConnectionPoint(target, i);
          if (null != args) {
            this.convertPoint(args, false);
            points = args.y;
          }
        }
        /** @type {!Array} */
        points = [new mxPoint(a.x, ref), new mxPoint(a.x, points)];
      }
    }
    /** @type {!Array} */
    this.points = points;
    name.view.updateFixedTerminalPoints(name, value, target);
    name.view.updatePoints(name, this.points, value, target);
    name.view.updateFloatingTerminalPoints(name, value, target);
  }
};
/**
 * @param {!Object} p
 * @param {?} e
 * @param {?} f
 * @param {?} a
 * @param {!Object} fn
 * @return {?}
 */
mxEdgeSegmentHandler.prototype.connect = function(p, e, f, a, fn) {
  var me = this.graph.getModel();
  var g = me.getGeometry(p);
  /** @type {null} */
  var prev = null;
  if (null != g && null != g.points && 0 < g.points.length) {
    var participants = this.abspoints;
    var p = participants[0];
    var p0 = participants[1];
    /** @type {!Array} */
    prev = [];
    /** @type {number} */
    var i = 2;
    for (; i < participants.length; i++) {
      var p1 = participants[i];
      if (!(0 == Math.round(p.x - p0.x) && 0 == Math.round(p0.x - p1.x) || 0 == Math.round(p.y - p0.y) && 0 == Math.round(p0.y - p1.y))) {
        prev.push(this.convertPoint(p0.clone(), false));
      }
      p = p0;
      p0 = p1;
    }
  }
  me.beginUpdate();
  try {
    if (null != prev) {
      g = me.getGeometry(p);
      if (null != g) {
        g = g.clone();
        /** @type {!Array} */
        g.points = prev;
        me.setGeometry(p, g);
      }
    }
    p = mxEdgeHandler.prototype.connect.apply(this, arguments);
  } finally {
    me.endUpdate();
  }
  return p;
};
/**
 * @param {string} topnode
 * @return {?}
 */
mxEdgeSegmentHandler.prototype.getTooltipForNode = function(topnode) {
  return null;
};
/**
 * @param {!Object} obj
 * @param {?} def
 * @param {?} text
 * @return {undefined}
 */
mxEdgeSegmentHandler.prototype.start = function(obj, def, text) {
  mxEdgeHandler.prototype.start.apply(this, arguments);
  if (!(null == this.bends || null == this.bends[text] || this.isSource || this.isTarget)) {
    mxUtils.setOpacity(this.bends[text].node, 100);
  }
};
/**
 * @return {?}
 */
mxEdgeSegmentHandler.prototype.createBends = function() {
  /** @type {!Array} */
  var yRanges = [];
  var range = this.createHandleShape(0);
  this.initBend(range);
  range.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
  yRanges.push(range);
  var pointsByColumns = this.getCurrentPoints();
  if (this.graph.isCellBendable(this.state.cell)) {
    if (null == this.points) {
      /** @type {!Array} */
      this.points = [];
    }
    /** @type {number} */
    var i = 0;
    for (; i < pointsByColumns.length - 1; i++) {
      range = this.createVirtualBend();
      yRanges.push(range);
      /** @type {boolean} */
      var vertical = 0 == Math.round(pointsByColumns[i].x - pointsByColumns[i + 1].x);
      if (0 == Math.round(pointsByColumns[i].y - pointsByColumns[i + 1].y) && i < pointsByColumns.length - 2) {
        /** @type {boolean} */
        vertical = 0 == Math.round(pointsByColumns[i].x - pointsByColumns[i + 2].x);
      }
      range.setCursor(vertical ? "col-resize" : "row-resize");
      this.points.push(new mxPoint(0, 0));
    }
  }
  range = this.createHandleShape(pointsByColumns.length);
  this.initBend(range);
  range.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
  yRanges.push(range);
  return yRanges;
};
/**
 * @return {undefined}
 */
mxEdgeSegmentHandler.prototype.redraw = function() {
  this.refresh();
  mxEdgeHandler.prototype.redraw.apply(this, arguments);
};
/**
 * @param {number} a
 * @param {number} b
 * @return {undefined}
 */
mxEdgeSegmentHandler.prototype.redrawInnerBends = function(a, b) {
  if (this.graph.isCellBendable(this.state.cell)) {
    var points = this.getCurrentPoints();
    if (null != points && 1 < points.length) {
      /** @type {boolean} */
      var args = false;
      if (4 == points.length && 0 == Math.round(points[1].x - points[2].x) && 0 == Math.round(points[1].y - points[2].y)) {
        if (args = true, 0 == Math.round(points[0].y - points[points.length - 1].y)) {
          var x = points[0].x + (points[points.length - 1].x - points[0].x) / 2;
          points[1] = new mxPoint(x, points[1].y);
          points[2] = new mxPoint(x, points[2].y);
        } else {
          x = points[0].y + (points[points.length - 1].y - points[0].y) / 2;
          points[1] = new mxPoint(points[1].x, x);
          points[2] = new mxPoint(points[2].x, x);
        }
      }
      /** @type {number} */
      x = 0;
      for (; x < points.length - 1; x++) {
        if (null != this.bends[x + 1]) {
          a = points[x];
          b = points[x + 1];
          var pt = new mxPoint(a.x + (b.x - a.x) / 2, a.y + (b.y - a.y) / 2);
          var table = this.bends[x + 1].bounds;
          this.bends[x + 1].bounds = new mxRectangle(Math.floor(pt.x - table.width / 2), Math.floor(pt.y - table.height / 2), table.width, table.height);
          this.bends[x + 1].redraw();
          if (this.manageLabelHandle) {
            this.checkLabelHandle(this.bends[x + 1].bounds);
          }
        }
      }
      if (args) {
        mxUtils.setOpacity(this.bends[1].node, this.virtualBendOpacity);
        mxUtils.setOpacity(this.bends[3].node, this.virtualBendOpacity);
      }
    }
  }
};
/**
 * @param {!Object} gf
 * @param {!Object} target
 * @return {undefined}
 */
function mxKeyHandler(gf, target) {
  if (null != gf) {
    /** @type {!Object} */
    this.graph = gf;
    this.target = target || document.documentElement;
    /** @type {!Array} */
    this.normalKeys = [];
    /** @type {!Array} */
    this.shiftKeys = [];
    /** @type {!Array} */
    this.controlKeys = [];
    /** @type {!Array} */
    this.controlShiftKeys = [];
    this.keydownHandler = mxUtils.bind(this, function(e) {
      this.keyDown(e);
    });
    mxEvent.addListener(this.target, "keydown", this.keydownHandler);
    if (mxClient.IS_IE) {
      mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
        this.destroy();
      }));
    }
  }
}
/** @type {null} */
mxKeyHandler.prototype.graph = null;
/** @type {null} */
mxKeyHandler.prototype.target = null;
/** @type {null} */
mxKeyHandler.prototype.normalKeys = null;
/** @type {null} */
mxKeyHandler.prototype.shiftKeys = null;
/** @type {null} */
mxKeyHandler.prototype.controlKeys = null;
/** @type {null} */
mxKeyHandler.prototype.controlShiftKeys = null;
/** @type {boolean} */
mxKeyHandler.prototype.enabled = true;
/**
 * @return {?}
 */
mxKeyHandler.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxKeyHandler.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @param {?} action
 * @param {?} keys
 * @return {undefined}
 */
mxKeyHandler.prototype.bindKey = function(action, keys) {
  this.normalKeys[action] = keys;
};
/**
 * @param {?} url
 * @param {?} eTag
 * @return {undefined}
 */
mxKeyHandler.prototype.bindShiftKey = function(url, eTag) {
  this.shiftKeys[url] = eTag;
};
/**
 * @param {?} descriptor
 * @param {?} exporter
 * @return {undefined}
 */
mxKeyHandler.prototype.bindControlKey = function(descriptor, exporter) {
  this.controlKeys[descriptor] = exporter;
};
/**
 * @param {?} url
 * @param {?} eTag
 * @return {undefined}
 */
mxKeyHandler.prototype.bindControlShiftKey = function(url, eTag) {
  this.controlShiftKeys[url] = eTag;
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxKeyHandler.prototype.isControlDown = function(evt) {
  return mxEvent.isControlDown(evt);
};
/**
 * @param {!Object} evt
 * @return {?}
 */
mxKeyHandler.prototype.getFunction = function(evt) {
  return null == evt || mxEvent.isAltDown(evt) ? null : this.isControlDown(evt) ? mxEvent.isShiftDown(evt) ? this.controlShiftKeys[evt.keyCode] : this.controlKeys[evt.keyCode] : mxEvent.isShiftDown(evt) ? this.shiftKeys[evt.keyCode] : this.normalKeys[evt.keyCode];
};
/**
 * @param {!Object} e
 * @return {?}
 */
mxKeyHandler.prototype.isGraphEvent = function(e) {
  var target = mxEvent.getSource(e);
  return target == this.target || target.parentNode == this.target || null != this.graph.cellEditor && this.graph.cellEditor.isEventSource(e) ? true : mxUtils.isAncestorNode(this.graph.container, target);
};
/**
 * @param {!Object} e
 * @return {undefined}
 */
mxKeyHandler.prototype.keyDown = function(e) {
  if (this.isEnabledForEvent(e)) {
    if (27 == e.keyCode) {
      this.escape(e);
    } else {
      if (!this.isEventIgnored(e)) {
        var func = this.getFunction(e);
        if (null != func) {
          func(e);
          mxEvent.consume(e);
        }
      }
    }
  }
};
/**
 * @param {(Object|string)} evt
 * @return {?}
 */
mxKeyHandler.prototype.isEnabledForEvent = function(evt) {
  return this.graph.isEnabled() && !mxEvent.isConsumed(evt) && this.isGraphEvent(evt) && this.isEnabled();
};
/**
 * @param {!Function} propertyName
 * @return {?}
 */
mxKeyHandler.prototype.isEventIgnored = function(propertyName) {
  return this.graph.isEditing();
};
/**
 * @param {!Function} value
 * @return {undefined}
 */
mxKeyHandler.prototype.escape = function(value) {
  if (this.graph.isEscapeEnabled()) {
    this.graph.escape(value);
  }
};
/**
 * @return {undefined}
 */
mxKeyHandler.prototype.destroy = function() {
  if (null != this.target && null != this.keydownHandler) {
    mxEvent.removeListener(this.target, "keydown", this.keydownHandler);
    /** @type {null} */
    this.keydownHandler = null;
  }
  /** @type {null} */
  this.target = null;
};
/**
 * @param {!Object} src
 * @param {number} delay
 * @return {undefined}
 */
function mxTooltipHandler(src, delay) {
  if (null != src) {
    /** @type {!Object} */
    this.graph = src;
    this.delay = delay || 500;
    this.graph.addMouseListener(this);
  }
}
/** @type {number} */
mxTooltipHandler.prototype.zIndex = 10005;
/** @type {null} */
mxTooltipHandler.prototype.graph = null;
/** @type {null} */
mxTooltipHandler.prototype.delay = null;
/** @type {boolean} */
mxTooltipHandler.prototype.ignoreTouchEvents = true;
/** @type {boolean} */
mxTooltipHandler.prototype.hideOnHover = false;
/** @type {boolean} */
mxTooltipHandler.prototype.destroyed = false;
/** @type {boolean} */
mxTooltipHandler.prototype.enabled = true;
/**
 * @return {?}
 */
mxTooltipHandler.prototype.isEnabled = function() {
  return this.enabled;
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxTooltipHandler.prototype.setEnabled = function(state) {
  /** @type {string} */
  this.enabled = state;
};
/**
 * @return {?}
 */
mxTooltipHandler.prototype.isHideOnHover = function() {
  return this.hideOnHover;
};
/**
 * @param {boolean} a
 * @return {undefined}
 */
mxTooltipHandler.prototype.setHideOnHover = function(a) {
  /** @type {boolean} */
  this.hideOnHover = a;
};
/**
 * @return {undefined}
 */
mxTooltipHandler.prototype.init = function() {
  if (null != document.body) {
    /** @type {!Element} */
    this.div = document.createElement("div");
    /** @type {string} */
    this.div.className = "mxTooltip";
    /** @type {string} */
    this.div.style.visibility = "hidden";
    document.body.appendChild(this.div);
    mxEvent.addGestureListeners(this.div, mxUtils.bind(this, function(node) {
      if ("A" != mxEvent.getSource(node).nodeName) {
        this.hideTooltip();
      }
    }));
  }
};
/**
 * @param {!Object} b
 * @return {?}
 */
mxTooltipHandler.prototype.getStateForEvent = function(b) {
  return b.getState();
};
/**
 * @param {!Object} e
 * @param {!Object} element
 * @return {undefined}
 */
mxTooltipHandler.prototype.mouseDown = function(e, element) {
  this.reset(element, false);
  this.hideTooltip();
};
/**
 * @param {?} state
 * @param {!Object} e
 * @return {undefined}
 */
mxTooltipHandler.prototype.mouseMove = function(state, e) {
  if (e.getX() != this.lastX || e.getY() != this.lastY) {
    this.reset(e, true);
    var state = this.getStateForEvent(e);
    if (this.isHideOnHover() || state != this.state || e.getSource() != this.node && (!this.stateSource || null != state && this.stateSource == (e.isSource(state.shape) || !e.isSource(state.text)))) {
      this.hideTooltip();
    }
  }
  this.lastX = e.getX();
  this.lastY = e.getY();
};
/**
 * @param {?} editor
 * @param {!Object} e
 * @return {undefined}
 */
mxTooltipHandler.prototype.mouseUp = function(editor, e) {
  this.reset(e, true);
  this.hideTooltip();
};
/**
 * @return {undefined}
 */
mxTooltipHandler.prototype.resetTimer = function() {
  if (null != this.thread) {
    window.clearTimeout(this.thread);
    /** @type {null} */
    this.thread = null;
  }
};
/**
 * @param {!Object} t
 * @param {string} url
 * @param {!Object} data
 * @return {undefined}
 */
mxTooltipHandler.prototype.reset = function(t, url, data) {
  if (!this.ignoreTouchEvents || mxEvent.isMouseEvent(t.getEvent())) {
    if (this.resetTimer(), data = null != data ? data : this.getStateForEvent(t), url && this.isEnabled() && null != data && (null == this.div || "hidden" == this.div.style.visibility)) {
      var nodes = t.getSource();
      var type = t.getX();
      var options = t.getY();
      var g = t.isSource(data.shape) || t.isSource(data.text);
      this.thread = window.setTimeout(mxUtils.bind(this, function() {
        if (!this.graph.isEditing() && !this.graph.popupMenuHandler.isMenuShowing() && !this.graph.isMouseDown) {
          var result = this.graph.getTooltip(data, nodes, type, options);
          this.show(result, type, options);
          this.state = data;
          this.node = nodes;
          this.stateSource = g;
        }
      }), this.delay);
    }
  }
};
/**
 * @return {undefined}
 */
mxTooltipHandler.prototype.hide = function() {
  this.resetTimer();
  this.hideTooltip();
};
/**
 * @return {undefined}
 */
mxTooltipHandler.prototype.hideTooltip = function() {
  if (null != this.div) {
    /** @type {string} */
    this.div.style.visibility = "hidden";
    /** @type {string} */
    this.div.innerHTML = "";
  }
};
/**
 * @param {!Object} text
 * @param {string} x
 * @param {number} y
 * @return {undefined}
 */
mxTooltipHandler.prototype.show = function(text, x, y) {
  if (!this.destroyed && null != text && 0 < text.length) {
    if (null == this.div) {
      this.init();
    }
    var chart = mxUtils.getScrollOrigin();
    this.div.style.zIndex = this.zIndex;
    /** @type {string} */
    this.div.style.left = x + chart.x + "px";
    /** @type {string} */
    this.div.style.top = y + mxConstants.TOOLTIP_VERTICAL_OFFSET + chart.y + "px";
    if (mxUtils.isNode(text)) {
      /** @type {string} */
      this.div.innerHTML = "";
      this.div.appendChild(text);
    } else {
      this.div.innerHTML = text.replace(/\n/g, "<br>");
    }
    /** @type {string} */
    this.div.style.visibility = "";
    mxUtils.fit(this.div);
  }
};
/**
 * @return {undefined}
 */
mxTooltipHandler.prototype.destroy = function() {
  if (!this.destroyed) {
    this.graph.removeMouseListener(this);
    mxEvent.release(this.div);
    if (null != this.div && null != this.div.parentNode) {
      this.div.parentNode.removeChild(this.div);
    }
    /** @type {boolean} */
    this.destroyed = true;
    /** @type {null} */
    this.div = null;
  }
};
/**
 * @param {?} a
 * @param {?} b
 * @param {string} variableNames
 * @return {undefined}
 */
function mxCellTracker(a, b, variableNames) {
  mxCellMarker.call(this, a, b);
  this.graph.addMouseListener(this);
  if (null != variableNames) {
    /** @type {string} */
    this.getCell = variableNames;
  }
  if (mxClient.IS_IE) {
    mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
      this.destroy();
    }));
  }
}
mxUtils.extend(mxCellTracker, mxCellMarker);
/**
 * @param {!Object} e
 * @param {?} editor
 * @return {undefined}
 */
mxCellTracker.prototype.mouseDown = function(e, editor) {
};
/**
 * @param {?} scheduled
 * @param {!Object} callback
 * @return {undefined}
 */
mxCellTracker.prototype.mouseMove = function(scheduled, callback) {
  if (this.isEnabled()) {
    this.process(callback);
  }
};
/**
 * @param {?} offset
 * @param {?} callback
 * @return {undefined}
 */
mxCellTracker.prototype.mouseUp = function(offset, callback) {
};
/**
 * @return {undefined}
 */
mxCellTracker.prototype.destroy = function() {
  if (!this.destroyed) {
    /** @type {boolean} */
    this.destroyed = true;
    this.graph.removeMouseListener(this);
    mxCellMarker.prototype.destroy.apply(this);
  }
};
/**
 * @param {!Object} g
 * @param {string} data
 * @param {number} name
 * @param {!Object} force
 * @return {undefined}
 */
function mxCellHighlight(g, data, name, force) {
  if (null != g) {
    /** @type {!Object} */
    this.graph = g;
    this.highlightColor = null != data ? data : mxConstants.DEFAULT_VALID_COLOR;
    this.strokeWidth = null != name ? name : mxConstants.HIGHLIGHT_STROKEWIDTH;
    this.dashed = null != force ? force : false;
    this.opacity = mxConstants.HIGHLIGHT_OPACITY;
    this.repaintHandler = mxUtils.bind(this, function() {
      if (null != this.state) {
        var STATE_BEFORECHANGEOFFSET = this.graph.view.getState(this.state.cell);
        if (null == STATE_BEFORECHANGEOFFSET) {
          this.hide();
        } else {
          this.state = STATE_BEFORECHANGEOFFSET;
          this.repaint();
        }
      }
    });
    this.graph.getView().addListener(mxEvent.SCALE, this.repaintHandler);
    this.graph.getView().addListener(mxEvent.TRANSLATE, this.repaintHandler);
    this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.repaintHandler);
    this.graph.getModel().addListener(mxEvent.CHANGE, this.repaintHandler);
    this.resetHandler = mxUtils.bind(this, function() {
      this.hide();
    });
    this.graph.getView().addListener(mxEvent.DOWN, this.resetHandler);
    this.graph.getView().addListener(mxEvent.UP, this.resetHandler);
  }
}
/** @type {boolean} */
mxCellHighlight.prototype.keepOnTop = false;
/** @type {null} */
mxCellHighlight.prototype.graph = null;
/** @type {null} */
mxCellHighlight.prototype.state = null;
/** @type {number} */
mxCellHighlight.prototype.spacing = 2;
/** @type {null} */
mxCellHighlight.prototype.resetHandler = null;
/**
 * @param {string} color
 * @return {undefined}
 */
mxCellHighlight.prototype.setHighlightColor = function(color) {
  /** @type {string} */
  this.highlightColor = color;
  if (null != this.shape) {
    /** @type {string} */
    this.shape.stroke = color;
  }
};
/**
 * @return {undefined}
 */
mxCellHighlight.prototype.drawHighlight = function() {
  this.shape = this.createShape();
  this.repaint();
  if (!(this.keepOnTop || this.shape.node.parentNode.firstChild == this.shape.node)) {
    this.shape.node.parentNode.insertBefore(this.shape.node, this.shape.node.parentNode.firstChild);
  }
};
/**
 * @return {?}
 */
mxCellHighlight.prototype.createShape = function() {
  var data = this.graph.cellRenderer.createShape(this.state);
  data.svgStrokeTolerance = this.graph.tolerance;
  data.points = this.state.absolutePoints;
  data.apply(this.state);
  data.stroke = this.highlightColor;
  data.opacity = this.opacity;
  data.isDashed = this.dashed;
  /** @type {boolean} */
  data.isShadow = false;
  data.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
  data.init(this.graph.getView().getOverlayPane());
  mxEvent.redirectMouseEvents(data.node, this.graph, this.state);
  if (this.graph.dialect != mxConstants.DIALECT_SVG) {
    /** @type {boolean} */
    data.pointerEvents = false;
  } else {
    /** @type {string} */
    data.svgPointerEvents = "stroke";
  }
  return data;
};
/**
 * @param {?} multiplier
 * @return {?}
 */
mxCellHighlight.prototype.getStrokeWidth = function(multiplier) {
  return this.strokeWidth;
};
/**
 * @return {undefined}
 */
mxCellHighlight.prototype.repaint = function() {
  if (null != this.state && null != this.shape) {
    this.shape.scale = this.state.view.scale;
    if (this.graph.model.isEdge(this.state.cell)) {
      this.shape.strokewidth = this.getStrokeWidth();
      this.shape.points = this.state.absolutePoints;
      /** @type {boolean} */
      this.shape.outline = false;
    } else {
      this.shape.bounds = new mxRectangle(this.state.x - this.spacing, this.state.y - this.spacing, this.state.width + 2 * this.spacing, this.state.height + 2 * this.spacing);
      /** @type {number} */
      this.shape.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
      /** @type {number} */
      this.shape.strokewidth = this.getStrokeWidth() / this.state.view.scale;
      /** @type {boolean} */
      this.shape.outline = true;
    }
    if (null != this.state.shape) {
      this.shape.setCursor(this.state.shape.getCursor());
    }
    if (mxClient.IS_QUIRKS || 8 == document.documentMode) {
      if ("transparent" == this.shape.stroke) {
        /** @type {string} */
        this.shape.stroke = "white";
        /** @type {number} */
        this.shape.opacity = 1;
      } else {
        this.shape.opacity = this.opacity;
      }
    }
    this.shape.redraw();
  }
};
/**
 * @return {undefined}
 */
mxCellHighlight.prototype.hide = function() {
  this.highlight(null);
};
/**
 * @param {!Object} state
 * @return {undefined}
 */
mxCellHighlight.prototype.highlight = function(state) {
  if (this.state != state) {
    if (null != this.shape) {
      this.shape.destroy();
      /** @type {null} */
      this.shape = null;
    }
    /** @type {!Object} */
    this.state = state;
    if (null != this.state) {
      this.drawHighlight();
    }
  }
};
/**
 * @param {number} x
 * @param {?} y
 * @return {?}
 */
mxCellHighlight.prototype.isHighlightAt = function(x, y) {
  /** @type {boolean} */
  var c = false;
  if (null != this.shape && null != document.elementFromPoint && !mxClient.IS_QUIRKS) {
    /** @type {(Element|null)} */
    var from = document.elementFromPoint(x, y);
    for (; null != from;) {
      if (from == this.shape.node) {
        /** @type {boolean} */
        c = true;
        break;
      }
      /** @type {(Node|null)} */
      from = from.parentNode;
    }
  }
  return c;
};
/**
 * @return {undefined}
 */
mxCellHighlight.prototype.destroy = function() {
  this.graph.getView().removeListener(this.resetHandler);
  this.graph.getView().removeListener(this.repaintHandler);
  this.graph.getModel().removeListener(this.repaintHandler);
  if (null != this.shape) {
    this.shape.destroy();
    /** @type {null} */
    this.shape = null;
  }
};
/**
 * @param {!Object} editor
 * @return {undefined}
 */
function mxDefaultKeyHandler(editor) {
  if (null != editor) {
    /** @type {!Object} */
    this.editor = editor;
    this.handler = new mxKeyHandler(editor.graph);
    var onNew = this.handler.escape;
    /**
     * @param {!Function} source
     * @return {undefined}
     */
    this.handler.escape = function(source) {
      onNew.apply(this, arguments);
      editor.hideProperties();
      editor.fireEvent(new mxEventObject(mxEvent.ESCAPE, "event", source));
    };
  }
}
/** @type {null} */
mxDefaultKeyHandler.prototype.editor = null;
/** @type {null} */
mxDefaultKeyHandler.prototype.handler = null;
/**
 * @param {?} component
 * @param {undefined} target
 * @param {?} selector
 * @return {undefined}
 */
mxDefaultKeyHandler.prototype.bindAction = function(component, target, selector) {
  var f = mxUtils.bind(this, function() {
    this.editor.execute(target);
  });
  if (selector) {
    this.handler.bindControlKey(component, f);
  } else {
    this.handler.bindKey(component, f);
  }
};
/**
 * @return {undefined}
 */
mxDefaultKeyHandler.prototype.destroy = function() {
  this.handler.destroy();
  /** @type {null} */
  this.handler = null;
};
/**
 * @param {!Object} config
 * @return {undefined}
 */
function mxDefaultPopupMenu(config) {
  /** @type {!Object} */
  this.config = config;
}
/** @type {null} */
mxDefaultPopupMenu.prototype.imageBasePath = null;
/** @type {null} */
mxDefaultPopupMenu.prototype.config = null;
/**
 * @param {undefined} items
 * @param {string} options
 * @param {?} name
 * @param {?} data
 * @return {undefined}
 */
mxDefaultPopupMenu.prototype.createMenu = function(items, options, name, data) {
  if (null != this.config) {
    var match = this.createConditions(items, name, data);
    this.addItems(items, options, name, data, match, this.config.firstChild, null);
  }
};
/**
 * @param {!Object} items
 * @param {string} options
 * @param {!Array} keys
 * @param {?} type
 * @param {?} obj
 * @param {!Object} node
 * @param {!Object} parent
 * @return {undefined}
 */
mxDefaultPopupMenu.prototype.addItems = function(items, options, keys, type, obj, node, parent) {
  /** @type {boolean} */
  var k = false;
  for (; null != node;) {
    if ("add" == node.nodeName) {
      var item = node.getAttribute("if");
      if (null == item || obj[item]) {
        item = node.getAttribute("as");
        item = mxResources.get(item) || item;
        var track = mxUtils.eval(mxUtils.getTextContent(node));
        var currentCategory = node.getAttribute("action");
        var index = node.getAttribute("icon");
        var field = node.getAttribute("iconCls");
        var _id = node.getAttribute("enabled-if");
        _id = null == _id || obj[_id];
        if (k) {
          options.addSeparator(parent);
          /** @type {boolean} */
          k = false;
        }
        if (null != index && this.imageBasePath) {
          index = this.imageBasePath + index;
        }
        item = this.addAction(options, items, item, index, track, currentCategory, keys, parent, field, _id);
        this.addItems(items, options, keys, type, obj, node.firstChild, item);
      }
    } else {
      if ("separator" == node.nodeName) {
        /** @type {boolean} */
        k = true;
      }
    }
    node = node.nextSibling;
  }
};
/**
 * @param {!Object} key
 * @param {!Object} callback
 * @param {undefined} type
 * @param {string} index
 * @param {!Function} obj
 * @param {?} item
 * @param {!Object} target
 * @param {string} data
 * @param {string} name
 * @param {undefined} e
 * @return {?}
 */
mxDefaultPopupMenu.prototype.addAction = function(key, callback, type, index, obj, item, target, data, name, e) {
  return key.addItem(type, index, function(url) {
    if ("function" == typeof obj) {
      obj.call(callback, callback, target, url);
    }
    if (null != item) {
      callback.execute(item, target, url);
    }
  }, data, name, e);
};
/**
 * @param {!Object} data
 * @param {!Object} type
 * @param {?} val
 * @return {?}
 */
mxDefaultPopupMenu.prototype.createConditions = function(data, type, val) {
  var i = data.graph.getModel();
  var elements = i.getChildCount(type);
  /** @type {!Array} */
  var settings = [];
  /** @type {boolean} */
  settings.nocell = null == type;
  /** @type {boolean} */
  settings.ncells = 1 < data.graph.getSelectionCount();
  /** @type {boolean} */
  settings.notRoot = i.getRoot() != i.getParent(data.graph.getDefaultParent());
  /** @type {boolean} */
  settings.cell = null != type;
  /** @type {boolean} */
  i = null != type && 1 == data.graph.getSelectionCount();
  /** @type {boolean} */
  settings.nonEmpty = i && 0 < elements;
  settings.expandable = i && data.graph.isCellFoldable(type, false);
  settings.collapsable = i && data.graph.isCellFoldable(type, true);
  settings.validRoot = i && data.graph.isValidRoot(type);
  settings.emptyValidRoot = settings.validRoot && 0 == elements;
  settings.swimlane = i && data.graph.isSwimlane(type);
  elements = this.config.getElementsByTagName("condition");
  /** @type {number} */
  i = 0;
  for (; i < elements.length; i++) {
    var callback = mxUtils.eval(mxUtils.getTextContent(elements[i]));
    var key = elements[i].getAttribute("name");
    if (null != key && "function" == typeof callback) {
      settings[key] = callback(data, type, val);
    }
  }
  return settings;
};
/**
 * @param {string} definition
 * @param {!Object} instance
 * @return {undefined}
 */
function mxDefaultToolbar(definition, instance) {
  /** @type {!Object} */
  this.editor = instance;
  if (null != definition && null != instance) {
    this.init(definition);
  }
}
/** @type {null} */
mxDefaultToolbar.prototype.editor = null;
/** @type {null} */
mxDefaultToolbar.prototype.toolbar = null;
/** @type {null} */
mxDefaultToolbar.prototype.resetHandler = null;
/** @type {number} */
mxDefaultToolbar.prototype.spacing = 4;
/** @type {boolean} */
mxDefaultToolbar.prototype.connectOnDrop = false;
/**
 * @param {string} key
 * @return {undefined}
 */
mxDefaultToolbar.prototype.init = function(key) {
  if (null != key) {
    this.toolbar = new mxToolbar(key);
    this.toolbar.addListener(mxEvent.SELECT, mxUtils.bind(this, function(a, type) {
      var handler = type.getProperty("function");
      this.editor.insertFunction = null != handler ? mxUtils.bind(this, function() {
        handler.apply(this, arguments);
        this.toolbar.resetMode();
      }) : null;
    }));
    this.resetHandler = mxUtils.bind(this, function() {
      if (null != this.toolbar) {
        this.toolbar.resetMode(true);
      }
    });
    this.editor.graph.addListener(mxEvent.DOUBLE_CLICK, this.resetHandler);
    this.editor.addListener(mxEvent.ESCAPE, this.resetHandler);
  }
};
/**
 * @param {string} name
 * @param {string} type
 * @param {?} c
 * @param {string} data
 * @return {?}
 */
mxDefaultToolbar.prototype.addItem = function(name, type, c, data) {
  var item = mxUtils.bind(this, function() {
    if (null != c && 0 < c.length) {
      this.editor.execute(c);
    }
  });
  return this.toolbar.addItem(name, type, item, data);
};
/**
 * @param {!Object} target
 * @return {undefined}
 */
mxDefaultToolbar.prototype.addSeparator = function(target) {
  target = target || mxClient.imageBasePath + "/separator.gif";
  this.toolbar.addSeparator(target);
};
/**
 * @return {?}
 */
mxDefaultToolbar.prototype.addCombo = function() {
  return this.toolbar.addCombo();
};
/**
 * @param {string} name
 * @return {?}
 */
mxDefaultToolbar.prototype.addActionCombo = function(name) {
  return this.toolbar.addActionCombo(name);
};
/**
 * @param {undefined} name
 * @param {string} option
 * @param {?} target
 * @return {undefined}
 */
mxDefaultToolbar.prototype.addActionOption = function(name, option, target) {
  var d = mxUtils.bind(this, function() {
    this.editor.execute(target);
  });
  this.addOption(name, option, d);
};
/**
 * @param {!Element} name
 * @param {string} value
 * @param {!Function} title
 * @return {?}
 */
mxDefaultToolbar.prototype.addOption = function(name, value, title) {
  return this.toolbar.addOption(name, value, title);
};
/**
 * @param {string} name
 * @param {string} text
 * @param {string} id
 * @param {!Array} object
 * @param {!Object} action
 * @return {?}
 */
mxDefaultToolbar.prototype.addMode = function(name, text, id, object, action) {
  var currentChr = mxUtils.bind(this, function() {
    this.editor.setMode(id);
    if (null != action) {
      action(this.editor);
    }
  });
  return this.toolbar.addSwitchMode(name, text, currentChr, object);
};
/**
 * @param {string} name
 * @param {string} index
 * @param {string} state
 * @param {?} width
 * @param {!Object} handler
 * @param {string} db
 * @return {?}
 */
mxDefaultToolbar.prototype.addPrototype = function(name, index, state, width, handler, db) {
  var makeFragment = mxUtils.bind(this, function() {
    return "function" == typeof state ? state() : null != state ? this.editor.graph.cloneCell(state) : null;
  });
  var context = mxUtils.bind(this, function(e, target) {
    if ("function" == typeof handler) {
      handler(this.editor, makeFragment(), e, target);
    } else {
      this.drop(makeFragment(), e, target);
    }
    this.toolbar.resetMode();
    mxEvent.consume(e);
  });
  name = this.toolbar.addMode(name, index, context, width, null, db);
  this.installDropHandler(name, function(a, scenario, _arg) {
    context(scenario, _arg);
  });
  return name;
};
/**
 * @param {undefined} x
 * @param {!Array} data
 * @param {?} target
 * @return {undefined}
 */
mxDefaultToolbar.prototype.drop = function(x, data, target) {
  var graph = this.editor.graph;
  var utils = graph.getModel();
  if (null != target && !utils.isEdge(target) && this.connectOnDrop && graph.isCellConnectable(target)) {
    this.connect(x, data, target);
  } else {
    for (; null != target && !graph.isValidDropTarget(target, [x], data);) {
      target = utils.getParent(target);
    }
    this.insert(x, data, target);
  }
};
/**
 * @param {boolean} item
 * @param {!Array} e
 * @param {boolean} target
 * @return {?}
 */
mxDefaultToolbar.prototype.insert = function(item, e, target) {
  var graph = this.editor.graph;
  if (graph.canImportCell(item)) {
    var data = mxEvent.getClientX(e);
    var opacity = mxEvent.getClientY(e);
    data = mxUtils.convertPoint(graph.container, data, opacity);
    return graph.isSplitEnabled() && graph.isSplitTarget(target, [item], e) ? graph.splitEdge(target, [item], null, data.x, data.y) : this.editor.addVertex(target, item, data.x, data.y);
  }
  return null;
};
/**
 * @param {!Array} value
 * @param {!Object} that
 * @param {(Object|string)} target
 * @return {undefined}
 */
mxDefaultToolbar.prototype.connect = function(value, that, target) {
  that = this.editor.graph;
  var me = that.getModel();
  if (null != target && that.isCellConnectable(value) && that.isEdgeValid(null, target, value)) {
    /** @type {null} */
    var cell = null;
    me.beginUpdate();
    try {
      var offset = me.getGeometry(target);
      var e = me.getGeometry(value).clone();
      e.x = offset.x + (offset.width - e.width) / 2;
      e.y = offset.y + (offset.height - e.height) / 2;
      /** @type {number} */
      var originWidth = this.spacing * that.gridSize;
      /** @type {number} */
      var margin = 20 * me.getDirectedEdgeCount(target, true);
      if (this.editor.horizontalFlow) {
        e.x += (e.width + offset.width) / 2 + originWidth + margin;
      } else {
        e.y += (e.height + offset.height) / 2 + originWidth + margin;
      }
      value.setGeometry(e);
      var item = me.getParent(target);
      that.addCell(value, item);
      that.constrainChild(value);
      cell = this.editor.createEdge(target, value);
      if (null == me.getGeometry(cell)) {
        var geo = new mxGeometry;
        /** @type {boolean} */
        geo.relative = true;
        me.setGeometry(cell, geo);
      }
      that.addEdge(cell, item, target, value);
    } finally {
      me.endUpdate();
    }
    that.setSelectionCells([value, cell]);
    that.scrollCellToVisible(value);
  }
};
/**
 * @param {!Object} elt
 * @param {string} dropHandler
 * @return {undefined}
 */
mxDefaultToolbar.prototype.installDropHandler = function(elt, dropHandler) {
  /** @type {!Element} */
  var e = document.createElement("img");
  e.setAttribute("src", elt.getAttribute("src"));
  var clickHandler = mxUtils.bind(this, function(canCreateDiscussions) {
    /** @type {string} */
    e.style.width = 2 * elt.offsetWidth + "px";
    /** @type {string} */
    e.style.height = 2 * elt.offsetHeight + "px";
    mxUtils.makeDraggable(elt, this.editor.graph, dropHandler, e);
    mxEvent.removeListener(e, "load", clickHandler);
  });
  if (mxClient.IS_IE) {
    clickHandler();
  } else {
    mxEvent.addListener(e, "load", clickHandler);
  }
};
/**
 * @return {undefined}
 */
mxDefaultToolbar.prototype.destroy = function() {
  if (null != this.resetHandler) {
    this.editor.graph.removeListener("dblclick", this.resetHandler);
    this.editor.removeListener("escape", this.resetHandler);
    /** @type {null} */
    this.resetHandler = null;
  }
  if (null != this.toolbar) {
    this.toolbar.destroy();
    /** @type {null} */
    this.toolbar = null;
  }
};
/**
 * @param {!Object} hash
 * @return {undefined}
 */
function mxEditor(hash) {
  /** @type {!Array} */
  this.actions = [];
  this.addActions();
  if (null != document.body) {
    /** @type {!Array} */
    this.cycleAttributeValues = [];
    this.popupHandler = new mxDefaultPopupMenu;
    this.undoManager = new mxUndoManager;
    this.graph = this.createGraph();
    this.toolbar = this.createToolbar();
    this.keyHandler = new mxDefaultKeyHandler(this);
    this.configure(hash);
    this.graph.swimlaneIndicatorColorAttribute = this.cycleAttributeName;
    if (null != this.onInit) {
      this.onInit();
    }
    if (mxClient.IS_IE) {
      mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
        this.destroy();
      }));
    }
  }
}
if (mxLoadResources) {
  mxResources.add(mxClient.basePath + "/resources/editor");
} else {
  mxClient.defaultBundles.push(mxClient.basePath + "/resources/editor");
}
mxEditor.prototype = new mxEventSource;
/** @type {function(!Object): undefined} */
mxEditor.prototype.constructor = mxEditor;
/** @type {string} */
mxEditor.prototype.askZoomResource = "none" != mxClient.language ? "askZoom" : "";
/** @type {string} */
mxEditor.prototype.lastSavedResource = "none" != mxClient.language ? "lastSaved" : "";
/** @type {string} */
mxEditor.prototype.currentFileResource = "none" != mxClient.language ? "currentFile" : "";
/** @type {string} */
mxEditor.prototype.propertiesResource = "none" != mxClient.language ? "properties" : "";
/** @type {string} */
mxEditor.prototype.tasksResource = "none" != mxClient.language ? "tasks" : "";
/** @type {string} */
mxEditor.prototype.helpResource = "none" != mxClient.language ? "help" : "";
/** @type {string} */
mxEditor.prototype.outlineResource = "none" != mxClient.language ? "outline" : "";
/** @type {null} */
mxEditor.prototype.outline = null;
/** @type {null} */
mxEditor.prototype.graph = null;
/** @type {null} */
mxEditor.prototype.graphRenderHint = null;
/** @type {null} */
mxEditor.prototype.toolbar = null;
/** @type {null} */
mxEditor.prototype.status = null;
/** @type {null} */
mxEditor.prototype.popupHandler = null;
/** @type {null} */
mxEditor.prototype.undoManager = null;
/** @type {null} */
mxEditor.prototype.keyHandler = null;
/** @type {null} */
mxEditor.prototype.actions = null;
/** @type {string} */
mxEditor.prototype.dblClickAction = "edit";
/** @type {boolean} */
mxEditor.prototype.swimlaneRequired = false;
/** @type {boolean} */
mxEditor.prototype.disableContextMenu = true;
/** @type {null} */
mxEditor.prototype.insertFunction = null;
/** @type {boolean} */
mxEditor.prototype.forcedInserting = false;
/** @type {null} */
mxEditor.prototype.templates = null;
/** @type {null} */
mxEditor.prototype.defaultEdge = null;
/** @type {null} */
mxEditor.prototype.defaultEdgeStyle = null;
/** @type {null} */
mxEditor.prototype.defaultGroup = null;
/** @type {null} */
mxEditor.prototype.groupBorderSize = null;
/** @type {null} */
mxEditor.prototype.filename = null;
/** @type {string} */
mxEditor.prototype.linefeed = "&#xa;";
/** @type {string} */
mxEditor.prototype.postParameterName = "xml";
/** @type {boolean} */
mxEditor.prototype.escapePostData = true;
/** @type {null} */
mxEditor.prototype.urlPost = null;
/** @type {null} */
mxEditor.prototype.urlImage = null;
/** @type {boolean} */
mxEditor.prototype.horizontalFlow = false;
/** @type {boolean} */
mxEditor.prototype.layoutDiagram = false;
/** @type {number} */
mxEditor.prototype.swimlaneSpacing = 0;
/** @type {boolean} */
mxEditor.prototype.maintainSwimlanes = false;
/** @type {boolean} */
mxEditor.prototype.layoutSwimlanes = false;
/** @type {null} */
mxEditor.prototype.cycleAttributeValues = null;
/** @type {number} */
mxEditor.prototype.cycleAttributeIndex = 0;
/** @type {string} */
mxEditor.prototype.cycleAttributeName = "fillColor";
/** @type {null} */
mxEditor.prototype.tasks = null;
/** @type {null} */
mxEditor.prototype.tasksWindowImage = null;
/** @type {number} */
mxEditor.prototype.tasksTop = 20;
/** @type {null} */
mxEditor.prototype.help = null;
/** @type {null} */
mxEditor.prototype.helpWindowImage = null;
/** @type {null} */
mxEditor.prototype.urlHelp = null;
/** @type {number} */
mxEditor.prototype.helpWidth = 300;
/** @type {number} */
mxEditor.prototype.helpHeight = 260;
/** @type {number} */
mxEditor.prototype.propertiesWidth = 240;
/** @type {null} */
mxEditor.prototype.propertiesHeight = null;
/** @type {boolean} */
mxEditor.prototype.movePropertiesDialog = false;
/** @type {boolean} */
mxEditor.prototype.validating = false;
/** @type {boolean} */
mxEditor.prototype.modified = false;
/**
 * @return {?}
 */
mxEditor.prototype.isModified = function() {
  return this.modified;
};
/**
 * @param {string} modified
 * @return {undefined}
 */
mxEditor.prototype.setModified = function(modified) {
  /** @type {string} */
  this.modified = modified;
};
/**
 * @return {undefined}
 */
mxEditor.prototype.addActions = function() {
  this.addAction("save", function(builtDoc) {
    builtDoc.save();
  });
  this.addAction("print", function(patternGraph) {
    (new mxPrintPreview(patternGraph.graph, 1)).open();
  });
  this.addAction("show", function(s) {
    mxUtils.show(s.graph, null, 10, 10);
  });
  this.addAction("exportImage", function(obj) {
    var value = obj.getUrlImage();
    if (null == value || mxClient.IS_LOCAL) {
      obj.execute("show");
    } else {
      var xml = mxUtils.getViewXml(obj.graph, 1);
      xml = mxUtils.getXml(xml, "\n");
      mxUtils.submit(value, obj.postParameterName + "=" + encodeURIComponent(xml), document, "_blank");
    }
  });
  this.addAction("refresh", function(box) {
    box.graph.refresh();
  });
  this.addAction("cut", function(context) {
    if (context.graph.isEnabled()) {
      mxClipboard.cut(context.graph);
    }
  });
  this.addAction("copy", function(context) {
    if (context.graph.isEnabled()) {
      mxClipboard.copy(context.graph);
    }
  });
  this.addAction("paste", function(context) {
    if (context.graph.isEnabled()) {
      mxClipboard.paste(context.graph);
    }
  });
  this.addAction("delete", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.removeCells();
    }
  });
  this.addAction("group", function(graph) {
    if (graph.graph.isEnabled()) {
      graph.graph.setSelectionCell(graph.groupCells());
    }
  });
  this.addAction("ungroup", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.setSelectionCells(context.graph.ungroupCells());
    }
  });
  this.addAction("removeFromParent", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.removeCellsFromParent();
    }
  });
  this.addAction("undo", function(context) {
    if (context.graph.isEnabled()) {
      context.undo();
    }
  });
  this.addAction("redo", function(context) {
    if (context.graph.isEnabled()) {
      context.redo();
    }
  });
  this.addAction("zoomIn", function(data) {
    data.graph.zoomIn();
  });
  this.addAction("zoomOut", function(data) {
    data.graph.zoomOut();
  });
  this.addAction("actualSize", function(patternGraph) {
    patternGraph.graph.zoomActual();
  });
  this.addAction("fit", function(result) {
    result.graph.fit();
  });
  this.addAction("showProperties", function(ResourcePanel, triple) {
    ResourcePanel.showProperties(triple);
  });
  this.addAction("selectAll", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.selectAll();
    }
  });
  this.addAction("selectNone", function(self) {
    if (self.graph.isEnabled()) {
      self.graph.clearSelection();
    }
  });
  this.addAction("selectVertices", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.selectVertices();
    }
  });
  this.addAction("selectEdges", function(self) {
    if (self.graph.isEnabled()) {
      self.graph.selectEdges();
    }
  });
  this.addAction("edit", function(context, col) {
    if (context.graph.isEnabled() && context.graph.isCellEditable(col)) {
      context.graph.startEditingAtCell(col);
    }
  });
  this.addAction("toBack", function(context, b) {
    if (context.graph.isEnabled()) {
      context.graph.orderCells(true);
    }
  });
  this.addAction("toFront", function(context, b) {
    if (context.graph.isEnabled()) {
      context.graph.orderCells(false);
    }
  });
  this.addAction("enterGroup", function(patternGraph, b) {
    patternGraph.graph.enterGroup(b);
  });
  this.addAction("exitGroup", function(patternGraph) {
    patternGraph.graph.exitGroup();
  });
  this.addAction("home", function(context) {
    context.graph.home();
  });
  this.addAction("selectPrevious", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.selectPreviousCell();
    }
  });
  this.addAction("selectNext", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.selectNextCell();
    }
  });
  this.addAction("selectParent", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.selectParentCell();
    }
  });
  this.addAction("selectChild", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.selectChildCell();
    }
  });
  this.addAction("collapse", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.foldCells(true);
    }
  });
  this.addAction("collapseAll", function(context) {
    if (context.graph.isEnabled()) {
      var matchFeedback = context.graph.getChildVertices();
      context.graph.foldCells(true, false, matchFeedback);
    }
  });
  this.addAction("expand", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.foldCells(false);
    }
  });
  this.addAction("expandAll", function(context) {
    if (context.graph.isEnabled()) {
      var matchFeedback = context.graph.getChildVertices();
      context.graph.foldCells(false, false, matchFeedback);
    }
  });
  this.addAction("bold", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.toggleCellStyleFlags(mxConstants.STYLE_FONTSTYLE, mxConstants.FONT_BOLD);
    }
  });
  this.addAction("italic", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.toggleCellStyleFlags(mxConstants.STYLE_FONTSTYLE, mxConstants.FONT_ITALIC);
    }
  });
  this.addAction("underline", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.toggleCellStyleFlags(mxConstants.STYLE_FONTSTYLE, mxConstants.FONT_UNDERLINE);
    }
  });
  this.addAction("alignCellsLeft", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.alignCells(mxConstants.ALIGN_LEFT);
    }
  });
  this.addAction("alignCellsCenter", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.alignCells(mxConstants.ALIGN_CENTER);
    }
  });
  this.addAction("alignCellsRight", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.alignCells(mxConstants.ALIGN_RIGHT);
    }
  });
  this.addAction("alignCellsTop", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.alignCells(mxConstants.ALIGN_TOP);
    }
  });
  this.addAction("alignCellsMiddle", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.alignCells(mxConstants.ALIGN_MIDDLE);
    }
  });
  this.addAction("alignCellsBottom", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.alignCells(mxConstants.ALIGN_BOTTOM);
    }
  });
  this.addAction("alignFontLeft", function(patternGraph) {
    patternGraph.graph.setCellStyles(mxConstants.STYLE_ALIGN, mxConstants.ALIGN_LEFT);
  });
  this.addAction("alignFontCenter", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.setCellStyles(mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER);
    }
  });
  this.addAction("alignFontRight", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.setCellStyles(mxConstants.STYLE_ALIGN, mxConstants.ALIGN_RIGHT);
    }
  });
  this.addAction("alignFontTop", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.setCellStyles(mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_TOP);
    }
  });
  this.addAction("alignFontMiddle", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.setCellStyles(mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
    }
  });
  this.addAction("alignFontBottom", function(context) {
    if (context.graph.isEnabled()) {
      context.graph.setCellStyles(mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_BOTTOM);
    }
  });
  this.addAction("zoom", function(action) {
    /** @type {number} */
    var value = 100 * action.graph.getView().scale;
    /** @type {number} */
    value = parseFloat(mxUtils.prompt(mxResources.get(action.askZoomResource) || action.askZoomResource, value)) / 100;
    if (!isNaN(value)) {
      action.graph.getView().setScale(value);
    }
  });
  this.addAction("toggleTasks", function(block) {
    if (null != block.tasks) {
      block.tasks.setVisible(!block.tasks.isVisible());
    } else {
      block.showTasks();
    }
  });
  this.addAction("toggleHelp", function(scope) {
    if (null != scope.help) {
      scope.help.setVisible(!scope.help.isVisible());
    } else {
      scope.showHelp();
    }
  });
  this.addAction("toggleOutline", function(me) {
    if (null == me.outline) {
      me.showOutline();
    } else {
      me.outline.setVisible(!me.outline.isVisible());
    }
  });
  this.addAction("toggleConsole", function(a) {
    mxLog.setVisible(!mxLog.isVisible());
  });
};
/**
 * @param {!Object} node
 * @return {undefined}
 */
mxEditor.prototype.configure = function(node) {
  if (null != node) {
    (new mxCodec(node.ownerDocument)).decode(node, this);
    this.resetHistory();
  }
};
/**
 * @return {undefined}
 */
mxEditor.prototype.resetFirstTime = function() {
  /** @type {string} */
  document.cookie = "mxgraph=seen; expires=Fri, 27 Jul 2001 02:47:11 UTC; path=/";
};
/**
 * @return {undefined}
 */
mxEditor.prototype.resetHistory = function() {
  /** @type {number} */
  this.lastSnapshot = (new Date).getTime();
  this.undoManager.clear();
  /** @type {number} */
  this.ignoredChanges = 0;
  this.setModified(false);
};
/**
 * @param {string} key
 * @param {!Function} obj
 * @return {undefined}
 */
mxEditor.prototype.addAction = function(key, obj) {
  /** @type {!Function} */
  this.actions[key] = obj;
};
/**
 * @param {!Object} key
 * @param {!Object} value
 * @param {?} module
 * @return {undefined}
 */
mxEditor.prototype.execute = function(key, value, module) {
  var action = this.actions[key];
  if (null != action) {
    try {
      /** @type {!Arguments} */
      var arg = arguments;
      arg[0] = this;
      action.apply(this, arg);
    } catch (controlFlowAction) {
      throw mxUtils.error("Cannot execute " + key + ": " + controlFlowAction.message, 280, true), controlFlowAction;
    }
  } else {
    mxUtils.error("Cannot find action " + key, 280, true);
  }
};
/**
 * @param {?} name
 * @param {?} data
 * @return {undefined}
 */
mxEditor.prototype.addTemplate = function(name, data) {
  this.templates[name] = data;
};
/**
 * @param {?} templateId
 * @return {?}
 */
mxEditor.prototype.getTemplate = function(templateId) {
  return this.templates[templateId];
};
/**
 * @return {?}
 */
mxEditor.prototype.createGraph = function() {
  var graph = new mxGraph(null, null, this.graphRenderHint);
  graph.setTooltips(true);
  graph.setPanning(true);
  this.installDblClickHandler(graph);
  this.installUndoHandler(graph);
  this.installDrillHandler(graph);
  this.installChangeHandler(graph);
  this.installInsertHandler(graph);
  graph.popupMenuHandler.factoryMethod = mxUtils.bind(this, function(text_label_id, currentMenu, thetarget) {
    return this.createPopupMenu(text_label_id, currentMenu, thetarget);
  });
  graph.connectionHandler.factoryMethod = mxUtils.bind(this, function(site, to) {
    return this.createEdge(site, to);
  });
  this.createSwimlaneManager(graph);
  this.createLayoutManager(graph);
  return graph;
};
/**
 * @param {string} item
 * @return {?}
 */
mxEditor.prototype.createSwimlaneManager = function(item) {
  item = new mxSwimlaneManager(item, false);
  item.isHorizontal = mxUtils.bind(this, function() {
    return this.horizontalFlow;
  });
  item.isEnabled = mxUtils.bind(this, function() {
    return this.maintainSwimlanes;
  });
  return item;
};
/**
 * @param {?} graph
 * @return {?}
 */
mxEditor.prototype.createLayoutManager = function(graph) {
  var node = new mxLayoutManager(graph);
  var s = this;
  /**
   * @param {!Object} id
   * @return {?}
   */
  node.getLayout = function(id) {
    /** @type {null} */
    var styleoutlinecolor = null;
    var DOM = s.graph.getModel();
    if (null != DOM.getParent(id)) {
      if (s.layoutSwimlanes && graph.isSwimlane(id)) {
        if (null == s.swimlaneLayout) {
          s.swimlaneLayout = s.createSwimlaneLayout();
        }
        styleoutlinecolor = s.swimlaneLayout;
      } else {
        if (s.layoutDiagram && (graph.isValidRoot(id) || null == DOM.getParent(DOM.getParent(id)))) {
          if (null == s.diagramLayout) {
            s.diagramLayout = s.createDiagramLayout();
          }
          styleoutlinecolor = s.diagramLayout;
        }
      }
    }
    return styleoutlinecolor;
  };
  return node;
};
/**
 * @param {undefined} link
 * @return {undefined}
 */
mxEditor.prototype.setGraphContainer = function(link) {
  if (null == this.graph.container) {
    this.graph.init(link);
    this.rubberband = new mxRubberband(this.graph);
    if (this.disableContextMenu) {
      mxEvent.disableContextMenu(link);
    }
    if (mxClient.IS_QUIRKS) {
      new mxDivResizer(link);
    }
  }
};
/**
 * @param {!Object} camera
 * @return {undefined}
 */
mxEditor.prototype.installDblClickHandler = function(camera) {
  camera.addListener(mxEvent.DOUBLE_CLICK, mxUtils.bind(this, function(event, self) {
    var arg = self.getProperty("cell");
    if (null != arg && camera.isEnabled() && null != this.dblClickAction) {
      this.execute(this.dblClickAction, arg);
      self.consume();
    }
  }));
};
/**
 * @param {!Object} graph
 * @return {undefined}
 */
mxEditor.prototype.installUndoHandler = function(graph) {
  var undoHandler = mxUtils.bind(this, function(a, link) {
    var edit = link.getProperty("edit");
    this.undoManager.undoableEditHappened(edit);
  });
  graph.getModel().addListener(mxEvent.UNDO, undoHandler);
  graph.getView().addListener(mxEvent.UNDO, undoHandler);
  /**
   * @param {?} sender
   * @param {!Object} evt
   * @return {undefined}
   */
  undoHandler = function(sender, evt) {
    var changes = evt.getProperty("edit").changes;
    graph.setSelectionCells(graph.getSelectionCellsForChanges(changes));
  };
  this.undoManager.addListener(mxEvent.UNDO, undoHandler);
  this.undoManager.addListener(mxEvent.REDO, undoHandler);
};
/**
 * @param {(Object|number|string)} funcs
 * @return {undefined}
 */
mxEditor.prototype.installDrillHandler = function(funcs) {
  var b = mxUtils.bind(this, function(a) {
    this.fireEvent(new mxEventObject(mxEvent.ROOT));
  });
  funcs.getView().addListener(mxEvent.DOWN, b);
  funcs.getView().addListener(mxEvent.UP, b);
};
/**
 * @param {!Object} g
 * @return {undefined}
 */
mxEditor.prototype.installChangeHandler = function(g) {
  var b = mxUtils.bind(this, function(b, link) {
    this.setModified(true);
    if (1 == this.validating) {
      g.validateGraph();
    }
    var changes = link.getProperty("edit").changes;
    /** @type {number} */
    var i = 0;
    for (; i < changes.length; i++) {
      var change = changes[i];
      if (change instanceof mxRootChange || change instanceof mxValueChange && change.cell == this.graph.model.root || change instanceof mxCellAttributeChange && change.cell == this.graph.model.root) {
        this.fireEvent(new mxEventObject(mxEvent.ROOT));
        break;
      }
    }
  });
  g.getModel().addListener(mxEvent.CHANGE, b);
};
/**
 * @param {?} State
 * @return {undefined}
 */
mxEditor.prototype.installInsertHandler = function(State) {
  var popup = this;
  State.addMouseListener({
    mouseDown : function(event, self) {
      if (!(null == popup.insertFunction || self.isPopupTrigger() || !popup.forcedInserting && null != self.getState())) {
        popup.graph.clearSelection();
        popup.insertFunction(self.getEvent(), self.getCell());
        /** @type {boolean} */
        this.isActive = true;
        self.consume();
      }
    },
    mouseMove : function(event, callback) {
      if (this.isActive) {
        callback.consume();
      }
    },
    mouseUp : function(editor, e) {
      if (this.isActive) {
        /** @type {boolean} */
        this.isActive = false;
        e.consume();
      }
    }
  });
};
/**
 * @return {?}
 */
mxEditor.prototype.createDiagramLayout = function() {
  var frame = this.graph.gridSize;
  var tree = new mxStackLayout(this.graph, !this.horizontalFlow, this.swimlaneSpacing, 2 * frame, 2 * frame);
  /**
   * @param {!Array} s
   * @return {?}
   */
  tree.isVertexIgnored = function(s) {
    return !tree.graph.isSwimlane(s);
  };
  return tree;
};
/**
 * @return {?}
 */
mxEditor.prototype.createSwimlaneLayout = function() {
  return new mxCompactTreeLayout(this.graph, this.horizontalFlow);
};
/**
 * @return {?}
 */
mxEditor.prototype.createToolbar = function() {
  return new mxDefaultToolbar(null, this);
};
/**
 * @param {undefined} name
 * @return {undefined}
 */
mxEditor.prototype.setToolbarContainer = function(name) {
  this.toolbar.init(name);
  if (mxClient.IS_QUIRKS) {
    new mxDivResizer(name);
  }
};
/**
 * @param {string} value
 * @return {undefined}
 */
mxEditor.prototype.setStatusContainer = function(value) {
  if (null == this.status) {
    /** @type {string} */
    this.status = value;
    this.addListener(mxEvent.SAVE, mxUtils.bind(this, function() {
      /** @type {string} */
      var msg = (new Date).toLocaleString();
      this.setStatus((mxResources.get(this.lastSavedResource) || this.lastSavedResource) + ": " + msg);
    }));
    this.addListener(mxEvent.OPEN, mxUtils.bind(this, function() {
      this.setStatus((mxResources.get(this.currentFileResource) || this.currentFileResource) + ": " + this.filename);
    }));
    if (mxClient.IS_QUIRKS) {
      new mxDivResizer(value);
    }
  }
};
/**
 * @param {string} state
 * @return {undefined}
 */
mxEditor.prototype.setStatus = function(state) {
  if (null != this.status && null != state) {
    /** @type {string} */
    this.status.innerHTML = state;
  }
};
/**
 * @param {!Object} data
 * @return {undefined}
 */
mxEditor.prototype.setTitleContainer = function(data) {
  this.addListener(mxEvent.ROOT, mxUtils.bind(this, function(b) {
    data.innerHTML = this.getTitle();
  }));
  if (mxClient.IS_QUIRKS) {
    new mxDivResizer(data);
  }
};
/**
 * @param {?} tree
 * @param {boolean} options
 * @return {undefined}
 */
mxEditor.prototype.treeLayout = function(tree, options) {
  if (null != tree) {
    (new mxCompactTreeLayout(this.graph, options)).execute(tree);
  }
};
/**
 * @return {?}
 */
mxEditor.prototype.getTitle = function() {
  /** @type {string} */
  var s = "";
  var graph = this.graph;
  var target = graph.getCurrentRoot();
  for (; null != target && null != graph.getModel().getParent(graph.getModel().getParent(target));) {
    if (graph.isValidRoot(target)) {
      /** @type {string} */
      s = " > " + graph.convertValueToString(target) + s;
    }
    target = graph.getModel().getParent(target);
  }
  return this.getRootTitle() + s;
};
/**
 * @return {?}
 */
mxEditor.prototype.getRootTitle = function() {
  var t = this.graph.getModel().getRoot();
  return this.graph.convertValueToString(t);
};
/**
 * @return {undefined}
 */
mxEditor.prototype.undo = function() {
  this.undoManager.undo();
};
/**
 * @return {undefined}
 */
mxEditor.prototype.redo = function() {
  this.undoManager.redo();
};
/**
 * @return {?}
 */
mxEditor.prototype.groupCells = function() {
  var target = null != this.groupBorderSize ? this.groupBorderSize : this.graph.gridSize;
  return this.graph.groupCells(this.createGroup(), target);
};
/**
 * @return {?}
 */
mxEditor.prototype.createGroup = function() {
  return this.graph.getModel().cloneCell(this.defaultGroup);
};
/**
 * @param {!Object} id
 * @return {undefined}
 */
mxEditor.prototype.open = function(id) {
  if (null != id) {
    var gAndroidDB = mxUtils.load(id).getXml();
    this.readGraphModel(gAndroidDB.documentElement);
    /** @type {!Object} */
    this.filename = id;
    this.fireEvent(new mxEventObject(mxEvent.OPEN, "filename", id));
  }
};
/**
 * @param {!Object} node
 * @return {undefined}
 */
mxEditor.prototype.readGraphModel = function(node) {
  (new mxCodec(node.ownerDocument)).decode(node, this.graph.getModel());
  this.resetHistory();
};
/**
 * @param {string} url
 * @param {string} fn
 * @return {undefined}
 */
mxEditor.prototype.save = function(url, fn) {
  url = url || this.getUrlPost();
  if (null != url && 0 < url.length) {
    var ret = this.writeGraphModel(fn);
    this.postDiagram(url, ret);
    this.setModified(false);
  }
  this.fireEvent(new mxEventObject(mxEvent.SAVE, "url", url));
};
/**
 * @param {string} href
 * @param {string} content
 * @return {undefined}
 */
mxEditor.prototype.postDiagram = function(href, content) {
  if (this.escapePostData) {
    /** @type {string} */
    content = encodeURIComponent(content);
  }
  mxUtils.post(href, this.postParameterName + "=" + content, mxUtils.bind(this, function(edit) {
    this.fireEvent(new mxEventObject(mxEvent.POST, "request", edit, "url", href, "data", content));
  }));
};
/**
 * @param {string} data
 * @return {?}
 */
mxEditor.prototype.writeGraphModel = function(data) {
  data = null != data ? data : this.linefeed;
  var node = (new mxCodec).encode(this.graph.getModel());
  return mxUtils.getXml(node, data);
};
/**
 * @return {?}
 */
mxEditor.prototype.getUrlPost = function() {
  return this.urlPost;
};
/**
 * @return {?}
 */
mxEditor.prototype.getUrlImage = function() {
  return this.urlImage;
};
/**
 * @param {string} index
 * @param {string} name
 * @return {undefined}
 */
mxEditor.prototype.swapStyles = function(index, name) {
  var c = this.graph.getStylesheet().styles[name];
  this.graph.getView().getStylesheet().putCellStyle(name, this.graph.getStylesheet().styles[index]);
  this.graph.getStylesheet().putCellStyle(index, c);
  this.graph.refresh();
};
/**
 * @param {string} name
 * @return {undefined}
 */
mxEditor.prototype.showProperties = function(name) {
  name = name || this.graph.getSelectionCell();
  if (null == name) {
    name = this.graph.getCurrentRoot();
    if (null == name) {
      name = this.graph.getModel().getRoot();
    }
  }
  if (null != name) {
    this.graph.stopEditing(true);
    var d = mxUtils.getOffset(this.graph.container);
    var ret = d.x + 10;
    d = d.y;
    if (null == this.properties || this.movePropertiesDialog) {
      var b = this.graph.getCellBounds(name);
      if (null != b) {
        ret = ret + (b.x + Math.min(200, b.width));
        d = d + b.y;
      }
    } else {
      ret = this.properties.getX();
      d = this.properties.getY();
    }
    this.hideProperties();
    name = this.createProperties(name);
    if (null != name) {
      this.properties = new mxWindow(mxResources.get(this.propertiesResource) || this.propertiesResource, name, ret, d, this.propertiesWidth, this.propertiesHeight, false);
      this.properties.setVisible(true);
    }
  }
};
/**
 * @return {?}
 */
mxEditor.prototype.isPropertiesVisible = function() {
  return null != this.properties;
};
/**
 * @param {string} cell
 * @return {?}
 */
mxEditor.prototype.createProperties = function(cell) {
  var me = this.graph.getModel();
  var i = me.getValue(cell);
  if (mxUtils.isNode(i)) {
    var self = new mxForm("properties");
    self.addText("ID", cell.getId()).setAttribute("readonly", "true");
    /** @type {null} */
    var attr = null;
    /** @type {null} */
    var child = null;
    /** @type {null} */
    var params = null;
    /** @type {null} */
    var result = null;
    /** @type {null} */
    var temp = null;
    if (me.isVertex(cell)) {
      attr = me.getGeometry(cell);
      if (null != attr) {
        child = self.addText("top", attr.y);
        params = self.addText("left", attr.x);
        result = self.addText("width", attr.width);
        temp = self.addText("height", attr.height);
      }
    }
    var value = me.getStyle(cell);
    var style = self.addText("Style", value || "");
    var a = i.attributes;
    /** @type {!Array} */
    var in_tokens = [];
    /** @type {number} */
    i = 0;
    for (; i < a.length; i++) {
      in_tokens[i] = self.addTextarea(a[i].nodeName, a[i].value, "label" == a[i].nodeName ? 4 : 2);
    }
    i = mxUtils.bind(this, function() {
      this.hideProperties();
      me.beginUpdate();
      try {
        if (null != attr) {
          attr = attr.clone();
          /** @type {number} */
          attr.x = parseFloat(params.value);
          /** @type {number} */
          attr.y = parseFloat(child.value);
          /** @type {number} */
          attr.width = parseFloat(result.value);
          /** @type {number} */
          attr.height = parseFloat(temp.value);
          me.setGeometry(cell, attr);
        }
        if (0 < style.value.length) {
          me.setStyle(cell, style.value);
        } else {
          me.setStyle(cell, null);
        }
        /** @type {number} */
        var i = 0;
        for (; i < a.length; i++) {
          var d = new mxCellAttributeChange(cell, a[i].nodeName, in_tokens[i].value);
          me.execute(d);
        }
        if (this.graph.isAutoSizeCell(cell)) {
          this.graph.updateCellSize(cell);
        }
      } finally {
        me.endUpdate();
      }
    });
    value = mxUtils.bind(this, function() {
      this.hideProperties();
    });
    self.addButtons(i, value);
    return self.table;
  }
  return null;
};
/**
 * @return {undefined}
 */
mxEditor.prototype.hideProperties = function() {
  if (null != this.properties) {
    this.properties.destroy();
    /** @type {null} */
    this.properties = null;
  }
};
/**
 * @return {undefined}
 */
mxEditor.prototype.showTasks = function() {
  if (null == this.tasks) {
    /** @type {!Element} */
    var e = document.createElement("div");
    /** @type {string} */
    e.style.padding = "4px";
    /** @type {string} */
    e.style.paddingLeft = "20px";
    /** @type {number} */
    var node = document.body.clientWidth;
    node = new mxWindow(mxResources.get(this.tasksResource) || this.tasksResource, e, node - 220, this.tasksTop, 200);
    node.setClosable(true);
    /** @type {boolean} */
    node.destroyOnClose = false;
    var value = mxUtils.bind(this, function(b) {
      mxEvent.release(e);
      /** @type {string} */
      e.innerHTML = "";
      this.createTasks(e);
    });
    this.graph.getModel().addListener(mxEvent.CHANGE, value);
    this.graph.getSelectionModel().addListener(mxEvent.CHANGE, value);
    this.graph.addListener(mxEvent.ROOT, value);
    if (null != this.tasksWindowImage) {
      node.setImage(this.tasksWindowImage);
    }
    this.tasks = node;
    this.createTasks(e);
  }
  this.tasks.setVisible(true);
};
/**
 * @param {!Object} node
 * @return {undefined}
 */
mxEditor.prototype.refreshTasks = function(node) {
  if (null != this.tasks) {
    node = this.tasks.content;
    mxEvent.release(node);
    /** @type {string} */
    node.innerHTML = "";
    this.createTasks(node);
  }
};
/**
 * @param {!Object} callback
 * @return {undefined}
 */
mxEditor.prototype.createTasks = function(callback) {
};
/**
 * @param {!Object} callback
 * @return {undefined}
 */
mxEditor.prototype.showHelp = function(callback) {
  if (null == this.help) {
    /** @type {!Element} */
    var iframe = document.createElement("iframe");
    iframe.setAttribute("src", mxResources.get("urlHelp") || this.urlHelp);
    iframe.setAttribute("height", "100%");
    iframe.setAttribute("width", "100%");
    iframe.setAttribute("frameBorder", "0");
    /** @type {string} */
    iframe.style.backgroundColor = "white";
    /** @type {number} */
    callback = document.body.clientWidth;
    /** @type {number} */
    var c = document.body.clientHeight || document.documentElement.clientHeight;
    var me = new mxWindow(mxResources.get(this.helpResource) || this.helpResource, iframe, (callback - this.helpWidth) / 2, (c - this.helpHeight) / 3, this.helpWidth, this.helpHeight);
    me.setMaximizable(true);
    me.setClosable(true);
    /** @type {boolean} */
    me.destroyOnClose = false;
    me.setResizable(true);
    if (null != this.helpWindowImage) {
      me.setImage(this.helpWindowImage);
    }
    if (mxClient.IS_NS) {
      /**
       * @param {number} s
       * @return {undefined}
       */
      callback = function(s) {
        iframe.setAttribute("height", me.div.offsetHeight - 26 + "px");
      };
      me.addListener(mxEvent.RESIZE_END, callback);
      me.addListener(mxEvent.MAXIMIZE, callback);
      me.addListener(mxEvent.NORMALIZE, callback);
      me.addListener(mxEvent.SHOW, callback);
    }
    this.help = me;
  }
  this.help.setVisible(true);
};
/**
 * @return {undefined}
 */
mxEditor.prototype.showOutline = function() {
  if (null == this.outline) {
    /** @type {!Element} */
    var node = document.createElement("div");
    /** @type {string} */
    node.style.overflow = "hidden";
    /** @type {string} */
    node.style.position = "relative";
    /** @type {string} */
    node.style.width = "100%";
    /** @type {string} */
    node.style.height = "100%";
    /** @type {string} */
    node.style.background = "white";
    /** @type {string} */
    node.style.cursor = "move";
    if (8 == document.documentMode) {
      /** @type {string} */
      node.style.filter = "progid:DXImageTransform.Microsoft.alpha(opacity=100)";
    }
    var undoMgr = new mxWindow(mxResources.get(this.outlineResource) || this.outlineResource, node, 600, 480, 200, 200, false);
    var exp = new mxOutline(this.graph, node);
    undoMgr.setClosable(true);
    undoMgr.setResizable(true);
    /** @type {boolean} */
    undoMgr.destroyOnClose = false;
    undoMgr.addListener(mxEvent.RESIZE_END, function() {
      exp.update();
    });
    this.outline = undoMgr;
    this.outline.outline = exp;
  }
  this.outline.setVisible(true);
  this.outline.outline.update(true);
};
/**
 * @param {string} name
 * @return {undefined}
 */
mxEditor.prototype.setMode = function(name) {
  if ("select" == name) {
    /** @type {boolean} */
    this.graph.panningHandler.useLeftButtonForPanning = false;
    this.graph.setConnectable(false);
  } else {
    if ("connect" == name) {
      /** @type {boolean} */
      this.graph.panningHandler.useLeftButtonForPanning = false;
      this.graph.setConnectable(true);
    } else {
      if ("pan" == name) {
        /** @type {boolean} */
        this.graph.panningHandler.useLeftButtonForPanning = true;
        this.graph.setConnectable(false);
      }
    }
  }
};
/**
 * @param {string} id
 * @param {string} menu
 * @param {?} element
 * @return {undefined}
 */
mxEditor.prototype.createPopupMenu = function(id, menu, element) {
  this.popupHandler.createMenu(this, id, menu, element);
};
/**
 * @param {string} a
 * @param {string} b
 * @return {?}
 */
mxEditor.prototype.createEdge = function(a, b) {
  var div;
  if (null != this.defaultEdge) {
    div = this.graph.getModel().cloneCell(this.defaultEdge);
  } else {
    div = new mxCell("");
    div.setEdge(true);
    var p = new mxGeometry;
    /** @type {boolean} */
    p.relative = true;
    div.setGeometry(p);
  }
  p = this.getEdgeStyle();
  if (null != p) {
    div.setStyle(p);
  }
  return div;
};
/**
 * @return {?}
 */
mxEditor.prototype.getEdgeStyle = function() {
  return this.defaultEdgeStyle;
};
/**
 * @param {!Object} url
 * @return {?}
 */
mxEditor.prototype.consumeCycleAttribute = function(url) {
  return null != this.cycleAttributeValues && 0 < this.cycleAttributeValues.length && this.graph.isSwimlane(url) ? this.cycleAttributeValues[this.cycleAttributeIndex++ % this.cycleAttributeValues.length] : null;
};
/**
 * @param {!Object} a
 * @return {undefined}
 */
mxEditor.prototype.cycleAttribute = function(a) {
  if (null != this.cycleAttributeName) {
    var x = this.consumeCycleAttribute(a);
    if (null != x) {
      a.setStyle(a.getStyle() + ";" + this.cycleAttributeName + "=" + x);
    }
  }
};
/**
 * @param {string} name
 * @param {string} target
 * @param {number} width
 * @param {number} height
 * @return {?}
 */
mxEditor.prototype.addVertex = function(name, target, width, height) {
  var me = this.graph.getModel();
  for (; null != name && !this.graph.isValidDropTarget(name);) {
    name = me.getParent(name);
  }
  name = null != name ? name : this.graph.getSwimlaneAt(width, height);
  var scale = this.graph.getView().scale;
  var p = me.getGeometry(target);
  var x = me.getGeometry(name);
  if (this.graph.isSwimlane(target) && !this.graph.swimlaneNesting) {
    /** @type {null} */
    name = null;
  } else {
    if (null == name && this.swimlaneRequired) {
      return null;
    }
    if (null != name && null != x) {
      var d = this.graph.getView().getState(name);
      if (null != d) {
        if (width = width - d.origin.x * scale, height = height - d.origin.y * scale, this.graph.isConstrainedMoving) {
          x = p.width;
          var y = p.height;
          var br = d.x + d.width;
          if (width + x > br) {
            /** @type {number} */
            width = width - (width + x - br);
          }
          br = d.y + d.height;
          if (height + y > br) {
            /** @type {number} */
            height = height - (height + y - br);
          }
        }
      } else {
        if (null != x) {
          /** @type {number} */
          width = width - x.x * scale;
          /** @type {number} */
          height = height - x.y * scale;
        }
      }
    }
  }
  p = p.clone();
  p.x = this.graph.snap(width / scale - this.graph.getView().translate.x - this.graph.gridSize / 2);
  p.y = this.graph.snap(height / scale - this.graph.getView().translate.y - this.graph.gridSize / 2);
  target.setGeometry(p);
  if (null == name) {
    name = this.graph.getDefaultParent();
  }
  this.cycleAttribute(target);
  this.fireEvent(new mxEventObject(mxEvent.BEFORE_ADD_VERTEX, "vertex", target, "parent", name));
  me.beginUpdate();
  try {
    target = this.graph.addCell(target, name);
    if (null != target) {
      this.graph.constrainChild(target);
      this.fireEvent(new mxEventObject(mxEvent.ADD_VERTEX, "vertex", target));
    }
  } finally {
    me.endUpdate();
  }
  if (null != target) {
    this.graph.setSelectionCell(target);
    this.graph.scrollCellToVisible(target);
    this.fireEvent(new mxEventObject(mxEvent.AFTER_ADD_VERTEX, "vertex", target));
  }
  return target;
};
/**
 * @return {undefined}
 */
mxEditor.prototype.destroy = function() {
  if (!this.destroyed) {
    /** @type {boolean} */
    this.destroyed = true;
    if (null != this.tasks) {
      this.tasks.destroy();
    }
    if (null != this.outline) {
      this.outline.destroy();
    }
    if (null != this.properties) {
      this.properties.destroy();
    }
    if (null != this.keyHandler) {
      this.keyHandler.destroy();
    }
    if (null != this.rubberband) {
      this.rubberband.destroy();
    }
    if (null != this.toolbar) {
      this.toolbar.destroy();
    }
    if (null != this.graph) {
      this.graph.destroy();
    }
    /** @type {null} */
    this.templates = this.status = null;
  }
};
var mxCodecRegistry = {
  codecs : [],
  aliases : [],
  register : function(module) {
    if (null != module) {
      var name = module.getName();
      /** @type {!Object} */
      mxCodecRegistry.codecs[name] = module;
      var alias = mxUtils.getFunctionName(module.template.constructor);
      if (alias != name) {
        mxCodecRegistry.addAlias(alias, name);
      }
    }
    return module;
  },
  addAlias : function(alias, name) {
    /** @type {string} */
    mxCodecRegistry.aliases[alias] = name;
  },
  getCodec : function(func) {
    /** @type {null} */
    var name = null;
    if (null != func) {
      name = mxUtils.getFunctionName(func);
      var aliasedName = mxCodecRegistry.aliases[name];
      if (null != aliasedName) {
        name = aliasedName;
      }
      name = mxCodecRegistry.codecs[name];
      if (null == name) {
        try {
          name = new mxObjectCodec(new func);
          mxCodecRegistry.register(name);
        } catch (d) {
        }
      }
    }
    return name;
  }
};
/**
 * @param {!Object} doc
 * @return {undefined}
 */
function mxCodec(doc) {
  this.document = doc || mxUtils.createXmlDocument();
  /** @type {!Array} */
  this.objects = [];
}
/** @type {null} */
mxCodec.prototype.document = null;
/** @type {null} */
mxCodec.prototype.objects = null;
/** @type {null} */
mxCodec.prototype.elements = null;
/** @type {boolean} */
mxCodec.prototype.encodeDefaults = false;
/**
 * @param {?} key
 * @param {!Object} value
 * @return {?}
 */
mxCodec.prototype.putObject = function(key, value) {
  return this.objects[key] = value;
};
/**
 * @param {!Object} id
 * @return {?}
 */
mxCodec.prototype.getObject = function(id) {
  /** @type {null} */
  var result = null;
  if (null != id) {
    result = this.objects[id];
    if (null == result) {
      result = this.lookup(id);
      if (null == result) {
        id = this.getElementById(id);
        if (null != id) {
          result = this.decode(id);
        }
      }
    }
  }
  return result;
};
/**
 * @param {!Object} i
 * @return {?}
 */
mxCodec.prototype.lookup = function(i) {
  return null;
};
/**
 * @param {!Object} id
 * @return {?}
 */
mxCodec.prototype.getElementById = function(id) {
  this.updateElements();
  return this.elements[id];
};
/**
 * @return {undefined}
 */
mxCodec.prototype.updateElements = function() {
  if (null == this.elements) {
    this.elements = {};
    if (null != this.document.documentElement) {
      this.addElement(this.document.documentElement);
    }
  }
};
/**
 * @param {!Object} element
 * @return {undefined}
 */
mxCodec.prototype.addElement = function(element) {
  if (element.nodeType == mxConstants.NODETYPE_ELEMENT) {
    var name = element.getAttribute("id");
    if (null != name) {
      if (null == this.elements[name]) {
        /** @type {!Object} */
        this.elements[name] = element;
      } else {
        if (this.elements[name] != element) {
          throw Error(name + ": Duplicate ID");
        }
      }
    }
  }
  element = element.firstChild;
  for (; null != element;) {
    this.addElement(element);
    element = element.nextSibling;
  }
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxCodec.prototype.getId = function(value) {
  /** @type {null} */
  var ret = null;
  if (null != value) {
    ret = this.reference(value);
    if (null == ret && value instanceof mxCell) {
      ret = value.getId();
      if (null == ret) {
        ret = mxCellPath.create(value);
        if (0 == ret.length) {
          /** @type {string} */
          ret = "root";
        }
      }
    }
  }
  return ret;
};
/**
 * @param {!Object} name
 * @return {?}
 */
mxCodec.prototype.reference = function(name) {
  return null;
};
/**
 * @param {!Object} value
 * @return {?}
 */
mxCodec.prototype.encode = function(value) {
  /** @type {null} */
  var result = null;
  if (null != value && null != value.constructor) {
    var c = mxCodecRegistry.getCodec(value.constructor);
    if (null != c) {
      result = c.encode(this, value);
    } else {
      if (mxUtils.isNode(value)) {
        result = mxUtils.importNode(this.document, value, true);
      } else {
        mxLog.warn("mxCodec.encode: No codec for " + mxUtils.getFunctionName(value.constructor));
      }
    }
  }
  return result;
};
/**
 * @param {!Object} v
 * @param {!Object} b
 * @return {?}
 */
mxCodec.prototype.decode = function(v, b) {
  this.updateElements();
  /** @type {null} */
  var result = null;
  if (null != v && v.nodeType == mxConstants.NODETYPE_ELEMENT) {
    /** @type {null} */
    result = null;
    try {
      result = window[v.nodeName];
    } catch (d) {
    }
    result = mxCodecRegistry.getCodec(result);
    if (null != result) {
      result = result.decode(this, v, b);
    } else {
      result = v.cloneNode(true);
      result.removeAttribute("as");
    }
  }
  return result;
};
/**
 * @param {?} t
 * @param {!Object} a
 * @param {number} repeats
 * @return {undefined}
 */
mxCodec.prototype.encodeCell = function(t, a, repeats) {
  a.appendChild(this.encode(t));
  if (null == repeats || repeats) {
    repeats = t.getChildCount();
    /** @type {number} */
    var i = 0;
    for (; i < repeats; i++) {
      this.encodeCell(t.getChildAt(i), a);
    }
  }
};
/**
 * @param {!Object} n22
 * @return {?}
 */
mxCodec.prototype.isCellCodec = function(n22) {
  return null != n22 && "function" == typeof n22.isCellCodec ? n22.isCellCodec() : false;
};
/**
 * @param {!Object} data
 * @param {?} min
 * @return {?}
 */
mxCodec.prototype.decodeCell = function(data, min) {
  min = null != min ? min : true;
  /** @type {null} */
  var c = null;
  if (null != data && data.nodeType == mxConstants.NODETYPE_ELEMENT) {
    c = mxCodecRegistry.getCodec(data.nodeName);
    if (!this.isCellCodec(c)) {
      var node = data.firstChild;
      for (; null != node && !this.isCellCodec(c);) {
        c = mxCodecRegistry.getCodec(node.nodeName);
        node = node.nextSibling;
      }
    }
    if (!this.isCellCodec(c)) {
      c = mxCodecRegistry.getCodec(mxCell);
    }
    c = c.decode(this, data);
    if (min) {
      this.insertIntoGraph(c);
    }
  }
  return c;
};
/**
 * @param {?} self
 * @return {undefined}
 */
mxCodec.prototype.insertIntoGraph = function(self) {
  var parent = self.parent;
  var source = self.getTerminal(true);
  var target = self.getTerminal(false);
  self.setTerminal(null, false);
  self.setTerminal(null, true);
  /** @type {null} */
  self.parent = null;
  if (null != parent) {
    if (parent == self) {
      throw Error(parent.id + ": Self Reference");
    }
    parent.insert(self);
  }
  if (null != source) {
    source.insertEdge(self, true);
  }
  if (null != target) {
    target.insertEdge(self, false);
  }
};
/**
 * @param {!Object} name
 * @param {string} value
 * @param {string} key
 * @return {undefined}
 */
mxCodec.prototype.setAttribute = function(name, value, key) {
  if (null != value && null != key) {
    name.setAttribute(value, key);
  }
};
/**
 * @param {string} template
 * @param {string} v
 * @param {string} data
 * @param {!Object} mapping
 * @return {undefined}
 */
function mxObjectCodec(template, v, data, mapping) {
  /** @type {string} */
  this.template = template;
  this.exclude = null != v ? v : [];
  this.idrefs = null != data ? data : [];
  this.mapping = null != mapping ? mapping : [];
  this.reverse = {};
  var id;
  for (id in this.mapping) {
    /** @type {string} */
    this.reverse[this.mapping[id]] = id;
  }
}
/** @type {boolean} */
mxObjectCodec.allowEval = false;
/** @type {null} */
mxObjectCodec.prototype.template = null;
/** @type {null} */
mxObjectCodec.prototype.exclude = null;
/** @type {null} */
mxObjectCodec.prototype.idrefs = null;
/** @type {null} */
mxObjectCodec.prototype.mapping = null;
/** @type {null} */
mxObjectCodec.prototype.reverse = null;
/**
 * @return {?}
 */
mxObjectCodec.prototype.getName = function() {
  return mxUtils.getFunctionName(this.template.constructor);
};
/**
 * @return {?}
 */
mxObjectCodec.prototype.cloneTemplate = function() {
  return new this.template.constructor;
};
/**
 * @param {!Object} s
 * @return {?}
 */
mxObjectCodec.prototype.getFieldName = function(s) {
  if (null != s) {
    var mapped = this.reverse[s];
    if (null != mapped) {
      s = mapped;
    }
  }
  return s;
};
/**
 * @param {string} name
 * @return {?}
 */
mxObjectCodec.prototype.getAttributeName = function(name) {
  if (null != name) {
    var aliasedName = this.mapping[name];
    if (null != aliasedName) {
      name = aliasedName;
    }
  }
  return name;
};
/**
 * @param {!Object} path
 * @param {string} value
 * @param {!Object} file
 * @param {boolean} index
 * @return {?}
 */
mxObjectCodec.prototype.isExcluded = function(path, value, file, index) {
  return value == mxObjectIdentity.FIELD_NAME || 0 <= mxUtils.indexOf(this.exclude, value);
};
/**
 * @param {!Object} node
 * @param {string} obj
 * @param {!Object} path
 * @param {boolean} state
 * @return {?}
 */
mxObjectCodec.prototype.isReference = function(node, obj, path, state) {
  return 0 <= mxUtils.indexOf(this.idrefs, obj);
};
/**
 * @param {!Object} a
 * @param {!Object} b
 * @return {?}
 */
mxObjectCodec.prototype.encode = function(a, b) {
  var d = a.document.createElement(this.getName());
  b = this.beforeEncode(a, b, d);
  this.encodeObject(a, b, d);
  return this.afterEncode(a, b, d);
};
/**
 * @param {!Object} o
 * @param {!Object} value
 * @param {undefined} m
 * @return {undefined}
 */
mxObjectCodec.prototype.encodeObject = function(o, value, m) {
  o.setAttribute(m, "id", o.getId(value));
  var item;
  for (item in value) {
    /** @type {string} */
    var data = item;
    var items = value[data];
    if (!(null == items || this.isExcluded(value, data, items, true))) {
      if (mxUtils.isInteger(data)) {
        /** @type {null} */
        data = null;
      }
      this.encodeValue(o, value, data, items, m);
    }
  }
};
/**
 * @param {(Object|string)} name
 * @param {!Object} value
 * @param {string} id
 * @param {?} key
 * @param {!Object} prop
 * @return {undefined}
 */
mxObjectCodec.prototype.encodeValue = function(name, value, id, key, prop) {
  if (null != key) {
    if (this.isReference(value, id, key, true)) {
      var label = name.getId(key);
      if (null == label) {
        mxLog.warn("mxObjectCodec.encode: No ID for " + this.getName() + "." + id + "=" + key);
        return;
      }
      key = label;
    }
    label = this.template[id];
    if (null == id || name.encodeDefaults || label != key) {
      id = this.getAttributeName(id);
      this.writeAttribute(name, value, id, key, prop);
    }
  }
};
/**
 * @param {string} type
 * @param {!Object} a
 * @param {string} callback
 * @param {number} value
 * @param {!Object} name
 * @return {undefined}
 */
mxObjectCodec.prototype.writeAttribute = function(type, a, callback, value, name) {
  if ("object" != typeof value) {
    this.writePrimitiveAttribute(type, a, callback, value, name);
  } else {
    this.writeComplexAttribute(type, a, callback, value, name);
  }
};
/**
 * @param {!HTMLElement} el
 * @param {!Object} result
 * @param {string} key
 * @param {number} value
 * @param {!Object} item
 * @return {undefined}
 */
mxObjectCodec.prototype.writePrimitiveAttribute = function(el, result, key, value, item) {
  value = this.convertAttributeToXml(el, result, key, value, item);
  if (null == key) {
    result = el.document.createElement("add");
    if ("function" == typeof value) {
      result.appendChild(el.document.createTextNode(value));
    } else {
      el.setAttribute(result, "value", value);
    }
    item.appendChild(result);
  } else {
    if ("function" != typeof value) {
      el.setAttribute(item, key, value);
    }
  }
};
/**
 * @param {!Object} t
 * @param {!Object} uuid
 * @param {string} type
 * @param {undefined} str
 * @param {!Object} e
 * @return {undefined}
 */
mxObjectCodec.prototype.writeComplexAttribute = function(t, uuid, type, str, e) {
  t = t.encode(str);
  if (null != t) {
    if (null != type) {
      t.setAttribute("as", type);
    }
    e.appendChild(t);
  } else {
    mxLog.warn("mxObjectCodec.encode: No node for " + this.getName() + "." + type + ": " + str);
  }
};
/**
 * @param {!HTMLElement} href
 * @param {!Object} parent
 * @param {string} num
 * @param {number} sel
 * @return {?}
 */
mxObjectCodec.prototype.convertAttributeToXml = function(href, parent, num, sel) {
  if (this.isBooleanAttribute(href, parent, num, sel)) {
    /** @type {string} */
    sel = 1 == sel ? "1" : "0";
  }
  return sel;
};
/**
 * @param {!HTMLElement} attrValue
 * @param {!Object} attrName
 * @param {string} value
 * @param {number} node
 * @return {?}
 */
mxObjectCodec.prototype.isBooleanAttribute = function(attrValue, attrName, value, node) {
  return "undefined" == typeof node.length && (1 == node || 0 == node);
};
/**
 * @param {!Object} a
 * @param {!Object} c
 * @param {!Object} d
 * @return {?}
 */
mxObjectCodec.prototype.convertAttributeFromXml = function(a, c, d) {
  var w = c.value;
  if (this.isNumericAttribute(a, c, d) && (w = parseFloat(w), isNaN(w) || !isFinite(w))) {
    /** @type {number} */
    w = 0;
  }
  return w;
};
/**
 * @param {!Object} templateName
 * @param {!Object} obj
 * @param {!Object} time
 * @return {?}
 */
mxObjectCodec.prototype.isNumericAttribute = function(templateName, obj, time) {
  return time.constructor == mxGeometry && ("x" == obj.name || "y" == obj.name || "width" == obj.name || "height" == obj.name) || time.constructor == mxPoint && ("x" == obj.name || "y" == obj.name) || mxUtils.isNumeric(obj.value);
};
/**
 * @param {!Object} rect
 * @param {!Object} linesstrip
 * @param {?} optionsValue
 * @return {?}
 */
mxObjectCodec.prototype.beforeEncode = function(rect, linesstrip, optionsValue) {
  return linesstrip;
};
/**
 * @param {!Object} v03
 * @param {!Object} v13
 * @param {?} v23
 * @return {?}
 */
mxObjectCodec.prototype.afterEncode = function(v03, v13, v23) {
  return v23;
};
/**
 * @param {!Object} b
 * @param {!Object} a
 * @param {!Function} text
 * @return {?}
 */
mxObjectCodec.prototype.decode = function(b, a, text) {
  var key = a.getAttribute("id");
  var value = b.objects[key];
  if (null == value) {
    value = text || this.cloneTemplate();
    if (null != key) {
      b.putObject(key, value);
    }
  }
  a = this.beforeDecode(b, a, value);
  this.decodeNode(b, a, value);
  return this.afterDecode(b, a, value);
};
/**
 * @param {!Object} a
 * @param {!Object} definition
 * @param {!Object} object
 * @return {undefined}
 */
mxObjectCodec.prototype.decodeNode = function(a, definition, object) {
  if (null != definition) {
    this.decodeAttributes(a, definition, object);
    this.decodeChildren(a, definition, object);
  }
};
/**
 * @param {!Object} mask
 * @param {!Object} val
 * @param {!Object} rootVal
 * @return {undefined}
 */
mxObjectCodec.prototype.decodeAttributes = function(mask, val, rootVal) {
  val = val.attributes;
  if (null != val) {
    /** @type {number} */
    var bufferIdx = 0;
    for (; bufferIdx < val.length; bufferIdx++) {
      this.decodeAttribute(mask, val[bufferIdx], rootVal);
    }
  }
};
/**
 * @param {!Object} nothing
 * @param {!Object} obj
 * @param {!Object} instance
 * @return {?}
 */
mxObjectCodec.prototype.isIgnoredAttribute = function(nothing, obj, instance) {
  return "as" == obj.nodeName || "id" == obj.nodeName;
};
/**
 * @param {!Object} name
 * @param {!Object} value
 * @param {!Object} obj
 * @return {undefined}
 */
mxObjectCodec.prototype.decodeAttribute = function(name, value, obj) {
  if (!this.isIgnoredAttribute(name, value, obj)) {
    var k = value.nodeName;
    value = this.convertAttributeFromXml(name, value, obj);
    var old = this.getFieldName(k);
    if (this.isReference(obj, old, value, false)) {
      name = name.getObject(value);
      if (null == name) {
        mxLog.warn("mxObjectCodec.decode: No object for " + this.getName() + "." + k + "=" + value);
        return;
      }
      /** @type {!Object} */
      value = name;
    }
    if (!this.isExcluded(obj, k, value, false)) {
      /** @type {!Object} */
      obj[k] = value;
    }
  }
};
/**
 * @param {!Object} path
 * @param {!Object} node
 * @param {!Object} child
 * @return {undefined}
 */
mxObjectCodec.prototype.decodeChildren = function(path, node, child) {
  node = node.firstChild;
  for (; null != node;) {
    var next_node = node.nextSibling;
    if (!(node.nodeType != mxConstants.NODETYPE_ELEMENT || this.processInclude(path, node, child))) {
      this.decodeChild(path, node, child);
    }
    node = next_node;
  }
};
/**
 * @param {!Object} options
 * @param {!Object} node
 * @param {!Object} index
 * @return {undefined}
 */
mxObjectCodec.prototype.decodeChild = function(options, node, index) {
  var i = this.getFieldName(node.getAttribute("as"));
  if (null == i || !this.isExcluded(index, i, node, false)) {
    var value = this.getFieldTemplate(index, i, node);
    if ("add" == node.nodeName) {
      options = node.getAttribute("value");
      if (null == options && mxObjectCodec.allowEval) {
        options = mxUtils.eval(mxUtils.getTextContent(node));
      }
    } else {
      options = options.decode(node, value);
    }
    try {
      this.addObjectValue(index, i, options, value);
    } catch (controlFlowAction) {
      throw Error(controlFlowAction.message + " for " + node.nodeName);
    }
  }
};
/**
 * @param {!Object} i
 * @param {string} k
 * @param {!Object} options
 * @return {?}
 */
mxObjectCodec.prototype.getFieldTemplate = function(i, k, options) {
  i = i[k];
  if (i instanceof Array && 0 < i.length) {
    /** @type {null} */
    i = null;
  }
  return i;
};
/**
 * @param {!Object} cache
 * @param {string} p
 * @param {!Object} val
 * @param {!Object} disabled
 * @return {undefined}
 */
mxObjectCodec.prototype.addObjectValue = function(cache, p, val, disabled) {
  if (null != val && val != disabled) {
    if (null != p && 0 < p.length) {
      /** @type {!Object} */
      cache[p] = val;
    } else {
      cache.push(val);
    }
  }
};
/**
 * @param {!Object} path
 * @param {!Object} parent
 * @param {!Object} value
 * @return {?}
 */
mxObjectCodec.prototype.processInclude = function(path, parent, value) {
  if ("include" == parent.nodeName) {
    parent = parent.getAttribute("name");
    if (null != parent) {
      try {
        var d = mxUtils.load(parent).getDocumentElement();
        if (null != d) {
          path.decode(d, value);
        }
      } catch (e) {
      }
    }
    return true;
  }
  return false;
};
/**
 * @param {!Object} rect
 * @param {!Object} submenu
 * @param {?} eventArgs
 * @return {?}
 */
mxObjectCodec.prototype.beforeDecode = function(rect, submenu, eventArgs) {
  return submenu;
};
/**
 * @param {!Object} rect
 * @param {!Object} submenu
 * @param {?} eventArgs
 * @return {?}
 */
mxObjectCodec.prototype.afterDecode = function(rect, submenu, eventArgs) {
  return eventArgs;
};
mxCodecRegistry.register(function() {
  var me = new mxObjectCodec(new mxCell, ["children", "edges", "overlays", "mxTransient"], ["parent", "source", "target"]);
  /**
   * @return {?}
   */
  me.isCellCodec = function() {
    return true;
  };
  /**
   * @param {!Object} elementName
   * @param {!Object} element
   * @param {!Object} depth
   * @return {?}
   */
  me.isNumericAttribute = function(elementName, element, depth) {
    return "value" !== element.nodeName && mxObjectCodec.prototype.isNumericAttribute.apply(this, arguments);
  };
  /**
   * @param {!Object} path
   * @param {string} object
   * @param {!Object} value
   * @param {boolean} name
   * @return {?}
   */
  me.isExcluded = function(path, object, value, name) {
    return mxObjectCodec.prototype.isExcluded.apply(this, arguments) || name && "value" == object && value.nodeType == mxConstants.NODETYPE_ELEMENT;
  };
  /**
   * @param {!Object} node
   * @param {!Object} template
   * @param {!Element} d
   * @return {?}
   */
  me.afterEncode = function(node, template, d) {
    if (null != template.value && template.value.nodeType == mxConstants.NODETYPE_ELEMENT) {
      /** @type {!Element} */
      var u = d;
      d = mxUtils.importNode(node.document, template.value, true);
      d.appendChild(u);
      node = u.getAttribute("id");
      d.setAttribute("id", node);
      u.removeAttribute("id");
    }
    return d;
  };
  /**
   * @param {!Object} obj
   * @param {string} node
   * @param {!Object} t
   * @return {?}
   */
  me.beforeDecode = function(obj, node, t) {
    var child = node.cloneNode(true);
    var name = this.getName();
    if (node.nodeName != name) {
      child = node.getElementsByTagName(name)[0];
      if (null != child && child.parentNode == node) {
        mxUtils.removeWhitespace(child, true);
        mxUtils.removeWhitespace(child, false);
        child.parentNode.removeChild(child);
      } else {
        /** @type {null} */
        child = null;
      }
      t.value = node.cloneNode(true);
      node = t.value.getAttribute("id");
      if (null != node) {
        t.setId(node);
        t.value.removeAttribute("id");
      }
    } else {
      t.setId(node.getAttribute("id"));
    }
    if (null != child) {
      /** @type {number} */
      node = 0;
      for (; node < this.idrefs.length; node++) {
        name = this.idrefs[node];
        var i = child.getAttribute(name);
        if (null != i) {
          child.removeAttribute(name);
          var val = obj.objects[i] || obj.lookup(i);
          if (null == val) {
            i = obj.getElementById(i);
            if (null != i) {
              val = (mxCodecRegistry.codecs[i.nodeName] || this).decode(obj, i);
            }
          }
          t[name] = val;
        }
      }
    }
    return child;
  };
  return me;
}());
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxGraphModel);
  /**
   * @param {!Object} c
   * @param {!Object} m
   * @param {!Object} o
   * @return {undefined}
   */
  codec.encodeObject = function(c, m, o) {
    var b = c.document.createElement("root");
    c.encodeCell(m.getRoot(), b);
    o.appendChild(b);
  };
  /**
   * @param {!Object} projectName
   * @param {!Object} root
   * @param {!Object} vNode
   * @return {undefined}
   */
  codec.decodeChild = function(projectName, root, vNode) {
    if ("root" == root.nodeName) {
      this.decodeRoot(projectName, root, vNode);
    } else {
      mxObjectCodec.prototype.decodeChild.apply(this, arguments);
    }
  };
  /**
   * @param {!Object} uri
   * @param {!Object} c
   * @param {!Object} data
   * @return {undefined}
   */
  codec.decodeRoot = function(uri, c, data) {
    /** @type {null} */
    var rootNode = null;
    c = c.firstChild;
    for (; null != c;) {
      var node = uri.decodeCell(c);
      if (null != node && null == node.getParent()) {
        rootNode = node;
      }
      c = c.nextSibling;
    }
    if (null != rootNode) {
      data.setRoot(rootNode);
    }
  };
  return codec;
}());
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxRootChange, ["model", "previous", "root"]);
  /**
   * @param {!Object} t
   * @param {!Object} c
   * @param {!Object} d
   * @return {?}
   */
  codec.afterEncode = function(t, c, d) {
    t.encodeCell(c.root, d);
    return d;
  };
  /**
   * @param {!Object} n
   * @param {!Object} d
   * @param {!Object} result
   * @return {?}
   */
  codec.beforeDecode = function(n, d, result) {
    if (null != d.firstChild && d.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT) {
      d = d.cloneNode(true);
      var root = d.firstChild;
      result.root = n.decodeCell(root, false);
      result = root.nextSibling;
      root.parentNode.removeChild(root);
      /** @type {!Object} */
      root = result;
      for (; null != root;) {
        result = root.nextSibling;
        n.decodeCell(root);
        root.parentNode.removeChild(root);
        /** @type {!Object} */
        root = result;
      }
    }
    return d;
  };
  /**
   * @param {!Object} a
   * @param {!Object} kind
   * @param {!Object} options
   * @return {?}
   */
  codec.afterDecode = function(a, kind, options) {
    options.previous = options.root;
    return options;
  };
  return codec;
}());
mxCodecRegistry.register(function() {
  var util = new mxObjectCodec(new mxChildChange, ["model", "child", "previousIndex"], ["parent", "previous"]);
  /**
   * @param {!Object} node
   * @param {string} parent
   * @param {!Object} state
   * @param {boolean} obj
   * @return {?}
   */
  util.isReference = function(node, parent, state, obj) {
    return "child" != parent || obj && !node.model.contains(node.previous) ? 0 <= mxUtils.indexOf(this.idrefs, parent) : true;
  };
  /**
   * @param {!Object} page
   * @param {string} key
   * @param {!Object} value
   * @param {string} field
   * @return {?}
   */
  util.isExcluded = function(page, key, value, field) {
    return mxObjectCodec.prototype.isExcluded.apply(this, arguments) || field && null != value && ("previous" == key || "parent" == key) && !page.model.contains(value);
  };
  /**
   * @param {!Object} t
   * @param {!Object} node
   * @param {!Object} d
   * @return {?}
   */
  util.afterEncode = function(t, node, d) {
    if (this.isReference(node, "child", node.child, true)) {
      d.setAttribute("child", t.getId(node.child));
    } else {
      t.encodeCell(node.child, d);
    }
    return d;
  };
  /**
   * @param {!Object} app
   * @param {!Object} e
   * @param {!Object} link
   * @return {?}
   */
  util.beforeDecode = function(app, e, link) {
    if (null != e.firstChild && e.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT) {
      e = e.cloneNode(true);
      var target = e.firstChild;
      link.child = app.decodeCell(target, false);
      link = target.nextSibling;
      target.parentNode.removeChild(target);
      /** @type {!Object} */
      target = link;
      for (; null != target;) {
        link = target.nextSibling;
        if (target.nodeType == mxConstants.NODETYPE_ELEMENT) {
          var f = target.getAttribute("id");
          if (null == app.lookup(f)) {
            app.decodeCell(target);
          }
        }
        target.parentNode.removeChild(target);
        /** @type {!Object} */
        target = link;
      }
    } else {
      target = e.getAttribute("child");
      link.child = app.getObject(target);
    }
    return e;
  };
  /**
   * @param {!Object} a
   * @param {!Object} kind
   * @param {!Object} item
   * @return {?}
   */
  util.afterDecode = function(a, kind, item) {
    if (null != item.child) {
      if (null != item.child.parent && null != item.previous && item.child.parent != item.previous) {
        item.previous = item.child.parent;
      }
      item.child.parent = item.previous;
      item.previous = item.parent;
      item.previousIndex = item.index;
    }
    return item;
  };
  return util;
}());
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxTerminalChange, ["model", "previous"], ["cell", "terminal"]);
  /**
   * @param {!Object} a
   * @param {!Object} kind
   * @param {!Node} options
   * @return {?}
   */
  codec.afterDecode = function(a, kind, options) {
    options.previous = options.terminal;
    return options;
  };
  return codec;
}());
/**
 * @param {!Object} doc
 * @param {string} method
 * @return {?}
 */
var mxGenericChangeCodec = function(doc, method) {
  var codec = new mxObjectCodec(doc, ["model", "previous"], ["cell"]);
  /**
   * @param {!Object} data
   * @param {!Object} method
   * @param {!Object} options
   * @return {?}
   */
  codec.afterDecode = function(data, method, options) {
    if (mxUtils.isNode(options.cell)) {
      options.cell = data.decodeCell(options.cell, false);
    }
    options.previous = options[method];
    return options;
  };
  return codec;
};
mxCodecRegistry.register(mxGenericChangeCodec(new mxValueChange, "value"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxStyleChange, "style"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxGeometryChange, "geometry"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxCollapseChange, "collapsed"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxVisibleChange, "visible"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxCellAttributeChange, "value"));
mxCodecRegistry.register(function() {
  return new mxObjectCodec(new mxGraph, "graphListeners eventListeners view container cellRenderer editor selection".split(" "));
}());
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxGraphView);
  /**
   * @param {?} n
   * @param {!Object} context
   * @return {?}
   */
  codec.encode = function(n, context) {
    return this.encodeCell(n, context, context.graph.getModel().getRoot());
  };
  /**
   * @param {?} m
   * @param {!Object} data
   * @param {undefined} cell
   * @return {?}
   */
  codec.encodeCell = function(m, data, cell) {
    var model = data.graph.getModel();
    var p = data.getState(cell);
    var a = model.getParent(cell);
    if (null == a || null != p) {
      var max = model.getChildCount(cell);
      var prev = data.graph.getCellGeometry(cell);
      /** @type {null} */
      var type = null;
      if (a == model.getRoot()) {
        /** @type {string} */
        type = "layer";
      } else {
        if (null == a) {
          /** @type {string} */
          type = "graph";
        } else {
          if (model.isEdge(cell)) {
            /** @type {string} */
            type = "edge";
          } else {
            if (0 < max && null != prev) {
              /** @type {string} */
              type = "group";
            } else {
              if (model.isVertex(cell)) {
                /** @type {string} */
                type = "vertex";
              }
            }
          }
        }
      }
      if (null != type) {
        var self = m.document.createElement(type);
        if (null != data.graph.getLabel(cell)) {
          self.setAttribute("label", data.graph.getLabel(cell));
          if (data.graph.isHtmlLabel(cell)) {
            self.setAttribute("html", true);
          }
        }
        if (null == a) {
          var i = data.getGraphBounds();
          if (null != i) {
            self.setAttribute("x", Math.round(i.x));
            self.setAttribute("y", Math.round(i.y));
            self.setAttribute("width", Math.round(i.width));
            self.setAttribute("height", Math.round(i.height));
          }
          self.setAttribute("scale", data.scale);
        } else {
          if (null != p && null != prev) {
            for (i in p.style) {
              a = p.style[i];
              if ("function" == typeof a && "object" == typeof a) {
                a = mxStyleRegistry.getName(a);
              }
              if (null != a && "function" != typeof a && "object" != typeof a) {
                self.setAttribute(i, a);
              }
            }
            a = p.absolutePoints;
            if (null != a && 0 < a.length) {
              /** @type {string} */
              prev = Math.round(a[0].x) + "," + Math.round(a[0].y);
              /** @type {number} */
              i = 1;
              for (; i < a.length; i++) {
                /** @type {string} */
                prev = prev + (" " + Math.round(a[i].x) + "," + Math.round(a[i].y));
              }
              self.setAttribute("points", prev);
            } else {
              self.setAttribute("x", Math.round(p.x));
              self.setAttribute("y", Math.round(p.y));
              self.setAttribute("width", Math.round(p.width));
              self.setAttribute("height", Math.round(p.height));
            }
            i = p.absoluteOffset;
            if (null != i) {
              if (0 != i.x) {
                self.setAttribute("dx", Math.round(i.x));
              }
              if (0 != i.y) {
                self.setAttribute("dy", Math.round(i.y));
              }
            }
          }
        }
        /** @type {number} */
        i = 0;
        for (; i < max; i++) {
          p = this.encodeCell(m, data, model.getChildAt(cell, i));
          if (null != p) {
            self.appendChild(p);
          }
        }
      }
    }
    return self;
  };
  return codec;
}());
var mxStylesheetCodec = mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxStylesheet);
  /**
   * @param {!Object} n
   * @param {!Object} src
   * @return {?}
   */
  codec.encode = function(n, src) {
    var body = n.document.createElement(this.getName());
    var i;
    for (i in src.styles) {
      var oldo = src.styles[i];
      var script = n.document.createElement("add");
      if (null != i) {
        script.setAttribute("as", i);
        var j;
        for (j in oldo) {
          var transform = this.getStringValue(j, oldo[j]);
          if (null != transform) {
            var b = n.document.createElement("add");
            b.setAttribute("value", transform);
            b.setAttribute("as", j);
            script.appendChild(b);
          }
        }
        if (0 < script.childNodes.length) {
          body.appendChild(script);
        }
      }
    }
    return body;
  };
  /**
   * @param {string} name
   * @param {!Array} value
   * @return {?}
   */
  codec.getStringValue = function(name, value) {
    /** @type {string} */
    var s = typeof value;
    if ("function" == s) {
      value = mxStyleRegistry.getName(value);
    } else {
      if ("object" == s) {
        /** @type {null} */
        value = null;
      }
    }
    return value;
  };
  /**
   * @param {!Object} path
   * @param {!Object} node
   * @param {!Object} obj
   * @return {?}
   */
  codec.decode = function(path, node, obj) {
    obj = obj || new this.template.constructor;
    var p = node.getAttribute("id");
    if (null != p) {
      /** @type {!Object} */
      path.objects[p] = obj;
    }
    node = node.firstChild;
    for (; null != node;) {
      if (!this.processInclude(path, node, obj) && "add" == node.nodeName && (p = node.getAttribute("as"), null != p)) {
        var i = node.getAttribute("extend");
        var g = null != i ? mxUtils.clone(obj.styles[i]) : null;
        if (null == g) {
          if (null != i) {
            mxLog.warn("mxStylesheetCodec.decode: stylesheet " + i + " not found to extend");
          }
          g = {};
        }
        i = node.firstChild;
        for (; null != i;) {
          if (i.nodeType == mxConstants.NODETYPE_ELEMENT) {
            var index = i.getAttribute("as");
            if ("add" == i.nodeName) {
              var value = mxUtils.getTextContent(i);
              if (null != value && 0 < value.length && mxStylesheetCodec.allowEval) {
                value = mxUtils.eval(value);
              } else {
                value = i.getAttribute("value");
                if (mxUtils.isNumeric(value)) {
                  /** @type {number} */
                  value = parseFloat(value);
                }
              }
              if (null != value) {
                g[index] = value;
              }
            } else {
              if ("remove" == i.nodeName) {
                delete g[index];
              }
            }
          }
          i = i.nextSibling;
        }
        obj.putCellStyle(p, g);
      }
      node = node.nextSibling;
    }
    return obj;
  };
  return codec;
}());
/** @type {boolean} */
mxStylesheetCodec.allowEval = true;
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxDefaultKeyHandler);
  /**
   * @param {?} func
   * @param {!Object} context
   * @return {?}
   */
  codec.encode = function(func, context) {
    return null;
  };
  /**
   * @param {!Object} path
   * @param {!Object} node
   * @param {!Object} self
   * @return {?}
   */
  codec.decode = function(path, node, self) {
    if (null != self) {
      node = node.firstChild;
      for (; null != node;) {
        if (!this.processInclude(path, node, self) && "add" == node.nodeName) {
          var action = node.getAttribute("as");
          var listener = node.getAttribute("action");
          var labels = node.getAttribute("control");
          self.bindAction(action, listener, labels);
        }
        node = node.nextSibling;
      }
    }
    return self;
  };
  return codec;
}());
var mxDefaultToolbarCodec = mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxDefaultToolbar);
  /**
   * @param {?} func
   * @param {!Object} context
   * @return {?}
   */
  codec.encode = function(func, context) {
    return null;
  };
  /**
   * @param {!Object} path
   * @param {!Object} node
   * @param {!Object} self
   * @return {?}
   */
  codec.decode = function(path, node, self) {
    if (null != self) {
      var that = self.editor;
      node = node.firstChild;
      for (; null != node;) {
        if (node.nodeType == mxConstants.NODETYPE_ELEMENT && !this.processInclude(path, node, self)) {
          if ("separator" == node.nodeName) {
            self.addSeparator();
          } else {
            if ("br" == node.nodeName) {
              self.toolbar.addBreak();
            } else {
              if ("hr" == node.nodeName) {
                self.toolbar.addLine();
              } else {
                if ("add" == node.nodeName) {
                  var key = node.getAttribute("as");
                  key = mxResources.get(key) || key;
                  var type = node.getAttribute("icon");
                  var text = node.getAttribute("pressedIcon");
                  var item = node.getAttribute("action");
                  var params = node.getAttribute("mode");
                  var name = node.getAttribute("template");
                  /** @type {boolean} */
                  var t = "0" != node.getAttribute("toggle");
                  var src = mxUtils.getTextContent(node);
                  /** @type {null} */
                  var data = null;
                  if (null != item) {
                    data = self.addItem(key, type, item, text);
                  } else {
                    if (null != params) {
                      var index = mxDefaultToolbarCodec.allowEval ? mxUtils.eval(src) : null;
                      data = self.addMode(key, type, params, text, index);
                    } else {
                      if (null != name || null != src && 0 < src.length) {
                        data = that.templates[name];
                        name = node.getAttribute("style");
                        if (null != data && null != name) {
                          data = that.graph.cloneCell(data);
                          data.setStyle(name);
                        }
                        /** @type {null} */
                        name = null;
                        if (null != src && 0 < src.length && mxDefaultToolbarCodec.allowEval) {
                          name = mxUtils.eval(src);
                        }
                        data = self.addPrototype(key, type, data, text, name, t);
                      } else {
                        if (text = mxUtils.getChildNodes(node), 0 < text.length) {
                          if (null == type) {
                            name = self.addActionCombo(key);
                            /** @type {number} */
                            key = 0;
                            for (; key < text.length; key++) {
                              t = text[key];
                              if ("separator" == t.nodeName) {
                                self.addOption(name, "---");
                              } else {
                                if ("add" == t.nodeName) {
                                  type = t.getAttribute("as");
                                  t = t.getAttribute("action");
                                  self.addActionOption(name, type, t);
                                }
                              }
                            }
                          } else {
                            /** @type {null} */
                            var e = null;
                            var resolvedKey = self.addPrototype(key, type, function() {
                              var s = that.templates[e.value];
                              if (null != s) {
                                s = s.clone();
                                var c = e.options[e.selectedIndex].cellStyle;
                                if (null != c) {
                                  s.setStyle(c);
                                }
                                return s;
                              }
                              mxLog.warn("Template " + s + " not found");
                              return null;
                            }, null, null, t);
                            e = self.addCombo();
                            mxEvent.addListener(e, "change", function() {
                              self.toolbar.selectMode(resolvedKey, function(evt) {
                                evt = mxUtils.convertPoint(that.graph.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
                                return that.addVertex(null, index(), evt.x, evt.y);
                              });
                              /** @type {boolean} */
                              self.toolbar.noReset = false;
                            });
                            /** @type {number} */
                            key = 0;
                            for (; key < text.length; key++) {
                              t = text[key];
                              if ("separator" == t.nodeName) {
                                self.addOption(e, "---");
                              } else {
                                if ("add" == t.nodeName) {
                                  type = t.getAttribute("as");
                                  src = t.getAttribute("template");
                                  self.addOption(e, type, src || name).cellStyle = t.getAttribute("style");
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  if (null != data) {
                    name = node.getAttribute("id");
                    if (null != name && 0 < name.length) {
                      data.setAttribute("id", name);
                    }
                  }
                }
              }
            }
          }
        }
        node = node.nextSibling;
      }
    }
    return self;
  };
  return codec;
}());
/** @type {boolean} */
mxDefaultToolbarCodec.allowEval = true;
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxDefaultPopupMenu);
  /**
   * @param {?} func
   * @param {!Object} context
   * @return {?}
   */
  codec.encode = function(func, context) {
    return null;
  };
  /**
   * @param {!Object} path
   * @param {!Object} source
   * @param {!Object} d
   * @return {?}
   */
  codec.decode = function(path, source, d) {
    var agents_html = source.getElementsByTagName("include")[0];
    if (null != agents_html) {
      this.processInclude(path, agents_html, d);
    } else {
      if (null != d) {
        /** @type {!Object} */
        d.config = source;
      }
    }
    return d;
  };
  return codec;
}());
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxEditor, "modified lastSnapshot ignoredChanges undoManager graphContainer toolbarContainer".split(" "));
  /**
   * @param {!Object} key
   * @param {!Object} text
   * @param {!Object} obj
   * @return {?}
   */
  codec.afterDecode = function(key, text, obj) {
    key = text.getAttribute("defaultEdge");
    if (null != key) {
      text.removeAttribute("defaultEdge");
      obj.defaultEdge = obj.templates[key];
    }
    key = text.getAttribute("defaultGroup");
    if (null != key) {
      text.removeAttribute("defaultGroup");
      obj.defaultGroup = obj.templates[key];
    }
    return obj;
  };
  /**
   * @param {!Object} deps
   * @param {?} node
   * @param {!Object} scale
   * @return {undefined}
   */
  codec.decodeChild = function(deps, node, scale) {
    if ("Array" == node.nodeName) {
      if ("templates" == node.getAttribute("as")) {
        this.decodeTemplates(deps, node, scale);
        return;
      }
    } else {
      if ("ui" == node.nodeName) {
        this.decodeUi(deps, node, scale);
        return;
      }
    }
    mxObjectCodec.prototype.decodeChild.apply(this, arguments);
  };
  /**
   * @param {!Object} node
   * @param {number} list
   * @param {!Object} value
   * @return {undefined}
   */
  codec.decodeUi = function(node, list, value) {
    node = list.firstChild;
    for (; null != node;) {
      if ("add" == node.nodeName) {
        list = node.getAttribute("as");
        var i = node.getAttribute("element");
        var css = node.getAttribute("style");
        if (null != i) {
          /** @type {(Element|null)} */
          i = document.getElementById(i);
          if (null != i && null != css) {
            i.style.cssText += ";" + css;
          }
        } else {
          /** @type {number} */
          var whiteRating = parseInt(node.getAttribute("x"));
          /** @type {number} */
          var pageInd = parseInt(node.getAttribute("y"));
          var health_transition = node.getAttribute("width");
          var intrinsicHeight = node.getAttribute("height");
          /** @type {!Element} */
          i = document.createElement("div");
          i.style.cssText = css;
          (new mxWindow(mxResources.get(list) || list, i, whiteRating, pageInd, health_transition, intrinsicHeight, false, true)).setVisible(true);
        }
        if ("graph" == list) {
          value.setGraphContainer(i);
        } else {
          if ("toolbar" == list) {
            value.setToolbarContainer(i);
          } else {
            if ("title" == list) {
              value.setTitleContainer(i);
            } else {
              if ("status" == list) {
                value.setStatusContainer(i);
              } else {
                if ("map" == list) {
                  value.setMapContainer(i);
                }
              }
            }
          }
        }
      } else {
        if ("resource" == node.nodeName) {
          mxResources.add(node.getAttribute("basename"));
        } else {
          if ("stylesheet" == node.nodeName) {
            mxClient.link("stylesheet", node.getAttribute("name"));
          }
        }
      }
      node = node.nextSibling;
    }
  };
  /**
   * @param {!Object} deps
   * @param {!Array} node
   * @param {!Object} action
   * @return {undefined}
   */
  codec.decodeTemplates = function(deps, node, action) {
    if (null == action.templates) {
      /** @type {!Array} */
      action.templates = [];
    }
    node = mxUtils.getChildNodes(node);
    /** @type {number} */
    var i = 0;
    for (; i < node.length; i++) {
      var k = node[i].getAttribute("as");
      var b = node[i].firstChild;
      for (; null != b && 1 != b.nodeType;) {
        b = b.nextSibling;
      }
      if (null != b) {
        action.templates[k] = deps.decodeCell(b);
      }
    }
  };
  return codec;
}());
